# 十二、最佳实践

与每个软件项目一样，存在许多常见的问题和陷阱。通过嵌入式开发，硬件方面被添加到其中，从而产生了一组独特的问题。从资源管理问题到中断故障和硬件问题引起的怪异行为，本附录向您展示了如何预防和处理许多这些问题。此外，它还向您展示了各种优化方法以及需要警惕的内容。在本附录中，我们将介绍以下主题:

*   优化嵌入式代码的安全方法
*   如何避免和修复各种常见的软件和硬件相关问题
*   认识到硬件的不完美的世界，以及如何将其集成到您的设计中

# 所有最好的计划

与任何项目一样，预期的设计与现实中的功能之间存在不可避免的鸿沟。即使有最好的计划和丰富的经验，总会有不可预见或未被注意到的问题。你能做的最好的就是尽可能做好充分的准备。

第一步是访问目标平台的所有可用信息，了解可用的工具，并制定可靠的开发和测试计划。我们已经在这本书中经历了许多这样的方面。

在本附录中，我们将总结一些最佳实践，这些实践应该可以帮助您避免一些更常见的问题。

# 使用硬件

每个目标平台都有自己的怪癖和特点。这在很大程度上是由于该平台的发展历史。对于 AVR 这样的平台来说，它是相当连贯的，因为它是由一家公司 (Atmel) 多年来开发的，所以不同的芯片和用于平台的工具之间是相当一致的。

诸如 ESP8266 之类的平台 (在某种程度上是其 ESP32 的后继产品) 从未被设计为用作通用 MCU 系统，这在其相当粗略且零散的软件生态系统中得以显示。尽管在过去的几年里情况有所好转，各种框架和开源工具可以平滑处理最粗糙的地方，但由于缺乏文档、工具问题和缺乏片上调试，它是一个容易出错的平台。

ARM mcu (Cortex-M) 由各种各样的制造商以令人眼花缭乱的配置生产。尽管使用 OpenOCD 等工具对这些 MCU 进行编程往往是相当一致的，但添加到每个 MCU 的外围设备在制造商之间往往会有很大的不同，正如我们将在下一节中介绍的那样。

最后，ARM soc 和类似的人发现自己处于与 ARM MCU 相似的位置，但是其架构要比 MCU 的兄弟要复杂得多，外围设备要少得多。为此，ARM SoC 添加了一个复杂的初始化例程，需要全面的引导加载程序，这就是为什么大多数人选择使用现成的 Linux 映像或类似的 SoC，并为此进行开发的原因。

在这里，没有真正正确或错误的答案。这主要取决于项目的工作原理，但重要的是，您必须对所使用的硬件平台有一个良好的概述。

# 外围设备的混乱世界

ARM mcu 的一个非常有趣的现实是，它们具有不同且通常不兼容的外围设备，映射到内存空间中高度不同的区域。最糟糕的是定时器外围设备，它们具有各种复杂性，它们通常能够在 GPIO 引脚上生成任何所需的输出信号，包括 PWM，以及作为基于中断的定时器来控制固件的执行。

配置计时器外围设备和类似的复杂外围设备并不适合胆小的人。同样，使用带有外部 PHY (以太网物理接口) 的内置 MAC 需要大量深入的知识来知道如何配置它们。阅读数据表和应用说明在这里是必不可少的。

依靠诸如 ST 的 CubeMX 软件之类的工具自动生成的代码来实现其 STM32 系列的 ARM mcu 可能会导致您与非功能性代码作斗争，因为您由于不知道这些选项是什么而忘记在 CubeMX 编辑器中勾选几个框。

使用这种自动生成工具或制造商提供的高级库没有错，因为它们可以使生活变得更加轻松。然而，接受这个决定带来的风险是至关重要的，因为它要求人们相信所提供的代码是正确的，或者花时间验证它确实是正确的。

为了使跨不同 mcu 和 soc 的外围设备的使用不那么混乱，人们必须在某个地方添加一个抽象级别，以允许代码的可移植性。关键是要确保这确实使生活变得更轻松，而不仅仅是增加另一个可能使当前项目或未来项目脱轨的潜在问题。

# 了解您的工具

在处理嵌入式项目时，您必须知道目标平台存在哪些工具以及它们是如何工作的。范围从通过 JTAG 或其他接口对 MCU 进行编程以及启动用于片上调试的调试会话到片上调试的限制。在使用工具之前，有必要阅读该工具的手册或文档，并阅读其他开发人员使用这些工具的经验。

在前面的章节中，我们研究了许多此类工具，包括 MCU 和 SoC 平台，以及在将 MCU 设计闪烁到目标硬件之前验证 MCU 设计的方法。

# 选择异步方法

许多硬件设备和操作需要时间才能完成。因此，选择使用中断和计时器的异步动作而不是阻塞操作是有意义的。

在进行裸机编程时，您倾向于使用带有中断例程和计时器的单个循环，这些例程和计时器允许您对事件进行响应和轮询。如果以完全异步的方式进行编程，则此主循环将有效地完成任务，而中断处理程序将更新必须处理的数据。

即使在 SoC 平台上，使用异步方法也是一个好主意，因为诸如网络操作和其他 I/O 操作之类的事情可能需要更长的时间。有办法处理未完成的操作是另一个问题。

# 阅读数据表

特别是对于 mcu，该数据表为我们提供了许多有关硬件工作方式的有价值的信息，例如如何配置内部系统时钟，单个外围设备的工作方式以及可用的寄存器及其含义。

即使您使用现有的主板而不是自定义硬件系统，也需要了解底层硬件，即使它是从 MCU 或 SoC 数据表的粗略读取中获得的。

# 保持中断处理程序短路

中断的本质决定了它会中断处理器的常规执行，而是切换到中断处理程序。我们在中断处理程序代码中花费的任何微秒都是微秒，在此期间我们不运行其他例程或处理其他中断。

为了防止由此引起的任何问题，中断处理程序 (ISR) 应保持尽可能短，理想情况下仅在结束 ISR 并恢复正常操作之前以快速且安全的方式更新单个值。

# 8 位表示 8 位

毫不奇怪，在 8 位 mcu 上使用 16 位和 32 位整数相当慢。这是因为系统必须对同一整数值执行多个操作，因为它一次只能将 8 位放入其寄存器中。

类似地，在没有浮点单元 (FPU) 的系统上使用浮点变量意味着，由于仅整数处理器难以跟上旨在模拟浮点操作的指令流，因此此类操作非常适合将系统减速到爬网。

# 不要重新发明轮子

如果存在质量良好且可用于目标平台和项目许可证的库或框架，请使用它而不是编写自己的实现。

保留一个常用的代码段和示例库作为参考-不仅适合您自己，还适合其他团队成员。记住在哪里可以找到某个功能的示例要比记住该功能的确切实现细节要容易得多。

# 优化前先思考

优化代码的诀窍是，你不应该尝试这样做，而不完全了解你提议的改变会影响什么。仅仅对它可能是一个好主意有一种感觉或模糊的想法是不够的。

虽然具有完整操作系统的基于 SoC 的平台往往会给您更多的回旋余地，但对于 MCU 平台而言，您必须了解添加单个关键字或使用不同的数据结构来存储某些信息意味着什么。

这里最糟糕的事情是假设您在 SBCs 和台式机系统上使用的优化将在 MCU 平台上产生类似的效果。由于修改后的哈佛架构和 AVR 等平台的各种怪癖，这些最有可能适得其反，或者，如果幸运的话，只是无效。

在这里，为 (MCU) 平台提供的应用笔记对于了解如何优化硬件很有用。这里的外卖信息是在进行优化之前做你的研究，就像一个人不考虑项目设计就开始编写代码一样。

# 要求不是可选的

编写嵌入式软件，而对项目没有一套坚定的要求，就像开始建造一座新房子，却没有清楚地知道它应该有多少个房间，门窗应该在哪里，管道和电线应该在哪里运行。

虽然你可以完全开始编写工作代码，并立即敲定一个功能正常的原型，但现实情况是，这些原型通常是投入生产，而没有时间充分考虑产品的生命周期，或者那些在未来几年将不得不继续修补固件以添加原始固件代码从未设计过的功能的人。

完成产品必须满足的需求后，这些需求然后被转换为体系结构 (应用的整体结构)，然后被转换为设计 (将要实现的内容)。然后将设计转换为实际代码。

这种方法的优点是，你不仅需要回答很多关于*为什么*某件事是以特定的方式完成的问题，它还会生成大量的文档，一旦项目完成，这些文档就可以像实际使用一样。

此外，在具有全套需求的嵌入式项目中，可以节省大量的金钱和时间，因为它允许为项目选择合适的 MCU 或 SoC，而不必花更多的钱在比所需的芯片更强大的 “情况下”。它还可以防止令人尴尬的项目中期发现，因为突然 “被遗忘” 的功能需要更改硬件设计。

# 文档可以挽救生命

程序员不喜欢编写文档，因此引用他们编写的代码为*自文档代码*，这已经成为一个笑话。现实情况是，如果没有对设计要求、架构概述、设计计划和 API 文档的清晰文档，您就会冒着项目的未来风险，以及依赖软件运行的开发人员和最终用户的风险。

在开始编写第一行代码之前，遵循程序并完成所有无聊的文书工作，这似乎是一种彻底的杀戮。不幸的是，现实是，如果没有这种努力，这种知识将仍然锁定在项目开发人员的头脑中，这使固件集成到嵌入式项目的其余部分变得复杂，并使未来的维护，特别是如果转移到另一个团队，一个令人望而生畏的前景。

简单的事实是，没有代码是自我记录的，即使是这样，也没有硬件工程师会经历数千行代码，以找出当特定的输入条件发生时，在特定的 GPIO 引脚上发出什么样的信号。

# 测试代码意味着试图摧毁它

编写测试时的一个常见错误是编写您期望可以工作的测试场景。这没有意义。虽然一个特定的解析例程在处理完美格式化的数据时做了它应该做的事情，但这在现实生活中并不是很有帮助。

虽然您可以获得完美的数据，但同样可能的是，您的代码中会完全损坏甚至垃圾数据。目标是确保无论您对输入数据做什么可怕的事情，它都不会对系统的其余部分产生负面影响。

所有输入都应该经过验证和健全性检查。如果某些事情看起来不正确，则应该拒绝它，而不是让它在以后的代码中引起其他问题。

# 摘要

在本附录中，我们讨论了在进行嵌入式软件设计时可能出现的许多常见问题和陷阱。

读者现在应该知道项目中存在哪些阶段，以及记录项目每个步骤背后的原因。