["```cpp\nSTEP 1) to the output of the present value of the IRS (STEP 10).\n```", "```cpp\n for IR1_main.cpp file:\n```", "```cpp\n// IR1_main.cpp\n// requires random.cpp IR1_source.cpp\n\n#include \"IR.h\"\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\n  cout << \"\\n *** START IR1: IRS Monte Carlo Libor Market Model 1F * ** \\n\\n\";\n\n  // Plain Vanilla IRS, pays fixed, receives floating\n  // freq payments every 3M, maturity 1 year\n\n  // STEP 1: INPUT PARAMETERS\n  double notional = 1000000; // notional\n  double K = 0.04; // fixed rate IRS\n  double alpha = 0.25; // daycount factor\n  double sigma = 0.15; // fwd rates volatility\n  double dT = 0.25;\n  int N = 3; // number forward rates\n  int M = 1000; // number of simulations\n\n  // Construct a IR object from the input parameters:\n\n  IR ir1(notional, K, alpha, sigma, dT, N, M);\n\n  // Obtain the value of premium from member function \"get_premium()\":\n\n  auto results = ir1.get_simulation_data();\n\n  // STEP 10: OUTPUT RESULTS\n  auto sz = results.datapoints.size();\n  for (decltype(sz) nsim = 0; nsim < sz; ++nsim)\n  {\n    cout << \"simIRS[\" << nsim << \"] = \" << results.datapoints[nsim] << endl;\n  }\n\n  cout << \"\\n *** IRS PV = \" << results.Value << endl;\n  cout << \"\\n *** END IR1: IRS Monte Carlo Libor Market Model 1F *** \\n\";\n\n  return 0;\n}\n```", "```cpp\n// IR1_source.cpp\n\n#include \"IR.h\"\n#include \"random.h\"\n#include \"matrix.h\"\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nIR_results IR::run_LIBOR_simulations() const\n{\n  matrix<double> L; // forward rates\n  matrix_resize(L, N + 1, N + 1);\n  matrix<double> D; // discount factors\n  matrix_resize(D, N + 2, N + 2);\n  vector<double> dW(N + 1); // discount factors\n  vector<double> FV(N + 2); // future value payment\n  vector<double> FVprime(N + 2); // numeraire-rebased FV payment\n  vector<double> V(M); // simulation payoff\n\n  // Composing the SampleBoxMuller class:\n\n  SampleBoxMuller normal;\n\n  double df_prod = 1.0;\n  double drift_sum = 0.0;\n  double sumPV = 0.0;\n  double PV = 0.0;\n\n  // STEP 2: INITIALISE SPOT RATES\n  L[0][0] = 0.05;\n  L[1][0] = 0.05;\n  L[2][0] = 0.05;\n  L[3][0] = 0.05;\n\n  // start main MC loop\n\n  for (int nsim = 0; nsim < M; ++nsim)\n  {\n\n    // STEP 3: BROWNIAN MOTION INCREMENTS\n    dW[1] = sqrt(dT)*normal();\n    dW[2] = sqrt(dT)*normal();\n    dW[3] = sqrt(dT)*normal();\n\n    // STEP 4: COMPUTE FORWARD RATES TABLEAU\n    for (int n = 0; n < N; ++n)\n    {\n      for (int i = n + 1; i < N + 1; ++i)\n      {\n        drift_sum = 0.0;\n        for (int k = i + 1; k < N + 1; ++k)\n        {\n          drift_sum += (alpha*sigma*L[k][n]) / (1 + alpha*L[k][n]);\n        }\n        L[i][n + 1] = L[i][n] * exp((-drift_sum*sigma - 0.5*sigma*sigma)*dT + sigma*dW[n + 1]); // cout <<\"L: i= \" << i <<\", n+1 = \" << n+1 \" << L[i][n+1] << \"\\n\";\n      }\n    }\n    // STEP 5: COMPUTE DISCOUNT RATES TABLEAU\n    for (int n = 0; n < N + 1; ++n)\n    {\n      for (int i = n + 1; i < N + 2; ++i)\n      {\n        df_prod = 1.0;\n        for (int k = n; k < i; k++)\n        {\n          df_prod *= 1 / (1 + alpha*L[k][n]);\n        }\n        D[i][n] = df_prod;\n        // cout <<\"D: i = \" << i <<\", n = \" << n <<\", D[i][n] = \" << D[i][n] << \"\\n\";\n      }\n    }\n\n    // STEP 6: COMPUTE EFFECTIVE FV PAYMENTS\n    FV[1] = notional*alpha*(L[0][0] - K);\n    FV[2] = notional*alpha*(L[1][1] - K);\n    FV[3] = notional*alpha*(L[2][2] - K);\n    FV[4] = notional*alpha*(L[3][3] - K);\n\n    // STEP 7: COMPUTE NUMERAIRE-REBASED PAYMENT\n    FVprime[1] = FV[1] * D[1][0] / D[4][0];\n    FVprime[2] = FV[2] * D[2][1] / D[4][1];\n    FVprime[3] = FV[3] * D[3][2] / D[4][2];\n    FVprime[4] = FV[4] * D[4][3] / D[4][3];\n\n    // STEP 8: COMPUTE IRS NPV\n\n    V[nsim] = FVprime[1] * D[1][0] + FVprime[2] * D[2][0] + FVprime[3] * D[3][0] + FVprime[4] * D[4][0];\n  }\n  // end main MC loop\n\n  // STEP 9: COMPUTE DISCOUNTED EXPECTED PAYOFF\n  sumPV = 0.0;\n  for (int nsim = 0; nsim < M; nsim++)\n  {\n    sumPV += V[nsim];\n  }\n\n  PV = sumPV / M;\n\n  IR_results results(V, PV);\n\n  return results;\n}\n```", "```cpp\nIR.h, please refer to the code in the code bundle.\n```", "```cpp\n IR2_main.cpp file:\n```", "```cpp\n// IR2_main.cpp\n// requires random.cpp IR2_source.cpp\n\n#include \"IR.h\"\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n  std::cout << \"\\n *** START IR2: CAP Monte Carlo Libor Market Model 1F * ** \\n\\n\";\n\n  // STEP 1: INPUT PARAMETERS\n  double K = 0.05; // strike caplet\n  double alpha = 0.5; // daycount factor\n  double sigma = 0.15; // fwd rates volatility\n  double dT = 0.5;\n  int N = 4; // number forward rates\n  int M = 1000; // number of simulations\n\n  // Construct a IR object from the input parameters:\n  IR ir2(K, alpha, sigma, dT,  N, M);\n\n  // Obtain the value of premium from member function \"get_premium()\":\n\n  auto results = ir2.get_simulation_data();\n\n  // STEP 10: OUTPUT RESULTS\n  auto sz = results.datapoints.size();\n\n  for (decltype(sz) nsim = 0; nsim < sz; ++nsim)\n  {\n    cout << \"Vcap[\" << nsim << \"] = \" << results.datapoints[nsim] << endl;\n  }\n\n  cout << \"\\n *** IRS cap = \" << results.Value << \"\\n\";\n\n  cout << \"\\n *** END IR2: CAP Monte Carlo Libor Market Model 1F * ** \\n\";\n\n  return 0;\n}\n```", "```cpp\nfor IR2_source.cpp file:\n```", "```cpp\n// IR2_source.cpp\n\n#include \"IR.h\"\n#include \"random.h\"\n#include \"matrix.h\"\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nIR_results IR::run_LIBOR_simulations() const\n{\n  matrix<double> L; // forward rates\n  matrix_resize(L, N + 1, N + 1);\n  matrix<double> D; // discount factors\n  matrix_resize(D, N + 2, N + 2);\n  vector<double> dW(N + 1); // discount factors\n  vector<double> V(N + 2); // caplet payoff\n  vector<double> Vprime(N + 2); // numeraire-rebased caplet payoff\n  vector<double> Vcap(M); // simulation payoff\n\n  // Composing the SampleBoxMuller class:\n  SampleBoxMuller normal;\n\n  double df_prod = 1.0;\n  double drift_sum = 0.0;\n  double sumcap = 0.0;\n  double payoff = 0.0;\n\n  // STEP 2: INITIALISE SPOT RATES\n  L[0][0] = 0.05;\n  L[1][0] = 0.05;\n  L[2][0] = 0.05;\n  L[3][0] = 0.05;\n  L[4][0] = 0.05;\n\n  // start main MC loop\n\n  for (int nsim = 0; nsim < M; ++nsim)\n  {\n    // STEP 3: BROWNIAN MOTION INCREMENTS\n    dW[1] = sqrt(dT)*(normal());\n    dW[2] = sqrt(dT)*(normal());\n    dW[3] = sqrt(dT)*(normal());\n    dW[4] = sqrt(dT)*(normal());\n\n    // STEP 4: COMPUTE FORWARD RATES TABLEAU\n    for (int n = 0; n < N; ++n)\n    {\n      for (int i = n + 1; i < N + 1; ++i)\n      {\n        drift_sum = 0.0;\n        for (int k = i + 1; k < N + 1; ++k)\n        {\n          drift_sum += (alpha*sigma*L[k][n]) / (1 + alpha*L[k][n]);\n        }\n        L[i][n + 1] = L[i][n] * exp((-drift_sum*sigma - 0.5*sigma*sigma)*dT \n        + sigma*dW[n + 1]);\n        // cout <<\"L: i = \" << i <<\", n+1 = \" << n+1 <<\", = \" << L[i][n+1] << \"\\n\";\n      }\n    }\n\n    // STEP 5: COMPUTE DISCOUNT RATES TABLEAU\n    for (int n = 0; n < N + 1; ++n)\n    {\n      for (int i = n + 1; i < N + 2; ++i)\n      {\n        df_prod = 1.0;\n        for (int k = n; k < i; k++)\n        {\n          df_prod *= 1 / (1 + alpha*L[k][n]);\n        }\n        D[i][n] = df_prod;\n        // cout <<\"D: i = \" << i <<\", n = \" << n <<\", D[i][n] = \" \n        //\t\t<< D[i][n] << \"\\n\";\n      }\n    }\n\n    // STEP 6: COMPUTE CAPLETS\n    double diff;\n    diff = L[0][0] - K;\n    V[1] = max(diff, 0.0);\n    diff = L[1][1] - K;\n    V[2] = max(diff, 0.0);\n    diff = L[2][2] - K;\n    V[3] = max(diff, 0.0);\n    diff = L[3][3] - K;\n    V[4] = max(diff, 0.0);\n    diff = L[4][4] - K;\n    V[5] = max(diff, 0.0);\n\n    // STEP 7: COMPUTE NUMERAIRE-REBASED CAPLETS\n    Vprime[1] = V[1] * D[1][0] / D[5][0];\n    Vprime[2] = V[2] * D[2][1] / D[5][1];\n    Vprime[3] = V[3] * D[3][2] / D[5][2];\n    Vprime[4] = V[4] * D[4][3] / D[5][3];\n    Vprime[5] = V[5] * D[5][4] / D[5][4];\n\n    // STEP 8: COMPUTE CAP PAYOFF\n    Vcap[nsim] = Vprime[1] + Vprime[2] + Vprime[3] + Vprime[4] + Vprime[5];\n  }\n  // end main MC loop\n\n  // STEP 9: COMPUTE DISCOUNTED EXPECTED PAYOFF\n  sumcap = 0.0;\n\n  for (int nsim = 0; nsim < M; ++nsim)\n  {\n    sumcap += Vcap[nsim];\n  }\n\n  payoff = D[N + 1][0] * sumcap / M;\n\n  IR_results results(Vcap, payoff);\n\n  return results;\n}\n```"]