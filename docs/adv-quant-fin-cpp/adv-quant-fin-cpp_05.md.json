["```cpp\nFX1_main.cpp file:\n```", "```cpp\n// FX1_main.cpp\n// requires FX_source.cpp, FX_print.cpp\n\n#include \"FX.h\"\n\nusing namespace std;\n\nint main()\n{\n  cout << \"\\n *** START FX1: Finite Difference European Call *** \\n\\n\";\n\n  // STEP 1: INPUT PARAMETERS\n  auto T = 0.5; // maturity\n  auto K = 75.0; // strike\n  auto S0 = 75.0; // spot\n  auto sigma = 0.30; // volatility\n  auto r = 0.05; // interest rate\n  auto dx = 0.5; // space step\n  auto dt = 0.1; // time step\n  auto N = 5; // number of space steps\n  auto M = 6; // number of time steps\n\n  // Construct a FX_EQ1 object from the input parameters:\n\n  FX fx_eq1(T, K, S0, sigma, r, dt, dx, N, M);\n\n  // Ask the object to evaluate the FX data for European Call:\n\n  auto result = fx_eq1.get_data_and_premium();\n\n  // STEP 7: OUTPUT RESULTS\n\n  cout << result;\n\n  cout << \"\\n *** END FX1: Finite Difference European Call *** \\n\";\n\n  return 0;\n}\n```", "```cpp\nFX1_source.cpp file:\n```", "```cpp\n// FX1_source.cpp\n#include \"FX.h\"\n#include \"matrix.h\"\n#include <algorithm>\nusing namespace std;\n\nresult_data FX::evaluate_data_and_premium() const\n{\n  double dtau, alpha, k;\n\n  vector<double> t, tau, S, x;\n\n  matrix<double> u, v;\n\n  matrix_resize(u, N, M);\n\n  matrix_resize(v, N, M);\n\n  // Therefore, both the matrices u, v are resized to N by M\n  // Now, let us resize the vectors t, tau, S and x:\n  t.resize(M);\n  tau.resize(M);\n  S.resize(N);\n  x.resize(N);\n\n  dtau = dt * (0.5*sigma*sigma);\n  alpha = dtau / (dx*dx);\n  k = r / (0.5*sigma*sigma);\n  double xmin = -1;\n  double xmax = +1;\n\n  // STEP 2: SETUP MESH (x and tau grids)\n  for (int i = 0; i < N; i++)\n  {\n    x[i] = xmin + i*dx;\n    S[i] = K*exp(x[i]);\n  }\n\n  for (int j = 0; j < M; j++)\n  {\n    t[j] = j*dt;\n    tau[j] = (T - t[j]) / (0.5*sigma*sigma);\n  }\n\n  // STEP 3: SETUP INITIAL CONDITION\n  for (int i = 0; i < N; i++)\n  {\n    u[i][0] = max(exp(0.5*(k + 1)*x[i]) - exp(0.5*(k - 1)*x[i]), 0.0);\n  }\n\n  // STEP 4: SETUP BOUNDARY CONDITIONS\n  for (int j = 1; j < M; j++)\n  {\n    u[0][j] = 0.0;\n    u[N - 1][j] = u[N - 1][0];\n  }\n\n  // STEP 5: COMPUTE FORWARD DIFFERENCES\n  for (int j = 0; j < M - 1; j++)\n  {\n    for (int i = 1; i < N - 1; i++)\n    {\n      u[i][j + 1] = alpha*u[i + 1][j] + (1 - 2 * alpha)*u[i][j] + alpha*u[i - 1][j];\n    }\n  }\n\n  // STEP 6: TRANSFORM SOLUTION FROM X TO S COORDINATES (u and v)\n  for (int j = 0; j < M; j++)\n  {\n    for (int i = 0; i < N; i++)\n    {\n      v[i][j] = pow(K, (0.5*(1 + k)))*pow(S[i], (0.5*(1 - k)))*exp(1.0 / 8.0*(k + 1)*(k + 1)*sigma*sigma*(T - t[i]))*u[i][j];\n    }\n  }\n\n  result_data result(alpha, dtau, k, x, S, t, tau, u, v);\n\n  return result;\n\n}\n```", "```cpp\nFX.h, code snippet 12 FX_print.cpp, and code snippet 13 matrix.h, please refer to the code bundle of the book.\n```", "```cpp\nFX2_main.cpp file:\n```", "```cpp\n// FX2_main.cpp\n// requires FX2_source.cpp, FX_print.cpp\n\n#include \"FX.h\"\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n  cout << \"\\n *** START FX2: Finite Difference\"\n    << \" European Up-and-Out Barrier Call *** \\n\\n\";\n\n  // STEP 1: INPUT PARAMETERS\n  auto T = 0.5; // maturity\n  auto K = 75.0; // strike\n  auto S0 = 75.0; // spot\n  auto sigma = 0.30; // volatility\n  auto r = 0.05; // interest rate\n  auto dx = 0.5; // space step\n  auto dt = 0.1; // time step\n  auto N = 5; // number of space steps\n  auto M = 6; // number of time steps\n\n  // Construct a FX object from the input parameters:\n\n  FX fx_eq2(T, K, S0, sigma, r, dt, dx, N, M);\n\n  // Ask the object to evaluate the FX data\n  // for European Up-and_Out Barrier Call:\n\n  auto result = fx_eq2.get_data_and_premium();\n\n  // STEP 7: OUTPUT RESULTS\n  cout << result;\n\n  cout << \"\\n *** END FX2: Finite Difference\"\n    << \" European Up-and-Out Barrier Call *** \\n\";\n\n  return 0;\n}\n```", "```cpp\nFX2_source.cpp file:\n```", "```cpp\n// FX2_source.cpp\n\n#include \"FX.h\"\n#include \"matrix.h\"\n#include <algorithm>\n\nusing namespace std;\n\nresult_data FX::evaluate_data_and_premium() const\n{\n  double dtau, alpha, k\n  vector<double> t, tau, S, x\n  matrix<double> u, v\n  auto resz = [this](matrix<double>& u, int N, int M) {\n\n    // to make number of rows = \n    u.resize(N);\n\n    // to make number of columns = \n    for (auto& row : u)\n    row.resize(M);\n  };\n\n  resz(u, N, M)\n  resz(v, N, M);\n\n  // Therefore, both the matrices u, v are resized to N by M\n  // Now, let us resize the vectors t, tau, S and x:\n  t.resize(M);\n  tau.resize(M);\n  S.resize(N);\n  x.resize(N);\n\n  dtau = dt * (0.5*sigma*sigma);\n  alpha = dtau / (dx*dx);\n  k = r / (0.5*sigma*sigma);\n\n  double xmin = -1;\n  double xmax = +1;\n\n  // STEP 2: SETUP MESH (x and tau grids)\n  for (int i = 0; i < N; i++)\n  {\n    x[i] = xmin + i*dx;\n    S[i] = K*exp(x[i]);\n  }\n\n  for (int j = 0; j < M; j++)\n  {\n    t[j] = j*dt;\n    tau[j] = (T - t[j]) / (0.5*sigma*sigma);\n  }\n\n  // STEP 3: SETUP INITIAL CONDITION\n  for (int i = 0; i < N; i++)\n  {\n    u[i][0] = max(exp(0.5*(k + 1)*x[i]) - exp(0.5*(k - 1)*x[i]), 0.0);\n  }\n\n  // STEP 4: SETUP BOUNDARY CONDITIONS\n  for (int j = 1; j < M; j++)\n  {\n    u[0][j] = 0.0;\n    u[N - 1][j] = 0.0;\n  }\n\n  // STEP 5: COMPUTE FORWARD DIFFERENCES\n  for (int j = 0; j < M - 1; j++)\n  {\n    for (int i = 1; i < N - 1; i++)\n    {\n      u[i][j + 1] = alpha*u[i + 1][j] + (1 - 2 * alpha)*u[i][j] + alpha*u[i - 1][j];\n    }\n  }\n\n  // STEP 6: TRANSFORM SOLUTION FROM X TO S COORDINATES (u and v)\n  for (int j = 0; j < M; j++)\n  {\n    for (int i = 0; i < N; i++)\n    {\n      v[i][j] = pow(K, (0.5*(1 + k)))*pow(S[i], (0.5*(1 - k)))\n      *exp(1.0 / 8.0*(k + 1)*(k + 1)*sigma*sigma*(T - t[i]))*u[i][j];\n    }\n  }\n\n  result_data result(alpha, dtau, k, x, S, t, tau, u, v);\n\n  return result;\n\n}\n```"]