["```cpp\nmaineq1.cpp) is the pricing algorithm proper, while code snippets 2 and 3 are auxiliary functions. The algorithm is composed of six steps, which take us from the input parameters (STEP 1) to the output of the premium value (STEP 6).\nrandom.cpp). This implements the Box-Muller method to obtain random samples from the standard normal (Gaussian) distribution that are required for the GBM. Code snippet 3 (random.h) is simply the header file of code snippet 2 (random.cpp). The Box-Muller method takes two independent samples from a uniform distribution and transforms them into a single sample from a Gaussian distribution; this value needs to be assigned to the variable epsilon in the code. Certainly, a more efficient implementation is possible. The Box-Muller method in fact transforms a couple of uniform variables into a couple of normal variables. It would be better to also use the second normal sample, generated in the process, in order to be computationally more effective. Please refer to the book website for details of this more efficient implementation and to the original paper for further details (*A Note on the Generation of Random Normal Deviates*).\n```", "```cpp\n// maineq1.cpp\n// requires random.cpp\n#include \"random.h\"\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nint main()\n{\n  cout << \"\\n *** START EQ1: Monte Carlo European Call *** \\n\";\n  // STEP 1: INPUT PARAMETERS\n  double T=1; // maturity\n  double K=100; // strike\n  double S0=100; // spot\n  double sigma=0.10; // volatility\n  double r=0.05; // interest rate\n  int N=500; // number of steps\n  int M=10000; // number of simulations\n  double S[N+1];\n  double sumpayoff=0;\n  double premium=0;\n  double dt = T / N;\n\n  // STEP 2: MAIN SIMULATION LOOP\n  for (int j=0; j < M; j++)\n  {\n    S[0]=S0; // initialize each path for simulation\n\n    // STEP 3: TIME INTEGRATION LOOP\n    for (int i=0; i < N; i++)\n    {\n      double epsilon = SampleBoxMuller();  // get Gaussian draw\n      S[i+1] = S[i]*(1+r*dt+sigma*sqrt(dt)*epsilon);\n    }\n\n    // STEP 4: COMPUTE PAYOFF\n    sumpayoff += max(S[N]-K,0.0); // compute and ad payoff \n  }\n\n  // STEP 5: COMPUTE DISCOUNTED EXPECTED PAYOFF\n  premium =  exp(-r*T)*(sumpayoff / M);\n\n  // STEP 6: OUTPUT RESULTS\n  cout <<\"premium =  \" << premium << \"\\n\";\n  cout << \"\\n *** END EQ1: Monte Carlo single asset *** \\n\";\n\n  return 0;\n}\n```", "```cpp\n random.cpp file:\n```", "```cpp\n// random.cpp\n// Computing Gaussian deviates using Box-Muller method\n\n#include \"Random.h\"\n#include <cstdlib>\n#include <cmath>\nusing namespace std;\n\ndouble SampleBoxMuller()\n{\n  double result;\n  double x;\n  double y;\n\n  double xysquare;\n  do\n  {\n    x = 2.0*rand()/static_cast<double>(RAND_MAX)-1;\n    y = 2.0*rand()/static_cast<double>(RAND_MAX)-1;\n    xysquare = x*x + y*y;\n  }\n  while\n  ( xysquare >= 1.0);\n  result = x*sqrt(-2*log(xysquare)/xysquare);\n  return result;\n}\n```", "```cpp\n// random.h\ndouble SampleBoxMuller();\n```", "```cpp\nwith Code 1: first, regarding the input parameters (STEP 1) and second regarding the calculation of the GBM (STEP 4). We now need to specify the parameters for both processes, including their spot prices and volatilities. As we need to compute two correlated stochastic processes, the two Gaussian samples that are required are now computed as follows:\n```", "```cpp\n// maineq2.cpp\n// requires random.cpp\n#include \"random.h\"\n#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  cout << \"\\n *** START EQ2: Monte Carlo equity basket *** \\n\";\n  // STEP 1: INPUT PARAMETERS\n  double T=1; // maturity\n  double r=0.05; // interest rate\n  double S10=120; // spot equity 1\n  double S20=100; // spot equity 2\n  double sigma1=0.10; // volatility\n  double sigma2=0.15; // volatility\n  double rho=0.5; // correlation\n  int N=300; // number of steps\n  int M=10000; // number of simulations\n  double S1[N+1];\n  double S2[N+1];\n  double sumpayoff=0;\n  double premium=0;\n  double dt = T / N;\n\n  // STEP 2: MAIN SIMULATION LOOP\n  for (int j=0; j < M; j++)\n  {\n    S1[0]=S10;\n    S2[0]=S20;\n    // STEP 3: TIME INTEGRATION LOOP\n    for (int i=0; i < N; i++)\n    {\n      double epsilon1 = SampleBoxMuller();\n      double epsilon2 = SampleBoxMuller();\n      S1[i+1] = S1[i]*(1+r*dt+sigma1*sqrt(dt)*epsilon1);\n      epsilon2 = epsilon1*rho+sqrt(1-rho*rho)*epsilon2;\n      S2[i+1]=S2[i]*(1+r*dt+sigma2*sqrt(dt)*epsilon2);\n    }\n    // STEP 4: TIME INTEGRATION LOOP\n    sumpayoff += max(S1[N],S2[N]);\n  }\n  // STEP 5: COMPUTE DISCOUNTED EXPECTED PAYOFF\n premium =  exp(-r*T)*(sumpayoff / M);\n\n  // STEP 6: OUTPUT RESULTS\n  cout <<\"premium =  \" << premium << \"\\n\";\n  cout << \"\\n *** END EQ2: Monte Carlo equity basket *** \\n\";\n  return 0;\n}\n```"]