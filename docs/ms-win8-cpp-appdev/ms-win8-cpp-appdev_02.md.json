["```cpp\nvoid f1(int x) {\n  cout << \"f1(int)\" << endl;\n}\n\nvoid f1(const char* s) {\n  cout << \"f1(const char*)\" << endl;\n}\n```", "```cpp\nauto int x = 10;\n```", "```cpp\nint x = 5;\nstring name = \"Pavel\";\nvector<int> v;\nv.push_back(10);\nv.push_back(20);\nfor(vector<int>::const_iterator it = v.begin(); it != v.end(); \n   ++it)\n  cout << *it << endl;\n```", "```cpp\nauto x = 5;\nauto name = \"Pavel\";\nvector<int> v;\nv.push_back(10);\nv.push_back(20);\nfor(auto it = v.begin(); it != v.end(); ++it)\n  cout << *it << endl;\n```", "```cpp\ntemplate<class InIt, class OutIt, class Fn1> \nOutIt transform(InIt First, InIt Last, OutIt Dest, Fn1 Func);\n```", "```cpp\ndouble f1(int n) {\n  return ::sqrt(n);\n}\n\nvoid LambdaDemo() {\n  vector<int> v;\n  for(int i = 0; i < 5; i++)\n    v.push_back(i + 1);\n  for each (int i in v)\n    cout << i << endl;\n\n  vector<double> v2(5);\n\n  ::transform(begin(v), end(v), begin(v2), f1);\n\n  cout << endl;\n  for each (double d in v2)\n    cout << d << endl;\n```", "```cpp\nclass SqrtFunctor {\npublic:\n  double operator()(int n) {\n    return ::sqrt(n);\n  }\n};\n```", "```cpp\n::transform(begin(v), end(v), begin(v2), SqrtFunctor());\n```", "```cpp\n::transform(begin(v), end(v), begin(v2), [](int n) {\n  return ::sqrt(n);\n});\n```", "```cpp\n    ::transform(begin(v), end(v), begin(v2), [](int n) -> double {\n      return ::sqrt(n);\n    });\n    ```", "```cpp\nCar* pCar = new Car;\n```", "```cpp\npCar->Drive(); // use the car\ndelete pCar;\n```", "```cpp\nclass CarPtr {\npublic:\n  CarPtr(Car* pCar) : _pCar(pCar) { }\n  Car* operator->() const { return _pCar; }\n  ~CarPtr() { delete _pCar; }\n\nprivate:\n  Car* _pCar;\n};\n```", "```cpp\nCarPtr spCar(pCar);\nspCar->Drive();\n```", "```cpp\nunique_ptr<Car> spCar2(new Car);\nspCar2->Drive();\n```", "```cpp\nvoid UseCar(shared_ptr<Car> car) {\n  // ref count: 2\n  car->Drive();\n}\n\nvoid CreateCar() {\n  shared_ptr<Car> spCar3(new Car); // ref count: 1\n  UseCar(spCar3);\t// ref count: 2\n  // back to ref count of 1\n  spCar3->Drive();\n}\n```", "```cpp\nshared_ptr<Car> spCar3 = make_shared<Car>();\nspCar3->Drive();\n```", "```cpp\nshared_ptr<Car> spCar3 = make_shared<Car>();\nspCar3->Drive();\n\nweak_ptr<Car> spCar4(spCar3);\n\nauto car = spCar4.lock();\nif(car)\n  car->Drive();\nelse\n  cout << \"Car gone\" << endl;\n```", "```cpp\nspCar3 = nullptr;\n```", "```cpp\nclass ICar {\npublic:\n  virtual void Drive() = 0;\n  virtual void Start() = 0;\n  virtual void Refuel(double amount) = 0;\n};\n```", "```cpp\nclass Porche : public ICar {\npublic:\n  Porche() : _running(false), _fuel(50), _speed(0) { }\n\n  void Start() {\n    if(_running)\n      throw new std::exception(\n   \"car is already running\");\n    _running = true;\n  }\n\n  void Drive() {\n    if(!_running)\n      throw new std::exception(\"car is not running\");\n    _speed += 10;\n  }\n\n  void Refuel(double amount) {\n    if((_fuel += amount) > 60)\n      _fuel = 60;\n  }\n\nprivate:\n  bool _running;\n  double _fuel;\n  double _speed;\n};\n```", "```cpp\nvoid UseCar(ICar* pCar) {\n  pCar->Start();\n  pCar->Drive();\n  pCar->Drive();\n  pCar->Refuel(30);\n}\n```", "```cpp\nclass ICarrier {\npublic:\n  virtual int PlaceObject(double weight) = 0;\n  virtual void RemoveObject(int objectID) = 0;\n};\n```", "```cpp\nclass Porche : public ICar, public ICarrier {\n```", "```cpp\ndouble _totalWeight;\nstatic int _runningID;\nstd::map<int, double> _objects; \n```", "```cpp\nint PlaceObject(double weight) {\n  if(_totalWeight + weight > 200)\n    throw std::exception(\"too heavy\");\n  _totalWeight += weight;\n  _objects.insert(std::make_pair(++_runningID, weight));\n  return _runningID;\n}\n\nvoid RemoveObject(int objectID) {\n  auto obj = _objects.find(objectID);\n  if(obj == _objects.end())\n    throw new std::exception(\"object not found\");\n  _totalWeight -= obj->second;\n  _objects.erase(obj);\n}\n```", "```cpp\ncout << \"pCar: \" << pCar << endl;\nICarrier* pCarrier = dynamic_cast<ICarrier*>(pCar);\nif(pCarrier) {\n  // supported\n  cout << \"Placing object...\" << endl;\n  int id = pCarrier->PlaceObject(20);\n  cout << \"pCarrier: \" << pCarrier << endl;\n}\n```", "```cpp\nclass IUnknown {\npublic:\n  virtual HRESULT __stdcall QueryInterface(const IID& iid, \n      void **ppvObject) = 0;\n  virtual ULONG __stdcall AddRef() = 0;\n  virtual ULONG __stdcall Release() = 0;\n};\n```", "```cpp\nclass IInspectable : public IUnknown {\npublic:\n  virtual HRESULT __stdcall GetIids(ULONG *iidCount, \n      IID **iids) = 0;\n  virtual HRESULT __stdcall GetRuntimeClassName(\n      HSTRING *className) = 0;\n  virtual HRESULT __stdcall GetTrustLevel(\n      TrustLevel *trustLevel) = 0;\n};\n```", "```cpp\n#include <roapi.h>\n\n#pragma comment(lib, \"runtimeobject.lib\")\n```", "```cpp\n::RoInitialize(RO_INIT_MULTITHREADED);\n```", "```cpp\nHRESULT WINAPI RoActivateInstance(\n  _In_\u00a0\u00a0\u00a0HSTRING activatableClassId,\n  _Out_\u00a0\u00a0IInspectable **instance\n);\n```", "```cpp\nHSTRING hClassName;\nwstring className(L\"Windows.Globalization.Calendar\");\nHRESULT hr = ::WindowsCreateString(className.c_str(),\n   className.size(), &hClassName);\n```", "```cpp\nHRESULT RoGetActivationFactory(\n  _In_\u00a0\u00a0\u00a0HSTRING activatableClassId,\n  _In_\u00a0\u00a0\u00a0REFIID iid,\n  _Out_\u00a0\u00a0void **factory\n);\n```", "```cpp\nHRESULT ActivateInstance(IInspectable **instance);\n```", "```cpp\n#include <windows.globalization.h>\n```", "```cpp\nusing namespace ABI::Windows::Globalization;\n```", "```cpp\nICalendar* pCalendar;\nhr = pInst->QueryInterface(__uuidof(ICalendar), \n   (void**)&pCalendar);\n```", "```cpp\npCalendar->SetToNow();\nINT32 hour, minute, second;\npCalendar->get_Hour(&hour);\npCalendar->get_Minute(&minute);\npCalendar->get_Second(&second);\n\ncout << \"Time: \" << setfill('0') << setw(2) << hour << \":\" <<\n   setw(2) << minute << \":\" << setw(2) << second << endl;\n```", "```cpp\npCalendar->Release();\npInst->Release();\n::WindowsDeleteString(hClassName);\n```", "```cpp\n#include <wrl.h>\n#include <wrl/wrappers/corewrappers.h>\n```", "```cpp\nusing namespace Windows::Foundation;\nusing namespace Microsoft::WRL;\nusing namespace Microsoft::WRL::Wrappers;\n```", "```cpp\nRoInitializeWrapper init(RO_INIT_MULTITHREADED);\n```", "```cpp\nHString hClassName;\nhClassName.Set(RuntimeClass_Windows_Globalization_Calendar);\n```", "```cpp\nComPtr<ICalendar> spCalendar;\nHRESULT hr = ActivateInstance(hClassName.Get(), &spCalendar);\n```", "```cpp\nspCalendar->SetToNow();\nINT32 hour, minute, second;\nspCalendar->get_Hour(&hour);\nspCalendar->get_Minute(&minute);\nspCalendar->get_Second(&second);\n\ncout << \"Time: \" << setfill('0') << setw(2) << hour << \":\" << \n   setw(2) << minute << \":\" << setw(2) << second << endl;\n```", "```cpp\nusing namespace Windows::Globalization;\nCalendar^ cal = ref new Calendar;\n```", "```cpp\nCalendar^ cal = ref new Calendar;\ncal->SetToNow();\n\nICalendar^ ical = cal;\nical->SetToNow();\n```", "```cpp\n  cal->SetToNow();\n00A420D0  mov         eax,dword ptr [cal] \n00A420D3  push        eax \n00A420D4  call        Windows::Globalization::ICalendar::SetToNow (0A37266h) \n00A420D9  add         esp,4  \n\n  ICalendar^ ical = cal;\n00A420DC  mov         eax,dword ptr [cal]  \n00A420DF  push        eax  \n00A420E0  call        __abi_winrt_ptr_ctor (0A33094h)  \n00A420E5  add         esp,4  \n00A420E8  mov         dword ptr [ical],eax  \n00A420EB  mov         byte ptr [ebp-4],0Ah  \n  ical->SetToNow();\n00A420EF  mov         eax,dword ptr [ical] \n00A420F2  push        eax \n00A420F3  call        Windows::Globalization::ICalendar::SetToNow (0A37266h) \n\n```", "```cpp\nCalendar c1;\nc1.SetToNow();\n```", "```cpp\nComPtr<ICalendar> spCal2;\nActivateInstance(hClassName.Get(), &spCal2);\nspCal2->SetToNow();\nspCal2->AddMinutes(5);\n\nint result;\nhr = spCalendar->Compare(spCal2.Get(), &result);\n```", "```cpp\nauto cal2 = ref new Calendar;\ncal2->SetToNow();\ncal2->AddMinutes(5);\nint result = cal->Compare(cal2);\n```", "```cpp\n// read current hour\nINT32 hour;\nspCalendar->get_Hour(&hour);\n// set a new hour\nspCalendar->put_Hour(23);\n```", "```cpp\nint hour = cal->Hour;  // get\ncal->Hour = 23;    // set\n```", "```cpp\ncal->__abi_SetToNow();\nint r;\ncal->__abi_Compare(cal2, &r);\ncal->__abi_set_Hour(22);\n```", "```cpp\nIAsyncOperation<String^>^ operation = ...;\noperation->Completed = ref new\n   AsyncOperationCompletedHandler<String^>(this, &App::MyHandler);\n```", "```cpp\nvoid MyHandler(IAsyncOperation<String^>^ operation, \n   AsyncStatus status);\n```", "```cpp\noperation->Completed = ref new AsyncOperationCompletedHandler<String^>(\n   [](IAsyncOperation<String^>^ operation, AsyncStatus status) {\n    // do something...\n  });\n```", "```cpp\noperation->Completed->Invoke(operation, AsyncStatus::Completed);\noperation->Completed(operation, AsyncStatus::Completed);\n```", "```cpp\nthis->Suspending += ref new SuspendingEventHandler(\n   this, &App::OnSuspending);\n```", "```cpp\nnamespace Calculations {\n  public ref class Calculator sealed {\n  public:\n     Calculator(void);\n\n  };\n}\n```", "```cpp\n// ctor\nCalculator(double initial);\nCalculator();\n\n// operations\nvoid Add(double value);\nvoid Subtract(double value);\nvoid Multiply(double value);\nvoid Divide(double value);\n\nvoid Reset(double value);\nvoid Reset();\n```", "```cpp\nproperty double Result {\n  double get();\n}\n```", "```cpp\nprivate:\n  double _result;\n```", "```cpp\n#include \"Calculator.h\"\n\nusing namespace Calculations;\n\nCalculator::Calculator(double initial) : _result(initial) {\n}\n\nCalculator::Calculator() : _result(0) {\n}\n\nvoid Calculator::Add(double value) {\n  _result += value;\n}\n\nvoid Calculator::Subtract(double value) {\n  _result -= value;\n}\n\nvoid Calculator::Multiply(double value) {\n  _result *= value;\n}\n\nvoid Calculator::Divide(double value) {\n  _result /= value;\n}\n\nvoid Calculator::Reset() {\n  _result = 0.0;\n}\n\nvoid Calculator::Reset(double value) {\n  _result = value;\n}\n\ndouble Calculator::Result::get() {\n  return _result;\n}\n```", "```cpp\nref class Calculator;\n\npublic delegate void DivideByZeroHandler(Calculator^ sender);\n```", "```cpp\nevent DivideByZeroHandler^ DivideByZero;\n```", "```cpp\nvoid Calculator::Divide(double value) {\n  if(value == 0.0)\n    DivideByZero(this);\n  else\n    _result /= value;\n}\n```", "```cpp\nprivate:\n  Calculations::Calculator^ _calculator;\n```", "```cpp\n_calculator = ref new Calculator;\n_calculator->DivideByZero += ref new DivideByZeroHandler([this](Calculator^ sender) {\n  _error->Text = \"Cannot divide by zero\";\n});\n```", "```cpp\n_error->Text = \"\";\nwstringstream ss(_value->Text->Data());\ndouble value;\nss >> value;\nswitch(_operationList->SelectedIndex) {\ncase 0:\n\t_calculator->Add(value); break;\ncase 1:\n\t_calculator->Subtract(value); break;\ncase 2:\n\t_calculator->Multiply(value); break;\ncase 3:\n\t_calculator->Divide(value); break;\n}\n// update result\n_result->Text = _calculator->Result.ToString();\n```", "```cpp\nCalculator _calculator;\n\npublic MainPage() {\n  this.InitializeComponent();\n  _calculator = new Calculator();\n  _calculator.DivideByZero += calc => {\n    _error.Text = \"Cannot divide by zero\";\n  };\n}\n```", "```cpp\n_error.Text = String.Empty;\ndouble value = double.Parse(_value.Text);\nswitch (_operationList.SelectedIndex) {\n  case 0:\n    _calculator.Add(value); break;\n  case 1:\n    _calculator.Subtract(value); break;\n  case 2:\n    _calculator.Multiply(value); break;\n  case 3:\n    _calculator.Divide(value); break;\n}\n// update result\n_result.Text = _calculator.Result.ToString();\n```", "```cpp\nstd::wstring GetResultAsString();\n```", "```cpp\nPlatform::String^ GetResultAsString();\n```", "```cpp\nauto picker = ref new FileOpenPicker;\npicker->FileTypeFilter->Append(\".jpg\");\npicker->FileTypeFilter->Append(\".png\");\npicker->ViewMode = PickerViewMode::Thumbnail;\n```", "```cpp\nauto fileOperation = picker->PickSingleFileAsync();\nfileOperation->Completed = ref new \n   AsyncOperationCompletedHandler<StorageFile^>(\n[this](IAsyncOperation<StorageFile^>^ op, AsyncStatus status) {\n  auto file = op->GetResults();\n  });\n```", "```cpp\nusing namespace Windows::UI::Core;\nauto openOperation = file->OpenReadAsync();\nopenOperation->Completed = ref new AsyncOperationCompletedHandler<IRandomAccessStreamWithContentType^>(\n  [this](IAsyncOperation<IRandomAccessStreamWithContentType^>^\n    op, AsyncStatus status) {\n    auto bmp = ref new BitmapImage;\n    bmp->SetSource(op->GetResults());\n    _image->Source = bmp;\n});\n```", "```cpp\nDispatcher->RunAsync(CoreDispatcherPriority::Normal, \n   ref new DispatchedHandler([op, this]() {\n    auto bmp = ref new BitmapImage;\n    bmp->SetSource(op->GetResults());\n    _image->Source = bmp;\n  }));\n```", "```cpp\nauto fileTask = create_task(picker->PickSingleFileAsync());\nfileTask.then([](StorageFile^ file) {\n  return create_task(file->OpenReadAsync());\n}).then([this](IRandomAccessStreamWithContentType^ stm) {\n  auto bmp = ref new BitmapImage;\n  bmp->SetSource(stm);\n  _image->Source = bmp;\n});\n```", "```cpp\ntask<StorageFile^> fileTask(picker->PickSingleFileAsync());\n```", "```cpp\nthen([](task<void> t) {\n  try {\n    t.get();\n  }\n  catch(task_canceled) {\n    // task cancelled\n  }\n  catch(Exception^ ex) {\n    // some error occurred\n  }\n});\n```", "```cpp\nextern \"C\" BOOL WINAPI MessageBoxW(HWND hParent, LPCTSTR msg,\n   LPCTSTR title, DWORD flags);\n\n#pragma comment(lib, \"user32.lib\")\n```", "```cpp\nauto s1 = ref new String(L\"Hello\");\nstd::wstring s2(L\"Second\");\nauto s3 = ref new String(s2.c_str());\nint compare = wcscmp(L\"xyz\", s1->Data());\nfor(auto i = begin(s3); i != end(s3); ++i)\n  DoSomethingWithChar(*i);\n```"]