["```cpp\n// Assume Person class exists with its usual implementation\nclass Student: public Person\u00a0\u00a0// Notice that Student is now\u00a0\u00a0\n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// an abstract class\nprivate:\n\u00a0\u00a0\u00a0\u00a0float gpa;\n\u00a0\u00a0\u00a0\u00a0char *currentCourse;\n\u00a0\u00a0\u00a0\u00a0const char *studentId;\npublic:\n\u00a0\u00a0\u00a0\u00a0Student();\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0Student(const char *, const char *, char, const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float, const char *, const char *);\n\u00a0\u00a0\u00a0\u00a0Student(const Student &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Student();\u00a0\u00a0// destructor\n\u00a0\u00a0\u00a0\u00a0float GetGpa() const { return gpa; }\n\u00a0\u00a0\u00a0\u00a0const char *GetCurrentCourse() const \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return currentCourse; }\n\u00a0\u00a0\u00a0\u00a0const char *GetStudentId() const { return studentId; }\n\u00a0\u00a0\u00a0\u00a0void SetCurrentCourse(const char *); // prototype only\n\u00a0\u00a0\u00a0\u00a0virtual void Print() const override;\n\u00a0\u00a0\u00a0\u00a0virtual const char *IsA() override { return \"Student\"; }\n\u00a0\u00a0\u00a0\u00a0virtual void Graduate() = 0;\u00a0\u00a0// Now Student is abstract\n\u00a0\u00a0\u00a0\u00a0// Creates a derived Student type based on degree sought\n\u00a0\u00a0\u00a0\u00a0static Student *MatriculateStudent(const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *, const char *, char, const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float, const char *, const char *);\n};\n// Assume all the usual Student member functions exist \n```", "```cpp\nclass GradStudent: public Student\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0char *degree;\u00a0\u00a0// PhD, MS, MA, etc.\npublic:\n\u00a0\u00a0\u00a0\u00a0GradStudent() { degree = 0; }\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0GradStudent(const char *, const char *, const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char, const char *, float, const char *, const char *);\n\u00a0\u00a0\u00a0\u00a0GradStudent(const GradStudent &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~GradStudent() { delete degree; } // destructor\n\u00a0\u00a0\u00a0\u00a0void EarnPhD();\n\u00a0\u00a0\u00a0\u00a0virtual const char *IsA() override \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return \"GradStudent\"; }\n\u00a0\u00a0\u00a0\u00a0virtual void Graduate() override;\n};\n// Assume alternate and copy constructors are implemented\n// as expected. See online code for full implementation.\nvoid GradStudent::EarnPhD()\n{\n\u00a0\u00a0\u00a0\u00a0if (!strcmp(degree, \"PhD\")) // only PhD candidates can \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ModifyTitle(\"Dr.\");\u00a0\u00a0\u00a0\u00a0\u00a0// EarnPhd(), not MA and MS \n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// candidates\nvoid GradStudent::Graduate()\n{\u00a0\u00a0\u00a0// Here, we can check that the required number of credits\n\u00a0\u00a0\u00a0\u00a0// have been met with a passing gpa, and that their \n\u00a0\u00a0\u00a0\u00a0// doctoral or master's thesis has been completed.\n\u00a0\u00a0\u00a0\u00a0EarnPhD();\u00a0\u00a0// Will change title only if a PhD candidate\n\u00a0\u00a0\u00a0\u00a0cout << \"GradStudent::Graduate()\" << endl;\n}\n```", "```cpp\nclass UnderGradStudent: public Student\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0char *degree;\u00a0\u00a0// BS, BA, etc\npublic:\n\u00a0\u00a0\u00a0\u00a0UnderGradStudent() { degree = 0; }\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0UnderGradStudent(const char *, const char *, const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char, const char *, float, const char *, const char *);\n\u00a0\u00a0\u00a0\u00a0UnderGradStudent(const UnderGradStudent &);\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0virtual ~UnderGradStudent() { delete degree; } \n\u00a0\u00a0\u00a0\u00a0virtual const char *IsA() override \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return \"UnderGradStudent\"; }\n\u00a0\u00a0\u00a0\u00a0virtual void Graduate() override;\n};\n// Assume alternate and copy constructors are implemented\n// as expected. See online code for full implementation.\nvoid UnderGradStudent::Graduate()\n{\u00a0\u00a0\u00a0// Verify that number of credits and gpa requirements have\n\u00a0\u00a0\u00a0\u00a0// been met for major and any minors or concentrations.\n\u00a0\u00a0\u00a0\u00a0// Have all applicable university fees been paid?\n\u00a0\u00a0\u00a0\u00a0cout << \"UnderGradStudent::Graduate()\" << endl;\n}\n```", "```cpp\nclass NonDegreeStudent: public Student\n{\npublic:\n\u00a0\u00a0\u00a0\u00a0NonDegreeStudent() { }\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0NonDegreeStudent(const char *, const char *, char, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *, float, const char *, const char *);\n\u00a0\u00a0\u00a0\u00a0NonDegreeStudent(const NonDegreeStudent &s): Student(s){ }\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0virtual ~NonDegreeStudent() { } // destructor\n\u00a0\u00a0\u00a0\u00a0virtual const char *IsA() override \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return \"NonDegreeStudent\"; }\n\u00a0\u00a0\u00a0\u00a0virtual void Graduate() override;\n};\n// Assume alternate constructor is implemented as expected.\n// Notice copy constructor is inline above (as is default)\n// See online code for full implementation.\nvoid NonDegreeStudent::Graduate()\n{\u00a0\u00a0\u00a0// Check if applicable tuition has been paid. \n\u00a0\u00a0\u00a0\u00a0// There is no credit or gpa requirement.\n\u00a0\u00a0\u00a0\u00a0cout << \"NonDegreeStudent::Graduate()\" << endl;\n}\n```", "```cpp\n// Creates a Student based on the degree they seek\n// This is a static method of Student (keyword in prototype)\nStudent *Student::MatriculateStudent(const char *degree, \n\u00a0\u00a0\u00a0\u00a0const char *fn, const char *ln, char mi, const char *t,\n\u00a0\u00a0\u00a0\u00a0float avg, const char *course, const char *id)\n{\n\u00a0\u00a0\u00a0\u00a0if (!strcmp(degree, \"PhD\") || !strcmp(degree, \"MS\") \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| !strcmp(degree, \"MA\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return new GradStudent(degree, fn, ln, mi, t, avg,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0course, id);\n\u00a0\u00a0\u00a0\u00a0else if (!strcmp(degree, \"BS\") || !strcmp(degree, \"BA\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return new UnderGradStudent(degree, fn, ln, mi, t,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0avg, course, id);\n\u00a0\u00a0\u00a0\u00a0else if (!strcmp(degree, \"None\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return new NonDegreeStudent(fn, ln, mi, t, avg,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0course, id);\n}\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student *scholars[MAX];\n\u00a0\u00a0\u00a0\u00a0// Student is now abstract....cannot instantiate directly\n\u00a0\u00a0\u00a0\u00a0// Use the Factory Method to make derived types uniformly\n\u00a0\u00a0\u00a0\u00a0scholars[0] = Student::MatriculateStudent(\"PhD\", \"Sara\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Kato\", 'B', \"Ms.\", 3.9, \"C++\", \"272PSU\");\n\u00a0\u00a0\u00a0\u00a0scholars[1] = Student::MatriculateStudent(\"BS\", \"Ana\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Sato\", 'U', \"Ms.\", 3.8, \"C++\", \"178PSU\");\n\u00a0\u00a0\u00a0\u00a0scholars[2] = Student::MatriculateStudent(\"None\", \"Elle\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"LeBrun\", 'R', \"Miss\", 3.5, \"C++\", \"111BU\");\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scholars[i]->Graduate();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scholars[i]->Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete scholars[i];\u00a0\u00a0\u00a0// engage virtual dest. sequence\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nGradStudent::Graduate()\n\u00a0\u00a0Dr. Sara B. Kato with id: 272PSU GPA:\u00a0\u00a03.9 Course: C++\nUnderGradStudent::Graduate()\n\u00a0\u00a0Ms. Ana U. Sato with id: 178PSU GPA:\u00a0\u00a03.8 Course: C++\nNonDegreeStudent::Graduate()\n\u00a0\u00a0Miss Elle R. LeBrun with id: 111BU GPA:\u00a0\u00a03.5 Course: C++\n```", "```cpp\n// Assume Person class exists with its usual implementation\nclass Student: public Person\u00a0\u00a0\u00a0// Notice Student is \n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// an abstract class\nprivate:\n\u00a0\u00a0\u00a0\u00a0float gpa;\n\u00a0\u00a0\u00a0\u00a0char *currentCourse;\n\u00a0\u00a0\u00a0\u00a0const char *studentId;\npublic:\n\u00a0\u00a0\u00a0\u00a0Student();\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0Student(const char *, const char *, char, const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float, const char *, const char *);\n\u00a0\u00a0\u00a0\u00a0Student(const Student &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Student();\u00a0\u00a0// destructor\n\u00a0\u00a0\u00a0\u00a0float GetGpa() const { return gpa; }\n\u00a0\u00a0\u00a0\u00a0const char *GetCurrentCourse() const \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return currentCourse; }\n\u00a0\u00a0\u00a0\u00a0const char *GetStudentId() const { return studentId; }\n\u00a0\u00a0\u00a0\u00a0void SetCurrentCourse(const char *); // prototype only\n\u00a0\u00a0\u00a0\u00a0virtual void Print() const override;\n\u00a0\u00a0\u00a0\u00a0virtual const char *IsA() override { return \"Student\"; }\n\u00a0\u00a0\u00a0\u00a0virtual void Graduate() = 0;\u00a0\u00a0// Student is abstract\n};\n```", "```cpp\nclass GradStudent: public Student\n{\u00a0\u00a0\u00a0// Implemented as in our last example\n};\nclass UnderGradStudent: public Student\n{\u00a0\u00a0\u00a0// Implemented as in our last example\n};\nclass NonDegreeStudent: public Student\n{\u00a0\u00a0\u00a0// Implemented as in our last example\n};\n```", "```cpp\nclass StudentFactory\u00a0\u00a0\u00a0\u00a0// Object Factory class\n{\npublic:\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0// Factory Method \u2013 creates Student based on degree sought\n\u00a0\u00a0\u00a0\u00a0Student *MatriculateStudent(const char *degree, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *fn, const char *ln, char mi, const char *t,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float avg, const char *course, const char *id)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!strcmp(degree, \"PhD\") || !strcmp(degree, \"MS\") \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| !strcmp(degree, \"MA\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return new GradStudent(degree, fn, ln, mi, t, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0avg, course, id);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (!strcmp(degree, \"BS\") || \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0!strcmp(degree, \"BA\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return new UnderGradStudent(degree, fn, ln, mi, t,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0avg, course, id);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (!strcmp(degree, \"None\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return new NonDegreeStudent(fn, ln, mi, t, avg,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0course, id);\n\u00a0\u00a0\u00a0\u00a0}\n};\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student *scholars[MAX];\n\u00a0\u00a0\u00a0\u00a0// Create an Object Factory for Students\n\u00a0\u00a0\u00a0\u00a0StudentFactory *UofD = new StudentFactory();\n\u00a0\u00a0\u00a0\u00a0// Student is now abstract....cannot instantiate directly\n\u00a0\u00a0\u00a0\u00a0// Ask the Object Factory to create a Student\n\u00a0\u00a0\u00a0\u00a0scholars[0] = UofD->MatriculateStudent(\"PhD\", \"Sara\", \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Kato\", 'B', \"Ms.\", 3.9, \"C++\", \"272PSU\");\n\u00a0\u00a0\u00a0\u00a0scholars[1] = UofD->MatriculateStudent(\"BS\", \"Ana\", \"Sato\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'U', \"Dr.\", 3.8, \"C++\", \"178PSU\");\n\u00a0\u00a0\u00a0\u00a0scholars[2] = UofD->MatriculateStudent(\"None\", \"Elle\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"LeBrun\", 'R', \"Miss\", 3.5, \"c++\", \"111BU\");\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scholars[i]->Graduate();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scholars[i]->Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete scholars[i];\u00a0\u00a0\u00a0// engage virtual dest. sequence\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```"]