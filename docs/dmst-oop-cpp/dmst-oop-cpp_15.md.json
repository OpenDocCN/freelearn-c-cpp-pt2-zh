["```cpp\nclass Student;\u00a0\u00a0// forward declaration of Student class\nclass Id\u00a0\u00a0\u00a0\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0char *idNumber;\n\u00a0\u00a0\u00a0\u00a0Student *student;\npublic:\u00a0\u00a0// Assume constructors, destructor, etc. exist\n\u00a0\u00a0\u00a0\u00a0void SetStudent(Student *);\n\u00a0\u00a0\u00a0\u00a0// all member functions of Student are friend fns to/of Id\n\u00a0\u00a0\u00a0\u00a0friend class Student;\n};\nclass Student\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0char *name;\n\u00a0\u00a0\u00a0\u00a0float gpa;\n\u00a0\u00a0\u00a0\u00a0Id *studentId;\npublic:\u00a0\u00a0\u00a0// Assume constructors, destructor, etc. exist\n\u00a0\u00a0\u00a0\u00a0// only the following mbr function of Id is a friend fn.\n\u00a0\u00a0\u00a0\u00a0friend void Id::SetStudent(Student *);\u00a0\u00a0\u00a0\u00a0// to/of Student\n};\n```", "```cpp\ntypedef int Item;\u00a0\u00a0\nclass LinkList;\u00a0\u00a0// forward declaration\nclass LinkListElement\n{\nprivate:\n\u00a0\u00a0\u00a0void *data;\n\u00a0\u00a0\u00a0LinkListElement *next;\n\u00a0\u00a0\u00a0// private access methods to be used in scope of friend \n\u00a0\u00a0\u00a0void *GetData() { return data; } \n\u00a0\u00a0\u00a0LinkListElement *GetNext() { return next; }\n\u00a0\u00a0\u00a0void SetNext(LinkListElement *e) { next = e; }\npublic:\n// All mbr fns of LinkList are friend fns of LinkListElement \n\u00a0\u00a0\u00a0friend class LinkList;\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0LinkListElement() { data = 0; next = 0; }\n\u00a0\u00a0\u00a0LinkListElement(Item *i) { data = i; next = 0; }\n\u00a0\u00a0\u00a0~LinkListElement(){ delete (Item *)data; next = 0;}\n};\n// LinkList should only be extended as a protected or private\n// base class; it does not contain a virtual destructor. It\n// can be used as-is, or as implementation for another ADT.\nclass LinkList\n{\nprivate:\n\u00a0\u00a0\u00a0LinkListElement *head, *tail, *current;\npublic:\n\u00a0\u00a0\u00a0LinkList() { head = tail = current = 0; }\n\u00a0\u00a0\u00a0LinkList(LinkListElement *e) { head = tail = current = e; }\n\u00a0\u00a0\u00a0void InsertAtFront(Item *);\n\u00a0\u00a0\u00a0LinkListElement *RemoveAtFront();\u00a0\u00a0\n\u00a0\u00a0\u00a0void DeleteAtFront()\u00a0\u00a0{ delete RemoveAtFront(); }\n\u00a0\u00a0\u00a0int IsEmpty() { return head == 0; } \n\u00a0\u00a0\u00a0void Print();\u00a0\u00a0\u00a0\u00a0// see online definition\n\u00a0\u00a0\u00a0~LinkList() { while (!IsEmpty()) DeleteAtFront(); }\n};\n```", "```cpp\nvoid LinkList::InsertAtFront(Item *theItem)\n{\n\u00a0\u00a0\u00a0LinkListElement *temp = new LinkListElement(theItem);\n\u00a0\u00a0\u00a0// Note: temp can access private SetNext() as if it were\n\u00a0\u00a0\u00a0// in its own scope \u2013 it is in the scope of a friend fn.\n\u00a0\u00a0\u00a0temp->SetNext(head);\u00a0\u00a0// same as: temp->next = head;\n\u00a0\u00a0\u00a0head = temp;\n}\nLinkListElement *LinkList::RemoveAtFront()\n{\n\u00a0\u00a0\u00a0LinkListElement *remove = head;\n\u00a0\u00a0\u00a0head = head->GetNext();\u00a0\u00a0// head = head->next;\n\u00a0\u00a0\u00a0current = head;\u00a0\u00a0\u00a0\u00a0// reset current for usage elsewhere\n\u00a0\u00a0\u00a0return remove;\n}\n```", "```cpp\nStudent &operator+(float gpa, const Student &s);\n```", "```cpp\n// Assume usual header files and std namespace\nclass Person\n{\nprivate: \n\u00a0\u00a0\u00a0\u00a0char *firstName, *lastname, *title;\n\u00a0\u00a0\u00a0\u00a0char middleInitial;\nprotected:\n\u00a0\u00a0\u00a0\u00a0void ModifyTitle(const char *);\u00a0\u00a0\npublic:\n\u00a0\u00a0\u00a0\u00a0Person();\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0Person(const char *, const char *, char, const char *);\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Person(const Person &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Person();\u00a0\u00a0// destructor\n\u00a0\u00a0\u00a0\u00a0const char *GetFirstName() const { return firstName; }\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0const char *GetLastName() const { return lastName; }\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0const char *GetTitle() const { return title; } \n\u00a0\u00a0\u00a0\u00a0char GetMiddleInitial() const { return middleInitial; }\n\u00a0\u00a0\u00a0\u00a0virtual void Print() const;\n\u00a0\u00a0\u00a0\u00a0// overloaded operator functions\n\u00a0\u00a0\u00a0\u00a0Person &operator=(const Person &);\u00a0\u00a0// overloaded assign\n\u00a0\u00a0\u00a0\u00a0bool operator==(const Person &); // overloaded comparison\n\u00a0\u00a0\u00a0\u00a0Person &operator+(const char *); // overloaded plus\n\u00a0\u00a0\u00a0\u00a0// non-mbr friend fn. for operator+ (to make associative)\n\u00a0\u00a0\u00a0\u00a0friend Person &operator+(const char *, Person &);\u00a0\u00a0\n};\n```", "```cpp\n// Assume the required constructors, destructor and basic\n// member functions prototyped in the class definition exist.\n// overloaded assignment operator\nPerson &Person::operator=(const Person &p)\n{\n\u00a0\u00a0\u00a0\u00a0if (this != &p)\u00a0\u00a0// make sure we're not assigning an \n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// object to itself\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete firstName;\u00a0\u00a0// or call ~Person() to release\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete lastName;\u00a0\u00a0\u00a0// this memory (unconventional)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete title; \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0firstName = new char [strlen(p.firstName) + 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strcpy(firstName, p.firstName);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastName = new char [strlen(p.lastName) + 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strcpy(lastName, p.lastName);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0middleInitial = p.middleInitial;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0title = new char [strlen(p.title) + 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strcpy(title, p.title);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return *this;\u00a0\u00a0// allow for cascaded assignments\n}\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0// disallow assignment\n\u00a0\u00a0\u00a0\u00a0Person &operator=(const Person &) = delete;\n```", "```cpp\n// overloaded comparison operator\nbool Person::operator==(const Person &p)\n{\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0// if the objects are the same object, or if the\n\u00a0\u00a0\u00a0\u00a0// contents are equal, return true. Otherwise, false.\n\u00a0\u00a0\u00a0\u00a0if (this == &p) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1;\n\u00a0\u00a0\u00a0\u00a0else if ( (!strcmp(firstName, p.firstName)) &&\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(!strcmp(lastName, p.lastName)) &&\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(!strcmp(title, p.title)) &&\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(middleInitial == p.middleInitial) )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 1;\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n// overloaded operator + (member function)\nPerson &Person::operator+(const char *t)\n{\n\u00a0\u00a0\u00a0\u00a0ModifyTitle(t);\n\u00a0\u00a0\u00a0\u00a0return *this;\n}\n```", "```cpp\n// overloaded + operator (not a mbr function) \nPerson &operator+(const char *t, Person &p)\n{\n\u00a0\u00a0\u00a0\u00a0p.ModifyTitle(t);\n\u00a0\u00a0\u00a0\u00a0return p;\n}\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Person p1;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// default constructed Person\n\u00a0\u00a0\u00a0\u00a0Person p2(\"Gabby\", \"Doone\", 'A', \"Miss\");\n\u00a0\u00a0\u00a0\u00a0Person p3(\"Renee\", \"Alexander\", 'Z', \"Dr.\");\n\u00a0\u00a0\u00a0\u00a0p1.Print();\n\u00a0\u00a0\u00a0\u00a0p2.Print();\n\u00a0\u00a0\u00a0\u00a0p3.Print();\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0p1 = p2;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// invoke overloaded assignment operator\n\u00a0\u00a0\u00a0\u00a0p1.Print();\n\u00a0\u00a0\u00a0\u00a0p2 = \"Ms.\" + p2;\u00a0\u00a0\u00a0// invoke overloaded + operator\n\u00a0\u00a0\u00a0\u00a0p2.Print();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// then invoke overloaded =\u00a0\u00a0operator\n\u00a0\u00a0\u00a0\u00a0p1 = p2 = p3;\u00a0\u00a0\u00a0// overloaded = can handle cascaded =\n\u00a0\u00a0\u00a0\u00a0p2.Print();\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0p1.Print();\n\u00a0\u00a0\u00a0\u00a0if (p2 == p2)\u00a0\u00a0\u00a0// overloaded comparison operator\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Same people\" << endl;\n\u00a0\u00a0\u00a0\u00a0if (p1 == p3)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Same people\" << endl;\n\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nNo first name No last name\nMiss Gabby A. Doone\nDr. Renee Z. Alexander\nMiss Gabby A. Doone\nMs. Gabby A. Doone\nDr. Renee Z. Alexander\nDr. Renee Z. Alexander\nSame people\nSame people\n```", "```cpp\n    class ArrayInt\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0int numElements;\n    \u00a0\u00a0\u00a0\u00a0int *contents;\u00a0\u00a0\u00a0// dynamically allocated array\n    public:\n    \u00a0\u00a0\u00a0\u00a0ArrayInt(int size);// set numElements, alloc contents\n    \u00a0\u00a0\u00a0\u00a0int &operator[](int index) // returns a referenceable\n    \u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// memory location \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (index < numElements) return contents[index];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else cout << \"error\"; // or throw OutOfBounds\n    \u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// exception\n    };\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0ArrayInt a1(5); // Create an ArrayInt of 5 elements\n    \u00a0\u00a0\u00a0\u00a0A1[4] = 7;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// a1.operator[](4) = 7;\n    }\n    ```"]