["```cpp\nPerson p1(\"Alexa\", \"Gutierrez\", 'R', \"Ms.\");\nPerson p2(move(p1));\u00a0\u00a0// move copy constructor\nPerson p3 = move(p2); // also the move copy constructor\n```", "```cpp\nPerson p3(\"Alexa\", \"Gutierrez\", 'R', \"Ms.\");\nPerson p5(\"Xander\", \"LeBrun\", 'R', \"Dr.\");\np5 = move(p3);\u00a0\u00a0// move assignment; replaces p5\n```", "```cpp\nclass Person\n{\nprivate:\u00a0\u00a0\u00a0\u00a0// Assume all usual data members exist\nprotected:\u00a0\u00a0// Assume usual protected member functions exist \npublic:\n\u00a0\u00a0\u00a0\u00a0Person();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0// Assume other usual constructors exist\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Person(const Person &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0Person(Person &&);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// move copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Person();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// virtual destructor\n\u00a0\u00a0\u00a0\u00a0// Assume usual access functions and virtual fns. exist \n\u00a0\u00a0\u00a0\u00a0Person &operator=(const Person &);\u00a0\u00a0// assignment operator\n\u00a0\u00a0\u00a0\u00a0Person &operator=(Person &&);\u00a0\u00a0// move assignment operator\n};\n// copy constructor\nPerson::Person(const Person &pers)\u00a0\u00a0\u00a0\u00a0\u00a0\n{\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0// Assume deep copy is implemented here\u00a0\u00a0\n}\n// overloaded assignment operator\nPerson &Person::operator=(const Person &p)\n{\n\u00a0\u00a0\u00a0\u00a0if (this != &p)\u00a0\u00a0// check for self-assignment\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Delete existing Person ptr data members for 'this',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// then re-allocate correct size and copy from source\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return *this;\u00a0\u00a0// allow for cascaded assignments\n}\n```", "```cpp\n// move copy constructor\nPerson::Person(const Person &&pers)\u00a0\u00a0\u00a0\n{\u00a0\u00a0\u00a0// overtake source object's dynamically allocated memory\n\u00a0\u00a0\u00a0\u00a0// and null-out source object's pointers to that memory\n\u00a0\u00a0\u00a0\u00a0firstName = pers.firstName;\n\u00a0\u00a0\u00a0\u00a0pers.firstName = 0;\n\u00a0\u00a0\u00a0\u00a0lastName = pers.lastName;\n\u00a0\u00a0\u00a0\u00a0pers.lastName = 0;\n\u00a0\u00a0\u00a0\u00a0middleInitial = pers.middleInitial;\n\u00a0\u00a0\u00a0\u00a0pers.middleInitial = '\\0'; // null char indicates non-use\n\u00a0\u00a0\u00a0\u00a0title = pers.title;\n\u00a0\u00a0\u00a0\u00a0pers.title = 0;\n}\n// move overloaded assignment operator\nPerson &Person::operator=(const Person &p)\n{ \n\u00a0\u00a0\u00a0\u00a0if (this != &p)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// check for self-assignment\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete firstName;\u00a0\u00a0// or call ~Person(); (unusual)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete lastName;\u00a0\u00a0\u00a0// Delete existing object's\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete title;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// allocated data members\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// overtake source object's dynamically alloc memory\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// and null source object's pointers to that memory\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0firstName = p.firstName;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p.firstName = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastName = p.lastName;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p.lastName = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0middleInitial = p.middleInitial;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p.middleInitial = '\\0'; // null char indicates non-use\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0title = p.title;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p.title = 0;\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return *this;\u00a0\u00a0// allow for cascaded assignments\u00a0\u00a0\n}\n```", "```cpp\nclass Student: public Person\n{\nprivate:\u00a0\u00a0// Assume usual data members exist\npublic:\n\u00a0\u00a0\u00a0\u00a0Student();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0// Assume other usual constructors exist\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Student(const Student &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0Student(Student &&);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// move copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Student();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// virtual destructor\n\u00a0\u00a0\u00a0\u00a0// Assume usual access functions exist \n\u00a0\u00a0\u00a0\u00a0// as well as virtual overrides and additional methods\n\u00a0\u00a0\u00a0\u00a0Student &operator=(const Student &);\u00a0\u00a0// assignment op.\n\u00a0\u00a0\u00a0\u00a0Student &operator=(Student &&);\u00a0\u00a0// move assignment op.\n};\n// copy constructor\nStudent::Student(const Student &s): Person(s)\n{\u00a0\u00a0\u00a0// Use member init. list to specify base copy constructor\n\u00a0\u00a0\u00a0\u00a0// to initialize base sub-object\n\u00a0\u00a0\u00a0\u00a0// Assume deep copy for Student is implemented here\u00a0\u00a0\n}\n// Overloaded assignment operator\nStudent &Student::operator=(const Student &s)\n{\n\u00a0\u00a0\u00a0if (this != &s)\u00a0\u00a0\u00a0// check for self-assignment\n\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Person::operator=(s);\u00a0\u00a0// call base class assignment op\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// delete existing Student ptr data members for 'this'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// then reallocate correct size and copy from source\n\u00a0\u00a0\u00a0}\n}\n```", "```cpp\n// move copy constructor\nStudent::Student(Student &&ps): Person(move(ps))\u00a0\u00a0\u00a0\n{\u00a0\u00a0\u00a0// Use member init. list to specify base move copy \n\u00a0\u00a0\u00a0\u00a0// constructor to initialize base sub-object\n\u00a0\u00a0\u00a0\u00a0gpa = ps.gpa;\n\u00a0\u00a0\u00a0\u00a0ps.gpa = 0.0;\n\u00a0\u00a0\u00a0\u00a0currentCourse = ps.currentCourse;\n\u00a0\u00a0\u00a0\u00a0ps.currentCourse = 0;\n\u00a0\u00a0\u00a0\u00a0studentId = ps.studentId;\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0ps.studentId = 0;\n}\n// move assignment operator\nStudent &Student::operator=(Student &&s)\n{\n\u00a0\u00a0\u00a0// make sure we're not assigning an object to itself\n\u00a0\u00a0\u00a0if (this != &s)\n\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Person::operator=(move(s));\u00a0\u00a0// call base move oper=\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete currentCourse;\u00a0\u00a0// delete existing data members\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete studentId;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0gpa = s.gpa;\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.gpa = 0.0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currentCourse = s.currentCourse;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.currentCourse = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0studentId = s.studentId;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s.studentId = 0;\n\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0return *this;\u00a0\u00a0// allow for cascaded assignments\n}\n```", "```cpp\n#include \"Person.h\"\u00a0\u00a0\u00a0\u00a0// include relevant class header files\n#include \"Student.h\"\nusing namespace std;\nconst int MAX = 3;\nint main()\u00a0\u00a0\u00a0// Driver to test Student class. Stored in above\n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// filename for chapter example consistency \n\u00a0\u00a0\u00a0\u00a0// Test all means for instantiation, including copy const.\n\u00a0\u00a0\u00a0\u00a0Student s0; // Default construction\n\u00a0\u00a0\u00a0\u00a0// alternate constructor\n\u00a0\u00a0\u00a0\u00a0Student s1(\"Jo\", \"Li\", 'H', \"Ms.\", 3.7, \"C++\", \"UD1234\");\n\u00a0\u00a0\u00a0\u00a0Student s2(\"Sam\", \"Lo\", 'A', \"Mr.\", 3.5, \"C++\", \"UD2245\");\n\u00a0\u00a0\u00a0\u00a0// These initializations implicitly invoke copy const.\n\u00a0\u00a0\u00a0\u00a0Student s3(s1);\n\u00a0\u00a0\u00a0\u00a0Student s4 = s2;\u00a0\u00a0\u00a0// This is also initialization\n\u00a0\u00a0\u00a0\u00a0// Test the assignment operator\n\u00a0\u00a0\u00a0\u00a0Student s5(\"Ren\", \"Ze\", 'A', \"Dr.\", 3.8, \"C++\", \"BU5563\");\n\u00a0\u00a0\u00a0\u00a0Student s6;\n\u00a0\u00a0\u00a0\u00a0s6 = s5;\u00a0\u00a0// this is an assignment, not initialization\n\u00a0\u00a0\u00a0\u00a0// Test each public method. A sample is shown here\n\u00a0\u00a0\u00a0\u00a0s1.Print();\u00a0\u00a0// Be sure to test each method! \n\n\u00a0\u00a0\u00a0\u00a0// Generalize derived instances as base types \n\u00a0\u00a0\u00a0\u00a0// Do the polymorphic operations work as expected?\n\u00a0\u00a0\u00a0\u00a0Person *people[MAX];\n\u00a0\u00a0\u00a0\u00a0// base instance for comparison\n\u00a0\u00a0\u00a0\u00a0people[0] = new Person(\"Juliet\", \"Martinez\", 'M', \"Ms.\");\n\u00a0\u00a0\u00a0\u00a0// derived instances, generalized with base class ptrs.\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0people[1] = new Student(\"Zack\", \"Moon\", 'R', \"Dr.\", 3.8,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"C++\", \"UMD1234\");\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0people[2] = new Student(\"Gabby\", \"Doone\", 'A', \"Dr.\", 3.9,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"C++\", \"GWU4321\");\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people[i]->IsA();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"\u00a0\u00a0\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people[i]->Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Test destruction sequence (dynam. allocated instances)\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete people[i];\u00a0\u00a0\u00a0// engage virtual dest. sequence\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```"]