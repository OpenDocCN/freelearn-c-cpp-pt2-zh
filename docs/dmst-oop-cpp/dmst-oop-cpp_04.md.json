["```cpp\nint x = 10;\nint *pointerToX;\u00a0\u00a0\u00a0// pointer variable which may someday\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// point to an integer\npointerToX = &x;\u00a0\u00a0// assign memory location of x to pointerToX\ncout << \"x is \" << x << \" and *pointerToX is \" << *pointerToX;\n```", "```cpp\nx is 10 and *pointerToX is 10\n```", "```cpp\nint *y;\u00a0\u00a0\u00a0\u00a0// y is a pointer which may someday point to an int\ny = new int;\u00a0\u00a0// y points to memory allocated on the heap\n*y = 17;\u00a0\u00a0\u00a0// dereference y to load the newly allocated memory\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// with a value of 17\ncout << \"*y is: \" << *y << endl;\ndelete y;\u00a0\u00a0// relinquish the allocated memory\n```", "```cpp\ninclude <iostream>\nusing namespace std;\nstruct collection\n{\n\u00a0\u00a0\u00a0\u00a0int x;\n\u00a0\u00a0\u00a0\u00a0float y;\n};\n\nint main()\u00a0\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0collection *item;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// pointer declaration \n\u00a0\u00a0\u00a0\u00a0item = new collection; // memory allocation \n\u00a0\u00a0\u00a0\u00a0item->x = 9;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// use -> to access data member x\n\u00a0\u00a0\u00a0\u00a0(*item).y = 120.77; // alt. notation to access member y\n\u00a0\u00a0\u00a0\u00a0cout << (*item).x << \" \" << item->y << endl;\n\u00a0\u00a0\u00a0\u00a0delete item;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// relinquish memory\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n9 120.77\n```", "```cpp\n#include <iostream>\nusing namespace std;\nstruct collection\n{\n\u00a0\u00a0\u00a0\u00a0int x;\n\u00a0\u00a0\u00a0\u00a0float y;\n};\n\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0int numElements;\n\u00a0\u00a0\u00a0\u00a0int *intArray;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// pointer declarations \n\u00a0\u00a0\u00a0\u00a0collection *collectionArray;\u00a0\u00a0// to eventual arrays\n\u00a0\u00a0\u00a0\u00a0cout << \"How many elements would you like? \" << flush;\n\u00a0\u00a0\u00a0\u00a0cin >> numElements;\n\u00a0\u00a0\u00a0\u00a0intArray = new int[numElements]; // allocate array bodies\n\u00a0\u00a0\u00a0\u00a0collectionArray = new collection[numElements];\n\u00a0\u00a0\u00a0\u00a0// continued \u2026\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0// load each array with values\n\u00a0\u00a0\u00a0\u00a0for (int i 0; i < numElements; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intArray[i] = i;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// load each array w values\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0collectionArray[i].x = i;\u00a0\u00a0// using array notation []\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0collectionArray[i].y = i + .5;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// alternatively use ptr notation to print two values\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << *(intArray + i) << \" \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << (*(collectionArray + i)).y << endl;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0delete intArray;\u00a0\u00a0\u00a0\u00a0\u00a0// mark memory for deletion\n\u00a0\u00a0\u00a0\u00a0delete [] collectionArray;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nHow many elements would you like? 3\n0 0.5\n1 1.5\n2 2.5\n```", "```cpp\n#include <iostream>\nusing namespace std;\nconst int NUMROWS = 5;\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0float *TwoDimArray[NUMROWS];\u00a0\u00a0// array of pointers\n\u00a0\u00a0\u00a0\u00a0int numColumns;\n\u00a0\u00a0\u00a0\u00a0cout << \"Enter number of columns: \";\n\u00a0\u00a0\u00a0\u00a0cin >> numColumns;\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < NUMROWS; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// allocate column quantity for each row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TwoDimArray[i] = new float [numColumns];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// load each column entry with data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < numColumns; j++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TwoDimArray[i][j] = i + j + .05;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << TwoDimArray[i][j] << \" \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << endl;\u00a0\u00a0// print newline between rows\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < NUMROWS; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete TwoDimArray[i];\u00a0\u00a0// delete column for each row\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nEnter number of columns: 3\n0.05 1.05 2.05\n1.05 2.05 3.05\n2.05 3.05 4.05\n3.05 4.05 5.05\n4.05 5.05 6.05\n```", "```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0int numRows, numColumns;\n\u00a0\u00a0\u00a0\u00a0float **TwoDimArray;\u00a0\u00a0\u00a0\u00a0// pointer to a pointer\n\u00a0\u00a0\u00a0\u00a0cout << \"Enter number of rows: \" << flush;\n\u00a0\u00a0\u00a0\u00a0cin >> numRows;\n\u00a0\u00a0\u00a0\u00a0TwoDimArray = new float * [numRows];\u00a0\u00a0// allocate row ptrs\n\u00a0\u00a0\u00a0\u00a0cout << \"Enter number of Columns: \";\n\u00a0\u00a0\u00a0\u00a0cin >> numColumns;\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < numRows; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// allocate column quantity for each row\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TwoDimArray[i] = new float [numColumns];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// load each column entry with data\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < numColumns; j++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TwoDimArray[i][j] = i + j + .05;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << TwoDimArray[i][j] << \" \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << end;\u00a0\u00a0// print newline between rows\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0for (i = 0; i < numRows; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete TwoDimArray[i];\u00a0\u00a0// delete columns for each row\n\u00a0\u00a0\u00a0\u00a0delete TwoDimArray;\u00a0\u00a0// delete allocated rows\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nEnter number of rows: 3\nEnter number of columns: 4\n0.05 1.05 2.05 3.05\n1.05 2.05 3.05 4.05\n2.05 3.05 4.05 5.05\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0int dim1, dim1, dim3;\n\u00a0\u00a0\u00a0\u00a0int ***ThreeDimArray;\u00a0\u00a0\u00a0// 3-D dynamically allocated array\n\u00a0\u00a0\u00a0\u00a0cout << \"Enter dim 1, dim 2, dim 3: \";\n\u00a0\u00a0\u00a0\u00a0cin >> dim1 >> dim2 >> dim3;\n\u00a0\u00a0\u00a0\u00a0ThreeDimArray = new int ** [dim1]; // allocate dim 1\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < dim1; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ThreeDimArray[i] = new int * [dim2]; // allocate dim 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < dim2; j++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// allocate dim 3\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ThreeDimArray[i][j] = new int [dim3];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int k = 0; k < dim3; k++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ThreeDimArray[i][j][k] = i + j + k; \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << ThreeDimArray[i][j][k] << \" \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << endl;\u00a0\u00a0// print newline between dimensions\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << end;\u00a0\u00a0// print newline between dimensions\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < dim1; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < dim2; j++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete ThreeDimArray[i][j]; // release dim 3\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete ThreeDimArray[i];\u00a0\u00a0// release dim 2\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0delete ThreeDimArray;\u00a0\u00a0\u00a0// release dim 1\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nEnter dim1, dim2, dim3: 2 4 3\n0 1 2\n1 2 3\n2 3 4\n3 4 5\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n```", "```cpp\nvoid TryToAddOne(int arg)\n{\n\u00a0\u00a0\u00a0arg++;\n}\nvoid AddOne(int *arg)\n{\n\u00a0\u00a0\u00a0(*arg)++;\n}\n```", "```cpp\n#include <iostream>\nusing namespace std;\nvoid TryToAddOne(int); // function prototypes\nvoid AddOne(int *);\nint main()\n{\n\u00a0\u00a0\u00a0int x = 10, *y;\n\u00a0\u00a0\u00a0y = new int;\u00a0\u00a0\u00a0\u00a0// allocate y's memory\n\u00a0\u00a0\u00a0*y = 15;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// dereference y to assign a value\n\u00a0\u00a0\u00a0cout << \"x: \" << x << \" and *y: \" << *y << endl;\n\u00a0\u00a0\u00a0TryToAddOne(x);\u00a0\u00a0\u00a0// unsuccessful, call by value\n\u00a0\u00a0\u00a0TryToAddOne(*y);\u00a0\u00a0// still unsuccessful\n\u00a0\u00a0\u00a0cout << \"x: \" << x << \" and *y: \" << *y << endl;\n\u00a0\u00a0\u00a0AddOne(&x);\u00a0\u00a0\u00a0// successful, passing an address \n\u00a0\u00a0\u00a0AddOne(y);\u00a0\u00a0\u00a0\u00a0// also successful\n\u00a0\u00a0\u00a0cout << \"x: \" << x << \" and *y: \" << *y << endl;\n\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nx: 10 and *y: 15\nx: 10 and *y: 15\nx: 11 and *y: 16\n```", "```cpp\n#include <iostream>\n#include <iomanip>\nusing namespace std; \nconst int MAX = 20;\nchar *createName();\u00a0\u00a0// function prototype\nint main()\u00a0\u00a0\u00a0\u00a0\n{\n\u00a0\u00a0\u00a0char *name;\u00a0\u00a0\u00a0// pointer declaration\n\u00a0\u00a0\u00a0name = createName();\u00a0\u00a0// function will allocate memory\n\u00a0\u00a0\u00a0cout << \"Name: \" << name << endl;\n\u00a0\u00a0\u00a0delete name;\u00a0\u00a0// delete allocated memory\n\u00a0\u00a0\u00a0return 0;\n}\nchar *createName()\n{\n\u00a0\u00a0\u00a0char *temp = new char[MAX];\n\u00a0\u00a0\u00a0cout << \"Enter name: \" << flush;\n\u00a0\u00a0\u00a0cin >> setw(MAX) >> temp; \n\u00a0\u00a0\u00a0return temp;\n}\n```", "```cpp\nEnter name: Gabrielle\nName: Gabrielle\n```", "```cpp\n// const qualified strings; the data pointed to will be const\nconst char *constData = \"constant\"; \nconst char *moreConstData;\u00a0\u00a0\n// regular strings, defined. One is loaded using strcpy()\u00a0\u00a0\nchar *regularString;\nchar *anotherRegularString = new char[8];\nstrcpy(anotherRegularString, \"regular\"); \n// Trying to modify data marked as const will not work\n// strcpy(constData, \"Can I do this? \");\u00a0\u00a0// NO! \n// Trying to circumvent by having a char * point to\n// a const char * also will not work\n// regularString = constData; // NO! \n// But we can treat a char * more strictly by assigning it to\n// a const char *. It will be const from that viewpoint only\nmoreConstData = anotherRegularString; // Yes, I can do this!\n```", "```cpp\n// Define, allocate, load two regular strings using strcpy()\nchar *regularString = new char[36];\nstrcpy(regularString, \"I am a string which can be modified\");\nchar *anotherRegularString = new char[21];\nstrcpy(anotherRegularString, \"I am also modifiable\"); \n// Define a const pointer to a string. It must be initialized\nchar *const constPtrString = regularString; // Ok\n// You may not modify a const pointer to point elsewhere\n// constPtrString = anotherRegularString;\u00a0\u00a0//No! \n// But you may change the data which you point to\nstrcpy(constPtrString, \"I can change the value\"); // Yes\n```", "```cpp\n// Define two regular strings and load using strcpy()\nchar *regularString = new char[36];\nstrcpy(regularString, \"I am a string which can be modified\");\nchar *anotherRegularString = new char[21];\nstrcpy(anotherRegularString, \"I am also modifiable\"); \n// Define a const ptr to a const object. Must be initialized\nconst char *const constStringandPtr = regularString; // Ok \n// Trying to change the pointer or the data is illegal\nconstStringandPtr = anotherRegularString; //No! Can't mod addr\nstrcpy(constStringandPtr, \"Nope\"); // No! Can't mod data\n```", "```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\nchar suffix = 'A';\nconst char *genId(const char *);\u00a0\u00a0// function prototype\nint main()\u00a0\u00a0\u00a0\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0const char *newId1, *newId2;\u00a0\u00a0\u00a0// pointer declarations\n\u00a0\u00a0\u00a0\u00a0newId1 = genId(\"Group\");\u00a0\u00a0// function will allocate memory\n\u00a0\u00a0\u00a0\u00a0newId2 = genId(\"Group\");\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0cout << \"New ids: \" << newId1 << \" \" << newId2 << endl;\n\u00a0\u00a0\u00a0\u00a0delete newId1;\u00a0\u00a0// delete allocated memory\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0delete newId2;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\nconst char *genId(const char *base)\n{\n\u00a0\u00a0\u00a0\u00a0char *temp = new char[strlen(base) + 2]; \n\u00a0\u00a0\u00a0\u00a0strcpy(temp, base);\u00a0\u00a0// use base to initialize string\n\u00a0\u00a0\u00a0\u00a0temp[strlen(base)] = suffix++; // Append suffix to base\n\u00a0\u00a0\u00a0\u00a0temp[strlen(base) + 1] = '\\0'; // Add null character\n\u00a0\u00a0\u00a0\u00a0return temp; // temp will be up-cast to a const char *\n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// to be treated more restrictively than \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// it was defined\n```", "```cpp\nNew ids: GroupA GroupB\n```", "```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0void *unspecified;\u00a0\u00a0// void * may point to any data type\n\u00a0\u00a0\u00a0\u00a0int *x;\n\u00a0\u00a0\u00a0\u00a0unspecified = new int; // the void * now points to an int\n\u00a0\u00a0\u00a0\u00a0// void * must be cast to int * before it is dereferenced\n\u00a0\u00a0\u00a0\u00a0*((int *) unspecified) = 89;\n\u00a0\u00a0\u00a0\u00a0// let x point to the memory which unspecified points to\n\u00a0\u00a0\u00a0\u00a0x = (int *) unspecified;\n\u00a0\u00a0\u00a0\u00a0cout << *x << \" \" << *((int *) unspecified) << endl;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n89 89\n```"]