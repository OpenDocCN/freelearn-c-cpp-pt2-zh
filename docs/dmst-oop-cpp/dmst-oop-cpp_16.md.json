["```cpp\nclass ArrayInt\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0int numElements;\n\u00a0\u00a0\u00a0\u00a0int *contents;\u00a0\u00a0\u00a0// dynamically allocated array\npublic:\n\u00a0\u00a0\u00a0\u00a0ArrayInt(int size) : numElements(size) \n\u00a0\u00a0\u00a0\u00a0{ \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contents = new int [size];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0~ArrayInt() { delete contents; }\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0int &operator[](int index) // returns a referenceable\n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// memory location \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (index < numElements) return contents[index];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else cout << \"Out of Bounds\"; // or better \u2013 throw an\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// OutOfBounds exception\n};\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0ArrayInt a1(5); // Create an ArrayInt of 5 elements\n\u00a0\u00a0\u00a0\u00a0a1[4] = 7;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// a1.operator[](4) = 7;\n}\u00a0\u00a0\u00a0\n```", "```cpp\n// template function prototype\ntemplate <class Type1, class Type2>\u00a0\u00a0\u00a0// template preamble\nType2 ChooseFirst(Type1, Type2);\n// template function definition\ntemplate <class Type1, class Type2>\u00a0\u00a0// template preamble\nType2 ChooseFirst(Type1 x, Type2 y)\n{\n\u00a0\u00a0\u00a0\u00a0if (x < y) return (Type2) x;\n\u00a0\u00a0\u00a0\u00a0else return y; \n}\u00a0\u00a0\u00a0\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0int value1 = 4, value2 = 7;\n\u00a0\u00a0\u00a0\u00a0float value3 = 5.67f;\n\u00a0\u00a0\u00a0\u00a0cout << \"First: \" << ChooseFirst(value1, value3) << endl;\n\u00a0\u00a0\u00a0\u00a0cout << \"First: \" << ChooseFirst(value2, value1) << endl;\n}\n```", "```cpp\nFirst: 4\nFirst: 4\n```", "```cpp\ntemplate <class Type>\u00a0\u00a0\u00a0// template class preamble\nclass Array\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0int numElements;\n\u00a0\u00a0\u00a0\u00a0Type *contents;\u00a0\u00a0\u00a0// dynamically allocated array\npublic:\n\u00a0\u00a0\u00a0\u00a0Array(int size) : numElements(size)\n\u00a0\u00a0\u00a0\u00a0{ \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0contents = new Type [size];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0~Array() { delete contents; }\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0void Print() const;\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Type &operator[](int index) // returns a referenceable\n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// memory location \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (index < numElements) return contents[index];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else cout << \"Out of Bounds\"; // or better \u2013 throw an\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// OutOfBounds exception\n\u00a0\u00a0\u00a0\u00a0void operator+(Type);\u00a0\u00a0\u00a0// prototype only\n};\ntemplate <class Type>\nvoid Array<Type>::operator+(Type item)\u00a0\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0// resize array as necessary, add new data element and\n\u00a0\u00a0\u00a0\u00a0// increment numElements\n}\ntemplate <class Type>\nvoid Array<Type>::Print() const\n{\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < numElements; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << contents[i] << \" \";\n\u00a0\u00a0\u00a0\u00a0cout << endl;\n}\nint main()\n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0// Creation of int array will trigger template expansion\n\u00a0\u00a0\u00a0\u00a0Array<int> a1(3); // Create an int Array of 3 int elements\n\u00a0\u00a0\u00a0\u00a0a1[2] = 12;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0a1[1] = 70;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// a1.operator[](1) = 70;\n\u00a0\u00a0\u00a0\u00a0a1[0] = 2;\n\u00a0\u00a0\u00a0\u00a0a1.Print();\n}\u00a0\u00a0\u00a0\n```", "```cpp\n2 70 12\n```", "```cpp\n#include <iostream>\nusing namespace std;\ntemplate <class Type> class LinkList;\u00a0\u00a0// forward declaration\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// with template preamble\ntemplate <class Type>\u00a0\u00a0\u00a0// template preamble for class def\nclass LinkListElement\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0Type *data;\n\u00a0\u00a0\u00a0\u00a0LinkListElement *next;\n\u00a0\u00a0\u00a0\u00a0// private access methods to be used in scope of friend\n\u00a0\u00a0\u00a0\u00a0Type *GetData() { return data; } \n\u00a0\u00a0\u00a0\u00a0LinkListElement *GetNext() { return next; }\n\u00a0\u00a0\u00a0\u00a0void SetNext(LinkListElement *e) { next = e; }\npublic:\n\u00a0\u00a0\u00a0\u00a0friend class LinkList<Type>;\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0LinkListElement() { data = 0; next = 0; }\n\u00a0\u00a0\u00a0\u00a0LinkListElement(Type *i) { data = i; next = 0; }\n\u00a0\u00a0\u00a0\u00a0~LinkListElement(){ delete data; next = 0;}\n};\n// LinkList should only be extended as a protected or private\n// base class; it does not contain a virtual destructor. It\n// can be used as-is, or as implementation for another ADT.\ntemplate <class Type>\nclass LinkList\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0LinkListElement<Type> *head, *tail, *current;\npublic:\n\u00a0\u00a0\u00a0\u00a0LinkList() { head = tail = current = 0; }\n\u00a0\u00a0\u00a0\u00a0LinkList(LinkListElement<Type> *e) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ head = tail = current = e; }\n\u00a0\u00a0\u00a0\u00a0void InsertAtFront(Type *);\n\u00a0\u00a0\u00a0\u00a0LinkListElement<Type> *RemoveAtFront();\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0void DeleteAtFront()\u00a0\u00a0{ delete RemoveAtFront(); }\n\u00a0\u00a0\u00a0\u00a0int IsEmpty() { return head == 0; } \n\u00a0\u00a0\u00a0\u00a0void Print();\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0~LinkList(){ while (!IsEmpty()) DeleteAtFront(); }\n};\n```", "```cpp\ntemplate <class Type>\u00a0\u00a0\u00a0\u00a0\u00a0// template preamble\nvoid LinkList<Type>::InsertAtFront(Type *theItem)\n{\n\u00a0\u00a0\u00a0\u00a0LinkListElement<Type> *temp;\n\u00a0\u00a0\u00a0\u00a0temp = new LinkListElement<Type>(theItem);\n\u00a0\u00a0\u00a0\u00a0temp->SetNext(head);\u00a0\u00a0// temp->next = head;\n\u00a0\u00a0\u00a0\u00a0head = temp;\n}\ntemplate <class Type>\u00a0\u00a0\u00a0\u00a0// template preamble\nLinkListElement<Type> *LinkList<Type>::RemoveAtFront()\n{\n\u00a0\u00a0\u00a0\u00a0LinkListElement<Type> *remove = head;\n\u00a0\u00a0\u00a0\u00a0head = head->GetNext();\u00a0\u00a0// head = head->next;\n\u00a0\u00a0\u00a0\u00a0current = head;\u00a0\u00a0\u00a0\u00a0// reset current for usage elsewhere\n\u00a0\u00a0\u00a0\u00a0return remove;\n}\n\ntemplate <class Type>\u00a0\u00a0\u00a0\u00a0// template preamble\nvoid LinkList<Type>::Print()\n{\n\u00a0\u00a0\u00a0\u00a0Type output;\n\u00a0\u00a0\u00a0\u00a0if (!head)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"<EMPTY>\" << endl;\n\u00a0\u00a0\u00a0\u00a0current = head;\n\u00a0\u00a0\u00a0\u00a0while (current)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0output = *(current->GetData());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << output << \" \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current = current->GetNext();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0cout << endl;\n}\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0LinkList<int> list1; // create a LinkList of integers\n\u00a0\u00a0\u00a0\u00a0list1.InsertAtFront(new int (3000));\n\u00a0\u00a0\u00a0\u00a0list1.InsertAtFront(new int (600));\n\u00a0\u00a0\u00a0\u00a0list1.InsertAtFront(new int (475));\n\u00a0\u00a0\u00a0\u00a0cout << \"List 1: \";\n\u00a0\u00a0\u00a0\u00a0list1.Print();\n\u00a0\u00a0\u00a0\u00a0// delete elements from list, one by one\n\u00a0\u00a0\u00a0\u00a0while (!(list1.IsEmpty()))\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list1.DeleteAtFront();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"List 1 after removing an item: \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list1.Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0LinkList<float> list2;\u00a0\u00a0// now make a LinkList of floats\n\u00a0\u00a0\u00a0\u00a0list2.InsertAtFront(new float(30.50));\n\u00a0\u00a0\u00a0\u00a0list2.InsertAtFront(new float (60.89));\n\u00a0\u00a0\u00a0\u00a0list2.InsertAtFront(new float (45.93));\n\u00a0\u00a0\u00a0\u00a0cout << \"List 2: \";\n\u00a0\u00a0\u00a0\u00a0list2.Print();\n}\n```", "```cpp\nList 1: 475 600 3000\nList 1 after removing an item: 600 3000\nList 1 after removing an item: 3000\nList 1 after removing an item: <EMPTY>\nList 2: 45.93 60.89 30.5\n```", "```cpp\ntemplate <class Type>\nvoid LinkList<Type>::OrderedInsert(Type *theItem)\n{\n\u00a0\u00a0\u00a0\u00a0current = head;\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (theItem < head->GetData())\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0InsertAtFront(theItem);\u00a0\u00a0\u00a0// add theItem before head\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Traverse list, add theItem in the proper location\n}\n```", "```cpp\n// overload operator < As a member function of Student\nbool Student::operator<(const Student &s)\n{\n\u00a0\u00a0\u00a0\u00a0if (this->gpa < s.gpa)\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n}\n// OR, overload operator < as a non-member function\nbool operator<(const Student &s1, const Student &s2)\n{\n\u00a0\u00a0\u00a0\u00a0if (s1.gpa < s2.gpa)\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n}\n```"]