["```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0int x = 10;\n\u00a0\u00a0\u00a0\u00a0int *p = new int;\u00a0\u00a0\u00a0\u00a0// allocate memory for ptr variable\n\u00a0\u00a0\u00a0\u00a0*p = 20;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// dereference and assign value \n\u00a0\u00a0\u00a0\u00a0int &refInt1 = x;\u00a0\u00a0// reference to an integer\n\u00a0\u00a0\u00a0\u00a0int &refInt2 = *p; // also a reference to an integer\n\u00a0\u00a0\u00a0\u00a0cout << x << \" \" << *p << \" \";\n\u00a0\u00a0\u00a0\u00a0cout << refInt1 << \" \" << refInt2 << endl;\n\u00a0\u00a0\u00a0\u00a0x++;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// updates x and refInt1\n\u00a0\u00a0\u00a0\u00a0(*p)++;\u00a0\u00a0\u00a0// updates *p and refInt2\n\u00a0\u00a0\u00a0\u00a0cout << x << \" \" << *p << \" \";\n\u00a0\u00a0\u00a0\u00a0cout << refInt1 << \" \" << refInt2 << endl;\n\u00a0\u00a0\u00a0\u00a0refInt1++;\u00a0\u00a0\u00a0\u00a0// updates refInt1 and x\n\u00a0\u00a0\u00a0\u00a0refInt2++;\u00a0\u00a0\u00a0\u00a0// updates refInt2 and *p\n\u00a0\u00a0\u00a0\u00a0cout << x << \" \" << *p << \" \";\n\u00a0\u00a0\u00a0\u00a0cout << refInt1 << \" \" << refInt2 << endl;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n10 20 10 20\n11 21 11 21\n12 22 12 22\n```", "```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\nclass Student\n{\npublic:\n\u00a0\u00a0\u00a0\u00a0char name[20];\n\u00a0\u00a0\u00a0\u00a0float gpa;\n};\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student s1;\n\u00a0\u00a0\u00a0\u00a0Student &sRef = s1;\u00a0\u00a0// establish a reference to s1\n\u00a0\u00a0\u00a0\u00a0strcpy(s1.name, \"Katje Katz\");\u00a0\u00a0\u00a0// fill in the data\n\u00a0\u00a0\u00a0\u00a0s1.gpa = 3.75;\n\u00a0\u00a0\u00a0\u00a0cout << s1.name << \" has GPA: \" << s1.gpa << endl; \n\u00a0\u00a0\u00a0\u00a0cout << sRef.name << \" has GPA: \" << sRef.gpa << endl; \n\u00a0\u00a0\u00a0\u00a0strcpy(sRef.name, \"George Katz\");\u00a0\u00a0// change the data\n\u00a0\u00a0\u00a0\u00a0sRef.gpa = 3.25;\n\u00a0\u00a0\u00a0\u00a0cout << s1.name << \" has GPA: \" << s1.gpa << endl; \n\u00a0\u00a0\u00a0\u00a0cout << sRef.name << \" has GPA: \" << sRef.gpa << endl; \n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nKatje Katz has GPA: 3.75\nKatje Katz has GPA: 3.75\nGeorge Katz has GPA: 3.25\nGeorge Katz has GPA: 3.25\n```", "```cpp\nvoid AddOne(int &arg)\u00a0\u00a0\u00a0// These two functions are overloaded\n{\n\u00a0\u00a0\u00a0\u00a0arg++;\n}\nvoid AddOne(int *arg)\u00a0\u00a0\u00a0// Overloaded function definition\n{\n\u00a0\u00a0\u00a0\u00a0(*arg)++;\n}\nvoid Display(int &arg)\u00a0\u00a0// This fn passes a reference to arg\n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0cout << arg << \" \" << flush;\n}\n```", "```cpp\n#include <iostream>\nusing namespace std;\nvoid AddOne(int &);\u00a0\u00a0\u00a0\u00a0// function prototypes\nvoid AddOne(int *);\nvoid Display(int &);\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0int x = 10, *y;\n\u00a0\u00a0\u00a0\u00a0y = new int;\u00a0\u00a0\u00a0\u00a0// allocate y's memory\n\u00a0\u00a0\u00a0\u00a0*y = 15;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// dereference y to assign a value\n\u00a0\u00a0\u00a0\u00a0Display(x);\n\u00a0\u00a0\u00a0\u00a0Display(*y);\n\n\u00a0\u00a0\u00a0\u00a0AddOne(x);\u00a0\u00a0\u00a0\u00a0// calls reference version (with an object) \n\u00a0\u00a0\u00a0\u00a0AddOne(*y);\u00a0\u00a0\u00a0// also calls reference version \n\u00a0\u00a0\u00a0\u00a0Display(x);\u00a0\u00a0\u00a0// Based on prototype, we see we are passing\n\u00a0\u00a0\u00a0\u00a0Display(*y);\u00a0\u00a0// by reference. Without prototype, we might\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// have guessed it was by value.\n\u00a0\u00a0\u00a0\u00a0AddOne(&x);\u00a0\u00a0\u00a0// calls pointer version\n\u00a0\u00a0\u00a0\u00a0AddOne(y);\u00a0\u00a0\u00a0\u00a0// also calls pointer version\n\u00a0\u00a0\u00a0\u00a0Display(x);\n\u00a0\u00a0\u00a0\u00a0Display(*y);\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n10 15 11 16 12 17\n```", "```cpp\n#include <iostream>\nusing namespace std;\nint &CreateId();\u00a0\u00a0// function prototype\n\nint main()\u00a0\u00a0\u00a0\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0int &id1 = CreateId();\u00a0\u00a0// reference established\n\u00a0\u00a0\u00a0\u00a0int &id2 = CreateId();\n\u00a0\u00a0\u00a0\u00a0cout << \"Id1: \" << id1 << \" Id2: \" << id2 << endl;\n\u00a0\u00a0\u00a0\u00a0delete &id1;\u00a0\u00a0// Here, '&' is address-of, not reference\n\u00a0\u00a0\u00a0\u00a0delete &id2;\u00a0\u00a0// to calculate address to pass delete()\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\nint &CreateId()\u00a0\u00a0\u00a0// Function returns a reference to an int\n{\n\u00a0\u00a0\u00a0\u00a0static int count = 100;\u00a0\u00a0// initialize with first id \n\u00a0\u00a0\u00a0\u00a0int *memory = new int;\n\u00a0\u00a0\u00a0\u00a0*memory = count++;\u00a0\u00a0// use count as id, then increment\n\u00a0\u00a0\u00a0\u00a0return *memory;\n}\n```", "```cpp\nId1: 100 Id2: 101\n```", "```cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n\u00a0\u00a0\u00a0int x = 5;\n\u00a0\u00a0\u00a0const int &refInt = x;\n\u00a0\u00a0\u00a0cout << x << \" \" << refInt << endl;\n\u00a0\u00a0\u00a0// refInt = 6;\u00a0\u00a0// Illegal -- refInt is const \n\u00a0\u00a0\u00a0x = 7;\u00a0\u00a0\u00a0// we can inadvertently change refInt\n\u00a0\u00a0\u00a0cout << x << \" \" << refInt << endl;\n\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n5 5\n7 7\n```", "```cpp\n#include <iostream>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\nusing namespace std;\nclass Collection\n{\npublic:\n\u00a0\u00a0\u00a0\u00a0int x;\n\u00a0\u00a0\u00a0\u00a0float y;\n};\nvoid Update(Collection &);\u00a0\u00a0\u00a0// function prototypes\nvoid Print(const Collection &);\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Collection collect1, *collect2;\n\u00a0\u00a0\u00a0\u00a0collect2 = new Collection;\u00a0\u00a0// allocate memory from heap\n\u00a0\u00a0\u00a0\u00a0Update(collect1);\u00a0\u00a0\u00a0// a ref to the object will be passed\n\u00a0\u00a0\u00a0\u00a0Update(*collect2);\u00a0\u00a0// same here -- *collect2 is an object\n\u00a0\u00a0\u00a0\u00a0Print(collect1);\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Print(*collect2);\n\u00a0\u00a0\u00a0\u00a0delete collect2;\u00a0\u00a0\u00a0\u00a0// delete heap memory\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\nvoid Update(Collection &c)\n{\n\u00a0\u00a0\u00a0\u00a0cout << \"Enter x and y members: \";\n\u00a0\u00a0\u00a0\u00a0cin >> c.x >> c.y;\n}\n\nvoid Print(const Collection &c)\n{\n\u00a0\u00a0\u00a0\u00a0cout << \"x member: \" << c.x;\n\u00a0\u00a0\u00a0\u00a0cout << \"\u00a0\u00a0\u00a0y member: \" << c.y << endl;\n}\n```", "```cpp\nEnter x and y members: 33 23.77\nEnter x and y members: 10 12.11\nx member: 33\u00a0\u00a0\u00a0y member: 23.77\nx member: 10\u00a0\u00a0\u00a0y member: 12.11\n```", "```cpp\n#include <iostream>\u00a0\u00a0\u00a0\nusing namespace std;\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0int *ptr = new int;\n\u00a0\u00a0\u00a0\u00a0*ptr = 20;\n\u00a0\u00a0\u00a0\u00a0int *&refPtr = ptr;\u00a0\u00a0// establish a reference to a pointer\n\u00a0\u00a0\u00a0\u00a0cout << *ptr << \" \" << *refPtr << endl; \n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n20 20\n```"]