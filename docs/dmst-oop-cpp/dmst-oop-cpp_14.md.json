["```cpp\n// Assume Student class is as we've seen before, but with one\n// additional virtual member function. Assume usual headers.\nvoid Student::Validate()\u00a0\u00a0// defined as virtual in class def\n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// so derived classes may override\n\u00a0\u00a0\u00a0\u00a0// check constructed Student to see if standards are met\n\u00a0\u00a0\u00a0\u00a0// if not, throw an exception\n\u00a0\u00a0\u00a0\u00a0throw \"Does not meet prerequisites\";\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student s1(\"Sara\", \"Lin\", 'B', \"Dr.\", 3.9,\"C++\", \"23PSU\");\n\u00a0\u00a0\u00a0\u00a0try\u00a0\u00a0\u00a0\u00a0// Let's 'try' this block of code -- \n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Validate() may raise an exception\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s1.Validate();\u00a0\u00a0// does s1 meet admission standards?\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch (const char *err)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << err << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// try to fix problem here\u2026\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(1); // only if you can't fix, exit gracefully\n\u00a0\u00a0\u00a0\u00a0} \n\u00a0\u00a0\u00a0\u00a0cout << \"Moving onward with remainder of code.\" << endl;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nStudent does not meet prerequisites \n```", "```cpp\nvoid AppSpecificTerminate()\n{\u00a0\u00a0\u00a0// first, do what is necessary to end program gracefully\n\u00a0\u00a0\u00a0\u00a0cout << \"Uncaught exception. Program terminating\" << endl;\n\u00a0\u00a0\u00a0\u00a0exit(1);\n}\nint main()\n{\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0set_terminate(AppSpecificTerminate);\u00a0\u00a0// register fn.\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nUncaught exception. Program terminating\n```", "```cpp\n// Assume Student class is as we've seen it before, but with\n// two additional member functions. Assume usual header files.\nvoid Student::Validate()\u00a0\u00a0// defined as virtual in class def\n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// so derived classes may override\n\u00a0\u00a0\u00a0\u00a0// check constructed student to see if standards are met\n\u00a0\u00a0\u00a0\u00a0// if not, throw an exception\n\u00a0\u00a0\u00a0\u00a0throw \"Does not meet prerequisites\";\n}\nbool Student::TakePrerequisites()\u00a0\u00a0\n{\n\u00a0\u00a0\u00a0\u00a0// Assume this function can correct the issue at hand\n\u00a0\u00a0\u00a0\u00a0// if not, it returns false\n\u00a0\u00a0\u00a0\u00a0return false;\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student s1(\"Alex\", \"Ren\", 'Z', \"Dr.\", 3.9, \"C++\", \"89CU\");\n\u00a0\u00a0\u00a0\u00a0try\u00a0\u00a0\u00a0\u00a0// illustrates a nested try block \n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Assume another important task occurred in this\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// scope, which may have also raised an exception\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s1.Validate();\u00a0\u00a0// may raise an exception\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0catch (const char *err)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << err << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// try to correct (or partially handle) error.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If you cannot, pass exception to outer scope\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!s1.TakePrerequisites())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw;\u00a0\u00a0\u00a0\u00a0// re-throw the exception\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch (const char *err) // outer scope catcher (handler)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << err << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// try to fix problem here\u2026\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(1); // only if you can't fix, exit gracefully\n\u00a0\u00a0\u00a0\u00a0} \n\u00a0\u00a0\u00a0\u00a0cout << \"Moving onward with remainder of code. \" << endl;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nStudent does not meet prerequisites\nStudent does not meet prerequisites\n```", "```cpp\n// Assume Student class is as we've seen before, but with one\n// additional virtual member function, Graduate(). Assume \n// a simple Course class exists. All headers are as usual.\nvoid Student::Graduate()\n{\u00a0\u00a0\u00a0// Assume the below if statements are fully implemented \n\u00a0\u00a0\u00a0\u00a0if (gpa < 2.0) // if gpa doesn't meet requirements\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw gpa;\n\u00a0\u00a0\u00a0\u00a0// if Student is short credits, throw how many are missing\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw numCreditsMissing;\u00a0\u00a0// assume this is an int\n\u00a0\u00a0\u00a0\u00a0// or if Student is missing a Course, construct and\n\u00a0\u00a0\u00a0\u00a0// then throw the missing Course as a referenceable object\n\u00a0\u00a0\u00a0\u00a0// Assume appropriate Course constructor exists\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw *(new Course(\"Intro. To Programming\", 1234)); \n\u00a0\u00a0\u00a0\u00a0// or if another issue, throw a diagnostic message\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw (\"Does not meet requirements\"); \n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student s1(\"Ling\", \"Mau\", 'I', \"Ms.\", 3.1, \"C++\", \"55UD\");\n\u00a0\u00a0\u00a0\u00a0try\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s1.Graduate();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch (float err)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Too low gpa: \" << err << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(1); // only if you can't fix, exit gracefully\n\u00a0\u00a0\u00a0\u00a0} \n\u00a0\u00a0\u00a0\u00a0catch (int err)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Missing \" << err << \" credits\" << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(2);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch (const Course &err)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Needs to take: \" << err.GetTitle() << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Course #: \" << err.GetCourseNum() << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If you correct the error, and continue the program, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// be sure to deallocate heap mem using: delete &err;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(3);\u00a0\u00a0// Otherwise, heap memory for err will be \n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// reclaimed upon exit()\n\u00a0\u00a0\u00a0\u00a0catch (const char *err)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << err << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(4); \n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch (...)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Exiting\" << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(5);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0cout << \"Moving onward with remainder of code.\" << endl;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nNeeds to take: Intro. to Programming\nCourse #: 1234\n```", "```cpp\nvoid Student::Graduate() throw(float, int, Course &, char *)\n{\n\u00a0\u00a0\u00a0// this method might throw any of the above mentioned types\n}\nvoid Student::Enroll() throw()\n{\n\u00a0\u00a0\u00a0// this method might throw any type of exception\n}\n```", "```cpp\nvoid Student::Graduate() noexcept\u00a0\u00a0\u00a0// will not throw() \n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// same as\u00a0\u00a0noexcept(true) in extended signature\n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// same as deprecated throw() in ext. signature\nvoid Student::Enroll() noexcept(false)\u00a0\u00a0// may throw()\n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// an exception\n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n```", "```cpp\nvoid AppSpecificUnexpected()\n{\n\u00a0\u00a0\u00a0\u00a0cout << \"An unexpected type was thrown\" << endl;\n\u00a0\u00a0\u00a0\u00a0// optionally re-throw the correct type, or\n\u00a0\u00a0\u00a0\u00a0// terminate() will be called.\n}\nint main()\n{\n\u00a0\u00a0\u00a0set_unexpected(AppSpecificUnexpected)\n}\n```", "```cpp\n#include <iostream>\n#include <exception>\nusing namespace std;\nclass StudentException: public exception\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0int errCode;\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0char *details;\npublic:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0StudentException(const char *det, int num): errCode(num)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0details = new char[strlen(det) + 1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0strcpy(details, det);\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0virtual ~StudentException() { delete details; }\n\u00a0\u00a0\u00a0\u00a0virtual const char *what() const throw()\n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0// overridden function from exception class\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return \"Student Exception\";\n\u00a0\u00a0\u00a0\u00a0} \n\u00a0\u00a0\u00a0\u00a0int GetCode() const { return errCode; }\n\u00a0\u00a0\u00a0\u00a0const char *GetDetails() const { return details; }\n};\n// Assume Student class is as we've seen before, but with one\n// additional virtual member function Graduate() \nvoid Student::Graduate()\u00a0\u00a0// fn. may throw (StudentException)\n{\n\u00a0\u00a0\u00a0// if something goes wrong, instantiate a StudentException,\n\u00a0\u00a0\u00a0// pack it with relevant data during construction, and then\n\u00a0\u00a0\u00a0// throw the dereferenced pointer as a referenceable object\n\u00a0\u00a0\u00a0throw *(new StudentException(\"Missing Credits\", 4));\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student s1(\"Alexandra\", \"Doone\", 'G', \"Miss\", 3.95, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"C++\", \"231GWU\");\n\u00a0\u00a0\u00a0\u00a0try\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s1.Graduate();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch (const StudentException &e)\u00a0\u00a0// catch exc. by ref\n\u00a0\u00a0\u00a0\u00a0{ \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << e.what() << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << e.GetCode() << \" \" << e.GetDetails() << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Grab useful info from e and try to fix the problem\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// so that the program can continue.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If we fix the problem, deallocate heap memory for\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// thrown exception (take addr. of a ref): delete &e; \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Otherwise, memory will be reclaimed upon exit()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(1);\u00a0\u00a0// only exit if necessary!\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nStudent Exception\n4 Missing Credits\n```", "```cpp\n// Assume Student class is as before, but with the addition \n// of a nested exception class. All headers are as usual.\nclass Student: public Person\n{\nprivate:\u00a0\u00a0// assume usual data members\npublic:\u00a0\u00a0\u00a0// usual constructors, destructor, and methods\n\u00a0\u00a0\u00a0\u00a0virtual void Graduate();\n\u00a0\u00a0\u00a0\u00a0class StudentException\u00a0\u00a0\u00a0// nested exception class\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0private:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int number;\n\u00a0\u00a0\u00a0\u00a0public:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StudentException(int num): number(num) { }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0~StudentException() { }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int GetNum() const { return number; }\n\u00a0\u00a0\u00a0\u00a0};\n};\nvoid Student::Graduate()\n{\u00a0\u00a0\u00a0// assume we determine an error and wish to throw\n\u00a0\u00a0\u00a0\u00a0// the nested exception type\n\u00a0\u00a0\u00a0\u00a0throw *(new StudentException(5));\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student s1(\"Ling\", \"Mau\", 'I', \"Ms.\", 3.1, \"C++\", \"55UD\");\n\u00a0\u00a0\u00a0\u00a0try\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s1.Graduate();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0catch (const Student::StudentException &err)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Error: \" << err.GetNum() << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// If you correct err and continue with program, be\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// sure to delete heap mem for err: delete &err;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exit(1);\u00a0\u00a0// Otherwise, heap memory for err will be \n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// reclaimed upon exit()\n\u00a0\u00a0\u00a0\u00a0cout << \"Moving onward with remainder of code.\" << endl;\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nError: 5\n```"]