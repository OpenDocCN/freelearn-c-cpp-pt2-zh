["```cpp\nclass Singleton\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0static Singleton *theInstance;\n\u00a0\u00a0\u00a0\u00a0Singleton();\u00a0\u00a0// private to prevent multiple instantiation\npublic:\n\u00a0\u00a0\u00a0\u00a0static Singleton *instance(); // interface for creation\n\u00a0\u00a0\u00a0\u00a0virtual ~Singleton();\u00a0\u00a0// never called, unless you delete\n};\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Singleton explicitly, which is\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// unlikely and atypical\nSingleton *Singleton::theInstance = NULL; // external variable\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// to hold static mbr\nSingleton::Singleton()\n{\n\u00a0\u00a0\u00a0\u00a0cout << \"Constructor\" << endl;\n\u00a0\u00a0\u00a0\u00a0theInstance = NULL;\n}\nSingleton::~Singleton()\u00a0\u00a0// the destructor is not called in\n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the typical pattern usage\n\u00a0\u00a0\u00a0\u00a0cout << \"Destructor\" << endl;\n\u00a0\u00a0\u00a0\u00a0if (theInstance != NULL)\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Singleton *temp = theInstance;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0theInstance = NULL;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// removes ptr to Singleton\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp->theInstance = NULL; // prevents recursion\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete temp;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// delete the Singleton\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n}\nSingleton *Singleton::instance()\n{\n\u00a0\u00a0\u00a0\u00a0if (theInstance == NULL)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0theInstance = new Singleton();\u00a0\u00a0// allocate Singleton\n\u00a0\u00a0\u00a0\u00a0return theInstance;\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Singleton *s1 = Singleton::instance(); // create Singleton\n\u00a0\u00a0\u00a0\u00a0Singleton *s2 = Singleton::instance(); // returns existing\n\u00a0\u00a0\u00a0\u00a0cout << s1 << \" \" << s2 << endl; // addresses are the same\n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n```", "```cpp\nConstructor\n0xee1938 0xee1938\n```", "```cpp\nclass Singleton;\u00a0\u00a0\u00a0\u00a0// Necessary forward class declarations\nclass SingletonDestroyer;\nclass Person;\nclass President;\nclass SingletonDestroyer\u00a0\u00a0\u00a0\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0Singleton *theSingleton;\npublic:\n\u00a0\u00a0\u00a0\u00a0SingletonDestroyer(Singleton *s = 0) { theSingleton = s; }\n\u00a0\u00a0\u00a0\u00a0SingletonDestroyer(const SingletonDestroyer &) = delete; \n\u00a0\u00a0\u00a0\u00a0SingletonDestroyer &operator=(const SingletonDestroyer &)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= delete; \n\u00a0\u00a0\u00a0\u00a0~SingletonDestroyer(); // destructor shown further below\n\u00a0\u00a0\u00a0\u00a0void setSingleton(Singleton *s) { theSingleton = s; }\n\u00a0\u00a0\u00a0\u00a0Singleton *getSingleton() { return theSingleton; }\n};\n```", "```cpp\n// Singleton will be mixed-in using inheritance with a Target\n// class. If Singleton is used stand-alone, the data members\n// would be private, and add a Static *Singleton instance();\n// method to the public access region.\nclass Singleton\n{\nprotected:\n\u00a0\u00a0\u00a0\u00a0static Singleton *theInstance;\n\u00a0\u00a0\u00a0\u00a0static SingletonDestroyer destroyer;\nprotected:\n\u00a0\u00a0\u00a0\u00a0Singleton() {}\n\u00a0\u00a0\u00a0\u00a0Singleton(const Singleton &) = delete; // disallow copies\n\u00a0\u00a0\u00a0\u00a0Singleton &operator=(const Singleton &) = delete; // and =\n\u00a0\u00a0\u00a0\u00a0friend class SingletonDestroyer;\n\u00a0\u00a0\u00a0\u00a0virtual ~Singleton() \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ cout << \"Singleton destructor\" << endl; }\n};\n```", "```cpp\n// External (name mangled) variables to hold static data mbrs\nSingleton *Singleton::theInstance = 0;\nSingletonDestroyer Singleton::destroyer;\n// SingletonDestroyer destructor definition must appear after \n// class definition for Singleton because it is deleting a \n// Singleton (so its destructor can be seen)\n// This is not an issue when using header and source files.\nSingletonDestroyer::~SingletonDestroyer()\n{\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (theSingleton == NULL)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"SingletonDestroyer destructor: Singleton \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0has already been destructed\" << endl;\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"SingletonDestroyer destructor\" << endl;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete theSingleton;\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n}\n```", "```cpp\n// Assume our Person class definition is as we are accustomed\n// A President Is-A Person and also mixes-in Singleton \nclass President: public Person, public Singleton\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0President(const char *, const char *, char, const char *);\npublic:\n\u00a0\u00a0\u00a0\u00a0virtual ~President();\n\u00a0\u00a0\u00a0\u00a0President(const President &) = delete;\u00a0\u00a0// disallow copies\n\u00a0\u00a0\u00a0\u00a0President &operator=(const President &) = delete; // and =\n\u00a0\u00a0\u00a0\u00a0static President *instance(const char *, const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char, const char *);\n};\nPresident::President(const char *fn, const char *ln, char mi,\n\u00a0\u00a0\u00a0\u00a0const char *t) : Person(fn, ln, mi, t), Singleton()\n{\n}\nPresident::~President()\n{\n\u00a0\u00a0\u00a0\u00a0destroyer.setSingleton(NULL);\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0cout << \"President destructor\" << endl;\n}\nPresident *President::instance(const char *fn, const char *ln,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char mi, const char *t)\n{\n\u00a0\u00a0\u00a0\u00a0if (theInstance == NULL)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0theInstance = new President(fn, ln, mi, t);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destroyer.setSingleton(theInstance);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Creating the Singleton\" << endl;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Singleton previously created. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Returning existing singleton\" << endl;\n\u00a0\u00a0\u00a0\u00a0return (President *) theInstance; // cast necessary since\n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// theInstance is a Singleton * \n```", "```cpp\nint main()\n{ \n\u00a0\u00a0\u00a0\u00a0// Create a Singleton President\n\u00a0\u00a0\u00a0\u00a0President *p1 = President::instance(\"John\", \"Adams\", \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'Q', \"President\");\n\u00a0\u00a0\u00a0\u00a0// This second request will fail, returning orig. instance\n\u00a0\u00a0\u00a0\u00a0President *p2 = President::instance(\"William\", \"Harrison\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'H', \"President\");\n\u00a0\u00a0\u00a0\u00a0if (p1 == p2)\u00a0\u00a0\u00a0// Verification there's only one object\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Same instance (only one Singleton)\" << endl;\n\u00a0\u00a0\u00a0\u00a0p1->Print();\n\u00a0\u00a0\u00a0\u00a0// SingletonDestroyer will release Singleton at end\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nCreating the Singleton\nSingleton previously created. Returning existing singleton\nSame instance (only one Singleton)\nPresident John Q Adams\nSingletonDestroyer destructor\nPresident destructor\nSingleton destructor\nPerson destructor\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0President *p1 = President::instance(\"John\", \"Adams\", \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'Q', \"President\");\n\u00a0\u00a0\u00a0\u00a0President *p2 = President::instance(\"William\", \"Harrison\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'H', \"President\");\n\u00a0\u00a0\u00a0\u00a0if (p1 == p2)\u00a0\u00a0// Verification there's only one object\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Same instance (only one Singleton)\" << endl;\n\u00a0\u00a0\u00a0\u00a0p1->Print();\n\u00a0\u00a0\u00a0\u00a0delete p1;\u00a0\u00a0// Delete the Singleton \u2013 unusual.\n\u00a0\u00a0\u00a0\u00a0return 0;\u00a0\u00a0\u00a0// Upon checking, the SingletonDestroyer will\n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// no longer need to destroy its paired Singleton\n```", "```cpp\nCreating the Singleton\nSingleton previously created. Returning existing singleton\nSame instance (only one Singleton)\nPresident John Q Adams\nPresident destructor\nSingleton destructor\nPerson destructor\nSingletonDestroyer destructor: Singleton has already been destructed\n```"]