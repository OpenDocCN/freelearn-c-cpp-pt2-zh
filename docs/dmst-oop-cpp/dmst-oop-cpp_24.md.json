["```cpp\n#ifndef _PERSON_H\u00a0\u00a0// preprocessor directives to avoid \n#define _PERSON_H\u00a0\u00a0// multiple inclusion of header\nclass Person\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0char *firstName, *lastName, *title;\n\u00a0\u00a0\u00a0\u00a0char middleInitial;\nprotected:\n\u00a0\u00a0\u00a0\u00a0void ModifyTitle(const char *);\npublic:\n\u00a0\u00a0\u00a0\u00a0Person();\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0Person(const char *, const char *, char, const char *);\n\u00a0\u00a0\u00a0\u00a0Person(const Person &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Person();\u00a0\u00a0// virtual destructor\n\u00a0\u00a0\u00a0\u00a0const char *GetFirstName() const { return firstName; }\n\u00a0\u00a0\u00a0\u00a0const char *GetLastName() const { return lastName; }\n\u00a0\u00a0\u00a0\u00a0const char *GetTitle() const { return title; }\n\u00a0\u00a0\u00a0\u00a0char GetMiddleInitial() const { return middleInitial; }\n\u00a0\u00a0\u00a0\u00a0virtual void Print() const;\n\u00a0\u00a0\u00a0\u00a0virtual void IsA();\n\u00a0\u00a0\u00a0\u00a0virtual void Greeting(const char *);\n\u00a0\u00a0\u00a0\u00a0Person &operator=(const Person &);\u00a0\u00a0// overloaded op =\n};\n#endif\n```", "```cpp\n#include <iostream>\u00a0\u00a0// also include other relevant libraries\n#include \"Person.h\"\u00a0\u00a0// include the header file\nusing namespace std;\n// Include all the non-inline Person member functions\n// The default constructor is one example of many in the file\nPerson::Person()\n{\n\u00a0\u00a0\u00a0\u00a0firstName = lastName = title = 0;\u00a0\u00a0// NULL pointer\n\u00a0\u00a0\u00a0\u00a0middleInitial = '\\0';\u00a0\u00a0\u00a0// null character\n}\n```", "```cpp\n#ifndef _PERSON_H\u00a0\u00a0\u00a0\u00a0// Person.h header file definition\n#define _PERSON_H\nclass Person\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0class PersonImpl;\u00a0\u00a0// forward declaration of nested class\n\u00a0\u00a0\u00a0\u00a0PersonImpl *pImpl; // pointer to implementation of class\nprotected:\n\u00a0\u00a0\u00a0\u00a0void ModifyTitle(const char *);\npublic:\n\u00a0\u00a0\u00a0\u00a0Person();\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0Person(const char *, const char *, char, const char *);\n\u00a0\u00a0\u00a0\u00a0Person(const Person &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Person();\u00a0\u00a0// virtual destructor\n\u00a0\u00a0\u00a0\u00a0const char *GetFirstName() const; // no longer inline\n\u00a0\u00a0\u00a0\u00a0const char *GetLastName() const; \n\u00a0\u00a0\u00a0\u00a0const char *GetTitle() const; \n\u00a0\u00a0\u00a0\u00a0char GetMiddleInitial() const; \n\u00a0\u00a0\u00a0\u00a0virtual void Print() const;\n\u00a0\u00a0\u00a0\u00a0virtual void IsA();\n\u00a0\u00a0\u00a0\u00a0virtual void Greeting(const char *);\n\u00a0\u00a0\u00a0\u00a0Person &operator=(const Person &);\u00a0\u00a0// overloaded =\n};\n#endif\n```", "```cpp\n// PersonImpl.cpp source code file includes the nested class\n// Nested class definition supports implementation\nclass Person::PersonImpl\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0char *firstName, *lastName, *title;\n\u00a0\u00a0\u00a0\u00a0char middleInitial;\npublic:\n\u00a0\u00a0\u00a0\u00a0PersonImpl();\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0PersonImpl(const char *, const char *, char, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *);\n\u00a0\u00a0\u00a0\u00a0PersonImpl(const PersonImpl &);\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0virtual ~PersonImpl();\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0const char *GetFirstName() const { return firstName; }\n\u00a0\u00a0\u00a0\u00a0const char *GetLastName() const { return lastName; }\n\u00a0\u00a0\u00a0\u00a0const char *GetTitle() const { return title; }\n\u00a0\u00a0\u00a0\u00a0char GetMiddleInitial() const { return middleInitial; }\n\u00a0\u00a0\u00a0\u00a0void ModifyTitle(const char *);\n\u00a0\u00a0\u00a0\u00a0virtual void Print() const;\n\u00a0\u00a0\u00a0\u00a0virtual void IsA() { cout << \"Person\" << endl; }\n\u00a0\u00a0\u00a0\u00a0virtual void Greeting(const char *msg) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ cout << msg << endl; }\n\u00a0\u00a0\u00a0\u00a0PersonImpl &operator=(const PersonImpl &); \n};\n```", "```cpp\n// File: PersonImpl.cpp -- See online code for full methods. \n// Nested class member functions. \n// Notice that the class name is Outer::Inner class\nPerson::PersonImpl::PersonImpl()\n{\n\u00a0\u00a0\u00a0\u00a0firstName = lastName = title = 0;\u00a0\u00a0// NULL pointer\n\u00a0\u00a0\u00a0\u00a0middleInitial = '\\0';\n}\nPerson::PersonImpl::PersonImpl(const char *fn, const char *ln,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char mi, const char *t)\n{\n\u00a0\u00a0\u00a0\u00a0firstName = new char [strlen(fn) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(firstName, fn);\n\u00a0\u00a0\u00a0\u00a0// Continue memory allocation, init. for data members\n}\nPerson::PersonImpl::PersonImpl(const Person::PersonImpl &pers)\n{\n\u00a0\u00a0\u00a0\u00a0firstName = new char [strlen(pers.firstName) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(firstName, pers.firstName);\n\u00a0\u00a0\u00a0\u00a0// Continue memory allocation and deep copy for all\n}\u00a0\u00a0\u00a0// pointer data members and copy for non-ptr data members\nPerson::PersonImpl::~PersonImpl()\n{\u00a0\u00a0\u00a0// Delete all dynamically allocated data members\n}\nvoid Person::PersonImpl::ModifyTitle(const char *newTitle)\n{\u00a0\u00a0\u00a0// Delete old title, reallocate space for and copy new one\n}\nvoid Person::PersonImpl::Print() const\n{\u00a0\u00a0\u00a0// Print each data member as usual\n}\nPerson::PersonImpl &Person::PersonImpl::operator=\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(const PersonImpl &p)\n{\u00a0\u00a0// check for self-assignment, then delete destination\n\u00a0\u00a0\u00a0// object data members. Then reallocate and copy from \n\u00a0\u00a0\u00a0// source object. \n\u00a0\u00a0\u00a0return *this;\u00a0\u00a0// allow for cascaded assignments\n}\n```", "```cpp\n// Person member functions \u2013 also in PersonImpl.cpp\nPerson::Person(): pImpl(new PersonImpl())\n{\u00a0\u00a0// This is the complete member function definition\n}\nPerson::Person(const char *fn, const char *ln, char mi,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *t): \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pImpl(new PersonImpl(fn, ln, mi, t))\n{\u00a0\u00a0// This is the complete member function definition\n}\u00a0\u00a0\nPerson::Person(const Person &pers): \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pImpl(new PersonImpl(*(pers.pImpl)))\n{\u00a0\u00a0// This is the complete member function definition\n}\u00a0\u00a0// No Person data members to copy from pers except deep\n\u00a0\u00a0\u00a0// copy of *(pers.pImpl) to data member pImpl\nPerson::~Person()\n{\n\u00a0\u00a0\u00a0\u00a0delete pImpl;\u00a0\u00a0\u00a0// delete associated implementation\n}\nvoid Person::ModifyTitle(const char *newTitle)\n{\u00a0\u00a0\u00a0// delegate request to the implementation \n\u00a0\u00a0\u00a0\u00a0pImpl->ModifyTitle(newTitle);\u00a0\u00a0\n}\nconst char *Person::GetFirstName() const\n{\u00a0\u00a0\u00a0// no longer inline in Person;further hides implementation\n\u00a0\u00a0\u00a0\u00a0return pImpl->GetFirstName();\n}\n// Note: methods GetLastName(), GetTitle(), GetMiddleInitial()\n// are implemented similar to GetFirstName(). See online code.\nvoid Person::Print() const\n{\n\u00a0\u00a0\u00a0\u00a0pImpl->Print();\u00a0\u00a0\u00a0// delegate to implementation\n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// (same named member function)\n// Note: methods IsA() and Greeting() are implemented \n// similarly to Print() \u2013 using delegation. See online code.\nPerson &Person::operator=(const Person &p)\n{\u00a0\u00a0// delegate op= to implementation portion\n\u00a0\u00a0\u00a0pImpl->operator=(*(p.pImpl));\u00a0\u00a0\u00a0// call op= on impl. piece\n\u00a0\u00a0\u00a0return *this;\u00a0\u00a0// allow for cascaded assignments\n}\n```", "```cpp\n#include <iostream>\n#include \"Person.h\"\nusing namespace std;\nconst int MAX = 3;\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Person *people[MAX];\n\u00a0\u00a0\u00a0\u00a0people[0] = new Person(\"Giselle\", \"LeBrun\", 'R', \"Ms.\");\n\u00a0\u00a0\u00a0\u00a0people[1] = new Person(\"Zack\", \"Moon\", 'R', \"Dr.\");\n\u00a0\u00a0\u00a0\u00a0people[2] = new Person(\"Gabby\", \"Doone\", 'A', \"Dr.\");\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people[i]->Print();\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete people[i];\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nMs. Giselle R. LeBrun\nDr. Zack R. Moon\nDr. Gabby A. Doone\n```", "```cpp\n#include <iostream>\n#include \"Person.h\"\nusing namespace std;\ntemplate <class Type>\nclass SmartPointer\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0Type *pointer;\npublic:\n\u00a0\u00a0\u00a0\u00a0SmartPointer(Type *ptr = NULL) { pointer = ptr; }\n\u00a0\u00a0\u00a0\u00a0virtual ~SmartPointer();\u00a0\u00a0// allow specialized SmrtPtrs\n\u00a0\u00a0\u00a0\u00a0Type *operator->() { return pointer; }\n\u00a0\u00a0\u00a0\u00a0Type &operator*() { return *pointer; }\n};\nSmartPointer::~SmartPointer()\n{\n\u00a0\u00a0\u00a0\u00a0delete pointer;\n\u00a0\u00a0\u00a0\u00a0cout << \"SmartPtr Destructor\" << endl;\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0SmartPointer<int> p1(new int());\n\u00a0\u00a0\u00a0\u00a0SmartPointer<Person> pers1(new Person(\"Renee\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Alexander\", 'K', \"Dr.\"));\n\u00a0\u00a0\u00a0\u00a0*p1 = 100;\n\u00a0\u00a0\u00a0\u00a0cout << *p1 << endl;\n\u00a0\u00a0\u00a0\u00a0(*pers1).Print();\u00a0\u00a0\u00a0// or use: pers1->Print();\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n100\nDr. Renee K. Alexander\nSmartPtr Destructor\nSmartPtr Destructor\n```", "```cpp\n#include <iostream>\n#include <memory>\n#include \"Person.h\"\nusing namespace std;\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0unique_ptr<int> p1(new int());\n\u00a0\u00a0\u00a0\u00a0unique_ptr<Person> pers1(new Person(\"Renee\", \"Alexander\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'K', \"Dr.\"));\n\u00a0\u00a0\u00a0\u00a0*p1 = 100;\n\u00a0\u00a0\u00a0\u00a0cout << *p1 << endl;\n\u00a0\u00a0\u00a0\u00a0(*pers1).Print();\u00a0\u00a0\u00a0// or use: pers1->Print();\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n#ifndef _PERSON_H\u00a0\u00a0\u00a0\u00a0// Person.h header file definition\n#define _PERSON_H\n#include <memory>\nclass Person\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0class PersonImpl;\u00a0\u00a0// forward declaration to nested class\n\u00a0\u00a0\u00a0\u00a0std::unique_ptr<PersonImpl> pImpl; // unique ptr to impl\nprotected:\n\u00a0\u00a0\u00a0\u00a0void ModifyTitle(const char *);\npublic:\n\u00a0\u00a0\u00a0\u00a0Person();\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0Person(const char *, const char *, char, const char *);\n\u00a0\u00a0\u00a0\u00a0Person(const Person &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Person();\u00a0\u00a0// virtual destructor\n\u00a0\u00a0\u00a0\u00a0const char *GetFirstName() const; // no longer inline\n\u00a0\u00a0\u00a0\u00a0const char *GetLastName() const; \n\u00a0\u00a0\u00a0\u00a0const char *GetTitle() const; \n\u00a0\u00a0\u00a0\u00a0char GetMiddleInitial() const; \n\u00a0\u00a0\u00a0\u00a0virtual void Print() const;\n\u00a0\u00a0\u00a0\u00a0virtual void IsA();\n\u00a0\u00a0\u00a0\u00a0virtual void Greeting(const char *);\n\u00a0\u00a0\u00a0\u00a0Person &operator=(const Person &);\u00a0\u00a0// overloaded =\n};\n#endif\n```", "```cpp\n// Source file PersonImpl.cpp\n// Person destructor no longer needs to delete pImpl member\nPerson::~Person()\n{\u00a0\u00a0// unique_pointer pImpl will delete its own resources\n}\n```"]