["```cpp\n    class Person\u00a0\u00a0// base class\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0char *name;\n    \u00a0\u00a0\u00a0\u00a0char *title;\n    public:\n    \u00a0\u00a0\u00a0\u00a0// constructors, destructor, \n    \u00a0\u00a0\u00a0\u00a0// public access functions, public interface etc. \u2026\n    \u00a0\u00a0\u00a0\u00a0Person introduces a virtual function, Print(). By labeling this function as virtual, the Person class is inviting any future descendants to redefine this function with a more suitable implementation or method, should they be so motivated.\n    ```", "```cpp\n    class Student: public Person\u00a0\u00a0// derived class\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0float gpa;\n    public:\n    \u00a0\u00a0\u00a0\u00a0// constructors, destructor specific to Student,\n    \u00a0\u00a0\u00a0\u00a0// public access functions, public interface, etc. \u2026\n    \u00a0\u00a0\u00a0\u00a0Student introduces a new implementation of Print() that will override (that is, replace), the definition in Person. Note that if the implementation of Person::Print() were acceptable to Student, Student would not be obligated to override this function, even if it is marked as virtual in the base class. The mechanics of public inheritance would simply allow the derived class to inherit this method.But because this function is `virtual` in `Person`, `Student` may opt to redefine this operation with a more suitable method. Here, it does. In the `Student::Print()` implementation, `Student` first calls `Person::Print()` to take advantage of the aforementioned base class function, then prints additional information itself. `Student::Print()` is choosing to call a base class function for help; it is not required to do so if the desired functionality can be implemented fully within its own class scope. Notice that when `Student::Print()` is defined to override `Person::Print()`, the same signature as specified by the base class is used. This is important. Should a new signature have been used, we would get into a potential function hiding scenario, which we will soon discuss in our sub-section, *Considering function hiding*, within this chapter.Note that though the virtual functions in `Person` and `Student` are written inline, a virtual function will never be expanded as inline code by the compiler since the specific method for the operation must be determined at runtime.\n    ```", "```cpp\n#include <iostream>\n#include <iomanip>\n#include <cstring>\nusing namespace std;\nconst int MAX = 5;\nclass Person\n{\nprivate: // data members\n\u00a0\u00a0\u00a0\u00a0char *firstName;\n\u00a0\u00a0\u00a0\u00a0char *lastName;\n\u00a0\u00a0\u00a0\u00a0char middleInitial;\n\u00a0\u00a0\u00a0\u00a0char *title;\u00a0\u00a0// Mr., Ms., Mrs., Miss, Dr., etc.\nprotected:\n\u00a0\u00a0\u00a0\u00a0void ModifyTitle(const char *); \npublic:\n\u00a0\u00a0\u00a0\u00a0Person();\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0Person(const char *, const char *, char, const char *);\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0Person(const Person &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Person();\u00a0\u00a0// virtual destructor\n\u00a0\u00a0\u00a0\u00a0const char *GetFirstName() const { return firstName; }\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0const char *GetLastName() const { return lastName; }\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0const char *GetTitle() const { return title; } \n\u00a0\u00a0\u00a0\u00a0char GetMiddleInitial() const { return middleInitial; }\n\u00a0\u00a0\u00a0\u00a0virtual void Print() const;\n\u00a0\u00a0\u00a0\u00a0virtual void IsA();\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0virtual void Greeting(const char *);\n};\n```", "```cpp\nPerson::Person()\n{\n\u00a0\u00a0\u00a0\u00a0firstName = lastName = 0;\u00a0\u00a0// NULL pointer\n\u00a0\u00a0\u00a0\u00a0middleInitial = '\\0';\n\u00a0\u00a0\u00a0\u00a0title = 0;\n}\nPerson::Person(const char *fn, const char *ln, char mi, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *t)\n{\n\u00a0\u00a0\u00a0\u00a0firstName = new char [strlen(fn) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(firstName, fn);\n\u00a0\u00a0\u00a0\u00a0lastName = new char [strlen(ln) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(lastName, ln);\n\u00a0\u00a0\u00a0\u00a0middleInitial = mi;\n\u00a0\u00a0\u00a0\u00a0title = new char [strlen(t) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(title, t);\n}\nPerson::Person(const Person &pers)\n{\n\u00a0\u00a0\u00a0\u00a0firstName = new char [strlen(pers.firstName) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(firstName, pers.firstName);\n\u00a0\u00a0\u00a0\u00a0lastName = new char [strlen(pers.lastName) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(lastName, pers.lastName);\n\u00a0\u00a0\u00a0\u00a0middleInitial = pers.middleInitial;\n\u00a0\u00a0\u00a0\u00a0title = new char [strlen(pers.title) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(title, pers.title);\n}\nPerson::~Person()\n{\n\u00a0\u00a0\u00a0\u00a0delete firstName;\n\u00a0\u00a0\u00a0\u00a0delete lastName;\n\u00a0\u00a0\u00a0\u00a0delete title;\n}\nvoid Person::ModifyTitle(const char *newTitle)\n{\n\u00a0\u00a0\u00a0\u00a0delete title;\u00a0\u00a0// delete old title\n\u00a0\u00a0\u00a0\u00a0title = new char [strlen(newTitle) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(title, newTitle);\n}\nvoid Person::Print() const\n{\n\u00a0\u00a0\u00a0\u00a0cout << title << \" \" << firstName << \" \";\n\u00a0\u00a0\u00a0\u00a0cout << middleInitial << \". \" << lastName << endl;\n}\nvoid Person::IsA()\n{\n\u00a0\u00a0\u00a0\u00a0cout << \"Person\" << endl;\n}\nvoid Person::Greeting(const char *msg)\n{\n\u00a0\u00a0\u00a0\u00a0cout << msg << endl;\n}\n```", "```cpp\nclass Student: public Person\n{\nprivate: \n\u00a0\u00a0\u00a0\u00a0// data members\n\u00a0\u00a0\u00a0\u00a0float gpa;\n\u00a0\u00a0\u00a0\u00a0char *currentCourse;\n\u00a0\u00a0\u00a0\u00a0const char *studentId;\u00a0\u00a0\npublic:\n\u00a0\u00a0\u00a0\u00a0// member function prototypes\n\u00a0\u00a0\u00a0\u00a0Student();\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0\u00a0Student(const char *, const char *, char, const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float, const char *, const char *); \n\u00a0\u00a0\u00a0\u00a0Student(const Student &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0\u00a0virtual ~Student();\u00a0\u00a0// destructor\n\u00a0\u00a0\u00a0\u00a0void EarnPhD();\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0// inline function definitions\n\u00a0\u00a0\u00a0\u00a0float GetGpa() const { return gpa; }\n\u00a0\u00a0\u00a0\u00a0const char *GetCurrentCourse() const\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return currentCourse; }\n\u00a0\u00a0\u00a0\u00a0const char *GetStudentId() const { return studentId; }\n\u00a0\u00a0\u00a0\u00a0void SetCurrentCourse(const char *); // prototype only\n\n\u00a0\u00a0\u00a0\u00a0// In the derived class, the keyword virtual is optional, \n\u00a0\u00a0\u00a0\u00a0// but recommended for clarity. Same for override.\n\u00a0\u00a0\u00a0\u00a0virtual void Print() const override;\n\u00a0\u00a0\u00a0\u00a0virtual void IsA() override;\n\u00a0\u00a0\u00a0\u00a0// note: we choose not to redefine \n\u00a0\u00a0\u00a0\u00a0// Person::Greeting(const char *)\n};\ninline void Student::SetCurrentCourse(const char *c)\n{\n\u00a0\u00a0\u00a0\u00a0delete currentCourse;\u00a0\u00a0\u00a0// delete existing course\n\u00a0\u00a0\u00a0\u00a0currentCourse = new char [strlen(c) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(currentCourse, c); \n}\n```", "```cpp\nStudent::Student(): studentId (0) \n{\n\u00a0\u00a0\u00a0\u00a0gpa = 0.0;\n\u00a0\u00a0\u00a0\u00a0currentCourse = 0;\n}\n// Alternate constructor member function definition\nStudent::Student(const char *fn, const char *ln, char mi, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *t, float avg, const char *course,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *id): Person(fn, ln, mi, t)\n{\n\u00a0\u00a0\u00a0\u00a0gpa = avg;\n\u00a0\u00a0\u00a0\u00a0currentCourse = new char [strlen(course) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(currentCourse, course);\n\u00a0\u00a0\u00a0\u00a0char *temp = new char [strlen(id) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy (temp, id); \n\u00a0\u00a0\u00a0\u00a0studentId = temp;\n}\n// Copy constructor definition\nStudent::Student(const Student &ps): Person(ps)\n{\n\u00a0\u00a0\u00a0\u00a0gpa = ps.gpa;\n\u00a0\u00a0\u00a0\u00a0currentCourse = new char [strlen(ps.currentCourse) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy(currentCourse, ps.currentCourse);\n\u00a0\u00a0\u00a0\u00a0char *temp = new char [strlen(ps.studentId) + 1];\n\u00a0\u00a0\u00a0\u00a0strcpy (temp, ps.studentId); \n\u00a0\u00a0\u00a0\u00a0studentId = temp;\n}\n\n// destructor definition\nStudent::~Student()\n{\n\u00a0\u00a0\u00a0\u00a0delete currentCourse;\n\u00a0\u00a0\u00a0\u00a0delete (char *) studentId;\n}\nvoid Student::EarnPhD()\n{\n\u00a0\u00a0\u00a0\u00a0ModifyTitle(\"Dr.\");\u00a0\u00a0\n}\nvoid Student::Print() const\n{\u00a0\u00a0\u00a0// need to use access functions as these data members are\n\u00a0\u00a0\u00a0\u00a0// defined in Person as private\n\u00a0\u00a0\u00a0\u00a0cout << GetTitle() << \" \" << GetFirstName() << \" \";\n\u00a0\u00a0\u00a0\u00a0cout << GetMiddleInitial() << \". \" << GetLastName();\n\u00a0\u00a0\u00a0\u00a0cout << \" with id: \" << studentId << \" GPA: \";\n\u00a0\u00a0\u00a0\u00a0cout << setprecision(3) <<\u00a0\u00a0\" \" << gpa;\n\u00a0\u00a0\u00a0\u00a0cout << \" Course: \" << currentCourse << endl;\n}\nvoid Student::IsA()\n{\n\u00a0\u00a0\u00a0\u00a0cout << \"Student\" << endl;\n}\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Person *people[MAX];\n\u00a0\u00a0\u00a0\u00a0people[0] = new Person(\"Juliet\", \"Martinez\", 'M', \"Ms.\");\n\u00a0\u00a0\u00a0\u00a0people[1] = new Student(\"Hana\", \"Sato\", 'U', \"Dr.\", 3.8,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"C++\", \"178PSU\"); \n\u00a0\u00a0\u00a0\u00a0people[2] = new Student(\"Sara\", \"Kato\", 'B', \"Dr.\", 3.9,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"C++\", \"272PSU\"); \n\u00a0\u00a0\u00a0\u00a0people[3] = new Person(\"Giselle\", \"LeBrun\", 'R', \"Miss\");\n\u00a0\u00a0\u00a0\u00a0people[4] = new Person(\"Linus\", \"Van Pelt\", 'S', \"Mr.\");\n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people[i]->IsA();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"\u00a0\u00a0\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people[i]->Print();\n\u00a0\u00a0\u00a0\u00a0} \n\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < MAX; i++)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete people[i];\u00a0\u00a0\u00a0// engage virtual dest. sequence\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nPerson\n\u00a0\u00a0Ms. Juliet M. Martinez\nStudent\n\u00a0\u00a0Dr. Hana U. Sato with id: 178PSU GPA:\u00a0\u00a03.8 Course: C++\nStudent\n\u00a0\u00a0Dr. Sara B. Kato with id: 272PSU GPA:\u00a0\u00a03.9 Course: C++\nPerson\n\u00a0\u00a0Miss Giselle R. LeBrun\nPerson\n\u00a0\u00a0Mr. Linus S. Van Pelt\n```", "```cpp\n    class Person\u00a0\u00a0// base class\n    {\n    \u00a0\u00a0\u00a0\u00a0// data members\n    public:\u00a0\u00a0// member functions, etc. \n    \u00a0\u00a0\u00a0\u00a0Print() has changed from a base to a derived class. The derived class function does not redefine the virtual void Print(); of its base class. It is a new function that will in fact hide the existence of Person::Print(). This is actually what was intended, since you may not recall that the base class offers such an operation and tracking upward might cause surprising results in your application if you intended Print(const char *) to be called and if Print() is called instead. By adding this new function, the derived class designer is dictating this interface is the appropriate Print() for instances of Student.However, nothing is straightforward in C++. For situations where a `Student` is up-cast to a `Person`, the `Person::Print()` with no arguments will be called. The `Student::Print(const char *)` is not a virtual redefinition because it does not have the same signature. Hence, the `Person::Print()` will be called for generalized `Student` instances. And yet `Student::Print(const char *)` will be called for `Student` instances stored in `Student` variables. Unfortunately, this is inconsistent in how an instance will behave if it is stored in its own type versus a generalized type. Though function hiding was meant to work in this fashion, it may inevitably not be what you would like to happen. Programmers beware!\n    ```", "```cpp\n    int main()\n    { \n    \u00a0\u00a0\u00a0\u00a0Person *people[2];\n    \u00a0\u00a0\u00a0\u00a0people[0] = new Person(\"Jim\", \"Black\", 'M', \"Mr.\");\n    \u00a0\u00a0\u00a0\u00a0people[1] = new Student(\"Kim\", \"Lin\", 'Q', \"Dr.\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.55, \"C++\", \"334UD\"); \n    \u00a0\u00a0\u00a0\u00a0people[1]->Print();\u00a0\u00a0// ok, Person::Print() defined\n    \u00a0\u00a0\u00a0\u00a0// people[1]->Print(\"Go Team!\"); // error!\n    \u00a0\u00a0\u00a0\u00a0// explicit downcast to derived type assumes you\n    \u00a0\u00a0\u00a0\u00a0// correctly recall what the object is\n    \u00a0\u00a0\u00a0\u00a0((Student *)people[1])->Print(\"I have to study\");\n\n    \u00a0\u00a0\u00a0\u00a0// Student stored in its own type\n    \u00a0\u00a0\u00a0\u00a0Student s1(\"Jafari\", \"Kanumba\", 'B', \"Dr.\", 3.9,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"C++\", \"845BU\"); \n    \u00a0\u00a0\u00a0\u00a0// s1.Print();\u00a0\u00a0// error, base class version hidden\n    \u00a0\u00a0\u00a0\u00a0s1.Print(\"I got an A!\"); // works for type Student\n    \u00a0\u00a0\u00a0\u00a0s1.Person::Print(); // works using scope resolution\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// to base class type\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    class Person\u00a0\u00a0// base class\n    {\n    \u00a0\u00a0\u00a0\u00a0// data members\n    public:\u00a0\u00a0// member functions, etc.\n    \u00a0\u00a0\u00a0\u00a0Student class both overrides Person::Print() with Student::Print() and overloads Student::Print() with Student::Print(const char *) to envelop the additional desired interface. Now, for Student objects stored in Student variables, both interfaces are available \u2013 the base class interface is no longer hidden. Of course, Student objects referenced by Person pointers only have the Person::Print() interface, which is to be expected. \n    ```", "```cpp\n    class Person\n    {\n    private:\u00a0\u00a0\u00a0// data members will be as before\n    protected: // assume all member function are as before,\n    public:\u00a0\u00a0// but we will show only virtual functions here\n    \u00a0\u00a0\u00a0\u00a0Person and Student class definitions are as expected. Assume that the data members and member functions are as shown in the full program example. For brevity, we have just included the virtual functions introduced or redefined at each level. \n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0Person *people[3];\n    \u00a0\u00a0\u00a0\u00a0people[0] = new Person(\"Joy\", \"Lin\", 'M', \"Ms.\");\n    \u00a0\u00a0\u00a0\u00a0people[1] = new Student(\"Renee\", \"Alexander\", 'Z',\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Dr.\", 3.95, \"C++\", \"21-MIT\"); \n    \u00a0\u00a0\u00a0\u00a0people[2] = new Student(\"Gabby\", \"Doone\", 'A', \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Ms.\", 3.95, \"C++\", \"18-GWU\"); \n    \u00a0\u00a0\u00a0\u00a0for (int i = 0; i < 3; i++)\n    \u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// at compile time, modified to:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people[i]->IsA();\u00a0\u00a0// *(people[i]->vptr[2])()\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people[i]->Print();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0people[i]->Greeting();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete people[i];\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```"]