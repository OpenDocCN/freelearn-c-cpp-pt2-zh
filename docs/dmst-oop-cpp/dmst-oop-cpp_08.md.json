["```cpp\n    class Person\u00a0\u00a0// base class\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0char *name;\n    \u00a0\u00a0\u00a0\u00a0char *title;\n    public:\n    \u00a0\u00a0\u00a0\u00a0// constructors, destructor, \n    \u00a0\u00a0\u00a0\u00a0// public access functions, public interface etc \u2026\n    \u00a0\u00a0\u00a0\u00a0const char *GetTitle() const { return title; }\n    };\n    class StudentPerson, and the derived class is Student. The derived class need only define additional data members and member functions that augment those specified in the base class. Instances of a derived class may generally access `public` members specified by the derived class or by any ancestor of the derived class. Inherited members are accessed in the same fashion as those specified by the derived class. Recall, `.` dot notation is used to access members of objects, and `->` arrow notation is used to access members of pointers to objects. Of course, to make this example complete, we will need to add the applicable constructors, which we currently assume exist. Naturally, there will be nuances with constructors relating to inheritance, which we will soon cover in this chapter. \n    ```", "```cpp\n    int main()\n    {\u00a0\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0// Let's assume the applicable constructors exist\n    \u00a0\u00a0\u00a0\u00a0Person p1(\"Cyrus Bond\", \"Mr.\");\n    \u00a0\u00a0\u00a0\u00a0Student *s1 = new Student(\"Anne Lin\", \"Ms.\", 4.0);\n    \u00a0\u00a0\u00a0\u00a0cout << p1.GetTitle() << \" \" << s1->GetTitle();\n    \u00a0\u00a0\u00a0\u00a0cout << s1->GetGpa() << endl;\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    class Person\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0char *name;\n    \u00a0\u00a0\u00a0\u00a0char *title;\n    public:\n    \u00a0\u00a0\u00a0\u00a0Person();\u00a0\u00a0// various constructors\n    \u00a0\u00a0\u00a0\u00a0Person(const char *, const char *); \n    \u00a0\u00a0\u00a0\u00a0Person(const Person &);\n    \u00a0\u00a0\u00a0\u00a0~Person();\u00a0\u00a0// destructor\n    // Assume the public interface, access functions exist\n    };\n    class Student: public Person\n    {\n    private:\n    \u00a0\u00a0\u00a0\u00a0float gpa;\n    public:\n    \u00a0\u00a0\u00a0\u00a0Student();\n    \u00a0\u00a0\u00a0\u00a0Student(const char *, const char *, float);\n    \u00a0\u00a0\u00a0\u00a0~Student();\n    // Assume the public interface, access functions exist\n    };\n    ```", "```cpp\n    // Base class constructors\n    Person::Person()\n    {\n    \u00a0\u00a0\u00a0\u00a0name = title = 0;\u00a0\u00a0// null pointer\n    }\n    Person::Person(const char *n, const char *t)\n    {\u00a0\u00a0\u00a0\u00a0// implementation as expected\n    }\n    Person::Person(const Person &p)\n    {\u00a0\u00a0\u00a0// implementation as expected\n    }\n    // Derived class constructors\n    Student::Student()\u00a0\u00a0\u00a0// default constructor\n    {\n    \u00a0\u00a0\u00a0\u00a0gpa = 0.0;\n    }\n    Student::Student(const char *n, const char *t, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float g)Student::Student(), does not utilize the member initialization list to specify which Person constructor should be used. Because none has been selected, the default Person constructor (with no arguments) is called. Next, notice in the alternate derived class constructor, `Student::Student(const char *, const char *, float)`, the use of the member initialization list. Here, the `Person` constructor matching the signature of `Person::Person(const char *, const char *)` is selected to initialize the `Person` sub-object at hand. Also, notice that parameters from the `Student` constructor, `n` and `t`, are passed up to the aforementioned `Person` constructor to help complete the `Person` sub-object initialization.Now, notice in the copy constructor for the derived class, `Student::Student(const Student &)`, the member initialization list is used to select the `Person` copy constructor, passing `s` as a parameter to the `Person` copy constructor. Here, the object referenced by `s` is a `Student`, however, the top part of `Student` memory contains `Person` data members. Hence, it is acceptable to up-cast the `Student` to a `Person` to allow the `Person` copy constructor to initialize the `Person` sub-object. In the body of the `Student` copy constructor, the additional data members added by the `Student` class definition are initialized in the body of this function. Namely, by setting `gpa = s.gpa;`.\n    ```", "```cpp\n#include <iostream>\n#include <iomanip>\n#include <cstring>\nusing namespace std;\nclass Person\n{\nprivate: \n\u00a0\u00a0\u00a0// data members\n\u00a0\u00a0\u00a0char *firstName;\n\u00a0\u00a0\u00a0char *lastName;\n\u00a0\u00a0\u00a0char middleInitial;\n\u00a0\u00a0\u00a0char *title;\u00a0\u00a0// Mr., Ms., Mrs., Miss, Dr., etc.\nprotected: // make available to derived classes in their scope\n\u00a0\u00a0\u00a0void ModifyTitle(const char *); \npublic:\n\u00a0\u00a0\u00a0Person();\u00a0\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0Person(const char *, const char *, char, const char *);\u00a0\u00a0\n\u00a0\u00a0\u00a0Person(const Person &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0~Person();\u00a0\u00a0// destructor\n\u00a0\u00a0\u00a0// inline function definitions\n\u00a0\u00a0\u00a0const char *GetFirstName() const { return firstName; }\u00a0\u00a0\n\u00a0\u00a0\u00a0const char *GetLastName() const { return lastName; }\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0const char *GetTitle() const { return title; } \n\u00a0\u00a0\u00a0char GetMiddleInitial() const { return middleInitial; }\n};\n```", "```cpp\nPerson::Person()\n{\n\u00a0\u00a0\u00a0firstName = lastName = 0;\u00a0\u00a0// NULL pointer\n\u00a0\u00a0\u00a0middleInitial = '\\0';\n\u00a0\u00a0\u00a0title = 0;\n}\nPerson::Person(const char *fn, const char *ln, char mi, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *t)\n{\n\u00a0\u00a0\u00a0firstName = new char [strlen(fn) + 1];\n\u00a0\u00a0\u00a0strcpy(firstName, fn);\n\u00a0\u00a0\u00a0lastName = new char [strlen(ln) + 1];\n\u00a0\u00a0\u00a0strcpy(lastName, ln);\n\u00a0\u00a0\u00a0middleInitial = mi;\n\u00a0\u00a0\u00a0title = new char [strlen(t) + 1];\n\u00a0\u00a0\u00a0strcpy(title, t);\n}\nPerson::Person(const Person &pers)\n{\n\u00a0\u00a0\u00a0firstName = new char [strlen(pers.firstName) + 1];\n\u00a0\u00a0\u00a0strcpy(firstName, pers.firstName);\n\u00a0\u00a0\u00a0lastName = new char [strlen(pers.lastName) + 1];\n\u00a0\u00a0\u00a0strcpy(lastName, pers.lastName);\n\u00a0\u00a0\u00a0middleInitial = pers.middleInitial;\n\u00a0\u00a0\u00a0title = new char [strlen(pers.title) + 1];\n\u00a0\u00a0\u00a0strcpy(title, pers.title);\n}\nPerson::~Person()\n{\n\u00a0\u00a0\u00a0delete firstName;\n\u00a0\u00a0\u00a0delete lastName;\n\u00a0\u00a0\u00a0delete title;\n}\nvoid Person::ModifyTitle(const char *newTitle)\n{\n\u00a0\u00a0\u00a0delete title;\u00a0\u00a0// delete old title\n\u00a0\u00a0\u00a0title = new char [strlen(newTitle) + 1];\n\u00a0\u00a0\u00a0strcpy(title, newTitle);\n}\n```", "```cpp\nclass Student: public Person\n{\nprivate: \n\u00a0\u00a0\u00a0// data members\n\u00a0\u00a0\u00a0float gpa;\n\u00a0\u00a0\u00a0char *currentCourse;\n\u00a0\u00a0\u00a0const char *studentId;\u00a0\u00a0\npublic:\n\u00a0\u00a0\u00a0// member function prototypes\n\u00a0\u00a0\u00a0Student();\u00a0\u00a0// default constructor\n\u00a0\u00a0\u00a0Student(const char *, const char *, char, const char *,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float, const char *, const char *); \n\u00a0\u00a0\u00a0Student(const Student &);\u00a0\u00a0// copy constructor\n\u00a0\u00a0\u00a0~Student();\u00a0\u00a0// destructor\n\u00a0\u00a0\u00a0void Print() const;\n\u00a0\u00a0\u00a0void EarnPhD();\u00a0\u00a0// public interface to inherited \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// protected member\n\u00a0\u00a0\u00a0// inline function definitions\n\u00a0\u00a0\u00a0float GetGpa() const { return gpa; }\n\u00a0\u00a0\u00a0const char *GetCurrentCourse() const \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return currentCourse; }\n\u00a0\u00a0\u00a0const char *GetStudentId() const { return studentId; }\n\u00a0\u00a0\u00a0// prototype only, see inline function definition below\n\u00a0\u00a0\u00a0void SetCurrentCourse(const char *);\n};\ninline void Student::SetCurrentCourse(const char *c)\n{\n\u00a0\u00a0\u00a0delete currentCourse;\u00a0\u00a0\u00a0// delete existing course\n\u00a0\u00a0\u00a0currentCourse = new char [strlen(c) + 1];\n\u00a0\u00a0\u00a0strcpy(currentCourse, c); \n}\n```", "```cpp\nStudent::Student() : studentId (0)\u00a0\u00a0\u00a0// default constructor\n{\n\u00a0\u00a0\u00a0gpa = 0.0;\n\u00a0\u00a0\u00a0currentCourse = 0;\n}\n// alternate constructor\nStudent::Student(const char *fn, const char *ln, char mi, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *t, float avg, const char *course,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *id): Person(fn, ln, mi, t)\n{\n\u00a0\u00a0\u00a0gpa = avg;\n\u00a0\u00a0\u00a0currentCourse = new char [strlen(course) + 1];\n\u00a0\u00a0\u00a0strcpy(currentCourse, course);\n\u00a0\u00a0\u00a0char *temp = new char [strlen(id) + 1];\n\u00a0\u00a0\u00a0strcpy (temp, id); \n\u00a0\u00a0\u00a0studentId = temp;\n}\n// copy constructor\nStudent::Student(const Student &ps): Person(ps)\n{\n\u00a0\u00a0\u00a0gpa = ps.gpa;\n\u00a0\u00a0\u00a0currentCourse = new char [strlen(ps.currentCourse) + 1];\n\u00a0\u00a0\u00a0strcpy(currentCourse, ps.currentCourse);\n\u00a0\u00a0\u00a0char *temp = new char [strlen(ps.studentId) + 1];\n\u00a0\u00a0\u00a0strcpy (temp, ps.studentId); \n\u00a0\u00a0\u00a0studentId = temp;\n}\n\n// destructor definition\nStudent::~Student()\n{\n\u00a0\u00a0\u00a0delete currentCourse;\n\u00a0\u00a0\u00a0delete (char *) studentId;\n}\nvoid Student::Print() const\n{\n\u00a0\u00a0\u00a0// Private members of Person are not directly accessible\n\u00a0\u00a0\u00a0// within the scope of Student, so we use access functions \n\u00a0\u00a0\u00a0cout << GetTitle() << \" \" << GetFirstName() << \" \";\n\u00a0\u00a0\u00a0cout << GetMiddleInitial() << \". \" << GetLastName();\n\u00a0\u00a0\u00a0cout << \" with id: \" << studentId << \" gpa: \";\n\u00a0\u00a0\u00a0cout << setprecision(2) << gpa;\n\u00a0\u00a0\u00a0cout << \" course: \" << currentCourse << endl;\n}\nvoid Student::EarnPhD()\n{\n\u00a0\u00a0\u00a0// Protected members defined by the base class are\n\u00a0\u00a0\u00a0// accessible within the scope of the derived class.\n\u00a0\u00a0\u00a0// EarnPhd() provides a public interface to this\n\u00a0\u00a0\u00a0// functionality for derived class instances. \n\u00a0\u00a0\u00a0ModifyTitle(\"Dr.\");\u00a0\u00a0\n}\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Student s1(\"Jo\", \"Li\", 'U', \"Ms.\", 3.8, \"C++\", \"178PSU\"); \n\u00a0\u00a0\u00a0\u00a0// Public members of Person and Student are accessible\n\u00a0\u00a0\u00a0\u00a0// outside the scope of their respective classes....\n\u00a0\u00a0\u00a0\u00a0s1.Print();\n\u00a0\u00a0\u00a0\u00a0s1.SetCurrentCourse(\"Doctoral Thesis\");\n\u00a0\u00a0\u00a0\u00a0s1.EarnPhD();\n\u00a0\u00a0\u00a0\u00a0s1.Print();\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nMs. Jo U. Li with id: 178PSU gpa: 3.9 course: C++\nDr. Jo U. Li with id: 178PSU gpa: 3.9 course: Doctoral Thesis\n```", "```cpp\n    class Student: public Person\n    {\n    \u00a0\u00a0\u00a0\u00a0// usual class definition\n    };\n    ```", "```cpp\n#include <iostream>\nusing namespace std;\ntypedef int Item;\u00a0\u00a0\nclass LinkListElement\u00a0\u00a0// one 'node' or element in a LinkList\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0void *data;\n\u00a0\u00a0\u00a0\u00a0LinkListElement *next;\npublic:\n\u00a0\u00a0\u00a0\u00a0LinkListElement() { data = 0; next = 0; }\n\u00a0\u00a0\u00a0\u00a0LinkListElement(Item *i) { data = i; next = 0; }\n\u00a0\u00a0\u00a0\u00a0~LinkListElement() { delete (Item *) data; next = 0; }\n\u00a0\u00a0\u00a0\u00a0void *GetData() { return data; }\n\u00a0\u00a0\u00a0\u00a0LinkListElement *GetNext() { return next; }\n\u00a0\u00a0\u00a0\u00a0void SetNext(LinkListElement *e) { next = e; }\n};\nclass LinkList\u00a0\u00a0\u00a0// an encapsulated LinkList\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0LinkListElement *head;\n\u00a0\u00a0\u00a0\u00a0LinkListElement *tail;\n\u00a0\u00a0\u00a0\u00a0LinkListElement *current;\npublic:\n\u00a0\u00a0\u00a0\u00a0LinkList();\n\u00a0\u00a0\u00a0\u00a0LinkList(LinkListElement *);\n\u00a0\u00a0\u00a0~LinkList();\n\u00a0\u00a0\u00a0\u00a0void InsertAtFront(Item *);\n\u00a0\u00a0\u00a0\u00a0LinkListElement *RemoveAtFront();\n\u00a0\u00a0\u00a0\u00a0void DeleteAtFront();\n\u00a0\u00a0\u00a0\u00a0int IsEmpty() { return head == 0; } \n\u00a0\u00a0\u00a0\u00a0void Print();\u00a0\u00a0\n};\n```", "```cpp\nLinkList::LinkList()\n{\n\u00a0\u00a0\u00a0\u00a0head = tail = current = 0;\n}\nLinkList::LinkList(LinkListElement *element)\n{\n\u00a0\u00a0\u00a0\u00a0head = tail = current = element;\n}\nvoid LinkList::InsertAtFront(Item *theItem)\n{\n\u00a0\u00a0\u00a0\u00a0LinkListElement *temp = new LinkListElement(theItem);\n\u00a0\u00a0\u00a0\u00a0temp->SetNext(head);\u00a0\u00a0// temp->next = head;\n\u00a0\u00a0\u00a0\u00a0head = temp;\n}\nLinkListElement *LinkList::RemoveAtFront()\n{\n\u00a0\u00a0\u00a0\u00a0LinkListElement *remove = head;\n\u00a0\u00a0\u00a0\u00a0head = head->GetNext();\u00a0\u00a0// head = head->next;\n\u00a0\u00a0\u00a0\u00a0current = head;\u00a0\u00a0\u00a0\u00a0// reset current for usage elsewhere\n\u00a0\u00a0\u00a0\u00a0return remove;\n}\n\nvoid LinkList::DeleteAtFront()\n{\n\u00a0\u00a0\u00a0\u00a0LinkListElement *deallocate;\n\u00a0\u00a0\u00a0\u00a0deallocate = RemoveAtFront();\n\u00a0\u00a0\u00a0\u00a0delete deallocate;\u00a0\u00a0// destructor will both delete data \n}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// and will set next to NULL\n\nvoid LinkList::Print()\n{\n\u00a0\u00a0\u00a0\u00a0Item output;\n\u00a0\u00a0\u00a0\u00a0if (!head)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"<EMPTY>\";\n\u00a0\u00a0\u00a0\u00a0current = head;\n\u00a0\u00a0\u00a0\u00a0while (current)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0output = *((Item *) current->GetData());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << output << \" \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0current = current->GetNext();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0cout << endl;\n}\nLinkList::~LinkList()\n{\n\u00a0\u00a0\u00a0\u00a0while (!IsEmpty())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DeleteAtFront();\n}\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0// Create a few items, to be data for LinkListElements\n\u00a0\u00a0\u00a0\u00a0Item *item1 = new Item;\n\u00a0\u00a0\u00a0\u00a0*item1 = 100;\n\u00a0\u00a0\u00a0\u00a0Item *item2 = new Item(200);\n\u00a0\u00a0\u00a0\u00a0// create an element for the Linked List\n\u00a0\u00a0\u00a0\u00a0LinkListElement *element1 = new LinkListElement(item1);\n\u00a0\u00a0\u00a0\u00a0// create a linked list and initialize with one element\n\u00a0\u00a0\u00a0\u00a0LinkList list1(element1);\n\u00a0\u00a0\u00a0\u00a0// Add some new items to the list and print\n\u00a0\u00a0\u00a0\u00a0list1.InsertAtFront(item2);\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0list1.InsertAtFront(new Item(50)); // add a nameless item\n\u00a0\u00a0\u00a0\u00a0cout << \"List 1: \";\n\u00a0\u00a0\u00a0\u00a0list1.Print();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// print out contents of list\n\u00a0\u00a0\u00a0\u00a0// delete elements from list, one by one\n\u00a0\u00a0\u00a0\u00a0while (!(list1.IsEmpty()))\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list1.DeleteAtFront();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"List 1 after removing an item: \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list1.Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// create a second linked list, add some items and print\n\u00a0\u00a0\u00a0\u00a0LinkList list2;\n\u00a0\u00a0\u00a0\u00a0list2.InsertAtFront(new Item (3000));\n\u00a0\u00a0\u00a0\u00a0list2.InsertAtFront(new Item (600));\n\u00a0\u00a0\u00a0\u00a0list2.InsertAtFront(new Item (475));\n\u00a0\u00a0\u00a0\u00a0cout << \"List 2: \";\n\u00a0\u00a0\u00a0\u00a0list2.Print();\n\u00a0\u00a0\u00a0\u00a0// delete elements from list, one by one\n\u00a0\u00a0\u00a0\u00a0while (!(list2.IsEmpty()))\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list2.DeleteAtFront();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"List 2 after removing an item: \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0list2.Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nList 1: 50 200 100\nList 1 after removing an item: 200 100\nList 1 after removing an item: 100\nList 1 after removing an item: <EMPTY>\nList 2: 475 600 3000\nList 2 after removing an item: 600 3000\nList 2 after removing an item: 3000\nList 2 after removing an item: <EMPTY>\n```", "```cpp\nclass Stack: private LinkList\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0// no new data members are necessary\npublic:\n\u00a0\u00a0\u00a0\u00a0Stack() : LinkList() { }\n\u00a0\u00a0\u00a0\u00a0~Stack() { }\n\u00a0\u00a0\u00a0\u00a0// the public interface for Stack \n\u00a0\u00a0\u00a0\u00a0void Push(Item *i) { InsertAtFront(i); }\n\u00a0\u00a0\u00a0\u00a0Item *Pop(); \n\u00a0\u00a0\u00a0\u00a0// It is necessary to redefine these operation because\n\u00a0\u00a0\u00a0\u00a0// LinkList is a private base class of Stack\n\u00a0\u00a0\u00a0\u00a0int IsEmpty() { return LinkList::IsEmpty(); }\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0void Print() { LinkList::Print(); }\n};\nItem *Stack::Pop()\n{\n\u00a0\u00a0\u00a0\u00a0LinkListElement *temp;\n\u00a0\u00a0\u00a0\u00a0temp = RemoveAtFront();\n\u00a0\u00a0\u00a0\u00a0// copy temp's data\n\u00a0\u00a0\u00a0\u00a0Item *item = new Item(*((Item *) temp->GetData()));\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0delete temp;\n\u00a0\u00a0\u00a0\u00a0return item;\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Stack stack1;\u00a0\u00a0\u00a0\u00a0\u00a0// create a Stack\n\u00a0\u00a0\u00a0\u00a0// Add some items to the stack, using public interface \n\u00a0\u00a0\u00a0\u00a0stack1.Push(new Item (3000)); \n\u00a0\u00a0\u00a0\u00a0stack1.Push(new Item (600));\n\u00a0\u00a0\u00a0\u00a0stack1.Push(new Item (475));\n\u00a0\u00a0\u00a0\u00a0cout << \"Stack 1: \";\n\u00a0\u00a0\u00a0\u00a0stack1.Print();\n\u00a0\u00a0\u00a0\u00a0// Pop elements from stack, one by one\n\u00a0\u00a0\u00a0\u00a0while (!(stack1.IsEmpty()))\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack1.Pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Stack 1 after popping an item: \";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack1.Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return 0;\n} \n```", "```cpp\nStack 1: 475 600 3000\nStack 1 after popping an item: 600 3000\nStack 1 after popping an item: 3000\nStack 1 after popping an item: <EMPTY>\n```", "```cpp\n// class LinkListElement is as shown previously\n// The enhanced class definition of LinkList is:\nclass LinkList\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0LinkListElement *head;\n\u00a0\u00a0\u00a0\u00a0LinkListElement *tail;\n\u00a0\u00a0\u00a0\u00a0LinkListElement *current;\npublic:\n\u00a0\u00a0\u00a0\u00a0LinkList();\n\u00a0\u00a0\u00a0\u00a0LinkList(LinkListElement *);\n\u00a0\u00a0\u00a0\u00a0~LinkList();\n\u00a0\u00a0\u00a0\u00a0void InsertAtFront(Item *);\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0LinkListElement *RemoveAtFront();\n\u00a0\u00a0\u00a0\u00a0void DeleteAtFront();\n\u00a0\u00a0\u00a0\u00a0// Notice additional member functions added\n\u00a0\u00a0\u00a0\u00a0void InsertBeforeItem(Item *, Item *); \n\u00a0\u00a0\u00a0\u00a0LinkListElement *RemoveSpecificItem(Item *);\n\u00a0\u00a0\u00a0\u00a0void DeleteSpecificItem(Item *);\n\u00a0\u00a0\u00a0\u00a0void InsertAtEnd(Item *);\n\u00a0\u00a0\u00a0\u00a0LinkListElement *RemoveAtEnd();\n\u00a0\u00a0\u00a0\u00a0void DeleteAtEnd();\n\u00a0\u00a0\u00a0\u00a0int IsEmpty() { return head == 0; } \n\u00a0\u00a0\u00a0\u00a0void Print();\u00a0\u00a0\n};\n// Assume we have the implementation for the methods here\u2026\n```", "```cpp\nclass Queue: protected LinkList\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0// no new data members are necessary\npublic:\n\u00a0\u00a0\u00a0\u00a0Queue() : LinkList() { }\n\u00a0\u00a0\u00a0\u00a0virtual ~Queue() { }\u00a0\u00a0// we'll discuss virtual in Chp. 7\n\u00a0\u00a0\u00a0\u00a0// public interface of Queue\n\u00a0\u00a0\u00a0\u00a0void Enqueue(Item *i) { InsertAtEnd(i); }\n\u00a0\u00a0\u00a0\u00a0Item *Dequeue(); \n\u00a0\u00a0\u00a0\u00a0// redefine these methods --LinkList is a prot. base class\n\u00a0\u00a0\u00a0\u00a0int IsEmpty() { return LinkList::IsEmpty(); }\n\u00a0\u00a0\u00a0\u00a0void Print() { LinkList::Print(); }\n};\nItem *Queue::Dequeue()\n{\n\u00a0\u00a0\u00a0\u00a0LinkListElement *temp;\n\u00a0\u00a0\u00a0\u00a0temp = RemoveAtFront();\n\u00a0\u00a0\u00a0\u00a0// make copy of temp's data\n\u00a0\u00a0\u00a0\u00a0Item *item = new Item(*((Item *) temp->GetData())); \n\u00a0\u00a0\u00a0\u00a0delete temp; \n\u00a0\u00a0\u00a0\u00a0return item;\n}\nclass PriorityQueue: public Queue\n{\nprivate:\n\u00a0\u00a0\u00a0\u00a0// no new data members are necessary\npublic:\n\u00a0\u00a0\u00a0\u00a0PriorityQueue() : Queue() { }\n\u00a0\u00a0\u00a0\u00a0virtual ~PriorityQueue() { } // we'll see virtual in Chp 7\n\u00a0\u00a0\u00a0\u00a0void PriorityEnqueue(Item *i1, Item *i2) \n\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0InsertBeforeItem(i1, i2); } // accessible in this scope\n};\n```", "```cpp\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0Queue q1;\u00a0\u00a0\u00a0// Queue instance\n\u00a0\u00a0\u00a0\u00a0q1.Enqueue(new Item(50));\n\u00a0\u00a0\u00a0\u00a0q1.Enqueue(new Item(67));\n\u00a0\u00a0\u00a0\u00a0q1.Enqueue(new Item(80));\n\u00a0\u00a0\u00a0\u00a0q1.Print();\n\u00a0\u00a0\u00a0\u00a0while (!(q1.IsEmpty()))\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.Dequeue();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q1.Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0PriorityQueue q2;\u00a0\u00a0\u00a0// PiorityQueue instance\n\u00a0\u00a0\u00a0\u00a0Item *item = new Item(167); // save a handle to item\n\u00a0\u00a0\u00a0\u00a0q2.Enqueue(new Item(67));\u00a0\u00a0\u00a0// first item added\n\u00a0\u00a0\u00a0\u00a0q2.Enqueue(item);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// second item\n\u00a0\u00a0\u00a0\u00a0q2.Enqueue(new Item(180));\u00a0\u00a0// third item\n\u00a0\u00a0\u00a0\u00a0// add new item before an existing item\n\u00a0\u00a0\u00a0\u00a0q2.PriorityEnqueue(new Item(100), item); // fourth item\n\u00a0\u00a0\u00a0\u00a0q2.Print();\n\u00a0\u00a0\u00a0\u00a0while (!(q2.IsEmpty()))\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q2.Dequeue();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0q2.Print();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n50 67 80\n67 80\n80\n<EMPTY>\n67 100 167 180\n100 167 180\n167 180\n180\n<EMPTY>\n```"]