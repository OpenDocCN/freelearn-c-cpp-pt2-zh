["```cpp\n#include <Box2D/Collision/b2Collision.h>\n#include <Box2D/Collision/Shapes/b2CircleShape.h>\n#include <Box2D/Collision/Shapes/b2PolygonShape.h>\n\nvoid b2CollideCircles(\n  b2Manifold* manifold,\n  const b2CircleShape* circleA, const b2Transform& xfA,\n  const b2CircleShape* circleB, const b2Transform& xfB)\n{\n  manifold->pointCount = 0;\n\n  b2Vec2 pA = b2Mul(xfA, circleA->m_p);\n  b2Vec2 pB = b2Mul(xfB, circleB->m_p);\n\n  b2Vec2 d = pB - pA;\n  float32 distSqr = b2Dot(d, d);\n  float32 rA = circleA->m_radius, rB = circleB->m_radius;\n  float32 radius = rA + rB;\n  if (distSqr > radius * radius)\n  {\n    return;\n  }\n\n  manifold->type = b2Manifold::e_circles;\n  manifold->localPoint = circleA->m_p;\n  manifold->localNormal.SetZero();\n  manifold->pointCount = 1;\n\n  manifold->points[0].localPoint = circleB->m_p;\n  manifold->points[0].id.key = 0;\n}\n\nvoid b2CollidePolygonAndCircle(\n  b2Manifold* manifold,\n  const b2PolygonShape* polygonA, const b2Transform& xfA,\n  const b2CircleShape* circleB, const b2Transform& xfB)\n{\n  manifold->pointCount = 0;\n\n  // Compute circle position in the frame of the polygon.\n  b2Vec2 c = b2Mul(xfB, circleB->m_p);\n  b2Vec2 cLocal = b2MulT(xfA, c);\n\n  // Find the min separating edge.\n  int32 normalIndex = 0;\n  float32 separation = -b2_maxFloat;\n  float32 radius = polygonA->m_radius + circleB->m_radius;\n  int32 vertexCount = polygonA->m_count;\n  const b2Vec2* vertices = polygonA->m_vertices;\n  const b2Vec2* normals = polygonA->m_normals;\n\n  for (int32 i = 0; i < vertexCount; ++i)\n  {\n    float32 s = b2Dot(normals[i], cLocal - vertices[i]);\n\n    if (s > radius)\n    {\n      // Early out.\n      return;\n    }\n\n    if (s > separation)\n    {\n      separation = s;\n      normalIndex = i;\n    }\n  }\n\n  // Vertices that subtend the incident face.\n  int32 vertIndex1 = normalIndex;\n  int32 vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n  b2Vec2 v1 = vertices[vertIndex1];\n  b2Vec2 v2 = vertices[vertIndex2];\n\n  // If the center is inside the polygon ...\n  if (separation < b2_epsilon)\n  {\n    manifold->pointCount = 1;\n    manifold->type = b2Manifold::e_faceA;\n    manifold->localNormal = normals[normalIndex];\n    manifold->localPoint = 0.5f * (v1 + v2);\n    manifold->points[0].localPoint = circleB->m_p;\n    manifold->points[0].id.key = 0;\n    return;\n  }\n\n  // Compute barycentric coordinates\n  float32 u1 = b2Dot(cLocal - v1, v2 - v1);\n  float32 u2 = b2Dot(cLocal - v2, v1 - v2);\n  if (u1 <= 0.0f)\n  {\n    if (b2DistanceSquared(cLocal, v1) > radius * radius)\n    {\n      return;\n    }\n\n    manifold->pointCount = 1;\n    manifold->type = b2Manifold::e_faceA;\n    manifold->localNormal = cLocal - v1;\n    manifold->localNormal.Normalize();\n    manifold->localPoint = v1;\n    manifold->points[0].localPoint = circleB->m_p;\n    manifold->points[0].id.key = 0;\n  }\n  else if (u2 <= 0.0f)\n  {\n    if (b2DistanceSquared(cLocal, v2) > radius * radius)\n    {\n      return;\n    }\n\n    manifold->pointCount = 1;\n    manifold->type = b2Manifold::e_faceA;\n    manifold->localNormal = cLocal - v2;\n    manifold->localNormal.Normalize();\n    manifold->localPoint = v2;\n    manifold->points[0].localPoint = circleB->m_p;\n    manifold->points[0].id.key = 0;\n  }\n  else\n  {\n    b2Vec2 faceCenter = 0.5f * (v1 + v2);\n    float32 separation = b2Dot(cLocal - faceCenter, normals[vertIndex1]);\n    if (separation > radius)\n    {\n      return;\n    }\n\n    manifold->pointCount = 1;\n    manifold->type = b2Manifold::e_faceA;\n    manifold->localNormal = normals[vertIndex1];\n    manifold->localPoint = faceCenter;\n    manifold->points[0].localPoint = circleB->m_p;\n    manifold->points[0].id.key = 0;\n  }\n}\n```", "```cpp\n#include <Box2D/Collision/b2Collision.h>\n#include <Box2D/Collision/Shapes/b2PolygonShape.h>\n\n// Find the max separation between poly1 and poly2 using edge normals from poly1.\nstatic float32 b2FindMaxSeparation(int32* edgeIndex,\n             const b2PolygonShape* poly1, const b2Transform& xf1,\n             const b2PolygonShape* poly2, const b2Transform& xf2)\n{\n  int32 count1 = poly1->m_count;\n  int32 count2 = poly2->m_count;\n  const b2Vec2* n1s = poly1->m_normals;\n  const b2Vec2* v1s = poly1->m_vertices;\n  const b2Vec2* v2s = poly2->m_vertices;\n  b2Transform xf = b2MulT(xf2, xf1);\n\n  int32 bestIndex = 0;\n  float32 maxSeparation = -b2_maxFloat;\n  for (int32 i = 0; i < count1; ++i)\n  {\n    // Get poly1 normal in frame2.\n    b2Vec2 n = b2Mul(xf.q, n1s[i]);\n    b2Vec2 v1 = b2Mul(xf, v1s[i]);\n\n    // Find deepest point for normal i.\n    float32 si = b2_maxFloat;\n    for (int32 j = 0; j < count2; ++j)\n    {\n      float32 sij = b2Dot(n, v2s[j] - v1);\n      if (sij < si)\n      {\n        si = sij;\n      }\n    }\n\n    if (si > maxSeparation)\n    {\n      maxSeparation = si;\n      bestIndex = i;\n    }\n  }\n\n  *edgeIndex = bestIndex;\n  return maxSeparation;\n}\n\nstatic void b2FindIncidentEdge(b2ClipVertex c[2],\n           const b2PolygonShape* poly1, const b2Transform& xf1, int32 edge1,\n           const b2PolygonShape* poly2, const b2Transform& xf2)\n{\n  const b2Vec2* normals1 = poly1->m_normals;\n\n  int32 count2 = poly2->m_count;\n  const b2Vec2* vertices2 = poly2->m_vertices;\n  const b2Vec2* normals2 = poly2->m_normals;\n\n  b2Assert(0 <= edge1 && edge1 < poly1->m_count);\n\n  // Get the normal of the reference edge in poly2's frame.\n  b2Vec2 normal1 = b2MulT(xf2.q, b2Mul(xf1.q, normals1[edge1]));\n\n  // Find the incident edge on poly2.\n  int32 index = 0;\n  float32 minDot = b2_maxFloat;\n  for (int32 i = 0; i < count2; ++i)\n  {\n    float32 dot = b2Dot(normal1, normals2[i]);\n    if (dot < minDot)\n    {\n      minDot = dot;\n      index = i;\n    }\n  }\n\n  // Build the clip vertices for the incident edge.\n  int32 i1 = index;\n  int32 i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n\n  c[0].v = b2Mul(xf2, vertices2[i1]);\n  c[0].id.cf.indexA = (uint8)edge1;\n  c[0].id.cf.indexB = (uint8)i1;\n  c[0].id.cf.typeA = b2ContactFeature::e_face;\n  c[0].id.cf.typeB = b2ContactFeature::e_vertex;\n\n  c[1].v = b2Mul(xf2, vertices2[i2]);\n  c[1].id.cf.indexA = (uint8)edge1;\n  c[1].id.cf.indexB = (uint8)i2;\n  c[1].id.cf.typeA = b2ContactFeature::e_face;\n  c[1].id.cf.typeB = b2ContactFeature::e_vertex;\n}\n\n// Find edge normal of max separation on A - return if separating axis is found\n// Find edge normal of max separation on B - return if separation axis is found\n// Choose reference edge as min(minA, minB)\n// Find incident edge\n// Clip\n\n// The normal points from 1 to 2\nvoid b2CollidePolygons(b2Manifold* manifold,\n            const b2PolygonShape* polyA, const b2Transform& xfA,\n            const b2PolygonShape* polyB, const b2Transform& xfB)\n{\n  manifold->pointCount = 0;\n  float32 totalRadius = polyA->m_radius + polyB->m_radius;\n\n  int32 edgeA = 0;\n  float32 separationA = b2FindMaxSeparation(&edgeA, polyA, xfA, polyB, xfB);\n  if (separationA > totalRadius)\n    return;\n\n  int32 edgeB = 0;\n  float32 separationB = b2FindMaxSeparation(&edgeB, polyB, xfB, polyA, xfA);\n  if (separationB > totalRadius)\n    return;\n\n  const b2PolygonShape* poly1;  // reference polygon\n  const b2PolygonShape* poly2;  // incident polygon\n  b2Transform xf1, xf2;\n  int32 edge1;          // reference edge\n  uint8 flip;\n  const float32 k_tol = 0.1f * b2_linearSlop;\n\n  if (separationB > separationA + k_tol)\n  {\n    poly1 = polyB;\n    poly2 = polyA;\n    xf1 = xfB;\n    xf2 = xfA;\n    edge1 = edgeB;\n    manifold->type = b2Manifold::e_faceB;\n    flip = 1;\n  }\n  else\n  {\n    poly1 = polyA;\n    poly2 = polyB;\n    xf1 = xfA;\n    xf2 = xfB;\n    edge1 = edgeA;\n    manifold->type = b2Manifold::e_faceA;\n    flip = 0;\n  }\n\n  b2ClipVertex incidentEdge[2];\n  b2FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n\n  int32 count1 = poly1->m_count;\n  const b2Vec2* vertices1 = poly1->m_vertices;\n\n  int32 iv1 = edge1;\n  int32 iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n\n  b2Vec2 v11 = vertices1[iv1];\n  b2Vec2 v12 = vertices1[iv2];\n\n  b2Vec2 localTangent = v12 - v11;\n  localTangent.Normalize();\n\n  b2Vec2 localNormal = b2Cross(localTangent, 1.0f);\n  b2Vec2 planePoint = 0.5f * (v11 + v12);\n\n  b2Vec2 tangent = b2Mul(xf1.q, localTangent);\n  b2Vec2 normal = b2Cross(tangent, 1.0f);\n\n  v11 = b2Mul(xf1, v11);\n  v12 = b2Mul(xf1, v12);\n\n  // Face offset.\n  float32 frontOffset = b2Dot(normal, v11);\n\n  // Side offsets, extended by polytope skin thickness.\n  float32 sideOffset1 = -b2Dot(tangent, v11) + totalRadius;\n  float32 sideOffset2 = b2Dot(tangent, v12) + totalRadius;\n\n  // Clip incident edge against extruded edge1 side edges.\n  b2ClipVertex clipPoints1[2];\n  b2ClipVertex clipPoints2[2];\n  int np;\n\n  // Clip to box side 1\n  np = b2ClipSegmentToLine(clipPoints1, incidentEdge, -tangent, sideOffset1, iv1);\n\n  if (np < 2)\n    return;\n\n  // Clip to negative box side 1\n  np = b2ClipSegmentToLine(clipPoints2, clipPoints1,  tangent, sideOffset2, iv2);\n\n  if (np < 2)\n  {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  manifold->localNormal = localNormal;\n  manifold->localPoint = planePoint;\n\n  int32 pointCount = 0;\n  for (int32 i = 0; i < b2_maxManifoldPoints; ++i)\n  {\n    float32 separation = b2Dot(normal, clipPoints2[i].v) - frontOffset;\n\n    if (separation <= totalRadius)\n    {\n      b2ManifoldPoint* cp = manifold->points + pointCount;\n      cp->localPoint = b2MulT(xf2, clipPoints2[i].v);\n      cp->id = clipPoints2[i].id;\n      if (flip)\n      {\n        // Swap features\n        b2ContactFeature cf = cp->id.cf;\n        cp->id.cf.indexA = cf.indexB;\n        cp->id.cf.indexB = cf.indexA;\n        cp->id.cf.typeA = cf.typeB;\n        cp->id.cf.typeB = cf.typeA;\n      }\n      ++pointCount;\n    }\n  }\n\n  manifold->pointCount = pointCount;\n}\n```", "```cpp\nbool BoxesIntersect(const Box2D &a, const Box2D &b)\n{\n    if (a.max.x < b.min.x) return false; // a is left of b\n    if (a.min.x > b.max.x) return false; // a is right of b\n    if (a.max.y < b.min.y) return false; // a is above b\n    if (a.min.y > b.max.y) return false; // a is below b\n    return true; // boxes overlap\n}\n```", "```cpp\nclass Tiles : public Test\n{\npublic:\n  enum\n  {\n    e_count = 10\n  };\n\n  Tiles()\n  {\n    m_fixtureCount = 0;\n    b2Timer timer;\n\n    {\n      float32 a = 1.0f;\n      b2BodyDef bd;\n      bd.position.y = -a;\n      b2Body* ground = m_world->CreateBody(&bd);\n\n#if 1\n      int32 N = 200;\n      int32 M = 10;\n      b2Vec2 position;\n      position.y = 0.0f;\n      for (int32 j = 0; j < M; ++j)\n      {\n        position.x = -N * a;\n        for (int32 i = 0; i < N; ++i)\n        {\n          b2PolygonShape shape;\n          shape.SetAsBox(a, a, position, 0.0f);\n          ground->CreateFixture(&shape, 0.0f);\n          ++m_fixtureCount;\n          position.x += 2.0f * a;\n        }\n        position.y -= 2.0f * a;\n      }\n#else\n      int32 N = 200;\n      int32 M = 10;\n      b2Vec2 position;\n      position.x = -N * a;\n      for (int32 i = 0; i < N; ++i)\n      {\n        position.y = 0.0f;\n        for (int32 j = 0; j < M; ++j)\n        {\n          b2PolygonShape shape;\n          shape.SetAsBox(a, a, position, 0.0f);\n          ground->CreateFixture(&shape, 0.0f);\n          position.y -= 2.0f * a;\n        }\n        position.x += 2.0f * a;\n      }\n#endif\n    }\n\n    {\n      float32 a = 1.0f;\n      b2PolygonShape shape;\n      shape.SetAsBox(a, a);\n\n      b2Vec2 x(-7.0f, 0.75f);\n      b2Vec2 y;\n      b2Vec2 deltaX(1.125f, 2.5f);\n      b2Vec2 deltaY(2.25f, 0.0f);\n\n      for (int32 i = 0; i < e_count; ++i)\n      {\n        y = x;\n\n        for (int32 j = i; j < e_count; ++j)\n        {\n          b2BodyDef bd;\n          bd.type = b2_dynamicBody;\n          bd.position = y;\n\n          b2Body* body = m_world->CreateBody(&bd);\n          body->CreateFixture(&shape, 5.0f);\n          ++m_fixtureCount;\n          y += deltaY;\n        }\n\n        x += deltaX;\n      }\n    }\n\n    m_createTime = timer.GetMilliseconds();\n  }\n\n  void Step(Settings* settings)\n  {\n    const b2ContactManager& cm = m_world->GetContactManager();\n    int32 height = cm.m_broadPhase.GetTreeHeight();\n    int32 leafCount = cm.m_broadPhase.GetProxyCount();\n    int32 minimumNodeCount = 2 * leafCount - 1;\n    float32 minimumHeight = ceilf(logf(float32(minimumNodeCount)) / logf(2.0f));\n    g_debugDraw.DrawString(5, m_textLine, \"dynamic tree height = %d, min = %d\", height, int32(minimumHeight));\n    m_textLine += DRAW_STRING_NEW_LINE;\n\n    Test::Step(settings);\n\n    g_debugDraw.DrawString(5, m_textLine, \"create time = %6.2f ms, fixture count = %d\",\n      m_createTime, m_fixtureCount);\n    m_textLine += DRAW_STRING_NEW_LINE;\n\n  }\n\n  static Test* Create()\n  {\n    return new Tiles;\n  }\n\n  int32 m_fixtureCount;\n  float32 m_createTime;\n};\n\n#endif\n```", "```cpp\nvoid  b3DynamicBvhBroadphase::getAabb(int objectId,b3Vector3& aabbMin, b3Vector3& aabbMax ) const\n{\n  const b3DbvtProxy*            proxy=&m_proxies[objectId];\n  aabbMin = proxy->m_aabbMin;\n  aabbMax = proxy->m_aabbMax;\n}\n```", "```cpp\nvoid b3CpuNarrowPhase::computeContacts(b3AlignedObjectArray<b3Int4>& pairs, b3AlignedObjectArray<b3Aabb>& aabbsWorldSpace, b3AlignedObjectArray<b3RigidBodyData>& bodies)\n{\n  int nPairs = pairs.size();\n  int numContacts = 0;\n  int maxContactCapacity = m_data->m_config.m_maxContactCapacity;\n  m_data->m_contacts.resize(maxContactCapacity);\n\n  for (int i=0;i<nPairs;i++)\n  {\n    int bodyIndexA = pairs[i].x;\n    int bodyIndexB = pairs[i].y;\n    int collidableIndexA = bodies[bodyIndexA].m_collidableIdx;\n    int collidableIndexB = bodies[bodyIndexB].m_collidableIdx;\n\n    if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_SPHERE &&\n      m_data->m_collidablesCPU[collidableIndexB].m_shapeType == SHAPE_CONVEX_HULL)\n    {\n//     computeContactSphereConvex(i,bodyIndexA,bodyIndexB,collidableIndexA,collidableIndexB,&bodies[0],\n//     &m_data->m_collidablesCPU[0],&hostConvexData[0],&hostVertices[0],&hostIndices[0],&hostFaces[0],&hostContacts[0],nContacts,maxContactCapacity);\n    }\n\n    if (m_data->m_collidablesCPU[collidableIndexA].m_shapeType == SHAPE_\n\n  m_data->m_contacts.resize(numContacts);\n\n<. . . . . . .  More code to follow . . . . . . . .>\n}\n```", "```cpp\nclass Particle\n\n{\n  Vector3 location;\n  Vector3 velocity;\n  Vector3 acceleration;\n  float lifespan;\n\n  Particle(Vector3 vec)\n  {\n\n    acceleration = new Vector3(.05, 0.05);\n    velocity = new Vector3(random(-3, 3), random(-4, 0));\n    location = vec.get();\n    lifespan = 125.0;\n  }\n\n    void run()\n    {\n    update();\n    display();\n    }\n\n  void update() {\n    velocity.add(acceleration);\n    location.add(velocity);\n    lifespan -= 2.0;\n  }\n\n  void display()\n  {\n    stroke(0, lifespan);\n    fill(0, lifespan);\n    trapezoid(location.x, location.y, 8, 8);\n  }\n\n    boolean isDead()\n    {\n    if (lifespan < 0.0) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n};\n\nParticle p;\n\nvoid setup()\n{\n  size(800, 600);\n  p = new Particle(new Vector3(width / 2, 10));\n}\n\nvoid draw()\n{\n  for (int i = 0; i < particles.size(); i++) {\n    Particle p = particles.get(i);\n    p.run();\n\n      if (p.isDead()) {\n        particles.remove(i);\n      }\n  }\n}\n```", "```cpp\n#include \"RagDoll.h\"\n#include \"C3DETransform.h\"\n#include \"PhysicsFactory.h\"\n#include \"Physics.h\"\n#include \"DebugMemory.h\"\n\nRagDoll::RagDoll(C3DESkinnedMesh * a_skinnedMesh, C3DESkinnedMeshContainer * a_skinnedMeshContainer, int totalParts, int totalConstraints)\n{\n  m_skinnedMesh = a_skinnedMesh;\n  m_skinnedMeshContainer = a_skinnedMeshContainer;\n  m_totalParts = totalParts;\n  m_totalConstraints = totalConstraints;\n\n  m_ragdollBodies = (btRigidBody**)malloc(sizeof(btRigidBody) * totalParts);\n  m_ragdollShapes = (btCollisionShape**)malloc(sizeof(btCollisionShape) * totalParts);\n  m_ragdollConstraints = (btTypedConstraint**)malloc(sizeof(btTypedConstraint) * totalConstraints);\n\n  m_boneIndicesToFollow = (int*) malloc(sizeof(int) * m_skinnedMesh->GetTotalBones());\n\n  m_totalBones = m_skinnedMesh->GetTotalBones();\n\n  m_bonesCurrentWorldPosition = (D3DXMATRIX**)malloc(sizeof(D3DXMATRIX) * m_totalBones);\n\n  m_boneToPartTransforms = (D3DXMATRIX**)malloc(sizeof(D3DXMATRIX) * m_totalBones);\n\n  for(int i = 0; i < totalConstraints; i++)\n  {\n    m_ragdollConstraints[i] = NULL;\n  }\n\n  for(int i = 0; i < totalParts; i++)\n  {\n    m_ragdollBodies[i] = NULL;\n    m_ragdollShapes[i] = NULL;\n\n  }\n\n  for(int i = 0; i < m_totalBones; i++)\n  {    \n    m_boneToPartTransforms[i] = NULL;\n    m_boneToPartTransforms[i] = new D3DXMATRIX();\n\n    m_bonesCurrentWorldPosition[i] = NULL;\n    m_bonesCurrentWorldPosition[i] = new D3DXMATRIX();\n  }\n\n  m_constraintCount = 0;\n}\n\nRagDoll::~RagDoll()\n{\n  free(m_ragdollConstraints);  \n  free(m_ragdollBodies);\n  free(m_ragdollShapes);  \n\n  for(int i = 0; i < m_totalBones; i++)\n  {\n\n    delete m_boneToPartTransforms[i];\n    m_boneToPartTransforms[i] = NULL;\n\n    delete m_bonesCurrentWorldPosition[i];\n    m_bonesCurrentWorldPosition[i] = NULL;\n  }\n\n  free(m_bonesCurrentWorldPosition);\n  free(m_boneToPartTransforms);    \n  free(m_boneIndicesToFollow);    \n\n}\n\nint RagDoll::GetTotalParts()\n{\n  return m_totalParts;\n}\n\nint RagDoll::GetTotalConstraints()\n{\n  return m_totalConstraints;\n}\n\nC3DESkinnedMesh *RagDoll::GetSkinnedMesh()\n{\n  return m_skinnedMesh;\n}\n\n//sets up a part of the ragdoll\n//int index = the index number of the part\n//int setMeshBoneTransformIndex = the bone index that this part is linked to,\n//float offsetX, float offsetY, float offsetZ = translatin offset for the part in bone local space\n//float mass = part's mass,\n//btCollisionShape * a_shape = part's collision shape\nvoid RagDoll::SetPart(int index, int setMeshBoneTransformIndex, float offsetX, float offsetY, float offsetZ,float mass, btCollisionShape * a_shape)\n{  \n  m_boneIndicesToFollow[setMeshBoneTransformIndex] = index;\n\n  //we set the parts position according to the skinned mesh current position\n\n  D3DXMATRIX t_poseMatrix = m_skinnedMeshContainer->GetPoseMatrix()[setMeshBoneTransformIndex];\n  D3DXMATRIX *t_boneWorldRestMatrix = m_skinnedMesh->GetBoneWorldRestMatrix(setMeshBoneTransformIndex);\n\n  D3DXMATRIX t_boneWorldPosition;\n  D3DXMatrixMultiply(&t_boneWorldPosition, t_boneWorldRestMatrix, &t_poseMatrix);\n\n  D3DXVECTOR3 * t_head = m_skinnedMesh->GetBoneHead(setMeshBoneTransformIndex);\n  D3DXVECTOR3 * t_tail = m_skinnedMesh->GetBoneTail(setMeshBoneTransformIndex);        \n\n  float tx = t_tail->x - t_head->x;\n  float ty = t_tail->y - t_head->y;\n  float tz = t_tail->z - t_head->z;\n\n  //part's world matrix\n  D3DXMATRIX *t_partMatrix = new D3DXMATRIX();\n  *t_partMatrix = t_boneWorldPosition;\n\n  D3DXMATRIX *t_centerOffset = new D3DXMATRIX();\n  D3DXMatrixIdentity(t_centerOffset);\n  D3DXMatrixTranslation(t_centerOffset, (tx / 2.0f) + offsetX, (ty / 2.0f) + offsetY, (tz/2.0f) + offsetZ);\n  D3DXMatrixMultiply(t_partMatrix, t_partMatrix, t_centerOffset);\n\n  D3DXVECTOR3 t_pos;\n  D3DXVECTOR3 t_scale;\n  D3DXQUATERNION t_rot;\n\n  D3DXMatrixDecompose(&t_scale, &t_rot, &t_pos, t_partMatrix);\n\n  btRigidBody* body = PhysicsFactory::GetInstance()->CreateRigidBody(mass,t_pos.x, t_pos.y, t_pos.z, t_rot.x, t_rot.y, t_rot.z, t_rot.w, a_shape);\n\n  D3DXMATRIX t_partInverse;\n  D3DXMatrixInverse(&t_partInverse, NULL, t_partMatrix);\n\n  //puts the bone's matrix in part's local space, and store it in m_boneToPartTransforms\n  D3DXMatrixMultiply(m_boneToPartTransforms[setMeshBoneTransformIndex], &t_boneWorldPosition, &t_partInverse);\n\n  m_ragdollBodies[index] = body;\n\n  delete t_partMatrix;\n  t_partMatrix = NULL;\n\n  delete t_centerOffset;\n  t_centerOffset = NULL;\n\n}\n\n//when a bone is not going to have a part directly linked to it, it needs to follow a bone that has\n//a part linked to\n//int realBoneIndex = the bone that has no part linked\n//int followBoneIndex = the bone that has a part linked\nvoid RagDoll::SetBoneRelation(int realBoneIndex, int followBoneIndex)\n{\n  //it is going to the same thing the setPart method does, but the bone it is going to take\n  //as a reference is the one passed as followBoneIndex and the the part's matrix is below\n  //by calling GetPartForBoneIndex. Still there is going to be a new entry in m_boneToPartTransforms\n  //which is the bone transform in the part's local space\n  int partToFollowIndex = GetPartForBoneIndex(followBoneIndex);\n\n  m_boneIndicesToFollow[realBoneIndex] = partToFollowIndex;\n\n  D3DXMATRIX t_poseMatrix = m_skinnedMeshContainer->GetPoseMatrix()[realBoneIndex];\n  D3DXMATRIX *t_boneWorldRestMatrix = m_skinnedMesh->GetBoneWorldRestMatrix(realBoneIndex);\n\n  D3DXMATRIX t_boneWorldPosition;\n  D3DXMatrixMultiply(&t_boneWorldPosition, t_boneWorldRestMatrix, &t_poseMatrix);\n\n  D3DXMATRIX *t_partMatrix = new D3DXMATRIX();\n  btTransform t_partTransform = m_ragdollBodies[partToFollowIndex]->getWorldTransform();\n  *t_partMatrix = BT2DX_MATRIX(t_partTransform);\n\n  D3DXMATRIX t_partInverse;\n  D3DXMatrixInverse(&t_partInverse, NULL, t_partMatrix);\n\n  D3DXMatrixMultiply(m_boneToPartTransforms[realBoneIndex], &t_boneWorldPosition, &t_partInverse);    \n\n  delete t_partMatrix;\n  t_partMatrix = NULL;  \n\n}\n\nbtRigidBody ** RagDoll::GetRadollParts()\n{\n  return m_ragdollBodies;\n}\n\nbtTypedConstraint **RagDoll::GetConstraints()\n{\n  return m_ragdollConstraints;\n}\n\nvoid RagDoll::AddConstraint(btTypedConstraint *a_constraint)\n{\n  m_ragdollConstraints[m_constraintCount] = a_constraint;\n  m_constraintCount++;\n}\n\n//This method will return the world position that the given bone should have\nD3DXMATRIX * RagDoll::GetBoneWorldTransform(int boneIndex)\n{\n  //the part world matrix is fetched, and then we apply the bone transform offset to obtain\n  //the bone's world position\n  int t_partIndex = GetPartForBoneIndex(boneIndex);\n\n  btTransform  t_transform = m_ragdollBodies[t_partIndex]->getWorldTransform();    \n  D3DXMATRIX t_partMatrix = BT2DX_MATRIX(t_transform);\n\n  D3DXMatrixIdentity(m_bonesCurrentWorldPosition[boneIndex]);\n  D3DXMatrixMultiply(m_bonesCurrentWorldPosition[boneIndex], m_boneToPartTransforms[boneIndex], &t_partMatrix);\n\n  return m_bonesCurrentWorldPosition[boneIndex];\n}\n\nint RagDoll::GetPartForBoneIndex(int boneIndex)\n{\n  for(int i = 0; i < m_totalBones;i ++)\n  {\n    if(i == boneIndex)\n    {\n      return m_boneIndicesToFollow[i];\n    }\n  }\n\n  return -1;\n}\n```"]