["```cpp\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    class PhysicsManager\n    {\n    private:\n      static bool bCheckFlag;\n      static PhysicsManager *s_singleInstance;\n      PhysicsManager()\n      {\n        //private constructor\n      }\n    public:\n      static PhysicsManager* getInstance();\n      void GetCurrentGravity()const;\n\n      ~PhysicsManager()\n      {\n        bCheckFlag = false;\n      }\n    };\n\n    bool PhysicsManager::bCheckFlag = false;\n\n    PhysicsManager* PhysicsManager::s_singleInstance = NULL;\n\n    PhysicsManager* PhysicsManager::getInstance()\n    {\n      if (!bCheckFlag)\n      {\n        s_singleInstance = new PhysicsManager();\n        bCheckFlag = true;\n        return s_singleInstance;\n      }\n      else\n      {\n        return s_singleInstance;\n      }\n    }\n\n    void PhysicsManager::GetCurrentGravity() const\n    {\n      //Some calculations for finding the current gravity\n      //Probably a base variable which constantly gets updated with value\n      //based on the environment\n      cout << \"Current gravity of the system is: \" <<9.8<< endl;\n    }\n\n    int main()\n    {\n      PhysicsManager *sc1, *sc2;\n      sc1 = PhysicsManager::getInstance();\n      sc1->GetCurrentGravity();\n      sc2 = PhysicsManager::getInstance();\n      sc2->GetCurrentGravity();\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n    #include <vector>\n\n    using namespace std;\n\n    class IBuilding\n    {\n    public:\n      virtual void TotalHealth() = 0;\n    };\n\n    class Barracks : public IBuilding\n    {\n    public:\n      void TotalHealth()\n      {\n        cout << \"Health of Barrack is :\" << 100;\n      }\n    };\n    class Temple : public IBuilding\n    {\n    public:\n      void TotalHealth()\n      {\n        cout << \"Health of Temple is :\" << 75;\n      }\n    };\n    class Farmhouse : public IBuilding\n    {\n    public:\n      void TotalHealth()\n      {\n        cout << \"Health of Farmhouse is :\" << 50;\n      }\n    };\n\n    int main()\n    {\n      vector<IBuilding*> BuildingTypes;\n      int choice;\n\n      cout << \"Specify the different building types in your village\" << endl;\n      while (true)\n      {\n\n        cout << \"Barracks(1) Temple(2) Farmhouse(3) Go(0): \";\n        cin >> choice;\n        if (choice == 0)\n          break;\n        else if (choice == 1)\n          BuildingTypes.push_back(new Barracks);\n        else if (choice == 2)\n          BuildingTypes.push_back(new Temple);\n        else\n          BuildingTypes.push_back(new Farmhouse);\n      }\n      cout << endl;\n      cout << \"There are total \" << BuildingTypes.size() << \" buildings\" << endl;\n      for (int i = 0; i < BuildingTypes.size(); i++)\n      {\n        BuildingTypes[i]->TotalHealth();\n        cout << endl;\n      }\n\n      for (int i = 0; i < BuildingTypes.size(); i++)\n        delete BuildingTypes[i];\n\n      _getch();\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n    #include <string>\n\n    using namespace std;\n\n    //IFast interface\n    class IFast\n    {\n    public:\n      virtual std::string Name() = 0;\n    };\n\n    //ISlow interface\n    class ISlow\n    {\n    public:\n      virtual std::string Name() = 0;\n    };\n    class Rapter : public ISlow\n    {\n    public:\n      std::string Name()\n      {\n        return \"Rapter\";\n      }\n    };\n\n    class Cocumbi : public IFast\n    {\n    public:\n      std::string Name()\n      {\n        return \"Cocumbi\";\n      }\n    };\n       . . . . .// Similar classes can be written here\n    class AEnemyFactory\n    {\n    public:\n      enum Enemy_Factories\n      {\n        Land,\n        Air,\n        Water\n      };\n\n      virtual IFast* GetFast() = 0;\n      virtual ISlow* GetSlow() = 0;\n\n      static AEnemyFactory* CreateFactory(Enemy_Factories factory);\n    };\n\n    class LandFactory : public AEnemyFactory\n    {\n    public:\n      IFast* GetFast()\n      {\n        return new Cocumbi();\n      }\n\n      ISlow* GetSlow()\n      {\n        return new Marzel();\n      }\n    };\n\n    class AirFactory : public AEnemyFactory\n    {\n    public:\n      IFast* GetFast()\n      {\n        return new Zybgry();\n      }\n\n      ISlow* GetSlow()\n      {\n        return new Bungindi();\n      }\n    };\n\n    class WaterFactory : public AEnemyFactory\n    {\n    public:\n      IFast* GetFast()\n      {\n        return new Manama();\n      }\n\n      ISlow* GetSlow()\n      {\n        return new Pokili();\n      }\n    };\n\n    //CPP File\n    AEnemyFactory* AEnemyFactory::CreateFactory(Enemy_Factories factory)\n    {\n      if (factory == Enemy_Factories::Land)\n      {\n        return new LandFactory();\n      }\n      else if (factory == Enemy_Factories::Air)\n      {\n        return new AirFactory();\n      }\n      else if (factory == Enemy_Factories::Water)\n      {\n        return new WaterFactory();\n      }\n    }\n\n    int main(int argc, char* argv[])\n    {\n      AEnemyFactory *factory = AEnemyFactory::CreateFactory\n        (AEnemyFactory::Enemy_Factories::Land);\n\n      cout << \"Slow enemy of Land: \" << factory->GetSlow()->Name() << \"\\n\";\n      delete factory->GetSlow();\n      cout << \"Fast enemy of Land: \" << factory->GetFast()->Name() << \"\\n\";\n      delete factory->GetFast();\n      delete factory;\n      getchar();\n\n      factory = AEnemyFactory::CreateFactory(AEnemyFactory::Enemy_Factories::Air);\n      cout << \"Slow enemy of Air: \" << factory->GetSlow()->Name() << \"\\n\";\n      delete factory->GetSlow();\n      cout << \"Fast enemy of Air: \" << factory->GetFast()->Name() << \"\\n\";\n      delete factory->GetFast();\n      delete factory;\n      getchar();\n\n      factory = AEnemyFactory::CreateFactory(AEnemyFactory::Enemy_Factories::Water);\n      cout << \"Slow enemy of Water: \" << factory->GetSlow()->Name() << \"\\n\";\n      delete factory->GetSlow();\n      cout << \"Fast enemy of Water: \" << factory->GetFast()->Name() << \"\\n\";\n      delete factory->GetFast();\n      getchar();\n\n      return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <conio.h>\n\n    using namespace std;\n\n    class PhysicsSystem {\n\n      vector < class Observer * > views;\n      int value;\n    public:\n      void attach(Observer *obs) {\n        views.push_back(obs);\n      }\n      void setVal(int val) {\n        value = val;\n        notify();\n      }\n      int getVal() {\n        return value;\n      }\n      void notify();\n    };\n\n    class Observer {\n\n      PhysicsSystem *_attribute;\n      int iScalarMultiplier;\n    public:\n      Observer(PhysicsSystem *attribute, int value)\n      {\n        If(attribute)\n    {\n\n    _attribute = attribute;\n    }\n        iScalarMultiplier = value;\n\n        _attribute->attach(this);\n      }\n      virtual void update() = 0;\n    protected:\n      PhysicsSystem *getPhysicsSystem() {\n        return _attribute;\n      }\n      int getvalue()\n      {\n        return iScalarMultiplier;\n      }\n    };\n\n    void PhysicsSystem::notify() {\n\n      for (int i = 0; i < views.size(); i++)\n        views[i]->update();\n    }\n\n    class PlayerObserver : public Observer {\n    public:\n      PlayerObserver(PhysicsSystem *attribute, int value) : Observer(attribute, value){}\n      void update() {\n\n        int v = getPhysicsSystem()->getVal(), d = getvalue();\n        cout << \"Player is dependent on the Physics system\" << endl;\n        cout << \"Player new impulse value is \" << v / d << endl << endl;\n      }\n    };\n\n    class AIObserver : public Observer {\n    public:\n      AIObserver(PhysicsSystem *attribute, int value) : Observer(attribute, value){}\n      void update() {\n        int v = getPhysicsSystem()->getVal(), d = getvalue();\n        cout << \"AI is dependent on the Physics system\" << endl;\n        cout << \"AI new impulse value is \" << v % d << endl << endl;\n      }\n    };\n\n    int main() {\n      PhysicsSystem subj;\n\n      PlayerObserver valueObs1(&subj, 4);\n      AIObserver attributeObs3(&subj, 3);\n      subj.setVal(100);\n\n      _getch();\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <string>\n    #include <map>\n    #include <conio.h>\n\n    using namespace std;\n\n    class TreeType\n    {\n    public:\n      virtual void Display(int size) = 0;\n\n    protected:\n      //Some Model we need to assign. For relevance we are substituting this with a character symbol\n      char symbol_;\n      int width_;\n      int height_;\n      float color_;\n\n      int Size_;\n    };\n\n    class TreeTypeA : public TreeType\n    {\n    public:\n      TreeTypeA()\n      {\n        symbol_ = 'A';\n        width_ = 94;\n        height_ = 135;\n        color_ = 0;\n\n        Size_ = 0;\n      }\n      void Display(int size)\n      {\n        Size_ = size;\n        cout << \"Size of \" << symbol_ << \" is :\" << Size_ << endl;\n      }\n    };\n\n    class TreeTypeB : public TreeType\n    {\n    public:\n      TreeTypeB()\n      {\n        symbol_ = 'B';\n        width_ = 70;\n        height_ = 25;\n        color_ = 0;\n\n        Size_ = 0;\n      }\n      void Display(int size)\n      {\n        Size_ = size;\n        cout << \"Size of \" << symbol_ << \" is :\" << Size_ << endl;\n      }\n    };\n\n    class TreeTypeZ : public TreeType\n    {\n    public:\n      TreeTypeZ()\n      {\n        symbol_ = 'Z';\n        width_ = 20;\n        height_ = 40;\n        color_ = 1;\n\n        Size_ = 0;\n      }\n      void Display(int size)\n      {\n        Size_ = size;\n        cout <<\"Size of \" << symbol_ << \" is :\" << Size_ << endl;\n      }\n    };\n\n    // The 'FlyweightFactory' class\n    class TreeTypeFactory\n    {\n    public:\n      virtual ~TreeTypeFactory()\n      {\n        while (!TreeTypes_.empty())\n        {\n          map<char, TreeType*>::iterator it = TreeTypes_.begin();\n          delete it->second;\n          TreeTypes_.erase(it);\n        }\n      }\n      TreeType* GetTreeType(char key)\n      {\n        TreeType* TreeType = NULL;\n        if (TreeTypes_.find(key) != TreeTypes_.end())\n        {\n          TreeType = TreeTypes_[key];\n        }\n        else\n        {\n          switch (key)\n          {\n          case 'A':\n            TreeType = new TreeTypeA();\n            break;\n          case 'B':\n            TreeType = new TreeTypeB();\n            break;\n            //\u2026\n          case 'Z':\n            TreeType = new TreeTypeZ();\n            break;\n          default:\n            cout << \"Not Implemented\" << endl;\n            throw(\"Not Implemented\");\n          }\n          TreeTypes_[key] = TreeType;\n        }\n        return TreeType;\n      }\n    private:\n      map<char, TreeType*> TreeTypes_;\n    };\n\n    //The Main method\n    int main()\n    {\n      string forestType = \"ZAZZBAZZBZZAZZ\";\n      const char* chars = forestType.c_str();\n\n      TreeTypeFactory* factory = new TreeTypeFactory;\n\n      // extrinsic state\n      int size = 10;\n\n      // For each TreeType use a flyweight object\n      for (size_t i = 0; i < forestType.length(); i++)\n      {\n        size++;\n        TreeType* TreeType = factory->GetTreeType(chars[i]);\n        TreeType->Display(size);\n      }\n\n      //Clean memory\n      delete factory;\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    class SpecialPower\n    {\n    public:\n      virtual void power() = 0;\n    };\n\n    class Fire : public SpecialPower\n    {\n    public:\n      void power()\n      {\n        cout << \"My power is fire\" << endl;\n      }\n    };\n\n    class Invisibility : public SpecialPower\n    {\n    public:\n      void power()\n      {\n        cout << \"My power is invisibility\" << endl;\n      }\n    };\n\n    class FlyBehaviour\n    {\n    public:\n      virtual void fly() = 0; \n    };\n\n    class FlyWithWings : public FlyBehaviour\n    {\n    public:\n      void fly()\n      {\n        cout << \"I can fly\" << endl;\n      }\n    };\n\n    class FlyNoWay : public FlyBehaviour\n    {\n    public:\n      void fly()\n      {\n        cout << \"I can't fly!\" << endl;\n      }\n    };\n\n    class FlyWithRocket : public FlyBehaviour\n    {\n    public:\n      void fly()\n      {\n        cout << \"I have a jetpack\" << endl;\n      }\n    };\n\n    class Enemy\n    {\n\n    public:\n\n      SpecialPower *specialPower;\n      FlyBehaviour   *flyBehaviour;\n\n      void performPower()\n      {\n        specialPower->power();\n      }\n\n      void setSpecialPower(SpecialPower *qb)\n      {\n        cout << \"Changing special power...\" << endl;\n        specialPower = qb;\n      }\n\n      void performFly()\n      {\n        flyBehaviour->fly();\n      }\n\n      void setFlyBehaviour(FlyBehaviour *fb)\n      {\n        cout << \"Changing fly behaviour...\" << endl;\n        flyBehaviour = fb;\n      }\n\n      void floatAround()\n      {\n        cout << \"I can float.\" << endl;\n      }\n\n      virtual void display() = 0; // Make this an abstract class by having a pure virtual function\n\n    };\n\n    class Dragon : public Enemy\n    {\n    public:\n      Dragon()\n      {\n        specialPower = new Fire();\n        flyBehaviour = new FlyWithWings();\n      }\n\n      void display()\n      {\n        cout << \"I'm a dragon\" << endl;\n      }\n\n    };\n\n    class Soldier : public Enemy\n    {\n    public:\n      Soldier()\n      {\n        specialPower = new Invisibility();\n        flyBehaviour = new FlyNoWay();\n      }\n\n      void display()\n      {\n        cout << \"I'm a soldier\" << endl;\n      }\n    };\n\n    int main()\n    {\n      Enemy *dragon = new Dragon();\n      dragon->display();\n      dragon->floatAround();\n      dragon->performFly();\n      dragon->performPower();\n\n      cout << endl << endl;\n\n      Enemy *soldier = new Soldier();\n      soldier->display();\n      soldier->floatAround();\n      soldier->performFly();\n      soldier->setFlyBehaviour(new FlyWithRocket);\n      soldier->performFly();\n      soldier->performPower();\n      soldier->setSpecialPower(new Fire);\n      soldier->performPower();\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n    class NetworkProtocolCommand\n    {\n    public:\n      virtual void PerformAction() = 0;\n    };\n    class ServerReceiver\n    {\n    public:\n      void Action()\n      {\n        cout << \"Network Protocol Command received\" <<endl;\n\n      }\n    };\n    class ClientInvoker\n    {\n      NetworkProtocolCommand *m_NetworkProtocolCommand;\n\n    public:\n      ClientInvoker(NetworkProtocolCommand *cmd = 0) : m_NetworkProtocolCommand(cmd)\n      {\n      }\n\n      void SetCommad(NetworkProtocolCommand *cmd)\n      {\n        m_NetworkProtocolCommand = cmd;\n      }\n\n      void Invoke()\n      {\n        if (0 != m_NetworkProtocolCommand)\n        {\n          m_NetworkProtocolCommand->PerformAction();\n        }\n      }\n    };\n\n    class MyNetworkProtocolCommand : public NetworkProtocolCommand\n    {\n      ServerReceiver *m_ServerReceiver;\n\n    public:\n      MyNetworkProtocolCommand(ServerReceiver *rcv = 0) : m_ServerReceiver(rcv)\n      {\n      }\n\n      void SetServerReceiver(ServerReceiver *rcv)\n      {\n        m_ServerReceiver = rcv;\n      }\n\n      virtual void PerformAction()\n      {\n        if (0 != m_ServerReceiver)\n        {\n          m_ServerReceiver->Action();\n        }\n      }\n    };\n\n    int main()\n    {\n      ServerReceiver r;\n      MyNetworkProtocolCommand cmd(&r);\n      ClientInvoker caller(&cmd);\n      caller.Invoke();\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #ifndef _ISPEED_H\n    #define _SPEED_H\n\n    class ISpeed\n    {\n      public:\n        virtual void speed() = 0;\n\n    };\n\n    #end\n    #ifndef _ISPECIALPOWER\n    #define _ISPECIALPOWER\n    class ISpecialPower\n    {\n    public:\n      virtual void power() = 0;\n    };\n    #endif\n\n    #ifndef _IENEMY_H\n    #define _IENEMY_H\n\n    #include \"ISpecialPower.h\"\n    #include \"ISpeed.h\"\n\n    class IEnemy\n    {\n\n    public:\n\n      ISpecialPower *specialPower;\n      ISpeed   *speed;\n\n      void performPower()\n      {\n        specialPower->power();\n      }\n\n      void setSpecialPower(ISpecialPower *qb)\n      {\n\n      }\n\n    };\n    #endif\n    #include <iostream>\n    #include \"ISpeed.h\"\n\n    #pragma once\n    class HighSpeed :public ISpeed\n    {\n    public:\n      HighSpeed();\n      ~HighSpeed();\n    };\n\n    #include \"IEnemy.h\"\n\n    class Invisibility;\n    class HighSpeed;\n\n    class Soldier : public IEnemy\n    {\n    public:\n      Soldier()\n      {\n\n      }\n\n    };\n    ```"]