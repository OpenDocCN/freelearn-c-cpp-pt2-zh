["```cpp\n    #define WIN32_LEAN_AND_MEAN\n\n    #include <windows.h>\n    #include <windowsx.h>\n\n    int WINAPI WinMain(HINSTANCE _hInstance,\n      HINSTANCE _hPrevInstance,\n      LPSTR _lpCmdLine,\n      int _iCmdShow)\n    {\n      MessageBox(NULL, L\"My first message\",\n        L\"My first Windows Program\",\n        MB_OK | MB_ICONEXCLAMATION);\n\n      return (0);\n    }\n    ```", "```cpp\n       // This only adds the necessary windows files and not all of them\n    #define WIN32_LEAN_AND_MEAN\n\n    #include <windows.h>   // Include all the windows headers.\n    #include <windowsx.h>  // Include useful macros.\n\n    #define WINDOW_CLASS_NAME L\"WINCLASS1\"\n\n    void GameLoop()\n    {\n      //One frame of game logic occurs here...\n    }\n\n    LRESULT CALLBACK WindowProc(HWND _hwnd,\n      UINT _msg,\n      WPARAM _wparam,\n      LPARAM _lparam)\n    {\n      // This is the main message handler of the system.\n      PAINTSTRUCT ps; // Used in WM_PAINT.\n      HDC hdc;        // Handle to a device context.\n\n      // What is the message?\n      switch (_msg)\n      {\n      case WM_CREATE:\n      {\n                // Do initialization stuff here.\n\n                // Return Success.\n                return (0);\n      }\n        break;\n\n      case WM_PAINT:\n      {\n               // Simply validate the window.\n               hdc = BeginPaint(_hwnd, &ps);\n\n               // You would do all your painting here...\n\n               EndPaint(_hwnd, &ps);\n\n               // Return Success.\n               return (0);\n      }\n        break;\n\n      case WM_DESTROY:\n      {\n                 // Kill the application, this sends a WM_QUIT message.\n                 PostQuitMessage(0);\n\n                 // Return success.\n                 return (0);\n      }\n        break;\n\n      default:break;\n      } // End switch.\n\n      // Process any messages that we did not take care of...\n\n      return (DefWindowProc(_hwnd, _msg, _wparam, _lparam));\n    }\n\n    int WINAPI WinMain(HINSTANCE _hInstance,\n      HINSTANCE _hPrevInstance,\n      LPSTR _lpCmdLine,\n      int _nCmdShow)\n    {\n      WNDCLASSEX winclass; // This will hold the class we create.\n      HWND hwnd;           // Generic window handle.\n      MSG msg;             // Generic message.\n\n      // First fill in the window class structure.\n      winclass.cbSize = sizeof(WNDCLASSEX);\n      winclass.style = CS_DBLCLKS | CS_OWNDC | CS_HREDRAW | CS_VREDRAW;\n      winclass.lpfnWndProc = WindowProc;\n      winclass.cbClsExtra = 0;\n      winclass.cbWndExtra = 0;\n      winclass.hInstance = _hInstance;\n      winclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n      winclass.hCursor = LoadCursor(NULL, IDC_ARROW);\n      winclass.hbrBackground =\n        static_cast<HBRUSH>(GetStockObject(WHITE_BRUSH));\n      winclass.lpszMenuName = NULL;\n      winclass.lpszClassName = WINDOW_CLASS_NAME;\n      winclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n\n      // register the window class\n      if (!RegisterClassEx(&winclass))\n      {\n        return (0);\n      }\n\n      // create the window\n      hwnd = CreateWindowEx(NULL, // Extended style.\n        WINDOW_CLASS_NAME,      // Class.\n        L\"My first Window\",   // Title.\n        WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n        0, 0,                    // Initial x,y.\n        400, 400,                // Initial width, height.\n        NULL,                   // Handle to parent.\n        NULL,                   // Handle to menu.\n        _hInstance,             // Instance of this application.\n        NULL);                  // Extra creation parameters.\n\n      if (!(hwnd))\n      {\n        return (0);\n      }\n\n      // Enter main event loop\n      while (true)\n      {\n        // Test if there is a message in queue, if so get it.\n        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))\n        {\n          // Test if this is a quit.\n          if (msg.message == WM_QUIT)\n          {\n            break;\n          }\n\n          // Translate any accelerator keys.\n          TranslateMessage(&msg);\n          // Send the message to the window proc.\n          DispatchMessage(&msg);\n        }\n\n        // Main game processing goes here.\n        GameLoop(); //One frame of game logic occurs here...\n      }\n\n      // Return to Windows like this...\n      return (static_cast<int>(msg.wParam));\n    }\n    ```", "```cpp\n{\nUINT cbSize;          // Size of this structure.\nUINT style;           // Style flags.\nWNDPROC lpfnWndProc;  // Function pointer to handler.\nint cbClsExtra;       // Extra class info.\nint cbWndExtra;       // Extra window info.\nHANDLE hInstance;     // The instance of the app.\nHICON hIcon;          // The main icon.\nHCURSOR hCursor;      // The cursor for the window.\nHBRUSH hbrBackground; // The Background brush to paint the window.\nLPCTSTR lpszMenuName; // The name of the menu to attach.\nLPCTSTR lpszClassName;// The name of the class itself.\nHICON hIconSm;        // The handle of the small icon.\n} WNDCLASSEX;\n```", "```cpp\n    #define WIN32_LEAN_AND_MEAN\n\n    #include <windows.h>   // Include all the windows headers.\n    #include <windowsx.h>  // Include useful macros.\n    #include \"resource.h\"\n\n    #define WINDOW_CLASS_NAME L\"WINCLASS1\"\n\n    void GameLoop()\n    {\n      //One frame of game logic occurs here...\n    }\n\n    LRESULT CALLBACK WindowProc(HWND _hwnd,\n      UINT _msg,\n      WPARAM _wparam,\n      LPARAM _lparam)\n    {\n      // This is the main message handler of the system.\n      PAINTSTRUCT ps; // Used in WM_PAINT.\n      HDC hdc;        // Handle to a device context.\n\n      // What is the message?\n      switch (_msg)\n      {\n      case WM_CREATE:\n      {\n                // Do initialization stuff here.\n\n                // Return Success.\n                return (0);\n      }\n        break;\n\n      case WM_PAINT:\n      {\n               // Simply validate the window.\n               hdc = BeginPaint(_hwnd, &ps);\n\n               // You would do all your painting here...\n\n               EndPaint(_hwnd, &ps);\n\n               // Return Success.\n               return (0);\n      }\n        break;\n\n      case WM_DESTROY:\n      {\n                 // Kill the application, this sends a WM_QUIT message.\n                 PostQuitMessage(0);\n\n                 // Return success.\n                 return (0);\n      }\n        break;\n\n      default:break;\n      } // End switch.\n\n      // Process any messages that we did not take care of...\n\n      return (DefWindowProc(_hwnd, _msg, _wparam, _lparam));\n    }\n\n    int WINAPI WinMain(HINSTANCE _hInstance,\n      HINSTANCE _hPrevInstance,\n      LPSTR _lpCmdLine,\n      int _nCmdShow)\n    {\n      WNDCLASSEX winclass; // This will hold the class we create.\n      HWND hwnd;           // Generic window handle.\n      MSG msg;             // Generic message.\n\n      HCURSOR hCrosshair = LoadCursor(_hInstance, MAKEINTRESOURCE(IDC_CURSOR2));\n\n      // First fill in the window class structure.\n      winclass.cbSize = sizeof(WNDCLASSEX);\n      winclass.style = CS_DBLCLKS | CS_OWNDC | CS_HREDRAW | CS_VREDRAW;\n      winclass.lpfnWndProc = WindowProc;\n      winclass.cbClsExtra = 0;\n      winclass.cbWndExtra = 0;\n      winclass.hInstance = _hInstance;\n      winclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n      winclass.hCursor = LoadCursor(_hInstance, MAKEINTRESOURCE(IDC_CURSOR2));\n      winclass.hbrBackground =\n        static_cast<HBRUSH>(GetStockObject(WHITE_BRUSH));\n      winclass.lpszMenuName = NULL;\n      winclass.lpszClassName = WINDOW_CLASS_NAME;\n      winclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n\n      // register the window class\n      if (!RegisterClassEx(&winclass))\n      {\n        return (0);\n      }\n\n      // create the window\n      hwnd = CreateWindowEx(NULL, // Extended style.\n        WINDOW_CLASS_NAME,      // Class.\n        L\"Packt Publishing\",   // Title.\n        WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n        0, 0,                    // Initial x,y.\n        400, 400,                // Initial width, height.\n        NULL,                   // Handle to parent.\n        NULL,                   // Handle to menu.\n        _hInstance,             // Instance of this application.\n        NULL);                  // Extra creation parameters.\n\n      if (!(hwnd))\n      {\n        return (0);\n      }\n\n      // Enter main event loop\n      while (true)\n      {\n        // Test if there is a message in queue, if so get it.\n        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))\n        {\n          // Test if this is a quit.\n          if (msg.message == WM_QUIT)\n          {\n            break;\n          }\n\n          // Translate any accelerator keys.\n          TranslateMessage(&msg);\n          // Send the message to the window proc.\n          DispatchMessage(&msg);\n        }\n\n        // Main game processing goes here.\n        GameLoop(); //One frame of game logic occurs here...\n      }\n\n      // Return to Windows like this...\n      return (static_cast<int>(msg.wParam));\n    }\n    ```", "```cpp\n    #define WIN32_LEAN_AND_MEAN \n    #include <windows.h> //Include all the Windows headers.\n    #include <windowsx.h> //Include useful macros.\n    #include <strstream>\n    #include <string>\n    #include <cmath>\n\n    #include \"resource.h\"\n    #include \"mmsystem.h\"\n    //also uses winmm.lib\n\n    using namespace std;\n\n    #define WINDOW_CLASS_NAME \"WINCLASS1\"\n\n    HINSTANCE g_hInstance;\n    //RECT g_rect;\n    const RECT* g_prect;\n\n    POINT g_pos;\n    int g_iMouseX;\n    int g_iMouseY;\n\n    bool IS_LEFT_PRESSED  = 0;\n    bool IS_RIGHT_PRESSED = 0;\n    bool IS_UP_PRESSED    = 0;\n    bool IS_DOWN_PRESSED  = 0;\n\n    bool IS_LMB_PRESSED = 0;\n    bool IS_RMB_PRESSED = 0;\n    bool IS_MMB_PRESSED = 0;\n\n    int LAST_KEYPRESS_ASCII = 0;\n\n    float ang = 0.0f;\n\n    template<typename T>\n    std::string ToString(const T& _value)\n    {\n      std::strstream theStream;\n      theStream << _value << std::ends;\n      return (theStream.str());\n    }\n\n    //GameLoop\n    void GameLoop()\n    {\n      ang += 0.0005f;\n      //One frame of game logic goes here\n    }\n\n    //Event handling (window handle, message handle --\n    LRESULT CALLBACK WindowProc(HWND _hwnd, UINT _msg, WPARAM _wparam, LPARAM _lparam)\n    {\n      //This is the main message handler of the system.\n      PAINTSTRUCT ps; //Used in WM_PAINT\n      HDC hdc;        // Handle to a device context.\n\n          if ((GetAsyncKeyState(VK_LEFT) & 0x8000) == 0x8000)\n          {\n            IS_LEFT_PRESSED = TRUE;\n          }\n          else\n          {\n            IS_LEFT_PRESSED = FALSE;\n          }\n\n          if ((GetAsyncKeyState(VK_RIGHT) & 0x8000) == 0x8000)\n          {\n            IS_RIGHT_PRESSED = TRUE;\n          }\n          else\n          {\n            IS_RIGHT_PRESSED = FALSE;\n          }\n\n          if ((GetAsyncKeyState(VK_UP) & 0x8000) == 0x8000)\n          {\n            IS_UP_PRESSED = TRUE;\n          }\n          else\n          {\n            IS_UP_PRESSED = FALSE;\n          }\n\n          if ((GetAsyncKeyState(VK_DOWN) & 0x8000) == 0x8000)\n          {\n            IS_DOWN_PRESSED = TRUE;\n          }\n          else\n          {\n            IS_DOWN_PRESSED = FALSE;\n          }\n\n      //What is the message?\n      switch(_msg)\n      {\n      case WM_CREATE:\n        {\n          //Do initialisation stuff here.\n          //Return success.\n          return(0);\n        }\n        break;\n\n      case WM_PAINT:\n        {\n          ////Simply validate the window.\n          hdc = BeginPaint(_hwnd, &ps);\n\n          InvalidateRect( _hwnd,\n            g_prect,\n            FALSE);              \n\n          string temp;\n          int iYDrawPos = 15;\n\n          COLORREF red = RGB(255,0,0);\n\n          SetTextColor(hdc, red);\n\n          temp = \"MOUSE X: \";\n          temp += ToString((g_pos.x));\n          while (temp.size() < 14)\n          {\n            temp += \" \";\n          }\n\n          TextOut(hdc,30,iYDrawPos,temp.c_str(), static_cast<int>(temp.size()));\n\n          iYDrawPos+= 13;\n\n          temp = \"MOUSE Y: \";\n          temp += ToString((g_pos.y));\n          while (temp.size() < 14)\n          {\n            temp += \" \";\n          }\n\n          TextOut(hdc,30,iYDrawPos,temp.c_str(), static_cast<int>(temp.size()));\n\n          iYDrawPos+= 13;\n\n          if (IS_LEFT_PRESSED == TRUE)\n          {\n            TextOut(hdc,30,iYDrawPos,\"LEFT IS PRESSED\", 24);\n          }\n          else\n          {\n            TextOut(hdc,30,iYDrawPos,\"LEFT IS NOT PRESSED \", 20);\n          }\n          iYDrawPos+= 13;\n          if (IS_RIGHT_PRESSED == TRUE)\n          {\n            TextOut(hdc,30,iYDrawPos,\"RIGHT IS PRESSED\", 25);\n          }\n          else\n          {\n            TextOut(hdc,30,iYDrawPos,\"RIGHT IS NOT PRESSED \", 21);\n          }\n          iYDrawPos+= 13;\n          if (IS_DOWN_PRESSED == TRUE)\n          {\n            TextOut(hdc,30,iYDrawPos,\"DOWN IS PRESSED\", 24);\n          }\n          else\n          {\n            TextOut(hdc,30,iYDrawPos,\"DOWN IS NOT PRESSED\", 20);\n          }\n          iYDrawPos+= 13;\n          if (IS_UP_PRESSED == TRUE)\n          {\n            TextOut(hdc,30,iYDrawPos,\"UP IS PRESSED\", 22);\n          }\n          else\n          {\n            TextOut(hdc,30,iYDrawPos,\"UP IS NOT PRESSED \", 18);\n          }\n\n    //      TextOut(hdc, static_cast<int>(200 +(sin(ang)*200)), static_cast<int>(200 +(sin(ang)*200))) , \"O\", 1);\n\n          EndPaint(_hwnd, &ps);\n\n          //Return success.\n          return(0);\n        }\n        break;\n\n      case WM_DESTROY:\n        {\n          //Kill the application, this sends a WM_QUIT message.\n          PostQuitMessage(0);\n\n          //Return Sucess.\n          return(0);\n        }\n        break;\n\n      case WM_MOUSEMOVE:\n        {\n          GetCursorPos(&g_pos);\n          // here is your coordinates\n          //int x=pos.x;\n          //int y=pos.y;\n          return(0);\n        }\n      break;\n\n      case WM_COMMAND:\n        {\n\n        }\n\n      default:break;\n      } // End switch.\n\n      //Process any messages we didn't take care of...\n\n      return(DefWindowProc(_hwnd, _msg, _wparam, _lparam));\n    }\n\n    int WINAPI WinMain(HINSTANCE _hInstance, HINSTANCE _hPrevInstance, LPSTR _lpCmdLine, int _nCmdShow)\n    {\n      WNDCLASSEX winclass; ///This will hold the class we create\n      HWND hwnd; //Generic window handle.\n      MSG msg; //Generic message.\n\n      g_hInstance = _hInstance;\n\n      //First fill in the window class structure\n      winclass.cbSize         = sizeof(WNDCLASSEX);\n      winclass.style          = CS_DBLCLKS | CS_OWNDC | CS_HREDRAW | CS_VREDRAW;\n      winclass.lpfnWndProc    = WindowProc;\n      winclass.cbClsExtra     = 0;\n      winclass.cbWndExtra     = 0;\n      winclass.hInstance      = _hInstance;\n      winclass.hIcon          = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON1));\n      winclass.hCursor        = NULL;\n      winclass.hbrBackground  = static_cast<HBRUSH>(GetStockObject(WHITE_BRUSH));\n      winclass.lpszMenuName   = MAKEINTRESOURCE(IDR_MENU1);\n      winclass.lpszClassName  = WINDOW_CLASS_NAME;\n      winclass.hIconSm        = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON1));\n\n      //Register the window class\n      if (!RegisterClassEx(&winclass))\n      { //perhaps use log manager here\n        return(0);\n      }\n\n      //Create the window\n      if (!(hwnd = CreateWindowEx(NULL, //Extended style.\n                    WINDOW_CLASS_NAME, //Class\n                    \"Recipe4\", //Title\n                    WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n                    400,300, //Initial X, Y\n                    400,400, //Initial width, height.\n                    NULL, //handle to parent.\n                    NULL, //handle to menu\n                    _hInstance, //Instance of this application\n                    NULL))) //Extra creation parameters\n      {\n        return (0);\n      }\n\n      RECT rect;  \n      rect.left = 0;\n      rect.right = 400;\n      rect.top = 0;\n      rect.bottom = 400;\n      g_prect = &rect;\n\n      //Enter main event loop\n      while (TRUE)\n      {\n        //Test if there is a message in queue, if so get it.\n        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))\n        {\n          //Test if this is a quit\n          if (msg.message == WM_QUIT)\n          {\n            break;\n          }\n\n          //Translate any accelerator keys\n          TranslateMessage(&msg);\n          //Send the message to the window proc.\n          DispatchMessage(&msg);\n        }\n\n        //Main game processing goes here.\n        GameLoop(); //One frame of game logic goes here...\n      }\n      //Return to Windows like this...\n      return(static_cast<int>(msg.wParam));\n    }\n    ```", "```cpp\n    #define WIN32_LEAN_AND_MEAN\n\n    #include <windows.h>   // Include all the windows headers.\n    #include <windowsx.h>  // Include useful macros.\n    #include \"resource.h\"\n\n    #define WINDOW_CLASS_NAME L\"WINCLASS1\"\n\n    void GameLoop()\n    {\n      //One frame of game logic occurs here...\n    }\n\n    LRESULT CALLBACK WindowProc(HWND _hwnd,\n      UINT _msg,\n      WPARAM _wparam,\n      LPARAM _lparam)\n    {\n      // This is the main message handler of the system.\n      PAINTSTRUCT ps; // Used in WM_PAINT.\n      HDC hdc;        // Handle to a device context.\n\n      // What is the message?\n      switch (_msg)\n      {\n      case WM_CREATE:\n      {\n                // Do initialization stuff here.\n\n                // Return Success.\n                return (0);\n      }\n        break;\n\n      case WM_PAINT:\n      {\n               // Simply validate the window.\n               hdc = BeginPaint(_hwnd, &ps);\n\n               // You would do all your painting here...\n\n               EndPaint(_hwnd, &ps);\n\n               // Return Success.\n               return (0);\n      }\n        break;\n\n      case WM_DESTROY:\n      {\n                 // Kill the application, this sends a WM_QUIT message.\n                 PostQuitMessage(0);\n\n                 // Return success.\n                 return (0);\n      }\n        break;\n\n      default:break;\n      } // End switch.\n\n      // Process any messages that we did not take care of...\n\n      return (DefWindowProc(_hwnd, _msg, _wparam, _lparam));\n    }\n\n    int WINAPI WinMain(HINSTANCE _hInstance,\n      HINSTANCE _hPrevInstance,\n      LPSTR _lpCmdLine,\n      int _nCmdShow)\n    {\n      WNDCLASSEX winclass; // This will hold the class we create.\n      HWND hwnd;           // Generic window handle.\n      MSG msg;             // Generic message.\n\n      HCURSOR hCrosshair = LoadCursor(_hInstance, MAKEINTRESOURCE(IDC_CURSOR2));\n\n      // First fill in the window class structure.\n      winclass.cbSize = sizeof(WNDCLASSEX);\n      winclass.style = CS_DBLCLKS | CS_OWNDC | CS_HREDRAW | CS_VREDRAW;\n      winclass.lpfnWndProc = WindowProc;\n      winclass.cbClsExtra = 0;\n      winclass.cbWndExtra = 0;\n      winclass.hInstance = _hInstance;\n      winclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n      winclass.hCursor = LoadCursor(_hInstance, MAKEINTRESOURCE(IDC_CURSOR2));\n      winclass.hbrBackground =\n        static_cast<HBRUSH>(GetStockObject(WHITE_BRUSH));\n      winclass.lpszMenuName = NULL;\n      winclass.lpszClassName = WINDOW_CLASS_NAME;\n      winclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n\n      // register the window class\n      if (!RegisterClassEx(&winclass))\n      {\n        return (0);\n      }\n\n      // create the window\n      hwnd = CreateWindowEx(NULL, // Extended style.\n        WINDOW_CLASS_NAME,      // Class.\n        L\"PacktUp Publishing\",   // Title.\n        WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n        0, 0,                    // Initial x,y.\n        400, 400,                // Initial width, height.\n        NULL,                   // Handle to parent.\n        NULL,                   // Handle to menu.\n        _hInstance,             // Instance of this application.\n        NULL);                  // Extra creation parameters.\n\n      if (!(hwnd))\n      {\n        return (0);\n      }\n\n      // Enter main event loop\n      while (true)\n      {\n        // Test if there is a message in queue, if so get it.\n        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))\n        {\n          // Test if this is a quit.\n          if (msg.message == WM_QUIT)\n          {\n            break;\n          }\n\n          // Translate any accelerator keys.\n          TranslateMessage(&msg);\n          // Send the message to the window proc.\n          DispatchMessage(&msg);\n        }\n\n        // Main game processing goes here.\n        GameLoop(); //One frame of game logic occurs here...\n      }\n\n      // Return to Windows like this...\n      return (static_cast<int>(msg.wParam));\n    }\n    ```", "```cpp\nwinclass.hCursor = LoadCursor(_hInstance, MAKEINTRESOURCE(IDC_CURSOR2))\n```", "```cpp\n    #define WIN32_LEAN_AND_MEAN\n\n    #include <windows.h>   // Include all the windows headers.\n    #include <windowsx.h>  // Include useful macros.\n    #include \"resource.h\"\n    #define WINDOW_CLASS_NAME L\"WINCLASS1\"\n\n    void GameLoop()\n    {\n      //One frame of game logic occurs here...\n    }\n\n    BOOL CALLBACK AboutDlgProc(HWND hDlg, UINT msg, WPARAM wparam, LPARAM lparam)\n    {\n      switch (msg)\n      {\n        case WM_INITDIALOG:\n          break;\n        case WM_COMMAND:\n          switch (LOWORD(wparam))\n          {\n          case IDOK:\n            EndDialog(\n              hDlg, //Handle to the dialog to end.\n              0);   //Return code.\n            break;\n          case IDCANCEL:\n            EndDialog(\n              hDlg, //Handle to the dialog to end.\n              0);   //Return code.\n            break;\n          default:\n            break;\n          }\n\n      }\n\n      return true;\n    }\n\n    LRESULT CALLBACK WindowProc(HWND _hwnd,\n      UINT _msg,\n      WPARAM _wparam,\n      LPARAM _lparam)\n    {\n      // This is the main message handler of the system.\n      PAINTSTRUCT ps; // Used in WM_PAINT.\n      HDC hdc;        // Handle to a device context.\n\n      // What is the message?\n      switch (_msg)\n      {\n      case WM_CREATE:\n      {\n                // Do initialization stuff here.\n\n                // Return Success.\n                return (0);\n      }\n        break;\n\n      case WM_PAINT:\n      {\n               // Simply validate the window.\n               hdc = BeginPaint(_hwnd, &ps);\n\n               // You would do all your painting here...\n\n               EndPaint(_hwnd, &ps);\n\n               // Return Success.\n               return (0);\n      }\n        break;\n\n      case WM_DESTROY:\n      {\n                 // Kill the application, this sends a WM_QUIT message.\n                 PostQuitMessage(0);\n\n                 // Return success.\n                 return (0);\n      }\n        break;\n\n      default:break;\n      } // End switch.\n\n      // Process any messages that we did not take care of...\n\n      return (DefWindowProc(_hwnd, _msg, _wparam, _lparam));\n    }\n\n    int WINAPI WinMain(HINSTANCE _hInstance,\n      HINSTANCE _hPrevInstance,\n      LPSTR _lpCmdLine,\n      int _nCmdShow)\n    {\n      WNDCLASSEX winclass; // This will hold the class we create.\n      HWND hwnd;           // Generic window handle.\n      MSG msg;             // Generic message.\n\n      // First fill in the window class structure.\n      winclass.cbSize = sizeof(WNDCLASSEX);\n      winclass.style = CS_DBLCLKS | CS_OWNDC | CS_HREDRAW | CS_VREDRAW;\n      winclass.lpfnWndProc = WindowProc;\n      winclass.cbClsExtra = 0;\n      winclass.cbWndExtra = 0;\n      winclass.hInstance = _hInstance;\n      winclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);\n      winclass.hCursor = LoadCursor(NULL, IDC_ARROW);\n      winclass.hbrBackground =\n        static_cast<HBRUSH>(GetStockObject(BLACK_BRUSH));\n      winclass.lpszMenuName = NULL;\n      winclass.lpszClassName = WINDOW_CLASS_NAME;\n      winclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);\n\n      // register the window class\n      if (!RegisterClassEx(&winclass))\n      {\n        return (0);\n      }\n\n      // create the window\n      hwnd = CreateWindowEx(NULL, // Extended style.\n        WINDOW_CLASS_NAME,      // Class.\n        L\"My first Window\",   // Title.\n        WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n        0, 0,                    // Initial x,y.\n        1024, 980,                // Initial width, height.\n        NULL,                   // Handle to parent.\n        NULL,                   // Handle to menu.\n        _hInstance,             // Instance of this application.\n        NULL);                  // Extra creation parameters.\n\n      if (!(hwnd))\n      {\n        return (0);\n      }\n\n      DialogBox(_hInstance, MAKEINTRESOURCE(IDD_DIALOG1), hwnd, AboutDlgProc);\n\n      // Enter main event loop\n      while (true)\n      {\n        // Test if there is a message in queue, if so get it.\n        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))\n        {\n          // Test if this is a quit.\n          if (msg.message == WM_QUIT)\n          {\n            break;\n          }\n\n          // Translate any accelerator keys.\n          TranslateMessage(&msg);\n          // Send the message to the window proc.\n          DispatchMessage(&msg);\n        }\n\n        // Main game processing goes here.\n        GameLoop(); //One frame of game logic occurs here...\n      }\n\n      // Return to Windows like this...\n      return (static_cast<int>(msg.wParam));\n    }\n    ```", "```cpp\nDialogBox(_hInstance, MAKEINTRESOURCE(IDD_DIALOG1), hwnd, AboutDlgProc)\n```", "```cpp\n    #pragma once\n\n    #if !defined(__BACKBUFFER_H__)\n    #define __BACKBUFFER_H__\n\n    // Library Includes\n    #include <Windows.h>\n\n    // Local Includes\n\n    // Types\n\n    // Constants\n\n    // Prototypes\n    class CBackBuffer\n    {\n      // Member Functions\n    public:\n      CBackBuffer();\n      ~CBackBuffer();\n\n      bool Initialise(HWND _hWnd, int _iWidth, int _iHeight);\n\n      HDC GetBFDC() const;\n\n      int GetHeight() const;\n      int GetWidth() const;\n\n      void Clear();\n      void Present();\n\n    protected:\n\n    private:\n      CBackBuffer(const CBackBuffer& _kr);\n      CBackBuffer& operator= (const CBackBuffer& _kr);\n\n      // Member Variables\n    public:\n\n    protected:\n      HWND m_hWnd;\n      HDC m_hDC;\n      HBITMAP m_hSurface;\n      HBITMAP m_hOldObject;\n      int m_iWidth;\n      int m_iHeight;\n\n    private:\n\n    };\n\n    #endif    // __BACKBUFFER_H__\n    ```", "```cpp\n    // Library Includes\n\n    // Local Includes\n\n    // This include\n    #include \"BackBuffer.h\"\n\n    // Static Variables\n\n    // Static Function Prototypes\n\n    // Implementation\n\n    CBackBuffer::CBackBuffer()\n    : m_hWnd(0)\n    , m_hDC(0)\n    , m_hSurface(0)\n    , m_hOldObject(0)\n    , m_iWidth(0)\n    , m_iHeight(0)\n    {\n\n    }\n\n    CBackBuffer::~CBackBuffer()\n    {\n      SelectObject(m_hDC, m_hOldObject);\n\n      DeleteObject(m_hSurface);\n      DeleteObject(m_hDC);\n    }\n\n    bool\n    CBackBuffer::Initialise(HWND _hWnd, int _iWidth, int _iHeight)\n    {\n      m_hWnd = _hWnd;\n\n      m_iWidth = _iWidth;\n      m_iHeight = _iHeight;\n\n      HDC hWindowDC = ::GetDC(m_hWnd);\n\n      m_hDC = CreateCompatibleDC(hWindowDC);\n\n      m_hSurface = CreateCompatibleBitmap(hWindowDC, m_iWidth, m_iHeight);\n\n      ReleaseDC(m_hWnd, hWindowDC);\n\n      m_hOldObject = static_cast<HBITMAP>(SelectObject(m_hDC, m_hSurface));\n\n      HBRUSH brushWhite = static_cast<HBRUSH>(GetStockObject(LTGRAY_BRUSH));\n      HBRUSH oldBrush = static_cast<HBRUSH>(SelectObject(m_hDC, brushWhite));\n\n      Rectangle(m_hDC, 0, 0, m_iWidth, m_iHeight);\n\n      SelectObject(m_hDC, oldBrush);\n\n      return (true);\n    }\n\n    void\n    CBackBuffer::Clear()\n    {\n      HBRUSH hOldBrush = static_cast<HBRUSH>(SelectObject(GetBFDC(), GetStockObject(LTGRAY_BRUSH)));\n\n      Rectangle(GetBFDC(), 0, 0, GetWidth(), GetHeight());\n\n      SelectObject(GetBFDC(), hOldBrush);\n    }\n\n    HDC\n    CBackBuffer::GetBFDC() const\n    {\n      return (m_hDC);\n    }\n\n    int\n    CBackBuffer::GetWidth() const\n    {\n      return (m_iWidth);\n    }\n\n    int\n    CBackBuffer::GetHeight() const\n    {\n      return (m_iHeight);\n    }\n\n    void\n    CBackBuffer::Present()\n    {\n      HDC hWndDC = ::GetDC(m_hWnd);\n\n      BitBlt(hWndDC, 0, 0, m_iWidth, m_iHeight, m_hDC, 0, 0, SRCCOPY);\n\n      ReleaseDC(m_hWnd, hWndDC);\n    }\n    ```", "```cpp\n    #pragma once\n\n    #if !defined(__CLOCK_H__)\n    #define __CLOCK_H__\n\n    // Library Includes\n\n    // Local Includes\n\n    // Types\n\n    // Constants\n\n    // Prototypes\n    class CClock\n    {\n      // Member Functions\n    public:\n      CClock();\n      ~CClock();\n\n      bool Initialise();\n\n      void Process();\n\n      float GetDeltaTick();\n\n    protected:\n\n    private:\n      CClock(const CClock& _kr);\n      CClock& operator= (const CClock& _kr);\n\n      // Member Variables\n    public:\n\n    protected:\n      float m_fTimeElapsed;\n      float m_fDeltaTime;\n      float m_fLastTime;\n      float m_fCurrentTime;\n\n    private:\n\n    };\n\n    #endif    // __CLOCK_H__\n    ```", "```cpp\n    // Library Includes\n    #include <windows.h>\n\n    // Local Includes\n    #include \"Clock.h\"\n\n    // Static Variables\n\n    // Static Function Prototypes\n\n    // Implementation\n\n    CClock::CClock()\n    : m_fTimeElapsed(0.0f)\n    , m_fDeltaTime(0.0f)\n    , m_fLastTime(0.0f)\n    , m_fCurrentTime(0.0f)\n    {\n\n    }\n\n    CClock::~CClock()\n    {\n\n    }\n\n    bool\n    CClock::Initialise()\n    {\n      return (true);\n    }\n\n    void\n    CClock::Process()\n    {\n      m_fLastTime = m_fCurrentTime;\n\n      m_fCurrentTime = static_cast<float>(timeGetTime());\n\n      if (m_fLastTime == 0.0f)\n      {\n        m_fLastTime = m_fCurrentTime;\n      }\n\n      m_fDeltaTime = m_fCurrentTime - m_fLastTime;\n\n      m_fTimeElapsed += m_fDeltaTime;\n    }\n\n    float\n    CClock::GetDeltaTick()\n    {\n      return (m_fDeltaTime / 1000.0f);\n    }\n    ```", "```cpp\n    #pragma once\n\n    #if !defined(__GAME_H__)\n    #define __GAME_H__\n\n    // Library Includes\n    #include <windows.h>\n\n    // Local Includes\n    #include \"clock.h\"\n\n    // Types\n\n    // Constants\n\n    // Prototypes\n    class CBackBuffer;\n\n    class CGame\n    {\n      // Member Functions\n    public:\n      ~CGame();\n\n      bool Initialise(HINSTANCE _hInstance, HWND _hWnd, int _iWidth, int _iHeight);\n\n      void Draw();\n      void Process(float _fDeltaTick);\n\n      void ExecuteOneFrame();\n\n      CBackBuffer* GetBackBuffer();\n      HINSTANCE GetAppInstance();\n      HWND GetWindow();\n\n      // Singleton Methods\n      static CGame& GetInstance();\n      static void DestroyInstance();\n\n    protected:\n\n    private:\n      CGame();\n      CGame(const CGame& _kr);\n      CGame& operator= (const CGame& _kr);\n\n      // Member Variables\n    public:\n\n    protected:\n      CClock* m_pClock;\n\n      CBackBuffer* m_pBackBuffer;\n\n      //Application data\n      HINSTANCE m_hApplicationInstance;\n      HWND m_hMainWindow;\n\n      // Singleton Instance\n      static CGame* s_pGame;\n\n    private:\n\n    };\n\n    #endif    // __GAME_H__\n    ```", "```cpp\n    // Library Includes\n\n    // Local Includes\n    #include \"Clock.h\"\n    #include \"BackBuffer.h\"\n    #include \"Utilities.h\"\n\n    // This Include\n    #include \"Game.h\"\n\n    // Static Variables\n    CGame* CGame::s_pGame = 0;\n\n    // Static Function Prototypes\n\n    // Implementation\n\n    CGame::CGame()\n    : m_pClock(0)\n    , m_hApplicationInstance(0)\n    , m_hMainWindow(0)\n    , m_pBackBuffer(0)\n    {\n\n    }\n\n    CGame::~CGame()\n    {\n      delete m_pBackBuffer;\n      m_pBackBuffer = 0;\n\n      delete m_pClock;\n      m_pClock = 0;\n    }\n\n    bool\n    CGame::Initialise(HINSTANCE _hInstance, HWND _hWnd, int _iWidth, int _iHeight)\n    {\n      m_hApplicationInstance = _hInstance;\n      m_hMainWindow = _hWnd;\n\n      m_pClock = new CClock();\n      VALIDATE(m_pClock->Initialise());\n      m_pClock->Process();\n\n      m_pBackBuffer = new CBackBuffer();\n      VALIDATE(m_pBackBuffer->Initialise(_hWnd, _iWidth, _iHeight));\n\n      ShowCursor(false);\n\n      return (true);\n    }\n\n    void\n    CGame::Draw()\n    {\n      m_pBackBuffer->Clear();\n\n      // Do all the game's drawing here...\n\n      m_pBackBuffer->Present();\n    }\n\n    void\n    CGame::Process(float _fDeltaTick)\n    {\n      // Process all the game's logic here.\n    }\n\n    void\n    CGame::ExecuteOneFrame()\n    {\n      float fDT = m_pClock->GetDeltaTick();\n\n      Process(fDT);\n      Draw();\n\n      m_pClock->Process();\n\n      Sleep(1);\n    }\n\n    CGame&\n    CGame::GetInstance()\n    {\n      if (s_pGame == 0)\n      {\n        s_pGame = new CGame();\n      }\n\n      return (*s_pGame);\n    }\n\n    void\n    CGame::DestroyInstance()\n    {\n      delete s_pGame;\n      s_pGame = 0;\n    }\n\n    CBackBuffer*\n    CGame::GetBackBuffer()\n    {\n      return (m_pBackBuffer);\n    }\n\n    HINSTANCE\n    CGame::GetAppInstance()\n    {\n      return (m_hApplicationInstance);\n    }\n\n    HWND\n    CGame::GetWindow()\n    {\n      return (m_hMainWindow);\n    }\n    ```", "```cpp\n    #pragma once\n\n    #if !defined(__SPRITE_H__)\n    #define __SPRITE_H__\n\n    // Library Includes\n    #include \"windows.h\"\n\n    // Local Includes\n\n    // Types\n\n    // Constants\n\n    // Prototypes\n    class CSprite\n    {\n      // Member Functions\n    public:\n      CSprite();\n      ~CSprite();\n\n      bool Initialise(int _iResourceID, int _iMaskResourceID);\n\n      void Draw();\n      void Process(float _fDeltaTick);\n\n      int GetWidth() const;\n      int GetHeight() const;\n\n      int GetX() const;\n      int GetY() const;\n      void SetX(int _i);\n      void SetY(int _i);\n\n      void TranslateRelative(int _iX, int _iY);\n      void TranslateAbsolute(int _iX, int _iY);\n\n    protected:\n\n    private:\n      CSprite(const CSprite& _kr);\n      CSprite& operator= (const CSprite& _kr);\n\n      // Member Variables\n    public:\n\n    protected:\n      //Center handle\n      int m_iX;\n      int m_iY;\n\n      HBITMAP m_hSprite;\n      HBITMAP m_hMask;\n\n      BITMAP m_bitmapSprite;\n      BITMAP m_bitmapMask;\n\n      static HDC s_hSharedSpriteDC;\n      static int s_iRefCount;\n\n    private:\n\n    };\n\n    #endif    // __SPRITE_H__\n    ```", "```cpp\n    // Library Includes\n\n    // Local Includes\n    #include \"resource.h\"\n    #include \"Game.h\"\n    #include \"BackBuffer.h\"\n    #include \"Utilities.h\"\n\n    // This include\n    #include \"Sprite.h\"\n\n    // Static Variables\n    HDC CSprite::s_hSharedSpriteDC = 0;\n    int CSprite::s_iRefCount = 0;\n\n    // Static Function Prototypes\n\n    // Implementation\n\n    CSprite::CSprite()\n    : m_iX(0)\n    , m_iY(0)\n    {\n      ++s_iRefCount;\n    }\n\n    CSprite::~CSprite()\n    {\n      DeleteObject(m_hSprite);\n      DeleteObject(m_hMask);\n\n      --s_iRefCount;\n\n      if (s_iRefCount == 0)\n      {\n        DeleteDC(s_hSharedSpriteDC);\n        s_hSharedSpriteDC = 0;\n      }\n    }\n\n    bool\n    CSprite::Initialise(int _iSpriteResourceID, int _iMaskResourceID)\n    {\n      HINSTANCE hInstance = CGame::GetInstance().GetAppInstance();\n\n      if (!s_hSharedSpriteDC)\n      {\n        s_hSharedSpriteDC = CreateCompatibleDC(NULL);\n      }\n\n      m_hSprite = LoadBitmap(hInstance, MAKEINTRESOURCE(_iSpriteResourceID));\n      VALIDATE(m_hSprite);\n      m_hMask = LoadBitmap(hInstance, MAKEINTRESOURCE(_iMaskResourceID));\n      VALIDATE(m_hMask);\n\n      GetObject(m_hSprite, sizeof(BITMAP), &m_bitmapSprite);\n      GetObject(m_hMask, sizeof(BITMAP), &m_bitmapMask);\n\n      return (true);\n    }\n\n    void\n    CSprite::Draw()\n    {\n      int iW = GetWidth();\n      int iH = GetHeight();\n\n      int iX = m_iX - (iW / 2);\n      int iY = m_iY - (iH / 2);\n\n      CBackBuffer* pBackBuffer = CGame::GetInstance().GetBackBuffer();\n\n      HGDIOBJ hOldObj = SelectObject(s_hSharedSpriteDC, m_hMask);\n\n      BitBlt(pBackBuffer->GetBFDC(), iX, iY, iW, iH, s_hSharedSpriteDC, 0, 0, SRCAND);\n\n      SelectObject(s_hSharedSpriteDC, m_hSprite);\n\n      BitBlt(pBackBuffer->GetBFDC(), iX, iY, iW, iH, s_hSharedSpriteDC, 0, 0, SRCPAINT);\n\n      SelectObject(s_hSharedSpriteDC, hOldObj);\n    }\n\n    void\n    CSprite::Process(float _fDeltaTick)\n    {\n\n    }\n\n    int\n    CSprite::GetWidth() const\n    {\n      return (m_bitmapSprite.bmWidth);\n    }\n\n    int\n    CSprite::GetHeight() const\n    {\n      return (m_bitmapSprite.bmHeight);\n    }\n\n    int\n    CSprite::GetX() const\n    {\n      return (m_iX);\n    }\n\n    int\n    CSprite::GetY() const\n    {\n      return (m_iY);\n    }\n\n    void\n    CSprite::SetX(int _i)\n    {\n      m_iX = _i;\n    }\n\n    void\n    CSprite::SetY(int _i)\n    {\n      m_iY = _i;\n    }\n\n    void\n    CSprite::TranslateRelative(int _iX, int _iY)\n    {\n      m_iX += _iX;\n      m_iY += _iY;\n    }\n\n    void\n    CSprite::TranslateAbsolute(int _iX, int _iY)\n    {\n      m_iX = _iX;\n      m_iY = _iY;\n    }\n    ```", "```cpp\n    // Library Includes\n\n    // Local Includes\n    #include \"resource.h\"\n    #include \"Game.h\"\n    #include \"BackBuffer.h\"\n    #include \"Utilities.h\"\n\n    // This include\n    #include \"Sprite.h\"\n\n    // Static Variables\n    HDC CSprite::s_hSharedSpriteDC = 0;\n    int CSprite::s_iRefCount = 0;\n\n    // Static Function Prototypes\n\n    // Implementation\n\n    CSprite::CSprite()\n    : m_iX(0)\n    , m_iY(0)\n    {\n      ++s_iRefCount;\n    }\n\n    CSprite::~CSprite()\n    {\n      DeleteObject(m_hSprite);\n      DeleteObject(m_hMask);\n\n      --s_iRefCount;\n\n      if (s_iRefCount == 0)\n      {\n        DeleteDC(s_hSharedSpriteDC);\n        s_hSharedSpriteDC = 0;\n      }\n    }\n\n    bool\n    CSprite::Initialise(int _iSpriteResourceID, int _iMaskResourceID)\n    {\n      HINSTANCE hInstance = CGame::GetInstance().GetAppInstance();\n\n      if (!s_hSharedSpriteDC)\n      {\n        s_hSharedSpriteDC = CreateCompatibleDC(NULL);\n      }\n\n      m_hSprite = LoadBitmap(hInstance, MAKEINTRESOURCE(_iSpriteResourceID));\n      VALIDATE(m_hSprite);\n      m_hMask = LoadBitmap(hInstance, MAKEINTRESOURCE(_iMaskResourceID));\n      VALIDATE(m_hMask);\n\n      GetObject(m_hSprite, sizeof(BITMAP), &m_bitmapSprite);\n      GetObject(m_hMask, sizeof(BITMAP), &m_bitmapMask);\n\n      return (true);\n    }\n\n    void\n    CSprite::Draw()\n    {\n      int iW = GetWidth();\n      int iH = GetHeight();\n\n      int iX = m_iX - (iW / 2);\n      int iY = m_iY - (iH / 2);\n\n      CBackBuffer* pBackBuffer = CGame::GetInstance().GetBackBuffer();\n\n      HGDIOBJ hOldObj = SelectObject(s_hSharedSpriteDC, m_hMask);\n\n      BitBlt(pBackBuffer->GetBFDC(), iX, iY, iW, iH, s_hSharedSpriteDC, 0, 0, SRCAND);\n\n      SelectObject(s_hSharedSpriteDC, m_hSprite);\n\n      BitBlt(pBackBuffer->GetBFDC(), iX, iY, iW, iH, s_hSharedSpriteDC, 0, 0, SRCPAINT);\n\n      SelectObject(s_hSharedSpriteDC, hOldObj);\n    }\n\n    void\n    CSprite::Process(float _fDeltaTick)\n    {\n\n    }\n\n    int\n    CSprite::GetWidth() const\n    {\n      return (m_bitmapSprite.bmWidth);\n    }\n\n    int\n    CSprite::GetHeight() const\n    {\n      return (m_bitmapSprite.bmHeight);\n    }\n\n    int\n    CSprite::GetX() const\n    {\n      return (m_iX);\n    }\n\n    int\n    CSprite::GetY() const\n    {\n      return (m_iY);\n    }\n\n    void\n    CSprite::SetX(int _i)\n    {\n      m_iX = _i;\n    }\n\n    void\n    CSprite::SetY(int _i)\n    {\n      m_iY = _i;\n    }\n\n    void\n    CSprite::TranslateRelative(int _iX, int _iY)\n    {\n      m_iX += _iX;\n      m_iY += _iY;\n    }\n\n    void\n    CSprite::TranslateAbsolute(int _iX, int _iY)\n    {\n      m_iX = _iX;\n      m_iY = _iY;\n    }\n    ```", "```cpp\n    // This include\n    #include \"AnimatedSprite.h\"\n\n    // Static Variables\n\n    // Static Function Prototypes\n\n    // Implementation\n\n    CAnimatedSprite::CAnimatedSprite()\n    : m_fFrameSpeed(0.0f)\n    , m_fTimeElapsed(0.0f)\n    , m_iCurrentSprite(0)\n    {\n\n    }\n\n    CAnimatedSprite::~CAnimatedSprite()\n    {\n      Deinitialise();\n    }\n\n    bool\n    CAnimatedSprite::Deinitialise()\n    {\n      return (CSprite::Deinitialise());\n    }\n\n    bool\n    CAnimatedSprite::Initialise(int _iSpriteResourceID, int _iMaskResourceID)\n    {\n      return (CSprite::Initialise(_iSpriteResourceID, _iMaskResourceID));\n    }\n\n    void\n    CAnimatedSprite::Draw()\n    {\n      int iTopLeftX = m_vectorFrames[m_iCurrentSprite];\n      int iTopLeftY = 0;\n\n      int iW = GetFrameWidth();\n      int iH = GetHeight();\n\n      int iX = m_iX - (iW / 2);\n      int iY = m_iY - (iH / 2);\n\n      HDC hSpriteDC = hSharedSpriteDC;\n\n      HGDIOBJ hOldObj = SelectObject(hSpriteDC, m_hMask);\n\n      BitBlt(CGame::GetInstance().GetBackBuffer()->GetBFDC(), iX, iY, iW, iH, hSpriteDC, iTopLeftX, iTopLeftY, SRCAND);\n\n      SelectObject(hSpriteDC, m_hSprite);\n\n      BitBlt(CGame::GetInstance().GetBackBuffer()->GetBFDC(), iX, iY, iW, iH, hSpriteDC, iTopLeftX, iTopLeftY, SRCPAINT);\n\n      SelectObject(hSpriteDC, hOldObj);\n    }\n\n    void\n    CAnimatedSprite::Process(float _fDeltaTick)\n    {\n      m_fTimeElapsed += _fDeltaTick;\n\n      if (m_fTimeElapsed >= m_fFrameSpeed &&\n        m_fFrameSpeed != 0.0f)\n      {\n        m_fTimeElapsed = 0.0f;\n        ++m_iCurrentSprite;\n\n        if (m_iCurrentSprite >= m_vectorFrames.size())\n        {\n          m_iCurrentSprite = 0;\n        }\n      }\n\n      CSprite::Process(_fDeltaTick);\n    }\n\n    void\n    CAnimatedSprite::AddFrame(int _iX)\n    {\n      m_vectorFrames.push_back(_iX);\n    }\n\n    void\n    CAnimatedSprite::SetSpeed(float _fSpeed)\n    {\n      m_fFrameSpeed = _fSpeed;\n    }\n\n    void\n    CAnimatedSprite::SetWidth(int _iW)\n    {\n      m_iFrameWidth = _iW;\n    }\n\n    int\n    CAnimatedSprite::GetFrameWidth()\n    {\n      return (m_iFrameWidth);\n    }\n    ```"]