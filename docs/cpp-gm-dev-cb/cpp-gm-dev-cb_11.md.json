["```cpp\nusing namespace xmls;\n\nclass LastUsedDocument: public Serializable\n{\npublic:\n  LastUsedDocument();\n  xString Name;\n  xString Path;\n  xInt Size;\n};\n\nclass DatabaseLogin: public Serializable\n{\npublic:\n  DatabaseLogin();\n  xString HostName;\n  xInt Port;\n  xString User;\n  xString Password;\n};\n\nclass SerialisationData: public Serializable\n{\npublic:\n  SerialisationData();\n  xString Data1;\n  xString Data2;\n  xString Data3;\n  xInt Data4;\n  xInt Data5;\n  xBool Data6;\n  xBool Data7;\n  DatabaseLogin Login;\n  Collection<LastUsedDocument> LastUsedDocuments;\n};\n\nLastUsedDocument::LastUsedDocument()\n{\n  setClassName(\"LastUsedDocument\");\n  Register(\"Name\", &Name);\n  Register(\"Path\", &Path);\n  Register(\"Size\", &Size);\n};\n\nDatabaseLogin::DatabaseLogin()\n{\n  setClassName(\"DatabaseLogin\");\n  Register(\"HostName\", &HostName);\n  Register(\"Port\", &Port);\n  Register(\"User\", &User);\n  Register(\"Password\", &Password);\n};\n\nSerialisationData::SerialisationData()\n{\n  setClassName(\"SerialisationData\");\n  Register(\"Data1\", &Data1);\n  Register(\"Data2\", &Data2);\n  Register(\"Data3\", &Data3);\n  Register(\"Data4\", &Data4);\n  Register(\"Data5\", &Data5);\n  Register(\"Data6\", &Data6);\n  Register(\"Data7\", &Data7);\n  Register(\"Login\", &Login);\n  Register(\"LastUsedDocuments\", &LastUsedDocuments);\n  setVersion(\"2.1\");\n};\n\nint main()\n{\n  // Creating the Datas object\n  cout << \"Creating object...\" << endl;\n  SerialisationData *Datas=new SerialisationData;\n  Datas->Data1=\"This is the first string\";\n  Datas->Data2=\"This is the second random data\";\n  Datas->Data3=\"3rd data\";\n  Datas->Data4=1234;\n  Datas->Data5=5678;\n  Datas->Data6=false;\n  Datas->Data7=true;\n  Datas->Login.HostName=\"aws.localserver.something\";\n  Datas->Login.Port=2000;\n  Datas->Login.User=\"packt.pub\";\n  Datas->Login.Password=\"PacktPassword\";\n\n  for (int docNum=1; docNum<=10; docNum++)\n  {\n    LastUsedDocument *doc = Datas->LastUsedDocuments.newElement();\n    std::stringstream docName;\n    docName << \"Document #\" << docNum;\n    doc->Name = docName.str();\n    doc->Path = \"{FILEPATH}\"; // Set Placeholder for search/replace\n    doc->setVersion(\"1.1\");\n  }\n\n  cout << \"OK\" << endl;\n\n  // Serialize the Datas object\n  cout << \"Serializing object... \" << endl;\n  string xmlData = Datas->toXML();\n  cout << \"OK\" << endl << endl;\n  cout << \"Result:\" << endl;\n  cout << xmlData << endl << endl;\n\n  cout << \"Login, URL:\" << endl;\n  cout << \"Hostname: \" << Datas->Login.HostName.value();\n  cout << \":\" << Datas->Login.Port.toString() << endl << endl;\n  cout << \"Show all collection items\" << endl;\n  for (size_t i=0; i<Datas->LastUsedDocuments.size(); i++)\n  {\n    LastUsedDocument* doc = Datas->LastUsedDocuments.getItem(i);\n    cout << \"Item \" << i << \": \" << doc->Name.value() << endl;\n  }\n  cout << endl;\n\n  cout << \"Deserialization:\" << endl;\n  cout << \"Class version: \" << Serializable::IdentifyClassVersion(xmlData) << endl;\n  cout << \"Performing deserialization...\" << endl;\n\n  // Deserialize the XML text\n  SerialisationData* dser_Datas=new SerialisationData;\n  if (Serializable::fromXML(xmlData, dser_Datas))\n  {\n    cout << \"OK\" << endl << endl;\n\n    // compare both objects\n    cout << \"Compareing objects: \";\n    if (dser_Datas->Compare(Datas))\n      cout << \"equal\" << endl << endl; \nelse\n      cout << \"net equal\" << endl << endl;\n\n    // now set value\n    cout << \"Set new value for field >password<...\" << endl;\n    dser_Datas->Login.Password = \"newPassword\";\n    cout << \"OK\" << endl << endl;\n\n    cout << \"compare objects again: \";\n    if (dser_Datas->Compare(Datas))\n      cout << \"equal\" << endl << endl; else\n      cout << \"net equal\" << endl << endl;\n\n    cout << \"search and replace placeholders: \";\n    dser_Datas->Replace(\"{FILEPATH}\", \"c:\\\\temp\\\\\");\n    cout << \"OK\" << endl << endl;\n\n    //output xml-data\n    cout << \"Serialize and output xml data: \" << endl;\n    cout << dser_Datas->toXML() << endl << endl;\n\n    cout << \"Clone object:\" << endl;\n    SerialisationData *clone1(new SerialisationData);\n    Serializable::Clone(dser_Datas, clone1);\n    cout << \"Serialize and output clone: \" << endl;\n    cout << clone1->toXML() << endl << endl;\n    delete (clone1);\n  }\n  delete(Datas);\n  delete(dser_Datas);\n  getchar();\n  return 0;\n}\n```", "```cpp\nstruct sockaddr_in\n{\n      short      sin_family;\n      u_short      sin_port;\n      struct      in_addr sin_addr;\n      char      sin_zero[8];\n};\n\nint PASCAL connect(SOCKET,const struct sockaddr*,int);\n    target.sin_family = AF_INET; // address family Internet\n    target.sin_port = htons (PortNo); //Port to connect on\n    target.sin_addr.s_addr = inet_addr (IPAddress); //Target IP\n\n    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP); //Create socket\n    if (s == INVALID_SOCKET)\n    {\n        return false; //Couldn't create the socket\n    }\n```", "```cpp\n    sockfd = socket (PF_INET, SOCK_STREAM, 0):\n    ```", "```cpp\n      short int sin_family;     // set to AF_INET\n      unsigned short int sin_port;   // Port number\n      struct in_addr sin_addr;   // Internet address\n      unsigned char sin_zero[8];   //set to all zeros\n    }\n    ```", "```cpp\n// Using the SendTo Function\n#ifndef UNICODE\n#define UNICODE\n#endif\n\n#define WIN32_LEAN_AND_MEAN\n\n#include <winsock2.h>\n#include <Ws2tcpip.h>\n#include <stdio.h>\n#include <conio.h>\n\n// Link with ws2_32.lib\n#pragma comment(lib, \"Ws2_32.lib\")\n\nint main()\n{\n\n  int iResult;\n  WSADATA wsaData;\n\n  SOCKET SenderSocket = INVALID_SOCKET;\n  sockaddr_in ReceiverAddress;\n\n  unsigned short Port = 27015;\n\n  char SendBuf[1024];\n  int BufLen = 1024;\n\n  //----------------------\n  // Initialize Winsock\n  iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n  if (iResult != NO_ERROR) {\n    wprintf(L\"WSAStartup failed with error: %d\\n\", iResult);\n    return 1;\n\n  }\n\n  //---------------------------------------------\n  // Create a socket for sending data\n  SenderSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n  if (SenderSocket == INVALID_SOCKET) {\n    wprintf(L\"socket failed with error: %ld\\n\", WSAGetLastError());\n    WSACleanup();\n    return 1;\n  }\n  //---------------------------------------------\n  // Set up the ReceiverAddress structure with the IP address of\n  // the receiver (in this example case \"192.168.1.1\")\n  // and the specified port number.\n  ReceiverAddress.sin_family = AF_INET;\n  ReceiverAddress.sin_port = htons(Port);\n  ReceiverAddress.sin_addr.s_addr = inet_addr(\"192.168.1.1\");\n\n  //---------------------------------------------\n  // Send a datagram to the receiver\n  wprintf(L\"Sending a datagram to the receiver...\\n\");\n  iResult = sendto(SenderSocket,\n    SendBuf, BufLen, 0, (SOCKADDR *)& ReceiverAddress, sizeof(ReceiverAddress));\n  if (iResult == SOCKET_ERROR) {\n    wprintf(L\"sendto failed with error: %d\\n\", WSAGetLastError());\n    closesocket(SenderSocket);\n    WSACleanup();\n    return 1;\n  }\n  //---------------------------------------------\n  // When the application is finished sending, close the socket.\n  wprintf(L\"Finished sending. Closing socket.\\n\");\n  iResult = closesocket(SenderSocket);\n  if (iResult == SOCKET_ERROR) {\n    wprintf(L\"closesocket failed with error: %d\\n\", WSAGetLastError());\n    WSACleanup();\n    return 1;\n  }\n  //---------------------------------------------\n  // Clean up and quit.\n  wprintf(L\"Exiting.\\n\");\n  WSACleanup();\n\n  getch();\n  return 0;\n}\n\n//Using the Send Function\n#ifndef UNICODE\n#define UNICODE\n#endif\n\n#define WIN32_LEAN_AND_MEAN\n\n#include <winsock2.h>\n#include <Ws2tcpip.h>\n#include <stdio.h>\n\n// Link with ws2_32.lib\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT 27015\n\nint main() {\n\n  //----------------------\n  // Declare and initialize variables.\n  int iResult;\n  WSADATA wsaData;\n\n  SOCKET ConnectSocket = INVALID_SOCKET;\n  struct sockaddr_in clientService;\n\n  int recvbuflen = DEFAULT_BUFLEN;\n  char *sendbuf = \"Client: sending data test\";\n  char recvbuf[DEFAULT_BUFLEN] = \"\";\n\n  //----------------------\n  // Initialize Winsock\n  iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n  if (iResult != NO_ERROR) {\n    wprintf(L\"WSAStartup failed with error: %d\\n\", iResult);\n    return 1;\n  }\n\n  //----------------------\n  // Create a SOCKET for connecting to server\n  ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (ConnectSocket == INVALID_SOCKET) {\n    wprintf(L\"socket failed with error: %ld\\n\", WSAGetLastError());\n    WSACleanup();\n    return 1;\n  }\n\n  //----------------------\n  // The sockaddr_in structure specifies the address family,\n  // IP address, and port of the server to be connected to.\n  clientService.sin_family = AF_INET;\n  clientService.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n  clientService.sin_port = htons(DEFAULT_PORT);\n\n  //----------------------\n  // Connect to server.\n  iResult = connect(ConnectSocket, (SOCKADDR*)&clientService, sizeof(clientService));\n  if (iResult == SOCKET_ERROR) {\n    wprintf(L\"connect failed with error: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n  }\n\n  //----------------------\n  // Send an initial buffer\n  iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n  if (iResult == SOCKET_ERROR) {\n    wprintf(L\"send failed with error: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n  }\n\n  printf(\"Bytes Sent: %d\\n\", iResult);\n\n  // shutdown the connection since no more data will be sent\n  iResult = shutdown(ConnectSocket, SD_SEND);\n  if (iResult == SOCKET_ERROR) {\n    wprintf(L\"shutdown failed with error: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n  }\n\n  // Receive until the peer closes the connection\n  do {\n\n    iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);\n    if (iResult > 0)\n      wprintf(L\"Bytes received: %d\\n\", iResult);\n    else if (iResult == 0)\n      wprintf(L\"Connection closed\\n\");\n    else\n      wprintf(L\"recv failed with error: %d\\n\", WSAGetLastError());\n\n  } while (iResult > 0);\n\n  // close the socket\n  iResult = closesocket(ConnectSocket);\n  if (iResult == SOCKET_ERROR) {\n    wprintf(L\"close failed with error: %d\\n\", WSAGetLastError());\n    WSACleanup();\n    return 1;\n  }\n\n  WSACleanup();\n  return 0;\n}\n```", "```cpp\n#define WIN32_LEAN_AND_MEAN\n\n#include <winsock2.h>\n#include <Ws2tcpip.h>\n#include <stdio.h>\n\n// Link with ws2_32.lib\n#pragma comment(lib, \"Ws2_32.lib\")\n\n#define DEFAULT_BUFLEN 512\u2029\n#define DEFAULT_PORT \"27015\"\n\nint __cdecl main() {\n\n  //----------------------\n  // Declare and initialize variables.\n  WSADATA wsaData;\n  int iResult;\n\n  SOCKET ConnectSocket = INVALID_SOCKET;\n  struct sockaddr_in clientService;\n\n  char *sendbuf = \"this is a test\";\n  char recvbuf[DEFAULT_BUFLEN];\n  int recvbuflen = DEFAULT_BUFLEN;\n\n  //----------------------\n  // Initialize Winsock\n  iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n  if (iResult != NO_ERROR) {\n    printf(\"WSAStartup failed: %d\\n\", iResult);\n    return 1;\n  }\n\n  //----------------------\n  // Create a SOCKET for connecting to server\n  ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (ConnectSocket == INVALID_SOCKET) {\n    printf(\"Error at socket(): %ld\\n\", WSAGetLastError());\n    WSACleanup();\n    return 1;\n  }\n\n  //----------------------\n  // The sockaddr_in structure specifies the address family,\n  // IP address, and port of the server to be connected to.\n  clientService.sin_family = AF_INET;\n  clientService.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n  clientService.sin_port = htons(27015);\n\n  //----------------------\n  // Connect to server.\n  iResult = connect(ConnectSocket, (SOCKADDR*)&clientService, sizeof(clientService));\n  if (iResult == SOCKET_ERROR) {\n    closesocket(ConnectSocket);\n    printf(\"Unable to connect to server: %ld\\n\", WSAGetLastError());\n    WSACleanup();\n    return 1;\n  }\n\n  // Send an initial buffer\n  iResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n  if (iResult == SOCKET_ERROR) {\n    printf(\"send failed: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n  }\n\n  printf(\"Bytes Sent: %ld\\n\", iResult);\n\n  // shutdown the connection since no more data will be sent\n  iResult = shutdown(ConnectSocket, SD_SEND);\n  if (iResult == SOCKET_ERROR) {\n    printf(\"shutdown failed: %d\\n\", WSAGetLastError());\n    closesocket(ConnectSocket);\n    WSACleanup();\n    return 1;\n  }\n\n  // Receive until the peer closes the connection\n  do {\n\n    iResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);\n    if (iResult > 0)\n      printf(\"Bytes received: %d\\n\", iResult);\n    else if (iResult == 0)\n      printf(\"Connection closed\\n\");\n    else\n      printf(\"recv failed: %d\\n\", WSAGetLastError());\n\n  } while (iResult > 0);\n\n  // cleanup\n  closesocket(ConnectSocket);\n  WSACleanup();\n\n  return 0;\n}\n```", "```cpp\nint recv(int sockfd, void *buf,  int len, int flags);\n```", "```cpp\nread_network_messages()\n    read_local_input()\n    update_world()\n    send_network_updates()\n    render_world()\n```"]