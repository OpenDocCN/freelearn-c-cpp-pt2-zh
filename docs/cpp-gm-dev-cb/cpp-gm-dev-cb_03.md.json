["```cpp\n    #include \"HashTable.h\"\n    #include <conio.h>\n\n    int main()\n    {\n      // Create 26 Items to store in the Hash Table.\n      Item * A = new Item{ \"Enemy1\", NULL };\n      Item * B = new Item{ \"Enemy2\", NULL };\n      Item * C = new Item{ \"Enemy3\", NULL };\n      Item * D = new Item{ \"Enemy4\", NULL };\n      Item * E = new Item{ \"Enemy5\", NULL };\n      Item * F = new Item{ \"Enemy6\", NULL };\n      Item * G = new Item{ \"Enemy7\", NULL };\n      Item * H = new Item{ \"Enemy8\", NULL };\n      Item * I = new Item{ \"Enemy9\", NULL };\n      Item * J = new Item{ \"Enemy10\", NULL };\n      Item * K = new Item{ \"Enemy11\", NULL };\n      Item * L = new Item{ \"Enemy12\", NULL };\n      Item * M = new Item{ \"Enemy13\", NULL };\n      Item * N = new Item{ \"Enemy14\", NULL };\n      Item * O = new Item{ \"Enemy15\", NULL };\n      Item * P = new Item{ \"Enemy16\", NULL };\n      Item * Q = new Item{ \"Enemy17\", NULL };\n      Item * R = new Item{ \"Enemy18\", NULL };\n      Item * S = new Item{ \"Enemy19\", NULL };\n      Item * T = new Item{ \"Enemy20\", NULL };\n      Item * U = new Item{ \"Enemy21\", NULL };\n      Item * V = new Item{ \"Enemy22\", NULL };\n      Item * W = new Item{ \"Enemy23\", NULL };\n      Item * X = new Item{ \"Enemy24\", NULL };\n      Item * Y = new Item{ \"Enemy25\", NULL };\n      Item * Z = new Item{ \"Enemy26\", NULL };\n\n      // Create a Hash Table of 13 Linked List elements.\n      HashTable table;\n\n      // Add 3 Items to Hash Table.\n      table.insertItem(A);\n      table.insertItem(B);\n      table.insertItem(C);\n      table.printTable();\n\n      // Remove one item from Hash Table.\n      table.removeItem(\"Enemy3\");\n      table.printTable();\n\n      // Add 23 items to Hash Table.\n      table.insertItem(D);\n      table.insertItem(E);\n      table.insertItem(F);\n      table.insertItem(G);\n      table.insertItem(H);\n      table.insertItem(I);\n      table.insertItem(J);\n      table.insertItem(K);\n      table.insertItem(L);\n      table.insertItem(M);\n      table.insertItem(N);\n      table.insertItem(O);\n      table.insertItem(P);\n      table.insertItem(Q);\n      table.insertItem(R);\n      table.insertItem(S);\n      table.insertItem(T);\n      table.insertItem(U);\n      table.insertItem(V);\n      table.insertItem(W);\n      table.insertItem(X);\n      table.insertItem(Y);\n      table.insertItem(Z);\n      table.printTable();\n\n      // Look up an item in the hash table\n      Item * result = table.getItemByKey(\"Enemy4\");\n      if (result!=nullptr)\n      cout << endl<<\"The next key is \"<<result->next->key << endl;\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #ifndef LinkedList_h\n    #define LinkedList_h\n\n    #include <iostream>\n    #include <string>\n    using namespace std;\n\n    //*****************************************************************\n    // List items are keys with pointers to the next item.\n    //*****************************************************************\n    struct Item\n    {\n      string key;\n      Item * next;\n    };\n\n    //*****************************************************************\n    // Linked lists store a variable number of items.\n    //*****************************************************************\n    class LinkedList\n    {\n    private:\n      // Head is a reference to a list of data nodes.\n      Item * head;\n\n      // Length is the number of data nodes.\n      int length;\n\n    public:\n      // Constructs the empty linked list object.\n      // Creates the head node and sets length to zero.\n      LinkedList();\n\n      // Inserts an item at the end of the list.\n      void insertItem(Item * newItem);\n\n      // Removes an item from the list by item key.\n      // Returns true if the operation is successful.\n      bool removeItem(string itemKey);\n\n      // Searches for an item by its key.\n      // Returns a reference to first match.\n      // Returns a NULL pointer if no match is found.\n      Item * getItem(string itemKey);\n\n      // Displays list contents to the console window.\n      void printList();\n\n      // Returns the length of the list.\n      int getLength();\n\n      // De-allocates list memory when the program terminates.\n      ~LinkedList();\n    };\n\n    #endif\n    ```", "```cpp\n    #include \"LinkedList.h\"\n\n    // Constructs the empty linked list object.\n    // Creates the head node and sets length to zero.\n    LinkedList::LinkedList()\n    {\n      head = new Item;\n      head->next = NULL;\n      length = 0;\n    }\n\n    // Inserts an item at the end of the list.\n    void LinkedList::insertItem(Item * newItem)\n    {\n      if (!head->next)\n      {\n        head->next = newItem;\n    newItem->next=NULL;\n        length++;\n        return;\n      }\n    //Can be reduced to fewer lines of codes.\n    //Using 2 variables p and q to make it more clear\n      Item * p = head->next;\n      Item * q = p->next;\n      while (q)\n      {\n        p = q;\n        q = p->next;\n      }\n      p->next = newItem;\n      newItem->next = NULL;\n      length++;\n    }\n\n    // Removes an item from the list by item key.\n    // Returns true if the operation is successful.\n    bool LinkedList::removeItem(string itemKey)\n    {\n      if (!head->next) return false;\n      Item * p = head;\n      Item * q = head->next;\n      while (q)\n      {\n        if (q->key == itemKey)\n        {\n          p->next = q->next;\n          delete q;\n          length--;\n          return true;\n        }\n        p = q;\n        q = p->next;\n      }\n      return false;\n    }\n\n    // Searches for an item by its key.\n    // Returns a reference to first match.\n    // Returns a NULL pointer if no match is found.\n    Item * LinkedList::getItem(string itemKey)\n    {\n      Item * p = head;\n      Item * q = p->next;\n      while (q)\n      {\n\n    if (q->key == itemKey))\n      {  \n    return p;\n      }\n    p = q;  \n    q = p->next;\n      }\n      return NULL;\n    }\n\n    // Displays list contents to the console window.\n    void LinkedList::printList()\n    {\n      if (length == 0)\n      {\n        cout << \"\\n{ }\\n\";\n        return;\n      }\n      Item * p = head;\n      Item * q = p->next;\n      cout << \"\\n{ \";\n      while (q)\n      {\n        p = q;\n        if (p != head)\n        {\n          cout << p->key;\n          if (q->next) cout << \", \";\n          else cout << \" \";\n        }\n        q = p->next;\n      }\n      cout << \"}\\n\";\n    }\n\n    // Returns the length of the list.\n    int LinkedList::getLength()\n    {\n      return length;\n    }\n\n    // De-allocates list memory when the program terminates.\n    LinkedList::~LinkedList()\n    {\n      Item * p = head;\n      Item * q = head;\n      while (q)\n      {\n        p = q;\n        q = p->next;\n        if (q) \n      }\n    delete p;\n    }\n    ```", "```cpp\n    #include \"HashTable.h\"\n\n    // Constructs the empty Hash Table object.\n    // Array length is set to 13 by default.\n    HashTable::HashTable(int tableLength)\n    {\n      if (tableLength <= 0) tableLength = 13;\n      array = new LinkedList[tableLength];\n      length = tableLength;\n    }\n\n    // Returns an array location for a given item key.\n    int HashTable::hash(string itemKey)\n    {\n      int value = 0;\n      for (int i = 0; i < itemKey.length(); i++)\n        value += itemKey[i];\n      return (value * itemKey.length()) % length;\n    }\n\n    // Adds an item to the Hash Table.\n    void HashTable::insertItem(Item * newItem)\n    {\n    If(newItem)\n    {\n      int index = hash(newItem->key);\n      array[index].insertItem(newItem);\n    }\n    }\n\n    // Deletes an Item by key from the Hash Table.\n    // Returns true if the operation is successful.\n    bool HashTable::removeItem(string itemKey)\n    {\n      int index = hash(itemKey);\n      return array[index].removeItem(itemKey);\n    }\n\n    // Returns an item from the Hash Table by key.\n    // If the item isn't found, a null pointer is returned.\n    Item * HashTable::getItemByKey(string itemKey)\n    {\n      int index = hash(itemKey);\n      return array[index].getItem(itemKey);\n    }\n\n    // Display the contents of the Hash Table to console window.\n    void HashTable::printTable()\n    {\n      cout << \"\\n\\nHash Table:\\n\";\n      for (int i = 0; i < length; i++)\n      {\n        cout << \"Bucket \" << i + 1 << \": \";\n        array[i].printList();\n      }\n    }\n\n    // Returns the number of locations in the Hash Table.\n    int HashTable::getLength()\n    {\n      return length;\n    }\n\n    // Returns the number of Items in the Hash Table.\n    int HashTable::getNumberOfItems()\n    {\n      int itemCount = 0;\n      for (int i = 0; i < length; i++)\n      {\n        itemCount += array[i].getLength();\n      }\n      return itemCount;\n    }\n\n    // De-allocates all memory used for the Hash Table.\n    HashTable::~HashTable()\n    {\n      delete[] array;\n    }\n    ```", "```cpp\n    #ifndef HashTable_h\n    #define HashTable_h\n\n    #include \"LinkedList.h\"\n\n    //*****************************************************************\n    // Hash Table objects store a fixed number of Linked Lists.\n    //*****************************************************************\n    class HashTable\n    {\n    private:\n\n      // Array is a reference to an array of Linked Lists.\n      LinkedList * array;\n\n      // Length is the size of the Hash Table array.\n      int length;\n\n      // Returns an array location for a given item key.\n      int hash(string itemKey);\n\n    public:\n\n      // Constructs the empty Hash Table object.\n      // Array length is set to 13 by default.\n      HashTable(int tableLength = 13);\n\n      // Adds an item to the Hash Table.\n      void insertItem(Item * newItem);\n\n      // Deletes an Item by key from the Hash Table.\n      // Returns true if the operation is successful.\n      bool removeItem(string itemKey);\n\n      // Returns an item from the Hash Table by key.\n      // If the item isn't found, a null pointer is returned.\n      Item * getItemByKey(string itemKey);\n\n      // Display the contents of the Hash Table to console window.\n      void printTable();\n\n      // Returns the number of locations in the Hash Table.\n      int getLength();\n\n      // Returns the number of Items in the Hash Table.\n      int getNumberOfItems();\n\n      // De-allocates all memory used for the Hash Table.\n      ~HashTable();\n    };\n\n    #endif\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    typedef struct LinkedList {\n      int LevelNumber;\n      LinkedList * next;\n    } LinkedList;\n\n    int main() {\n      LinkedList * head = NULL;\n      int i;\n      for (i = 1; i <= 10; i++) {\n        LinkedList * currentNode = new LinkedList;\n        currentNode->LevelNumber = i;\n        currentNode->next = head;\n        head = currentNode;\n      }\n      while (head) {\n        cout << head->LevelNumber << \" \";\n        head = head->next;\n      }\n    delete head;\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n    #include <string>\n\n    using namespace std;\n\n    class Stack\n    {\n    private:\n      string UI_Elements[10];\n      int top;\n    public:\n      Stack()\n      {\n        top = -1;\n      }\n\n      void Push(string element)\n      {\n        if (top >= 10)\n        {\n          cout << \"Some error occurred\";\n        }\n        UI_Elements[++top] = element;\n      }\n\n      string Pop()\n      {\n        if (top == -1)\n        {\n          cout << \"Some error occurred\";\n        }\n        return UI_Elements[top--];\n      }\n\n      string Top()\n      {\n        return UI_Elements[top];\n      }\n\n      int Size()\n      {\n        return top + 1;\n      }\n\n      bool isEmpty()\n      {\n        return (top == -1) ? true : false;\n      }\n    };\n\n    int main()\n    {\n        Stack _stack;\n\n        if (_stack.isEmpty())\n        {\n          cout << \"Stack is empty\" << endl;\n        }\n        // Push elements    \n        _stack.Push(\"UI_Element1\");\n        _stack.Push(\"UI_Element2\");\n        // Size of stack\n        cout << \"Size of stack = \" << _stack.Size() << endl;\n        // Top element    \n        cout << _stack.Top() << endl;\n        // Pop element    \n        cout << _stack.Pop() << endl;\n        // Top element    \n        cout << _stack.Top() << endl;\n\n        _getch();\n        return 0;\n      }\n    ```", "```cpp\n    #include <iostream>\n    #include <queue>\n    #include <string>\n    #include <conio.h>\n\n    using namespace std;\n\n    int main()\n    {\n      queue <string> gunInventory;\n      gunInventory.push(\"AK-47\");\n      gunInventory.push(\"BullPup\");\n      gunInventory.push(\"Carbine\");\n\n      cout << \"This is your weapons inventory\" << endl << endl;\n      cout << \"The first gun that you are using is \"\n        << gunInventory.front() << endl << endl;\n      gunInventory.pop();\n      cout << \"There are currently \" << gunInventory.size()\n        << \" more guns in your inventory. \" << endl << endl\n        << \"The next gun in the inventory is \"\n        << gunInventory.front() << \".\" << endl << endl\n\n        << gunInventory.back() << \" is the last gun in the inventory.\"\n        << endl;\n\n      _getch();\n      return 0;\n\n    }\n    ```", "```cpp\n    // Initialize the node with a value and pointers\n    // to left child\n    // and right child\n    struct node\n    {\n      string data_value;\n      node *left;\n      node *right;\n    };\n\n    class Binary_Tree\n    {\n    public:\n      Binary_Tree();\n      ~Binary_Tree();\n\n      void insert(string key);\n      node *search(string key);\n      void destroy_tree();\n\n    private:\n      void destroy_tree(node *leaf);\n      void insert(string key, node *leaf);\n      node *search(string key, node *leaf);\n\n      node *root;\n    };\n\n    Binary_Tree::Binary_Tree()\n    {\n      root = NULL;\n    }\n\n    Binary_Tree::~Binary_Tree()\n    {\n      destroy_tree();\n    }\n\n    void Binary_Tree::destroy_tree(node *leaf)\n    {\n      if (leaf != NULL)\n      {\n        destroy_tree(leaf->left);\n        destroy_tree(leaf->right);\n        delete leaf;\n      }\n    }\n\n    void Binary_Tree::insert(string key, node *leaf)\n    {\n      if (key< leaf->key_value)\n      {\n        if (leaf->left != NULL)\n          insert(key, leaf->left);\n        else\n        {\n          leaf->left = new node;\n          leaf->left->key_value = key;\n          leaf->left->left = NULL;  \n          leaf->left->right = NULL;  \n        }\n      }\n      else if (key >= leaf->key_value)\n      {\n        if (leaf->right != NULL)\n          insert(key, leaf->right);\n        else\n        {\n          leaf->right = new node;\n          leaf->right->key_value = key;\n          leaf->right->left = NULL;\n          leaf->right->right = NULL;\n        }\n      }\n    }\n\n    node *Binary_Tree::search(string key, node *leaf)\n    {\n      if (leaf != NULL)\n      {\n        if (key == leaf->key_value)\n          return leaf;\n        if (key<leaf->key_value)\n          return search(key, leaf->left);\n        else\n          return search(key, leaf->right);\n      }\n      else return NULL;\n    }\n\n    void Binary_Tree::insert(string key)\n    {\n      if (root != NULL)\n        insert(key, root);\n      else\n      {\n        root = new node;\n        root->key_value = key;\n        root->left = NULL;\n        root->right = NULL;\n      }\n    }\n    node *Binary_Tree::search(string key)\n    {\n      return search(key, root);\n    }\n\n    void Binary_Tree::destroy_tree()\n    {\n      destroy_tree(root);\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <vector>\n    #include <map>\n    #include <string>\n\n    using namespace std;\n\n    struct vertex\n    {\n      typedef pair<int, vertex*> ve;\n      vector<ve> adj; //cost of edge, destination vertex\n      string name;\n      vertex(string s)\n      {\n        name = s;\n      }\n    };\n\n    class graph\n    {\n    public:\n      typedef map<string, vertex *> vmap;\n      vmap work;\n      void addvertex(const string&);\n      void addedge(const string& from, const string& to, double cost);\n    };\n    ```", "```cpp\n    void graph::addvertex(const string &name)\n    {\n      vmap::iterator itr = work.begin();\n      itr = work.find(name);\n      if (itr == work.end())\n      {\n        vertex *v;\n        v = new vertex(name);\n        work[name] = v;\n        return;\n      }\n      cout << \"\\nVertex already exists!\";\n    }\n\n    void graph::addedge(const string& from, const string& to, double cost)\n    {\n      vertex *f = (work.find(from)->second);\n      vertex *t = (work.find(to)->second);\n      pair<int, vertex *> edge = make_pair(cost, t);\n      f->adj.push_back(edge);\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <list>\n    #include <conio.h>\n\n    using namespace std;\n\n    int main()\n    {\n      list<int> possible_paths;\n      possible_paths.push_back(1);\n      possible_paths.push_back(1);\n      possible_paths.push_back(8);\n      possible_paths.push_back(9);\n      possible_paths.push_back(7);\n      possible_paths.push_back(8);\n      possible_paths.push_back(2);\n      possible_paths.push_back(3);\n      possible_paths.push_back(3);\n\n      possible_paths.sort();\n      possible_paths.unique();\n\n      for (list<int>::iterator list_iter = possible_paths.begin();\n        list_iter != possible_paths.end(); list_iter++)\n      {\n        cout << *list_iter << endl;\n      }\n\n      _getch();\n      return 0;\n\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <map>\n    #include <conio.h>\n\n    using namespace std;\n\n    int main()\n    {\n      map <string, int> score_list;\n\n      score_list[\"John\"] = 242;\n      score_list[\"Tim\"] = 768;\n      score_list[\"Sam\"] = 34;\n\n      if (score_list.find(\"Samuel\") == score_list.end())\n      {\n        cout << \"Samuel is not in the map!\" << endl;\n      }\n\n      cout << score_list.begin()->second << endl;\n\n      _getch();\n      return 0;\n\n    }\n    ```", "```cpp\n    #include <unordered_map>\n    #include <string>\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    int main()\n    {\n      unordered_map<string, string> hashtable;\n      hashtable.emplace(\"Alexander\", \"23ms\");\n      hashtable.emplace(\"Christopher\", \"21ms\");\n      hashtable.emplace(\"Steve\", \"55ms\");\n      hashtable.emplace(\"Amy\", \"17ms\");\n      hashtable.emplace(\"Declan\", \"999ms\");\n\n      cout << \"Ping time in milliseconds: \" << hashtable[\"Amy\"] << endl<<endl;\n      cout << \"----------------------------------\" << endl << endl;\n\n      hashtable.insert(make_pair(\"Fawad\", \"67ms\"));\n\n      cout << endl<<\"Ping time of all player is the server\" << endl;\n      cout << \"------------------------------------\" << endl << endl;\n      for (auto &itr : hashtable)\n      {\n        cout << itr.first << \": \" << itr.second << endl;\n      }\n\n      _getch();\n      return 0;\n    }\n    ```"]