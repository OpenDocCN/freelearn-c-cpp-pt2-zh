["```cpp\n    // Bubble Sort\n    template <class T>\n    void bubble_sort(T a[], int n)\n    {\n      T temp;\n      for (int i = 0; i<n; i++)\n      {\n        for (int j = 0; j<n - i - 1; j++)\n        {\n          if (a[j]>a[j + 1])\n          {\n            temp = a[j];\n            a[j] = a[j + 1];\n            a[j + 1] = temp;\n          }\n        }\n      }\n    }\n\n    //Insertion Sort\n    template <class T>\n    void insertion_sort(T a[], int n)\n    {\n      T key;\n      for (int i = 1; i<n; i++)\n      {\n        key = a[i];\n        int j = i - 1;\n        while (j >= 0 && a[j]>key)\n        {\n          a[j + 1] = a[j];\n          j = j - 1;\n        }\n        a[j + 1] = key;\n      }\n    }\n\n    //Selection Sort\n    template <class T>\n    int minimum_element(T a, int low, int up)\n    {\n      int min = low;\n      while (low<up)\n      {\n        if (a[low]<a[min])\n          min = low;\n        low++;\n      }\n      return min;\n    }\n\n    template <class T>\n\n    void selection_sort(T a[], int n)\n    {\n      int i = 0;\n      int loc = 0;\n      T temp;\n      for (i = 0; i<n; i++)\n      {\n        loc = minimum_element(a, i, n);\n        temp = a[loc];\n        a[loc] = a[i];\n        a[i] = temp;\n      }\n    }\n\n    //Quick Sort\n    template <class T>\n    int partition(T a[], int p, int r)\n    {\n      T x;\n      int i;\n      x = a[r];\n      i = p - 1;\n      for (int j = p; j <= r - 1; j++)\n      {\n        if (a[j] <= x)\n        {\n          i = i + 1;\n          swap(a[i], a[j]);\n        }\n      }\n      swap(a[i + 1], a[r]);\n      return i + 1;\n    }\n    template <class T>\n    void quick_sort(T a[], int p, int r)\n    {\n      int q;\n      if (p<r)\n      {\n        q = partition(a, p, r);\n        quick_sort(a, p, q - 1);\n        quick_sort(a, q + 1, r);\n      }\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    bool Linear_Search(int list[], int size, int key)\n    {\n      // Basic sequential search\n      bool found = false;\n      int i;\n\n      for (i = 0; i < size; i++)\n      {\n        if (key == list[i])\n          found = true;\n        break;\n      }\n\n      return found;\n    }\n    bool Binary_Search(int *list, int size, int key)\n    {\n      // Binary search\n      bool found = false;\n      int low = 0, high = size - 1;\n\n      while (high >= low)\n      {\n        int mid = (low + high) / 2;\n        if (key < list[mid])\n          high = mid - 1;\n        else if (key > list[mid])\n          low = mid + 1;\n        else\n        {\n          found = true;\n          break;\n        }\n      }\n\n      return found;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    void Cubic_Order()\n    {\n      int n = 100;\n      for (int i = 0; i < n; i++)\n      {\n        for (int j=0; j < n; j++)\n        {\n          for (int k = 0; k < n; k++)\n          {\n            //Some implementation\n          }\n        }\n      }\n    }\n    void Sqaure_Order()\n    {\n      int n = 100;\n      for (int i = 0; i < n; i++)\n      {\n        for (int j = 0; j < n; j++)\n        {\n          //Some implementation\n        }\n      }\n    }\n\n    int main()\n    {\n      Cubic_Order();\n      Sqaure_Order();\n\n      return 0;\n    }\n    ```", "```cpp\n    Source.cpp\n\n    #include <stdio.h>\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    bool isBigEndian()\n    {\n      unsigned int i = 1;\n      char *c = (char*)&i;\n      if (*c)\n        return false;\n      else\n        return true;\n    }\n    int main()\n    {\n      if (isBigEndian())\n      {\n        cout << \"This is a Big Endian machine\" << endl;\n      }\n      else\n      {\n        cout << \"This is a Little Endian machine\" << endl;\n      }\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include<iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    int max(int a, int b) { return (a > b) ? a : b; }\n\n    int knapSack(int TotalWeight, int individual_weight[], int individual_value[], int size)\n    {\n\n      if (size == 0 || TotalWeight == 0)\n        return 0;\n      if (individual_weight[size - 1] > TotalWeight)\n        return knapSack(TotalWeight, individual_weight, individual_value, size - 1);\n      else return max(individual_value[size - 1] + knapSack(TotalWeight - individual_weight[size - 1], individual_weight, individual_value, size - 1),\n        knapSack(TotalWeight, individual_weight, individual_value, size - 1)\n        );\n    }\n\n    int main()\n    {\n      int individual_value[] = { 60, 100, 120 };\n      int individual_weight[] = { 10, 25, 40 };\n      int  TotalWeight = 60;\n      int size = sizeof(individual_value) / sizeof(individual_weight[0]);\n      cout << \"Total value of sack \"<<knapSack(TotalWeight, individual_weight, individual_value, size);\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    void printMaxActivities(int start_Time[], int finish_Time[], int n)\n    {\n      int i, j;  \n      i = 0;\n      cout << i;\n      for (j = 1; j < n; j++)\n      {    \n        if (start_Time[j] >= finish_Time[i])\n        {\n          cout << j;\n          i = j;\n        }\n      }\n    }\n\n    int main()\n    {\n      int start_Time[] = { 0, 2, 4, 7, 8, 11 };\n      int finish_Time[] = { 2, 4, 6, 8, 9, 15 };\n      int n = sizeof(start_Time) / sizeof(start_Time[0]);\n      printMaxActivities(start_Time, finish_Time, n);\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n\n    using namespace std;\n\n    const int MAX = 10;\n\n    class rray\n    {\n    private:\n      int arr[MAX];\n      int count;\n    public:\n      array();\n      void add(int num);\n      void makeheap(int);\n      void heapsort();\n      void display();\n    };\n    array ::array()\n    {\n      count = 0;\n      for (int i = 0; i < MAX; i++)\n        arr[MAX] = 0;\n    }\n    void array ::add(int num)\n    {\n      if (count < MAX)\n      {\n        arr[count] = num;\n        count++;\n      }\n      else\n        cout << \"\\nArray is full\" << endl;\n    }\n    void array ::makeheap(int c)\n    {\n\n      for (int i = 1; i < c; i++)\n      {\n        int val = arr[i];\n        int s = i;\n        int f = (s - 1) / 2;\n        while (s > 0 && arr[f] < val)\n        {\n          arr[s] = arr[f];\n          s = f;\n          f = (s - 1) / 2;\n        }\n        arr[s] = val;\n      }\n    }\n    void array ::heapsort()\n    {\n      for (int i = count - 1; i > 0; i--)\n      {\n        int ivalue = arr[i];\n        arr[i] = arr[0];\n        arr[0] = ivalue;\n        makeheap(i);\n\n      }\n    }\n    void array ::display()\n    {\n      for (int i = 0; i < count; i++)\n        cout << arr[i] << \"\\t\";\n      cout << endl;\n    }\n    void main()\n    {\n      array a;\n\n      a.add(11);\n      a.add(2);\n      a.add(9);\n      a.add(13);\n      a.add(57);\n      a.add(25);\n      a.add(17);\n      a.add(1);\n      a.add(90);\n      a.add(3);\n      a.makeheap(10);\n      cout << \"\\nHeap Sort.\\n\";\n      cout << \"\\nBefore Sorting:\\n\";\n      a.display();\n      a.heapsort();\n      cout << \"\\nAfter Sorting:\\n\";\n      a.display();\n\n      _getch();\n    }\n    ```"]