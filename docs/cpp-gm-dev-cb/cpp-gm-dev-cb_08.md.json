["```cpp\n// Basic AI : Keyword identification\n\n#include <iostream>\n#include <string>\n#include <string.h>\n\nstd::string arr[] = { \"Hello, what is your name ?\", \"My name is Siri\" };\n\nint main()\n{\n\n  std::string UserResponse;\n\n  std::cout << \"Enter your question? \";\n  std::cin >> UserResponse;\n\n  if (UserResponse == \"Hi\")\n  {\n    std::cout << arr[0] << std::endl;\n    std::cout << arr[1];\n  }\n\n  int a;\n  std::cin >> a;\n  return 0;\n\n}\n```", "```cpp\n    for (auto next : graph.neighbors(current)) {\n      int new_cost = cost_so_far[current] + graph.cost(current, next);\n      if (!cost_so_far.count(next) || new_cost < cost_so_far[next]) {\n        cost_so_far[next] = new_cost;\n        int priority = new_cost + heuristic(next, goal);\n        frontier.put(next, priority);\n        came_from[next] = current;\n      }\n```", "```cpp\nsNode(elemVec& toProcess, const T_treeAdaptor& adap)\n      : m_pFront(NULL)\n      , m_pBack(NULL)\n    {\n      // Setup\n      elemVec frontVec, backVec;\n      frontVec.reserve(toProcess.size());\n      backVec.reserve(toProcess.size());\n\n      // Choose which node we're going to use.\n      adap.ChooseHyperplane(toProcess, &m_hp);\n\n      // Iterate across the rest of the polygons\n      elemVec::iterator iter = toProcess.begin();\n      for (; iter != toProcess.end(); ++iter)\n      {\n        T_element front, back;\n        switch (adap.Classify(m_hp, *iter))\n        {\n        case BSP_RELAT_IN_FRONT:\n          frontVec.push_back(*iter);\n          break;\n       <...> \n      }\n\n      // Now recurse if necessary\n      if (!frontVec.empty())\n        m_pFront = new sNode(frontVec, adap);\n      if (!backVec.empty())\n        m_pBack = new sNode(backVec, adap);\n    }\n\n    sNode(std::istream& in)\n    {\n      // First char is the child state\n      // (0x1 means front child, 0x2 means back child)\n      int childState;\n      in >> childState;\n\n      // Next is the hyperplane for the node\n      in >> m_hp;\n\n      // Next is the number of elements in the node\n      unsigned int nElem;\n      in >> nElem;\n      m_contents.reserve(nElem);\n\n      while (nElem--)\n      {\n        T_element elem;\n        in >> elem;\n        m_contents.push_back(elem);\n      }\n\n      // recurse if we have children.\n      if (childState & 0x1)\n        m_pFront = new sNode(in);\n      else\n        m_pFront = NULL;\n      if (childState & 0x2)\n        m_pBack = new sNode(in);\n      else\n        m_pBack = NULL;\n    }\n```", "```cpp\n/* Decision Making AI*/\n\n#include <iostream>\n#include <ctime>\n\nusing namespace std;\n\nclass TreeNodes\n{\npublic:\n  //tree node functions\n  TreeNodes(int nodeID/*, string QA*/);\n  TreeNodes();\n\n  virtual ~TreeNodes();\n\n  int m_NodeID;\n\n  TreeNodes* PrimaryBranch;\n  TreeNodes* SecondaryBranch;\n};\n\n//constructor\nTreeNodes::TreeNodes()\n{\n  PrimaryBranch = NULL;\n  SecondaryBranch = NULL;\n\n  m_NodeID = 0;\n}\n\n//deconstructor\nTreeNodes::~TreeNodes()\n{ }\n\n//Step 3! Also step 7 hah!\nTreeNodes::TreeNodes(int nodeID/*, string NQA*/)\n{\n  //create tree node with a specific node ID\n  m_NodeID = nodeID;\n\n  //reset nodes/make sure! that they are null. I wont have any funny business #s -_-\n  PrimaryBranch = NULL;\n  SecondaryBranch = NULL;\n}\n\n//the decision tree class\nclass DecisionTree\n{\npublic:\n  //functions\n  void RemoveNode(TreeNodes* node);\n  void DisplayTree(TreeNodes* CurrentNode);\n  void Output();\n  void Query();\n  void QueryTree(TreeNodes* rootNode);\n  void PrimaryNode(int ExistingNodeID, int NewNodeID);\n  void SecondaryNode(int ExistingNodeID, int NewNodeID);\n  void CreateRootNode(int NodeID);\n  void MakeDecision(TreeNodes* node);\n\n  bool SearchPrimaryNode(TreeNodes* CurrentNode, int ExistingNodeID, int NewNodeID);\n  bool SearchSecondaryNode(TreeNodes* CurrentNode, int ExistingNodeID, int NewNodeID);\n\n  TreeNodes* m_RootNode;\n\n  DecisionTree();\n\n  virtual ~DecisionTree();\n};\n\nint random(int upperLimit);\n\n//for random variables that will effect decisions/node values/weights\nint random(int upperLimit)\n{\n  int randNum = rand() % upperLimit;\n  return randNum;\n}\n\n//constructor\n//Step 1!\nDecisionTree::DecisionTree()\n{\n  //set root node to null on tree creation\n  //beginning of tree creation\n  m_RootNode = NULL;\n}\n\n//destructor\n//Final Step in a sense\nDecisionTree::~DecisionTree()\n{\n  RemoveNode(m_RootNode);\n}\n\n//Step 2!\nvoid DecisionTree::CreateRootNode(int NodeID)\n{\n  //create root node with specific ID\n  // In MO, you may want to use thestatic creation of IDs like with entities. depends on how many nodes you plan to have\n  //or have instantaneously created nodes/changing nodes\n  m_RootNode = new TreeNodes(NodeID);\n}\n\n//Step 5.1!~\nvoid DecisionTree::PrimaryNode(int ExistingNodeID, int NewNodeID)\n{\n  //check to make sure you have a root node. can't add another node without a root node\n  if (m_RootNode == NULL)\n  {\n    cout << \"ERROR - No Root Node\";\n    return;\n  }\n\n  if (SearchPrimaryNode(m_RootNode, ExistingNodeID, NewNodeID))\n  {\n    cout << \"Added Node Type1 With ID \" << NewNodeID << \" onto Branch Level \" << ExistingNodeID << endl;\n  }\n  else\n  {\n    //check\n    cout << \"Node: \" << ExistingNodeID << \" Not Found.\";\n  }\n}\n\n//Step 6.1!~ search and add new node to current node\nbool DecisionTree::SearchPrimaryNode(TreeNodes *CurrentNode, int ExistingNodeID, int NewNodeID)\n{\n  //if there is a node\n  if (CurrentNode->m_NodeID == ExistingNodeID)\n  {\n    //create the node\n    if (CurrentNode->PrimaryBranch == NULL)\n    {\n      CurrentNode->PrimaryBranch = new TreeNodes(NewNodeID);\n    }\n    else\n    {\n      CurrentNode->PrimaryBranch = new TreeNodes(NewNodeID);\n    }\n    return true;\n  }\n  else\n  {\n    //try branch if it exists\n    //for a third, add another one of these too!\n    if (CurrentNode->PrimaryBranch != NULL)\n    {\n      if (SearchPrimaryNode(CurrentNode->PrimaryBranch, ExistingNodeID, NewNodeID))\n      {\n        return true;\n      }\n      else\n      {\n        //try second branch if it exists\n        if (CurrentNode->SecondaryBranch != NULL)\n        {\n          return(SearchSecondaryNode(CurrentNode->SecondaryBranch, ExistingNodeID, NewNodeID));\n        }\n        else\n        {\n          return false;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n//Step 5.2!~    does same thing as node 1\\.  if you wanted to have more decisions, \n//create a node 3 which would be the same as this maybe with small differences\nvoid DecisionTree::SecondaryNode(int ExistingNodeID, int NewNodeID)\n{\n  if (m_RootNode == NULL)\n  {\n    cout << \"ERROR - No Root Node\";\n  }\n\n  if (SearchSecondaryNode(m_RootNode, ExistingNodeID, NewNodeID))\n  {\n    cout << \"Added Node Type2 With ID \" << NewNodeID << \" onto Branch Level \" << ExistingNodeID << endl;\n  }\n  else\n  {\n    cout << \"Node: \" << ExistingNodeID << \" Not Found.\";\n  }\n}\n\n//Step 6.2!~ search and add new node to current node\n//as stated earlier, make one for 3rd node if there was meant to be one\nbool DecisionTree::SearchSecondaryNode(TreeNodes *CurrentNode, int ExistingNodeID, int NewNodeID)\n{\n  if (CurrentNode->m_NodeID == ExistingNodeID)\n  {\n    //create the node\n    if (CurrentNode->SecondaryBranch == NULL)\n    {\n      CurrentNode->SecondaryBranch = new TreeNodes(NewNodeID);\n    }\n    else\n    {\n      CurrentNode->SecondaryBranch = new TreeNodes(NewNodeID);\n    }\n    return true;\n  }\n  else\n  {\n    //try branch if it exists\n    if (CurrentNode->PrimaryBranch != NULL)\n    {\n      if (SearchSecondaryNode(CurrentNode->PrimaryBranch, ExistingNodeID, NewNodeID))\n      {\n        return true;\n      }\n      else\n      {\n        //try second branch if it exists\n        if (CurrentNode->SecondaryBranch != NULL)\n        {\n          return(SearchSecondaryNode(CurrentNode->SecondaryBranch, ExistingNodeID, NewNodeID));\n        }\n        else\n        {\n          return false;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n//Step 11\nvoid DecisionTree::QueryTree(TreeNodes* CurrentNode)\n{\n  if (CurrentNode->PrimaryBranch == NULL)\n  {\n    //if both branches are null, tree is at a decision outcome state\n    if (CurrentNode->SecondaryBranch == NULL)\n    {\n      //output decision 'question'\n      ///////////////////////////////////////////////////////////////////////////////////////\n    }\n    else\n    {\n      cout << \"Missing Branch 1\";\n    }\n    return;\n  }\n  if (CurrentNode->SecondaryBranch == NULL)\n  {\n    cout << \"Missing Branch 2\";\n    return;\n  }\n\n  //otherwise test decisions at current node\n  MakeDecision(CurrentNode);\n}\n\n//Step 10\nvoid DecisionTree::Query()\n{\n  QueryTree(m_RootNode);\n}\n\n////////////////////////////////////////////////////////////\n//debate decisions   create new function for decision logic\n\n// cout << node->stringforquestion;\n\n//Step 12\nvoid DecisionTree::MakeDecision(TreeNodes *node)\n{\n  //should I declare variables here or inside of decisions.h\n  int PHealth;\n  int MHealth;\n  int PStrength;\n  int MStrength;\n  int DistanceFBase;\n  int DistanceFMonster;\n\n  ////sets random!\n  srand(time(NULL));\n\n  //randomly create the numbers for health, strength and distance for each variable\n  PHealth = random(60);\n  MHealth = random(60);\n  PStrength = random(50);\n  MStrength = random(50);\n  DistanceFBase = random(75);\n  DistanceFMonster = random(75);\n\n  //the decision to be made string example: Player health: Monster Health:  player health is lower/higher\n  cout << \"Player Health: \" << PHealth << endl;\n  cout << \"Monster Health: \" << MHealth << endl;\n  cout << \"Player Strength: \" << PStrength << endl;\n  cout << \"Monster Strength: \" << MStrength << endl;\n  cout << \"Distance Player is From Base: \" << DistanceFBase << endl;\n  cout << \"Distance Player is From Monster: \" << DistanceFMonster << endl;\n\n  if (PHealth > MHealth)\n  {\n    std::cout << \"Player health is greater than monster health\";\n    //Do some logic here\n  }\n  else\n  {\n    std::cout << \"Monster health is greater than player health\";\n    //Do some logic here\n  }\n\n  if (PStrength > MStrength)\n  {\n    //Do some logic here\n  }\n  else\n  {\n  }\n\n  //recursive question for next branch. Player distance from base/monster. \n  if (DistanceFBase > DistanceFMonster)\n  {\n  }\n  else\n  {\n  }\n\n}\n\nvoid DecisionTree::Output()\n{\n  //take respective node\n  DisplayTree(m_RootNode);\n}\n\n//Step 9\nvoid DecisionTree::DisplayTree(TreeNodes* CurrentNode)\n{\n  //if it doesn't exist, don't display of course\n  if (CurrentNode == NULL)\n  {\n    return;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  //need to make a string to display for each branch\n  cout << \"Node ID \" << CurrentNode->m_NodeID << \"Decision Display: \" << endl;\n\n  //go down branch 1\n  DisplayTree(CurrentNode->PrimaryBranch);\n\n  //go down branch 2\n  DisplayTree(CurrentNode->SecondaryBranch);\n}\n\nvoid DecisionTree::RemoveNode(TreeNodes *node)\n{\n\n  if (node != NULL)\n  {\n    if (node->PrimaryBranch != NULL)\n    {\n      RemoveNode(node->PrimaryBranch);\n    }\n\n    if (node->SecondaryBranch != NULL)\n    {\n      RemoveNode(node->SecondaryBranch);\n    }\n\n    cout << \"Deleting Node\" << node->m_NodeID << endl;\n\n    //delete node from memory\n    delete node;\n    //reset node\n    node = NULL;\n  }\n}\n\nint main()\n{\n  //create the new decision tree object\n  DecisionTree* NewTree = new DecisionTree();\n\n  //add root node   the very first 'Question' or decision to be made\n  //is monster health greater than player health?\n  NewTree->CreateRootNode(1);\n\n  //add nodes depending on decisions\n  //2nd decision to be made\n  //is monster strength greater than player strength?\n  NewTree->PrimaryNode(1, 2);\n\n  //3rd decision\n  //is the monster closer than home base?\n  NewTree->SecondaryNode(1, 3);\n\n  //depending on the weights of all three decisions, will return certain node result\n  //results!\n  //Run, Attack, \n  NewTree->PrimaryNode(2, 4);\n  NewTree->SecondaryNode(2, 5);\n  NewTree->PrimaryNode(3, 6);\n  NewTree->SecondaryNode(3, 7);\n\n  NewTree->Output();\n\n  //ask/answer question decision making process\n  NewTree->Query();\n\n  cout << \"Decision Made. Press Any Key To Quit.\" << endl;\n\n  int a;\n  cin >> a;\n\n  //release memory!\n  delete NewTree;\n\n  //return random value\n  //return 1;\n\n}\n```", "```cpp\n/* Adding Behavorial Movements*/\n\n#include <iostream>\nusing namespace std;\nclass Machine\n{\n  class State *current;\npublic:\n  Machine();\n  void setCurrent(State *s)\n  {\n    current = s;\n  }\n  void Run();\n  void Walk();\n};\n\nclass State\n{\npublic:\n  virtual void Run(Machine *m)\n  {\n    cout << \"   Already Running\\n\";\n  }\n  virtual void Walk(Machine *m)\n  {\n    cout << \"   Already Walking\\n\";\n  }\n};\n\nvoid Machine::Run()\n{\n  current->Run(this);\n}\n\nvoid Machine::Walk()\n{\n  current->Walk(this);\n}\n\nclass RUN : public State\n{\npublic:\n  RUN()\n  {\n    cout << \"   RUN-ctor \";\n  };\n  ~RUN()\n  {\n    cout << \"   dtor-RUN\\n\";\n  };\n  void Walk(Machine *m);\n};\n\nclass WALK : public State\n{\npublic:\n  WALK()\n  {\n    cout << \"   WALK-ctor \";\n  };\n  ~WALK()\n  {\n    cout << \"   dtor-WALK\\n\";\n  };\n  void Run(Machine *m)\n  {\n    cout << \" Changing behaviour from WALK to RUN\";\n    m->setCurrent(new RUN());\n    delete this;\n  }\n};\n\nvoid RUN::Walk(Machine *m)\n{\n  cout << \"   Changing behaviour RUN to WALK\";\n  m->setCurrent(new WALK());\n  delete this;\n}\n\nMachine::Machine()\n{\n  current = new WALK();\n  cout << '\\n';\n}\n\nint main()\n{\n  Machine m;\n  m.Run();\n  m.Walk();\n  m.Walk();\u2029\n  int a;\n  cin >> a;\n\n  return 0;\n}\n```", "```cpp\nclass neuralNetworkTrainer\n{\n\nprivate:\n\n  //network to be trained\n  neuralNetwork* NN;\n\n  //learning parameters\n  double learningRate;          // adjusts the step size of the weight update  \n  double momentum;            // improves performance of stochastic learning (don't use for batch)\n\n  //epoch counter\n  long epoch;\n  long maxEpochs;\n\n  //accuracy/MSE required\n  double desiredAccuracy;\n\n  //change to weights\n  double** deltaInputHidden;\n  double** deltaHiddenOutput;\n\n  //error gradients\n  double* hiddenErrorGradients;\n  double* outputErrorGradients;\n\n  //accuracy stats per epoch\n  double trainingSetAccuracy;\n  double validationSetAccuracy;\n  double generalizationSetAccuracy;\n  double trainingSetMSE;\n  double validationSetMSE;\n  double generalizationSetMSE;\n\n  //batch learning flag\n  bool useBatch;\n\n  //log file handle\n  bool loggingEnabled;\n  std::fstream logFile;\n  int logResolution;\n  int lastEpochLogged;\n\npublic:  \n\n  neuralNetworkTrainer( neuralNetwork* untrainedNetwork );\n  void setTrainingParameters( double lR, double m, bool batch );\n  void setStoppingConditions( int mEpochs, double dAccuracy);\n  void useBatchLearning( bool flag ){ useBatch = flag; }\n  void enableLogging( const char* filename, int resolution );\n\n  void trainNetwork( trainingDataSet* tSet );\n\nprivate:\n  inline double getOutputErrorGradient( double desiredValue, double outputValue );\n  double getHiddenErrorGradient( int j );\n  void runTrainingEpoch( std::vector<dataEntry*> trainingSet );\n  void backpropagate(double* desiredOutputs);\n  void updateWeights();\n};\n\nclass neuralNetwork\n{\n\nprivate:\n\n  //number of neurons\n  int nInput, nHidden, nOutput;\n\n  //neurons\n  double* inputNeurons;\n  double* hiddenNeurons;\n  double* outputNeurons;\n\n  //weights\n  double** wInputHidden;\n  double** wHiddenOutput;\n  friend neuralNetworkTrainer;\n\npublic:\n\n  //constructor & destructor\n  neuralNetwork(int numInput, int numHidden, int numOutput);\n  ~neuralNetwork();\n\n  //weight operations\n  bool loadWeights(char* inputFilename);\n  bool saveWeights(char* outputFilename);\n  int* feedForwardPattern( double* pattern );\n  double getSetAccuracy( std::vector<dataEntry*>& set );\n  double getSetMSE( std::vector<dataEntry*>& set );\n\nprivate:\n\n  void initializeWeights();\n  inline double activationFunction( double x );\n  inline int clampOutput( double x );\n  void feedForward( double* pattern );\n\n};\n```", "```cpp\nvoid crossover(int &seed);\nvoid elitist();\nvoid evaluate();\nint i4_uniform_ab(int a, int b, int &seed);\nvoid initialize(string filename, int &seed);\nvoid keep_the_best();\nvoid mutate(int &seed);\ndouble r8_uniform_ab(double a, double b, int &seed);\nvoid report(int generation);\nvoid selector(int &seed);\nvoid timestamp();\nvoid Xover(int one, int two, int &seed);\n```", "```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n  float positionA = 4.0f; float positionB = 2.0f; float positionC = -1.0f; float positionD = 10.0f; float positionE = 0.0f;\n\n  //Sort the points according to Djisktra's\n  //A* can be used on top of this to minimise the points for traversal\n  //Transform the  objects over these new points.\n  return 0;\n}\n```"]