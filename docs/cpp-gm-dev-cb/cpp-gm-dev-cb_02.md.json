["```cpp\n    #include \"CEnemy.h\"\n    #include <iostream>\n    #include <string>\n    #include <conio.h>\n    #include \"vld.h\"\n\n    using namespace std;\n\n    int main()\n    {\n      CEnemy* pEnemy = new CEnemy(10,100,\"DrEvil\",\"GOLD\");\n\n      int iAge;\n      int iHealth;\n      string sName;\n      string sArmour;\n\n      iAge = pEnemy->GetAge();\n      iHealth = pEnemy->TotalHealth();\n      sArmour = pEnemy->GetArmourName();\n      sName = pEnemy->GetName();\n\n      cout << \"Name of the enemy is :\" << sName << endl;\n      cout << \"Name of \" << sName << \"'s armour is :\" << sArmour << endl;\n      cout << \"Health of \" << sName << \" is :\" << iHealth << endl;\n      cout << sName << \"'s age is :\" << iAge;\n\n    delete pEnemy;\n      _getch();\n    }\n    ```", "```cpp\n    #ifndef _CENEMY_H\n    #define _CENEMY_H\n\n    #include <string>\n    using namespace std;\n\n    class CEnemy\n    {\n    public:\n      string GetName()const;\n      int GetAge()const;\n      string GetArmourName()const;\n      int TotalHealth()const;\n\n      //ctors\n      CEnemy(int,int,string,string);\n    //dtors\n      ~CEnemy();\n    private:\n      int m_iAge;\n      int m_iHealth;\n      string m_sName;\n      string m_sArmour;\n    };\n\n    #endif\n    ```", "```cpp\n    #include <iostream>\n    #include <string>\n    #include \"CEnemy.h\"\n\n    using namespace std;\n\n    CEnemy::CEnemy(int Age,int Health,int Armour,int Name)\n    {\n      m_iAge = Age;\n      m_iHealth = Health;\n      m_sArmour = Armour;\n      m_sName = Name;\n    }\n\n    int CEnemy::GetAge()const\n    {\n      return m_iAge;\n    }\n\n    int CEnemy::TotalHealth()const\n    {\n      return m_iHealth;\n    }\n\n    string CEnemy::GetArmourName()const\n    {\n      return m_sArmour;\n    }\n\n    string CEnemy::GetName()const\n    {\n      return m_sName;\n    }\n    ```", "```cpp\n    #ifndef _ENEMY_H\n    #define _ENEMY_H\n\n    #include <iostream>\n\n    using namespace std;\n\n    class CEnemy {\n    protected:\n      int m_ihealth,m_iarmourValue;\n    public:\n      CEnemy(int ihealth, int iarmourValue) : m_ihealth(ihealth), m_iarmourValue(iarmourValue) {}\n      virtual int TotalHP(void) = 0;\n      void PrintHealth()\n      {\n        cout << \"Total health is \" << this->TotalHP() << '\\n';\n      }\n    };\n\n       #endif\n    ```", "```cpp\n    #ifndef _DRAGON_H\n    #define _DRAGON_H\n\n    #include \"Enemy.h\"\n    #include <iostream>\n\n    using namespace std;\n\n    class CDragon : public CEnemy {\n    public:\n      CDragon(int m_ihealth, int m_iarmourValue) : CEnemy(m_ihealth, m_iarmourValue)\n      {\n      }\n      int TotalHP()\n      {\n        cout << \"Dragon's \";\n        return m_ihealth*2+3*m_iarmourValue;\n      }\n    };\n\n      #endif\n    ```", "```cpp\n    #ifndef _SOLDIER_H\n    #define _SOLDIER_H\n\n    #include \"Enemy.h\"\n    #include <iostream>\n\n    using namespace std;\n\n    class CSoldier : public CEnemy {\n    public:\n      CSoldier(int m_ihealth, int m_iarmourValue) : CEnemy(m_ihealth, m_iarmourValue) {}\n      int TotalHP()\n      {\n        cout << \"Soldier's \";\n        return m_ihealth+m_iarmourValue;\n      }\n    };\n\n    #endif\n    ```", "```cpp\n    // dynamic allocation and polymorphism\n    #include <iostream>\n    #include <conio.h>\n    #include \"vld.h\"\n    #include \"Enemy.h\"\n    #include \"Dragon.h\"\n    #include \"Soldier.h\"\n\n    int main()\n     {\n      CEnemy* penemy1 = new CDragon(100, 50);\n      CEnemy* penemy2 = new CSoldier(100, 100);\n\n      penemy1->PrintHealth();\n      penemy2->PrintHealth();\n\n      delete penemy1;\n      delete penemy2;\n\n      _getch();\n      return 0;\n\n    }\n    ```", "```cpp\n    #pragma once\n    #include <iostream>\n\n    using namespace std;\n    class CTerrain\n    {\n    public:\n      CTerrainCTerrain();\n      ~CTerrain();\n\n      CTerrain(const CTerrain &T)\n      {\n        cout << \"\\n Copy Constructor\";\n      }\n      CTerrain& operator =(const CTerrain &T)\n      {\n        cout << \"\\n Assignment Operator\";\n        return *this;\n      }\n    };\n    ```", "```cpp\n    #include <conio.h>\n    #include \"Terrain.h\"\n\n    using namespace std;\n\n    int main()\n    {\n      CTerrain Terrain1,Terrain2;\n\n      Terrain1 = Terrain2;\n\n      CTerrain Terrain3 = Terrain1;\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include \"vector3.h\"\n    #include <conio.h>\n    #include \"vld.h\"\n\n    int main()\n    {\n      // Vector tests:\n\n      // Create two vectors.\n      CVector3 a(1.0f, 2.0f, 3.0f);\n      CVector3 b(1.0f, 2.0f, 3.0f);\n\n      CVector3 c;\n\n      // Zero Vector.\n      c.Zero();\n\n      // Addition.\n      CVector3 d = a + b;\n\n      // Subtraction.\n      CVector3 e = a - b;\n\n      //Scalar Multiplication.\n      CVector3 f1 = a * 10;\n\n      //Scalar Multiplication.\n      CVector3 f2 = 10 * a;\n\n      //Scalar Division.\n      CVector3 g = a / 10;\n\n      // Unary minus.\n      CVector3 h = -a;\n\n      // Relational Operators.\n      bool bAEqualsB = (a == b);\n      bool bANotEqualsB = (a != b);\n\n      // Combined operations +=.\n      c = a;\n      c += a;\n\n      // Combined operations -=.\n      c = a;\n      c -= a;\n\n      // Combined operations /=.\n      c = a;\n      c /= 10;\n\n      // Combined operations *=.\n      c = a;\n      c *= 10;\n\n      // Normalization.\n      c.Normalize();\n\n      // Dot Product.\n      float fADotB = a * b;\n\n      // Magnitude.\n      float fMag1 = CVector3::Magnitude(a);\n      float fMag2 = CVector3::Magnitude(c);\n\n      // Cross product.\n      CVector3 crossProduct = CVector3::CrossProduct(a, c);\n\n      // Distance.\n      float distance = CVector3::Distance(a, c);\n\n      _getch();\n      return (0);\n\n    }\n    ```", "```cpp\n    #ifndef __VECTOR3_H__\n    #define __VECTOR3_H__\n\n    #include <cmath>\n\n    class CVector3\n    {\n    public:\n      // Public representation: Not many options here.\n      float x;\n      float y;\n      float z;\n\n      CVector3();\n      CVector3(const CVector3& _kr);\n      CVector3(float _fx, float _fy, float _fz);\n\n      // Assignment operator.\n      CVector3& operator =(const CVector3& _kr);\n\n      // Relational operators.\n      bool operator ==(const CVector3& _kr) const;\n      bool operator !=(const CVector3& _kr) const;\n\n      // Vector operations\n      void Zero();\n\n      CVector3 operator -() const;\n      CVector3 operator +(const CVector3& _kr) const;\n      CVector3 operator -(const CVector3& _kr) const;\n\n      // Multiplication and division by scalar.\n      CVector3 operator *(float _f) const;\n      CVector3 operator /(float _f) const;\n\n      // Combined assignment operators to conform to C notation convention.\n      CVector3& operator +=(const CVector3& _kr);\n      CVector3& operator -=(const CVector3& _kr);\n      CVector3& operator *=(float _f);\n      CVector3& operator /=(float _f);\n\n      // Normalize the vector\n      void Normalize();\n      // Vector dot product.\n      // We overload the standard multiplication symbol to do this.\n      float operator *(const CVector3& _kr) const;\n\n      // Static member functions.\n\n      // Compute the magnitude of a vector.\n      static inline float Magnitude(const CVector3& _kr)\n      {\n        return (sqrt(_kr.x * _kr.x + _kr.y * _kr.y + _kr.z * _kr.z));\n      }\n\n      // Compute the cross product of two vectors.\n      static inline CVector3 CrossProduct(const CVector3& _krA,\n        const CVector3& _krB)\n      {\n        return\n          (\n          CVector3(_krA.y * _krB.z - _krA.z * _krB.y,\n          _krA.z * _krB.x - _krA.x * _krB.z,\n          _krA.x * _krB.y - _krA.y * _krB.x)\n          );\n      }\n\n      // Compute the distance between two points.\n      static inline float Distance(const CVector3& _krA, const CVector3& _krB)\n      {\n        float fdx = _krA.x - _krB.x;\n        float fdy = _krA.y - _krB.y;\n        float fdz = _krA.z - _krB.z;\n\n        return sqrt(fdx * fdx + fdy * fdy + fdz * fdz);\n      }\n    };\n\n    // Scalar on the left multiplication, for symmetry.\n    inline CVector3 operator *(float _f, const CVector3& _kr)\n    {\n      return (CVector3(_f * _kr.x, _f * _kr.y, _f * _kr.z));\n    }\n\n    #endif // __VECTOR3_H__\n    ```", "```cpp\n    #include \"vector3.h\"\n\n    // Default constructor leaves vector in an indeterminate state.\n    CVector3::CVector3()\n    {\n\n    }\n\n    // Copy constructor.\n    CVector3::CVector3(const CVector3& _kr)\n    : x(_kr.x)\n    , y(_kr.y)\n    , z(_kr.z)\n    {\n\n    }\n\n    // Construct given three values.\n    CVector3::CVector3(float _fx, float _fy, float _fz)\n    : x(_fx)\n    , y(_fy)\n    , z(_fz)\n    {\n\n    }\n\n    // Assignment operator, we adhere to C convention and return reference to the lvalue.\n    CVector3&\n    CVector3::operator =(const CVector3& _kr)\n    {\n      x = _kr.x;\n      y = _kr.y;\n      z = _kr.z;\n\n      return (*this);\n    }\n\n    // Equality operator.\n    bool\n    CVector3::operator ==(const CVector3&_kr) const\n    {\n      return (x == _kr.x && y == _kr.y && z == _kr.z);\n    }\n\n    // Inequality operator.\n    bool\n    CVector3::operator !=(const CVector3& _kr) const\n    {\n      return (x != _kr.x || y != _kr.y || z != _kr.z);\n    }\n\n    // Set the vector to zero.\n    void\n    CVector3::Zero()\n    {\n      x = 0.0f;\n      y = 0.0f;\n      z = 0.0f;\n    }\n\n    // Unary minus returns the negative of the vector.\n    CVector3\n    CVector3::operator -() const\n    {\n      return (CVector3(-x, -y, -z));\n    }\n\n    // Binary +, add vectors.\n    CVector3\n    CVector3::operator +(const CVector3& _kr) const\n    {\n      return (CVector3(x + _kr.x, y + _kr.y, z + _kr.z));\n    }\n\n    // Binary \u2013, subtract vectors.\n    CVector3\n    CVector3::operator -(const CVector3& _kr) const\n    {\n      return (CVector3(x - _kr.x, y - _kr.y, z - _kr.z));\n    }\n\n    // Multiplication by scalar.\n    CVector3\n    CVector3::operator *(float _f) const\n    {\n      return (CVector3(x * _f, y * _f, z * _f));\n    }\n\n    // Division by scalar.\n    // Precondition: _f must not be zero.\n    CVector3\n    CVector3::operator /(float _f) const\n    {\n      // Warning: no check for divide by zero here.\n      ASSERT(float fOneOverA = 1.0f / _f);\n\n      return (CVector3(x * fOneOverA, y * fOneOverA, z * fOneOverA));\n    }\n\n    CVector3&\n    CVector3::operator +=(const CVector3& _kr)\n    {\n      x += _kr.x;\n      y += _kr.y;\n      z += _kr.z;\n\n      return (*this);\n    }\n\n    CVector3&\n    CVector3::operator -=(const CVector3& _kr)\n    {\n      x -= _kr.x;\n      y -= _kr.y;\n      z -= _kr.z;\n\n      return (*this);\n    }\n\n    CVector3&\n    CVector3::operator *=(float _f)\n    {\n      x *= _f;\n      y *= _f;\n      z *= _f;\n\n      return (*this);\n    }\n\n    CVector3&\n    CVector3::operator /=(float _f)\n    {\n      float fOneOverA = ASSERT(1.0f / _f);\n\n      x *= fOneOverA;\n      y *= fOneOverA;\n      z *= fOneOverA;\n\n      return (*this);\n    }\n\n    void\n    CVector3::Normalize()\n    {\n      float fMagSq = x * x + y * y + z * z;\n\n      if (fMagSq > 0.0f)\n      {\n        // Check for divide-by-zero.\n        float fOneOverMag = 1.0f / sqrt(fMagSq);\n\n        x *= fOneOverMag;\n        y *= fOneOverMag;\n        z *= fOneOverMag;\n      }\n    }\n\n    // Vector dot product.\n    //    We overload the standard multiplication symbol to do this.\n    float\n    CVector3::operator *(const CVector3& _kr) const\n    {\n      return (x * _kr.x + y * _kr.y + z * _kr.z);\n    }\n    ```", "```cpp\n(Member Access or Dot operator),?: (Ternary or Conditional Operator),:: (Scope Resolution Operator),.* (Pointer-to-member Operator),sizeof (Object size Operator) and typeid (Object type Operator)\n```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n    #include \"CSpeed.h\"\n\n    using namespace std;\n\n    //This is not overloading as the function differs only\n    //in return type\n    /*int Add(float x, float y)\n    {\n      return x + y;\n    }*/\n\n    int main()\n    {\n      CSpeed speed;\n\n      cout<<speed.AddSpeed(2.4f, 7.9f)<<endl;\n      cout << speed.AddSpeed(4, 5)<<endl;\n      cout << speed.AddSpeed(4, 9, 12)<<endl;\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include \"CSpeed.h\"\n\n    CSpeed::CSpeed()\n    {\n\n    }\n\n    CSpeed::~CSpeed()\n    {\n\n    }\n    int CSpeed::AddSpeed(int x, int y, int z)\n    {\n      return x + y + z;\n    }\n    int CSpeed::AddSpeed(int x, int y)\n    {\n      return x + y;\n    }\n    float CSpeed::AddSpeed(float x, float y)\n    {\n      return x + y;\n    }\n    ```", "```cpp\n    #ifndef _VELOCITY_H\n    #define _VELOCITY_H\n\n    class CSpeed\n    {\n    public:\n      int AddSpeed(int x, int y, int z);\n      int AddSpeed(int x, int y);\n      float AddSpeed(float x, float y);\n\n      CSpeed();\n      ~CSpeed();\n    private:\n\n    };\n\n    #endif\n    ```", "```cpp\n    #include <conio.h>\n    #include \"File.h\"\n\n    int main() {\n\n      CFile file;\n\n      file.WriteNewFile(\"Example.txt\");\n      file.WriteNewFile(\"Example.txt\", \"Logging text1\");\n      file.AppendFile(\"Example.txt\", \"Logging text2\");\n      file.ReadFile(\"Example.txt\");\n\n      _getch();\n      return 0;\n    }\n    ```", "```cpp\n    #include \"File.h\"\n    #include <string>\n    #include <fstream>\n    #include <iostream>\n\n    using namespace std;\n\n    CFile::CFile()\n    {\n      Text = \"This is the initial data\";\n    }\n    CFile::~CFile()\n    {\n\n    }\n    void CFile::WriteNewFile(string Filename)const\n    {\n      ofstream myfile(Filename);\n      if (myfile.is_open())\n      {\n        myfile << Text;\n\n        myfile.close();\n      }\n      else cout << \"Unable to open file\";\n    }\n    void CFile::WriteNewFile(string Filename,string Text)const\n    {\n      ofstream myfile(Filename);\n      if (myfile.is_open())\n      {\n        myfile << Text;\n\n        myfile.close();\n      }\n      else cout << \"Unable to open file\";\n    }\n\n    void CFile::AppendFile(string Filename, string Text)const\n    {\n      ofstream outfile;\n\n      outfile.open(Filename, ios_base::app);\n      outfile << Text;\n           outfile.close();\n\n    }\n    void CFile::ReadFile(string Filename)const\n    {\n      string line;\n      ifstream myfile(Filename);\n      if (myfile.is_open())\n      {\n        while (getline(myfile, line))\n        {\n          cout << line << '\\n';\n        }\n        myfile.close();\n      }\n\n      else cout << \"Unable to open file\";\n    }\n    ```", "```cpp\n    #ifndef _FILE_H\n    #define _FILE_H\n\n    #include <iostream>\n    #include <string.h>\n    using namespace std;\n\n    class CFile\n    {\n    public:\n      CFile();\n      ~CFile();\n\n      void WriteNewFile(string Filename)const;\n      void WriteNewFile(string Filename, string Text)const;\n      void AppendFile(string Filename, string Text)const;\n      void ReadFile(string Filename)const;\n    private:\n\n      string Text;\n    };\n    #endif\n    ```", "```cpp\n    #include <iostream>\n    #include <cstdlib>\n    #include <ctime>\n\n    int main(void) {\n      srand(time(NULL)); // To not have the same numbers over and over again.\n\n      while (true) { // Main loop.\n        // Initialize and allocate.\n        int inumber = rand() % 100 + 1 // System number is stored in here.\n        int iguess; // User guess is stored in here.\n        int itries = 0; // Number of tries is stored here.\n        char canswer; // User answer to question is stored here.\n\n        while (true) { // Get user number loop.\n          // Get number.\n          std::cout << \"Enter a number between 1 and 100 (\" << 20 - itries << \" tries left): \";\n          std::cin >> iguess;\n          std::cin.ignore();\n\n          // Check is tries are taken up.\n          if (itries >= 20) {\n            break;\n          }\n\n          // Check number.\n          if (iguess > inumber) {\n            std::cout << \"Too high! Try again.\\n\";\n          }\n          else if (iguess < inumber) {\n            std::cout << \"Too low! Try again.\\n\";\n          }\n          else {\n            break;\n          }\n\n          // If not number, increment tries.\n          itries++;\n        }\n\n        // Check for tries.\n        if (itries >= 20) {\n          std::cout << \"You ran out of tries!\\n\\n\";\n        }\n        else {\n          // Or, user won.\n          std::cout << \"Congratulations!! \" << std::endl;\n          std::cout << \"You got the right number in \" << itries << \" tries!\\n\";\n        }\n\n        while (true) { // Loop to ask user is he/she would like to play again.\n          // Get user response.\n          std::cout << \"Would you like to play again (Y/N)? \";\n          std::cin >> canswer;\n          std::cin.ignore();\n\n          // Check if proper response.\n          if (canswer == 'n' || canswer == 'N' || canswer == 'y' || canswer == 'Y') {\n            break;\n          }\n          else {\n            std::cout << \"Please enter \\'Y\\' or \\'N\\'...\\n\";\n          }\n        }\n\n        // Check user's input and run again or exit;\n        if (canswer == 'n' || canswer == 'N') {\n          std::cout << \"Thank you for playing!\";\n          break;\n        }\n        else {\n          std::cout << \"\\n\\n\\n\";\n        }\n      }\n\n      // Safely exit.\n      std::cout << \"\\n\\nEnter anything to exit. . . \";\n      std::cin.ignore();\n      return 0;\n    }\n    ```", "```cpp\n    #include <iostream>\n    #include <conio.h>\n    #include <string>\n    #include \"Stack.h\"\n\n    using namespace std;\n\n    template<class T>\n    void Print(T array[], int array_size)\n    {\n      for (int nIndex = 0; nIndex < array_size; ++nIndex)\n      {  \n        cout << array[nIndex] << \"\\t\";\n      }\n      cout << endl;\n    }\n\n    int main()\n    {\n      int iArray[5] = { 4, 5, 6, 6, 7 };\n      char cArray[3] = { 's', 's', 'b' };\n      string sArray[3] = { \"Kratos\", \"Dr.Evil\", \"Mario\" };\n\n      //Printing any type of elements\n      Print(iArray, sizeof(iArray) / sizeof(*iArray));\n      Print(cArray, sizeof(cArray) / sizeof(*cArray));\n      Print(sArray, sizeof(sArray) / sizeof(*sArray));\n\n      Stack<int> iStack;\n\n      //Pushes an element to the bottom of the stack\n      iStack.push(7);\n\n      cout << iStack.top() << endl;\n\n      for (int i = 0; i < 10; i++)\n      {\n        iStack.push(i);\n      }\n\n      //Removes an element from the top of the stack\n      iStack.pop();\n\n      //Prints the top of stack\n      cout << iStack.top() << endl;\n\n      _getch();\n    }\n    ```", "```cpp\n    #include <vector>\n\n    using namespace std;\n\n    template <class T>\n    class Stack {\n    private:\n      vector<T> elements;     // elements\n\n    public:\n      void push(T const&);  // push element\n      void pop();               // pop element\n      T top() const;            // return top element\n      bool empty() const{       // return true if empty.\n        return elements.empty();\n      }\n    };\n\n    template <class T>\n    void Stack<T>::push(T const& elem)\n    {\n      // append copy of passed element\n      elements.push_back(elem);\n    }\n\n    template <class T>\n    void Stack<T>::pop()\n    {\n      if (elements.empty()) {\n        throw out_of_range(\"Stack<>::pop(): empty stack\");\n      }\n      // remove last element\n      elements.pop_back();\n    }\n\n    template <class T>\n    T Stack<T>::top() const\n    {\n      if (elements.empty()) {\n        throw out_of_range(\"Stack<>::top(): empty stack\");\n      }\n      // return copy of last element\n      return elements.back();\n    }\n    ```"]