["```cpp\ntypedef signed short PCM16;\ntypedef unsigned int U32;\ntypedef unsigned short U16;\n```", "```cpp\ncount = sampling rate * duration * channels\n```", "```cpp\n// 1 second of audio data at 44100 Hz (Mono)\n// count = 44100 Hz * 1 second * 1 channel\nPCM16 data[44100];\n```", "```cpp\n// 1 second of audio data at 44100 Hz (Stereo)\n// data[0] = left, data[1] = right, data[2] = left, etc.\n// count = 44100 Hz * 1 second * 2 channels\nPCM16 data[88200];\n```", "```cpp\n// Create and initialize a sound info structure\nFMOD_CREATESOUNDEXINFO info;\nmemset(&info, 0, sizeof(FMOD_CREATESOUNDEXINFO));\ninfo.cbsize = sizeof(FMOD_CREATESOUNDEXINFO);\n\n// Specify sampling rate, format, and number of channels to use\n// In this case, 44100 Hz, signed 16-bit PCM, Stereo\ninfo.defaultfrequency = 44100;\ninfo.format = FMOD_SOUND_FORMAT_PCM16;\ninfo.numchannels = 2;\n\n// Size of the entire sound in bytes. Since the sound will be\n// looping, it does not need to be too long. In this example\n// we will be using the equivalent of a 5 seconds sound.\n// i.e. sampleRate * channels * bytesPerSample * durationInSeconds\ninfo.length = 44100 * 2 * sizeof(signed short) * 5;\n\n// Number of samples we will be submitting at a time\n// A smaller value results in less latency between operations\n// but if it is too small we get problems in the sound\n// In this case we will aim for a latency of 100ms\n// i.e. sampleRate * durationInSeconds = 44100 * 0.1 = 4410\ninfo.decodebuffersize = 4410;\n\n// Specify the callback function that will provide the audio data\ninfo.pcmreadcallback = WriteSoundData;\n```", "```cpp\n// Create a looping stream with FMOD_OPENUSER and the info we filled \nFMOD::Sound* sound;\nFMOD_MODE mode = FMOD_LOOP_NORMAL | FMOD_OPENUSER;\nsystem->createStream(0, mode, &info, &sound);\nsystem->playSound(FMOD_CHANNEL_FREE, sound, false, 0);\n```", "```cpp\nFMOD_RESULT F_CALLBACK\nWriteSoundData(FMOD_SOUND* sound, void* data, unsigned int length) {\n  // Cast data pointer to the appropriate format (in this case PCM16)\n  PCM16* pcmData = (PCM16*)data;\n\n  // Calculate how many samples can fit in the data array\n  // In this case, since each sample has 2 bytes, we divide\n  // length by 2\n  int pcmDataCount = length / 2;\n\n  // Output 0 in every sample\n  for(int i = 0; i < pcmDataCount; ++i) {\n    pcmData[i] = 0;\n  }\n\n  return FMOD_OK;\n}\n```", "```cpp\nclass MySound {\n public:\n  MySound(const char* path);\n  ~MySound();\n\n  U32 samplingRate;\n  U16 numChannels;\n  U16 bitsPerSample;\n  PCM16* data;\n  U32 count;\n};\n```", "```cpp\n#include <iostream>\n#include <fstream>\n\nMySound::MySound(const char* path) {\n  // Open file stream for input as binary\n  std::ifstream file(path, std::ios::in | std::ios::binary);\n\n  // Read number of channels and sample rate\n  file.seekg(22);\n  file.read((char*)&numChannels, 2);\n  file.read((char*)&samplingRate, 4);\n\n  // Read bits per sample\n  file.seekg(34);\n  file.read((char*)&bitsPerSample, 2);\n\n  // Read size of data in bytes\n  U32 length;\n  file.seekg(40);\n  file.read((char*)&length, 4);\n\n  // Allocate array to hold all the data as PCM samples\n  count = length / 2;\n  data = new PCM16[count];\n\n  // Read PCM data\n  file.read((char*)data, length);\n}\n```", "```cpp\nMySound::~MySound() {\n  delete[] data;\n}\n```", "```cpp\nclass MyChannel {\n public:\n  MyChannel() : sound(0), position(0) {}\n  void Play(MySound* mySound);\n  void Stop();\n  void WriteSoundData(PCM16* data, int count);\n\n private:\n  MySound* sound;\n  int position;\n};\n```", "```cpp\nvoid MyChannel::Play(MySound* mySound) {\n  sound = mySound;\n  position = 0;\n}\n```", "```cpp\nvoid MyChannel::Stop() {\n  sound = 0;\n}\n```", "```cpp\nvoid MyChannel::WriteSoundData(PCM16* data, int count) {\n  // If there is no sound assigned to the channel do nothing  \n  if(sound == 0) return;\n\n  // We need to write \"count\" samples to the \"data\" array\n  // Since output is stereo it is easier to advance in pairs\n  for (int i = 0; i < count; i += 2) {\n\n    // If we have reached the end of the sound, stop and return\n    if(position >= sound->count) {\n      Stop();\n      return;\n    }\n\n    // Read value from the sound data at the current position\n    PCM16 value = sound->data[position];\n\n    // Write value to both the left and right channels\n    data[i] = value;\n    data[i+1] = value;\n\n    // Advance the position by one sample\n    ++position;\n  }\n}\n```", "```cpp\nMyChannel channel;\n\nFMOD_RESULT F_CALLBACK \nWriteSoundData(FMOD_SOUND *sound, void *data, unsigned int length) {\n  // Clear output\n  memset(data, 0, length);\n\n  // Get data in the correct format and calculate sample count\n  PCM16* pcmData = (PCM16*)data;\n  int pcmDataCount = length / 2;\n\n  // Tell the channel to write to the output\n  channel.WriteSoundData(pcmData, pcmDataCount);\n\n  return FMOD_OK;\n}\n```", "```cpp\nMySound* sound = new MySound(\"explosion.wav\");\nchannel.Play(sound);\n```", "```cpp\npublic:\n  bool GetPaused() const { return paused; }\n  void SetPaused(bool value) { paused = value }\nprivate:\n  bool paused;\n```", "```cpp\nvoid MyChannel::WriteSoundData(PCM16* data, int count) {\n  if(sound == 0 || paused) return;\n  for (int i = 0; i < count; i += 2) {\n    if(position >= sound->count) {\n      Stop();\n      return;\n    }\n    PCM16 value = sound->data[position];\n    data[i] = value;\n    data[i+1] = value;\n    ++position;\n  }\n}    \n```", "```cpp\npublic:\n  bool GetLoop() const { return loop; }\n  void SetLoop(bool value) { loop = value }\nprivate:\n  bool loop;\n```", "```cpp\nvoid MyChannel::WriteSoundData(PCM16* data, int count) {\n  if(sound == 0 || paused) return;\n  for (int i = 0; i < count; i += 2) {\n    if(position >= sound->count) {\n      if(loop) {\n        position = 0;\n      } else {\n        Stop();\n        return;\n      }\n    }\n    PCM16 value = sound->data[position];\n    data[i] = value;\n    data[i+1] = value;\n    ++position;\n  }\n}\n```", "```cpp\npublic:\n  float GetVolume() const { return volume; }\n  void SetVolume(float value) {\n    if(value < 0.0f) volume = 0.0f;\n    else if(value > 1.0f) volume = 1.0f;\n    else volume = value;\n  }\nprivate:\n  float volume;\n```", "```cpp\nvoid MyChannel::WriteSoundData(PCM16* data, int count) {\n  if(sound == 0 || paused) return;\n  for (int i = 0; i < count; i += 2) {\n    if(position >= sound->count) {\n      if(loop) {\n        position = 0;\n      } else {\n        Stop();\n        return;\n      }\n    }\n    PCM16 value = (PCM16)(sound->data[position] * volume);\n    data[i] = value;\n    data[i+1] = value;\n    ++position;\n  }\n}\n```", "```cpp\npublic:\n  float GetPitch() const { return pitch; }\n  void SetPitch(float value) {\n    if(value < 0.25f) pitch = 0.25f;\n    else if(value > 4.0f) pitch = 4.0f;\n    else pitch = value;\n  }\nprivate:\n  float position;\n  float pitch;\n```", "```cpp\nvoid MyChannel::WriteSoundData(PCM16* data, int count) {\n  if(sound == 0 || paused) return;\n  for (int i = 0; i < count; i += 2) {\n    if(position >= sound->count) {\n      if(loop) {\n        position = 0;\n      } else {\n        Stop();\n        return;\n      }\n    }\n    PCM16 value = (PCM16)(sound->data[(int)position] * volume);\n    data[i] = value;\n    data[i+1] = value;\n    position += pitch;\n  }\n} \n```", "```cpp\nprivate:\n  float leftGain;\n  float rightGain;\n```", "```cpp\nvoid MyChannel::WriteSoundData(PCM16* data, int count) {\n  if(sound == 0 || paused) return;\n  for (int i = 0; i < count; i += 2) {\n    if(position >= sound->count) {\n      if(loop) {\n        position = 0;\n      } else {\n        Stop();\n        return;\n      }\n    }\n    float value = sound->data[(int)position] * volume;\n    data[i] = (PCM16)(value * leftGain);\n    data[i+1] = (PCM16)(value * rightGain);\n    position += pitch;\n  }\n}\n```", "```cpp\npublic:\n  float GetPan() const { return pan; }\n  void SetPan(float value) {\n    if(value < -1.0f) pan = -1.0f;\n    else if(value > 1.0f) pan = 1.0f;\n    else pan = value;\n    UpdatePan();\n  }\nprivate:\n  void UpdatePan();\n  float pan;\n```", "```cpp\n// Linear panning\nvoid MyChannel::UpdatePan() {\n  float position = pan * 0.5f;\n  leftGain = 0.5f - position;\n  rightGain = position + 0.5f;\n}\n```", "```cpp\n#include <math.h>\n\n#define PI_4 0.78539816339      // PI/4\n#define SQRT2_2 0.70710678118   // SQRT(2)/2\n\n// Constant-power panning\nvoid MyChannel::UpdatePan() {\n  double angle = pan * PI_4;\n  leftGain = (float)(SQRT2_2 * (cos(angle) - sin(angle)));\n  rightGain = (float)(SQRT2_2 * (cos(angle) + sin(angle)));\n}\n```", "```cpp\nvoid MyChannel::WriteSoundData(PCM16* data, int count) {\n  if(sound == 0 || paused) return;\n  for (int i = 0; i < count; i += 2) {\n    if(position >= sound->count) {\n      if(loop) {\n        position = 0;\n      } else {\n        Stop();\n        return;\n      }\n    }\n    float value = sound->data[(int)position] * volume;\n    data[i] = (PCM16)(value * leftGain + data[i]);\n    data[i+1] = (PCM16)(value * rightGain + data[i+1]);\n    position += pitch;\n  }\n}  \n```", "```cpp\nstd::vector<MyChannel> channels;\n\nFMOD_RESULT F_CALLBACK \nWriteSoundData(FMOD_SOUND *sound, void *data, unsigned int length) {\n  // Clear output\n  memset(data, 0, length);\n\n  // Get data in the correct format and calculate sample count\n  PCM16* pcmData = (PCM16*)data;\n  int pcmDataCount = length / 2;\n\n  // Tell every channel to write to the output\n  for(int i = 0; i < channels.size(); ++i)\n    channels[i].WriteSoundData(pcmData, pcmDataCount);\n\n  return FMOD_OK;\n}\n```", "```cpp\nclass MyDelay {\npublic:\n  MyDelay(float time, float decay);\n  ~MyDelay();\n  void WriteSoundData(PCM16* data, int count);\n\nprivate:\n  PCM16* buffer;\n  int size;\n  int position;\n  float decay;\n};\n```", "```cpp\nMyDelay::MyDelay(float time, float decay) : position(0), decay(decay)\n{\n  size = (int)(time * 44100);\n  buffer = new PCM16[size];\n  memset(buffer, 0, size * 2);\n}\n```", "```cpp\nMyDelay::~MyDelay() {\n  delete[] buffer;\n}\n```", "```cpp\nvoid MyDelay::WriteSoundData(PCM16* data, int count) {\n  for (int i = 0; i < count; ++i) {\n    // Mix sample with the one stored in the buffer at position\n    data[i] = (PCM16)(data[i] + buffer[position] * decay);\n\n    // Record this new value in the buffer at position\n    buffer[position] = data[i];\n\n    // Increment buffer position wrapping around\n    ++position;\n    if(position >= size)\n      position = 0;\n  }\n}\n```", "```cpp\n// When the application starts\nMyDelay* delay = new MyDelay(1.0f, 0.50f);\n\n// Inside the audio callback\nfor(int i = 0; i < channels.size(); ++i)\n  channels[i].WriteSoundData(pcmData, pcmDataCount);\ndelay->WriteSoundData(pcmData, pcmDataCount);\n```", "```cpp\n#include <math.h>\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nclass MyOscillator {\n public:\n  MyOscillator();\n  void SetVolume(double value) { volume = value; }  \n  void SetFrequency(double frequency);\n  void WriteSoundData(PCM16* data, int count);\n\n private:\n  double phase;\n  double increment;\n  double volume;\n};\n```", "```cpp\nMyOscillator::MyOscillator() : phase(0.0), volume(0.5) {\n  SetFrequency(440.0);\n}\n```", "```cpp\nvoid MyOscillator::SetFrequency(double frequency) {\n  increment = frequency / 44100.0 * TWO_PI;\n}\n```", "```cpp\nvoid WriteSoundData(PCM16* data, int count) {\n  for(int i = 0; i < count; i += 2) {\n    // Calculate sample value\n    double value = sine_wave(phase) * 32767.0 * volume;\n\n    // Mix sample with output\n    data[i] = (PCM16)(data[i] + value);\n    data[i+1] = (PCM16)(data[i+1] + value);\n\n    // Increment phase\n    phase += increment;\n\n    // Wrap phase to the 0-2PI range\n    if(phase >= TWO_PI)\n      phase -= TWO_PI;\n  }\n}\n```", "```cpp\ndouble sine_wave(double phase) {\n  return sin(phase);\n}\n\ndouble square_wave(double phase) {\n  return phase <= PI ? 1.0 : -1.0;\n}\n\ndouble downward_sawtooth_wave(double phase) {\n  return 1.0 - 2.0 * (phase / TWO_PI);\n}\ndouble upward_sawtooth_wave(double phase) {\n  return 2.0 * (phase / TWO_PI) - 1.0;\n}\n\ndouble triangle_wave(double phase) {\n  double result = upward_sawtooth_wave(phase);\n  if(result < 0.0)\n    result = -result;\n  return 2.0 * (result - 0.5);\n}\n```"]