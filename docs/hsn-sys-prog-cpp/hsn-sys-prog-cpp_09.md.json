["```cpp\nmyallocator<myclass> myalloc1;\nmyallocator<myclass> myalloc2;\n\nauto ptr = myalloc1.allocate(1);\nmyalloc2.deallocate(ptr, 1);\n```", "```cpp\nmyalloc1 == myalloc2; // true\n```", "```cpp\ntemplate<typename T>\nclass myallocator\n{\npublic:\n\n using value_type = T;\n using pointer = T *;\n using size_type = std::size_t;\n\npublic:\n\n myallocator() = default;\n\n template <typename U>\n myallocator(const myallocator<U> &other) noexcept\n { (void) other; }\n\n pointer allocate(size_type n)\n {\n if (auto ptr = static_cast<pointer>(malloc(sizeof(T) * n))) {\n return ptr;\n }\n\n throw std::bad_alloc();\n }\n\n void deallocate(pointer p, size_type n)\n { (void) n; return free(p); }\n};\n\ntemplate <typename T1, typename T2>\nbool operator==(const myallocator<T1> &, const myallocator<T2> &)\n{ return true; }\n\ntemplate <typename T1, typename T2>\nbool operator!=(const myallocator<T1> &, const myallocator<T2> &)\n{ return false; }\n```", "```cpp\ntemplate<typename T>\nclass myallocator\n```", "```cpp\nusing value_type = T;\nusing pointer = T *;\nusing size_type = std::size_t;\n```", "```cpp\nusing value_type = T;\n```", "```cpp\nusing value_type = T;\nusing pointer = T *;\nusing const_pointer = const T *;\nusing void_pointer = void *;\nusing const_void_pointer = const void *;\nusing size_type = std::size_t;\nusing difference_type = std::ptrdiff_t;\n```", "```cpp\npointer allocate(size_type n)\n{\n    if (auto ptr = static_cast<pointer>(malloc(sizeof(T) * n))) {\n        return ptr;\n    }\n\n    throw std::bad_alloc();\n}\n```", "```cpp\nvoid deallocate(pointer p, size_type n)\n{ (void) n; free(p); }\n```", "```cpp\ntemplate <typename U>\nmyallocator(const myallocator<U> &other) noexcept\n{ (void) other; }\n```", "```cpp\nstd::list<myclass, myallocator<myclass>> mylist;\n```", "```cpp\ntemplate <typename T1, typename T2>\nbool operator==(const myallocator<T1> &, const myallocator<T2> &)\n{ return true; }\n\ntemplate <typename T1, typename T2>\nbool operator!=(const myallocator<T1> &, const myallocator<T2> &)\n{ return false; }\n```", "```cpp\nmyallocator<int> myalloc1;\nmyallocator<int> myalloc2;\n\nauto ptr = myalloc1.allocate(1);\nmyalloc2.deallocate(ptr, 1);\n```", "```cpp\nmyallocator<myclass> myalloc;\n\nmyclass *ptr = myalloc.allocate(1);\nconst myclass *cptr = myalloc.allocate(1);\n\nstd::cout << (*ptr).data1 << '\\n';\nstd::cout << (*cptr).data2 << '\\n';\n\nstd::cout << ptr->data1 << '\\n';\nstd::cout << cptr->data2 << '\\n';\n\n// 0\n// 32644\n// 0\n// 32644\n```", "```cpp\nmyallocator<myclass> myalloc1;\nmyallocator<myclass> myalloc2;\n\nstd::cout << std::boolalpha;\nstd::cout << (myalloc1 == myalloc2) << '\\n';\nstd::cout << (myalloc1 != myalloc2) << '\\n';\n\n// true\n// false\n```", "```cpp\nusing is_always_equal = std::true_type;\n```", "```cpp\ntemplate<typename T>\nclass myallocator\n{\npublic:\n\n    using value_type = T;\n    using pointer = T *;\n    using size_type = std::size_t;\n    using is_always_equal = std::true_type;\n\npublic:\n\n    myallocator()\n    {\n        std::cout << this << \" constructor, sizeof(T): \"\n                  << sizeof(T) << '\\n';\n    }\n\n    template <typename U>\n    myallocator(const myallocator<U> &other) noexcept\n    { (void) other; }\n\n    pointer allocate(size_type n)\n    {\n        if (auto ptr = static_cast<pointer>(malloc(sizeof(T) * n))) {\n            std::cout << this << \" A [\" << n << \"]: \" << ptr << '\\n';\n            return ptr;\n        }\n\n        throw std::bad_alloc();\n    }\n\n    void deallocate(pointer p, size_type n)\n    {\n        (void) n;\n\n        std::cout << this << \" D [\" << n << \"]: \" << p << '\\n';\n        free(p);\n    }\n};\n\ntemplate <typename T1, typename T2>\nbool operator==(const myallocator<T1> &, const myallocator<T2> &)\n{ return true; }\n\ntemplate <typename T1, typename T2>\nbool operator!=(const myallocator<T1> &, const myallocator<T2> &)\n{ return false; }\n```", "```cpp\nstd::list<int, myallocator<int>> mylist;\nmylist.emplace_back(42);\n\n// 0x7ffe97b0e8e0 constructor, sizeof(T): 24\n// 0x7ffe97b0e8e0 A [1]: 0x55c0793e8580\n// 0x7ffe97b0e8e0 D [1]: 0x55c0793e8580\n```", "```cpp\nstd::vector<int, myallocator<int>> myvector;\nmyvector.emplace_back(42);\nmyvector.emplace_back(42);\nmyvector.emplace_back(42);\n\n// 0x7ffe1db8e2d0 constructor, sizeof(T): 4\n// 0x7ffe1db8e2d0 A [1]: 0x55bf9dbdd550\n// 0x7ffe1db8e2d0 A [2]: 0x55bf9dbebe90\n// 0x7ffe1db8e2d0 D [1]: 0x55bf9dbdd550\n// 0x7ffe1db8e2d0 A [4]: 0x55bf9dbdd550\n// 0x7ffe1db8e2d0 D [2]: 0x55bf9dbebe90\n// 0x7ffe1db8e2d0 D [4]: 0x55bf9dbdd550\n```", "```cpp\nstd::deque<int, myallocator<int>> mydeque;\nmydeque.emplace_back(42);\nmydeque.emplace_back(42);\nmydeque.emplace_back(42);\n\n// constructor, sizeof(T): 4\n// 0x7ffdea986e67 A [8]: 0x55d6822b0da0\n// 0x7ffdea986f30 A [128]: 0x55d6822afaf0\n// 0x7ffdea986f30 D [128]: 0x55d6822afaf0\n// 0x7ffdea986e67 D [8]: 0x55d6822b0da0\n```", "```cpp\nstd::deque<int, myallocator<int>> mydeque;\n\nfor (auto i = 0; i < 127; i++)\n    mydeque.emplace_back(42);\n\nfor (auto i = 0; i < 127; i++)\n    mydeque.emplace_back(42);\n\nfor (auto i = 0; i < 127; i++)\n    mydeque.emplace_back(42);\n\n// constructor, sizeof(T): 4\n// 0x7ffc5926b1b7 A [8]: 0x560285cc0da0\n// 0x7ffc5926b280 A [128]: 0x560285cbfaf0\n// 0x7ffc5926b280 A [128]: 0x560285cc1660\n// 0x7ffc5926b280 A [128]: 0x560285cc1bc0\n// 0x7ffc5926b280 D [128]: 0x560285cbfaf0\n// 0x7ffc5926b280 D [128]: 0x560285cc1660\n// 0x7ffc5926b280 D [128]: 0x560285cc1bc0\n// 0x7ffc5926b1b7 D [8]: 0x560285cc0da0\n```", "```cpp\nmyallocator(myallocator &&other) noexcept\n{\n    (void) other;\n    std::cout << this << \" move constructor, sizeof(T): \"\n                << sizeof(T) << '\\n';\n}\n\nmyallocator &operator=(myallocator &&other) noexcept\n{\n    (void) other;\n    std::cout << this << \" move assignment, sizeof(T): \"\n                << sizeof(T) << '\\n';\n    return *this;\n}\n\nmyallocator(const myallocator &other) noexcept\n{\n    (void) other;\n    std::cout << this << \" copy constructor, sizeof(T): \"\n                << sizeof(T) << '\\n';\n}\n\nmyallocator &operator=(const myallocator &other) noexcept\n{\n    (void) other;\n    std::cout << this << \" copy assignment, sizeof(T): \"\n                << sizeof(T) << '\\n';\n    return *this;\n}\n```", "```cpp\nstd::list<int, myallocator<int>> mylist1;\nstd::list<int, myallocator<int>> mylist2;\n\nmylist1.emplace_back(42);\nmylist1.emplace_back(42);\n\nstd::cout << \"----------------------------------------\\n\";\nmylist2 = mylist1;\nstd::cout << \"----------------------------------------\\n\";\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n```", "```cpp\n0x7fff866d1e50 constructor, sizeof(T): 24\n0x7fff866d1e70 constructor, sizeof(T): 24\n0x7fff866d1e50 A [1]: 0x557c430ec550\n0x7fff866d1e50 A [1]: 0x557c430fae90\n----------------------------------------\n0x7fff866d1d40 copy constructor, sizeof(T): 24\n0x7fff866d1d40 A [1]: 0x557c430e39a0\n0x7fff866d1d40 A [1]: 0x557c430f14a0\n----------------------------------------\n0x7fff866d1e70 A [1]: 0x557c430f3b30\n0x7fff866d1e70 A [1]: 0x557c430ec4d0\n0x7fff866d1e70 D [1]: 0x557c430e39a0\n0x7fff866d1e70 D [1]: 0x557c430f14a0\n0x7fff866d1e70 D [1]: 0x557c430f3b30\n0x7fff866d1e70 D [1]: 0x557c430ec4d0\n0x7fff866d1e50 D [1]: 0x557c430ec550\n0x7fff866d1e50 D [1]: 0x557c430fae90\n```", "```cpp\nstd::list<int, myallocator<int>> mylist1;\nstd::list<int, myallocator<int>> mylist2;\n\nmylist1.emplace_back(42);\nmylist1.emplace_back(42);\n\nstd::cout << \"----------------------------------------\\n\";\nmylist2 = std::move(mylist1);\nstd::cout << \"----------------------------------------\\n\";\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n```", "```cpp\n0x7ffe582e2850 constructor, sizeof(T): 24\n0x7ffe582e2870 constructor, sizeof(T): 24\n0x7ffe582e2850 A [1]: 0x56229562d550\n0x7ffe582e2850 A [1]: 0x56229563be90\n----------------------------------------\n----------------------------------------\n0x7ffe582e2870 A [1]: 0x5622956249a0\n0x7ffe582e2870 A [1]: 0x5622956324a0\n0x7ffe582e2870 D [1]: 0x56229562d550\n0x7ffe582e2870 D [1]: 0x56229563be90\n0x7ffe582e2870 D [1]: 0x5622956249a0\n0x7ffe582e2870 D [1]: 0x5622956324a0\n```", "```cpp\nclass myallocator_object\n{\npublic:\n\n    using size_type = std::size_t;\n\npublic:\n\n    void *allocate(size_type size)\n    {\n        if (auto ptr = malloc(size)) {\n            std::cout << this << \" A \" << ptr << '\\n';\n            return ptr;\n        }\n\n        throw std::bad_alloc();\n    }\n\n    void deallocate(void *ptr)\n    {\n        std::cout << this << \" D \" << ptr << '\\n';\n        free(ptr);\n    }\n};\n```", "```cpp\ntemplate<typename T>\nclass myallocator\n{\n```", "```cpp\npublic:\n\n    using value_type = T;\n    using pointer = T *;\n    using size_type = std::size_t;\n    using is_always_equal = std::false_type;\n```", "```cpp\nmyallocator() :\n    m_object{std::make_shared<myallocator_object>()}\n{\n    std::cout << this << \" constructor, sizeof(T): \"\n                << sizeof(T) << '\\n';\n}\n```", "```cpp\nmyallocator(myallocator &&other) noexcept :\n    m_object{std::move(other.m_object)}\n{\n    std::cout << this << \" move constructor, sizeof(T): \"\n                << sizeof(T) << '\\n';\n}\n\nmyallocator &operator=(myallocator &&other) noexcept\n{\n    std::cout << this << \" move assignment, sizeof(T): \"\n                << sizeof(T) << '\\n';\n\n    m_object = std::move(other.m_object);\n    return *this;\n}\n```", "```cpp\nmyallocator(const myallocator &other) noexcept :\n    m_object{other.m_object}\n{\n    std::cout << this << \" copy constructor, sizeof(T): \"\n                << sizeof(T) << '\\n';\n}\n\nmyallocator &operator=(const myallocator &other) noexcept\n{\n    std::cout << this << \" copy assignment, sizeof(T): \"\n                << sizeof(T) << '\\n';\n\n    m_object = other.m_object;\n    return *this;\n}\n```", "```cpp\ntemplate <typename U>\nmyallocator(const myallocator<U> &other) noexcept :\n    m_object{other.m_object}\n{\n    std::cout << this << \" copy constructor (U), sizeof(T): \"\n                << sizeof(T) << '\\n';\n}\n```", "```cpp\nmyallocator<int> alloc1;\nmyallocator<std::list::node> alloc2(alloc1);\n```", "```cpp\npointer allocate(size_type n)\n{\n    auto ptr = m_object->allocate(sizeof(T) * n);\n    return static_cast<pointer>(ptr);\n}\n\nvoid deallocate(pointer p, size_type n)\n{\n    (void) n;\n    return m_object->deallocate(p);\n}\n```", "```cpp\nstd::shared_ptr<myallocator_object> m_object;\n\ntemplate <typename T1, typename T2>\nfriend bool operator==(const myallocator<T1> &lhs, const myallocator<T2> &rhs);\n\ntemplate <typename T1, typename T2>\nfriend bool operator!=(const myallocator<T1> &lhs, const myallocator<T2> &rhs);\n```", "```cpp\ntemplate <typename T1, typename T2>\nbool operator==(const myallocator<T1> &lhs, const myallocator<T2> &rhs)\n{ return lhs.m_object.get() == rhs.m_object.get(); }\n\ntemplate <typename T1, typename T2>\nbool operator!=(const myallocator<T1> &lhs, const myallocator<T2> &rhs)\n{ return lhs.m_object.get() != rhs.m_object.get(); }\n```", "```cpp\nstd::list<int, myallocator<int>> mylist;\nmylist.emplace_back(42);\n\n// 0x7ffce60fbd10 constructor, sizeof(T): 24\n// 0x561feb431590 A [1]: 0x561feb43fec0\n// 0x561feb431590 D [1]: 0x561feb43fec0\n```", "```cpp\nstd::list<int, myallocator<int>> mylist1;\nstd::list<int, myallocator<int>> mylist2;\n\nmylist1.emplace_back(42);\nmylist1.emplace_back(42);\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n\nstd::cout << \"----------------------------------------\\n\";\nmylist2 = mylist1;\nstd::cout << \"----------------------------------------\\n\";\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n```", "```cpp\n// 0x7ffd65a15cb0 constructor, sizeof(T): 24\n// 0x7ffd65a15ce0 constructor, sizeof(T): 24\n// 0x55c4867c3a80 A [1]: 0x55c4867b9210  <--- add to list #1\n// 0x55c4867c3a80 A [1]: 0x55c4867baec0  <--- add to list #1\n// 0x55c4867d23c0 A [1]: 0x55c4867c89c0  <--- add to list #2\n// 0x55c4867d23c0 A [1]: 0x55c4867cb050  <--- add to list #2\n// ----------------------------------------\n// ----------------------------------------\n// 0x55c4867d23c0 A [1]: 0x55c4867c39f0  <--- add to list #2 after copy\n// 0x55c4867d23c0 A [1]: 0x55c4867c3a10  <--- add to list #2 after copy\n// 0x55c4867d23c0 D [1]: 0x55c4867c89c0  <--- deallocate list #2\n// 0x55c4867d23c0 D [1]: 0x55c4867cb050  <--- deallocate list #2\n// 0x55c4867d23c0 D [1]: 0x55c4867c39f0  <--- deallocate list #2\n// 0x55c4867d23c0 D [1]: 0x55c4867c3a10  <--- deallocate list #2\n// 0x55c4867c3a80 D [1]: 0x55c4867b9210  <--- deallocate list #1\n// 0x55c4867c3a80 D [1]: 0x55c4867baec0  <--- deallocate list #1\n```", "```cpp\nstd::list<int, myallocator<int>> mylist1;\nstd::list<int, myallocator<int>> mylist2;\n\nmylist1.emplace_back(42);\nmylist1.emplace_back(42);\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n\nstd::cout << \"----------------------------------------\\n\";\nmylist2 = std::move(mylist1);\nstd::cout << \"----------------------------------------\\n\";\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n```", "```cpp\n// 0x7ffd65a15cb0 constructor, sizeof(T): 24\n// 0x7ffd65a15ce0 constructor, sizeof(T): 24\n// 0x55c4867c3a80 A [1]: 0x55c4867c3a10  <--- add to list #1\n// 0x55c4867c3a80 A [1]: 0x55c4867c39f0  <--- add to list #1\n// 0x55c4867d23c0 A [1]: 0x55c4867c0170  <--- add to list #2\n// 0x55c4867d23c0 A [1]: 0x55c4867c0190  <--- add to list #2\n// ----------------------------------------\n// ----------------------------------------\n// 0x55c4867d23c0 A [1]: 0x55c4867b9c90  <--- add to list #2 after move\n// 0x55c4867d23c0 A [1]: 0x55c4867b9cb0  <--- add to list #2 after move\n// 0x55c4867d23c0 D [1]: 0x55c4867c0170  <--- deallocate list #2\n// 0x55c4867d23c0 D [1]: 0x55c4867c0190  <--- deallocate list #2\n// 0x55c4867d23c0 D [1]: 0x55c4867b9c90  <--- deallocate list #2\n// 0x55c4867d23c0 D [1]: 0x55c4867b9cb0  <--- deallocate list #2\n// 0x55c4867c3a80 D [1]: 0x55c4867c3a10  <--- deallocate list #1\n// 0x55c4867c3a80 D [1]: 0x55c4867c39f0  <--- deallocate list #1\n```", "```cpp\nusing propagate_on_container_copy_assignment = std::true_type;\nusing propagate_on_container_move_assignment = std::true_type;\nusing propagate_on_container_swap = std::true_type;\n```", "```cpp\nstd::list<int, myallocator<int>> mylist1;\nstd::list<int, myallocator<int>> mylist2;\n\nmylist1.emplace_back(42);\nmylist1.emplace_back(42);\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n\nstd::cout << \"----------------------------------------\\n\";\nmylist2 = mylist1;\nstd::cout << \"----------------------------------------\\n\";\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n```", "```cpp\n// 0x7ffc766ec580 constructor, sizeof(T): 24\n// 0x7ffc766ec5b0 constructor, sizeof(T): 24\n// 0x5638419d9720 A [1]: 0x5638419d0b60  <--- add to list #1\n// 0x5638419d9720 A [1]: 0x5638419de660  <--- add to list #1\n// 0x5638419e8060 A [1]: 0x5638419e0cf0  <--- add to list #2\n// 0x5638419e8060 A [1]: 0x5638419d9690  <--- add to list #2\n```", "```cpp\n// 0x5638419e8060 D [1]: 0x5638419e0cf0\n// 0x5638419e8060 D [1]: 0x5638419d9690\n// 0x7ffc766ec5b0 copy assignment, sizeof(T): 24\n// 0x7ffc766ec450 copy constructor (U), sizeof(T): 4\n// 0x7ffc766ec3f0 copy constructor (U), sizeof(T): 24\n// 0x7ffc766ec460 copy constructor, sizeof(T): 24\n// 0x5638419d9720 A [1]: 0x5638419e8050\n// 0x5638419d9720 A [1]: 0x5638419d9690\n```", "```cpp\n// 0x5638419d9720 A [1]: 0x5638419d96b0  <--- add to list #2 after copy\n// 0x5638419d9720 A [1]: 0x5638419d5e10  <--- add to list #2 after copy\n// 0x5638419d9720 D [1]: 0x5638419e8050  <--- deallocate list #2\n// 0x5638419d9720 D [1]: 0x5638419d9690  <--- deallocate list #2\n// 0x5638419d9720 D [1]: 0x5638419d96b0  <--- deallocate list #2\n// 0x5638419d9720 D [1]: 0x5638419d5e10  <--- deallocate list #2\n// 0x5638419d9720 D [1]: 0x5638419d0b60  <--- deallocate list #1\n// 0x5638419d9720 D [1]: 0x5638419de660  <--- deallocate list #1\n```", "```cpp\nstd::list<int, myallocator<int>> mylist1;\nstd::list<int, myallocator<int>> mylist2;\n\nmylist1.emplace_back(42);\nmylist1.emplace_back(42);\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n\nstd::cout << \"----------------------------------------\\n\";\nmylist2 = std::move(mylist1);\nstd::cout << \"----------------------------------------\\n\";\n\nmylist2.emplace_back(42);\nmylist2.emplace_back(42);\n```", "```cpp\n// 0x7ffc766ec580 constructor, sizeof(T): 24\n// 0x7ffc766ec5b0 constructor, sizeof(T): 24\n// 0x5638419d9720 A [1]: 0x5638419d96b0  <--- add to list #1\n// 0x5638419d9720 A [1]: 0x5638419d9690  <--- add to list #1\n// 0x5638419d5e20 A [1]: 0x5638419e8050  <--- add to list #2\n// 0x5638419d5e20 A [1]: 0x5638419d5e30  <--- add to list #2\n// ----------------------------------------\n// 0x5638419d5e20 D [1]: 0x5638419e8050  <--- deallocate list #2\n// 0x5638419d5e20 D [1]: 0x5638419d5e30  <--- deallocate list #2\n// 0x7ffc766ec5b0 move assignment, sizeof(T): 24\n// ----------------------------------------\n// 0x5638419d9720 A [1]: 0x5638419d5e10\n// 0x5638419d9720 A [1]: 0x5638419e8050\n// 0x5638419d9720 D [1]: 0x5638419d96b0  <--- deallocate list #1\n// 0x5638419d9720 D [1]: 0x5638419d9690  <--- deallocate list #1\n// 0x5638419d9720 D [1]: 0x5638419d5e10  <--- deallocate list #2\n// 0x5638419d9720 D [1]: 0x5638419e8050  <--- deallocate list #2\n```", "```cpp\nsize_type myallocator::max_size();\n```", "```cpp\ntemplate<typename T, typename... Args>\nstatic void myallocator::construct(T* ptr, Args&&... args);\n\ntemplate<typename T>\nstatic void myallocator::destroy(T* ptr);\n```", "```cpp\ntemplate<typename T, std::size_t Alignment = 0x40>\nclass myallocator\n{\npublic:\n\n    using value_type = T;\n    using pointer = T *;\n    using size_type = std::size_t;\n    using is_always_equal = std::true_type;\n\n    template<typename U> struct rebind {\n        using other = myallocator<U, Alignment>;\n    };\n\npublic:\n\n    myallocator()\n    { }\n\n    template <typename U>\n    myallocator(const myallocator<U, Alignment> &other) noexcept\n    { (void) other; }\n\n    pointer allocate(size_type n)\n    {\n        if (auto ptr = aligned_alloc(Alignment, sizeof(T) * n)) {\n            return static_cast<pointer>(ptr);\n        }\n\n        throw std::bad_alloc();\n    }\n\n    void deallocate(pointer p, size_type n)\n    {\n        (void) n;\n        free(p);\n    }\n};\n```", "```cpp\nmyallocator<int> myalloc;\n\nauto ptr = myalloc.allocate(1);\nstd::cout << ptr << '\\n';\nmyalloc.deallocate(ptr, 1);\n\n// 0x561d512b6500\n```", "```cpp\nmyallocator<int> myalloc;\n\nauto ptr = myalloc.allocate(42);\nstd::cout << ptr << '\\n';\nmyalloc.deallocate(ptr, 42);\n\n// 0x55dcdcb41500\n```", "```cpp\nstd::vector<int, myallocator<int>> myvector;\nmyvector.emplace_back(42);\n\nstd::cout << myvector.data() << '\\n';\n\n// 0x55f875a0f500\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter09/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example6\n```", "```cpp\n0x55aec04dbd00\n0x55aec04e8f40\n0x55aec04d5d00\n===============================================================================\ntest cases: 3 | 3 passed\nassertions: - none -\n```", "```cpp\nclass pool\n{\npublic:\n\n    using size_type = std::size_t;\n\npublic:\n\n    explicit pool(size_type size) :\n        m_size{size}\n    { }\n```", "```cpp\n    void *allocate()\n    {\n        if (m_addrs.empty()) \n        {\n            this->add_addrs();\n        }\n\n        auto ptr = m_addrs.top();\n        m_addrs.pop();\n\n        return ptr;\n    }\n```", "```cpp\n    void deallocate(void *ptr)\n    { \n        m_addrs.push(ptr); \n    }\n```", "```cpp\n    void rebind(size_type size)\n    {\n        if (!m_addrs.empty() || !m_blocks.empty()) \n        {\n            std::cerr << \"rebind after alloc unsupported\\n\";\n            abort();\n        }\n\n        m_size = size;\n    }\n```", "```cpp\n    void add_addrs()\n    {\n        constexpr const auto block_size = 0x1000;\n        auto block = std::make_unique<uint8_t[]>(block_size);\n\n        auto v = gsl::span<uint8_t>(\n            block.get(), block_size\n        );\n\n        auto total_size =\n            v.size() % m_size == 0 ? v.size() : v.size() - m_size;\n\n        for (auto i = 0; i < total_size; i += m_size) \n        {\n            m_addrs.push(&v.at(i));\n        }\n\n        m_blocks.push(std::move(block));\n    }\n```", "```cpp\n    size_type m_size;\n\n    std::stack<void *> m_addrs{};\n    std::stack<std::unique_ptr<uint8_t[]>> m_blocks{};\n```", "```cpp\ntemplate<typename T>\nclass myallocator\n{\npublic:\n\n    using value_type = T;\n    using pointer = T *;\n    using size_type = std::size_t;\n    using is_always_equal = std::false_type;\n    using propagate_on_container_copy_assignment = std::false_type;\n    using propagate_on_container_move_assignment = std::true_type;\n    using propagate_on_container_swap = std::true_type;\n```", "```cpp\n    myallocator() :\n        m_pool{std::make_shared<pool>(sizeof(T))}\n    {\n        std::cout << this << \" constructor, sizeof(T): \"\n                  << sizeof(T) << '\\n';\n    }\n\n    template <typename U>\n    myallocator(const myallocator<U> &other) noexcept :\n        m_pool{other.m_pool}\n    {\n        std::cout << this << \" copy constructor (U), sizeof(T): \"\n                  << sizeof(T) << '\\n';\n\n        m_pool->rebind(sizeof(T));\n    }\n\n    myallocator(myallocator &&other) noexcept :\n        m_pool{std::move(other.m_pool)}\n    {\n        std::cout << this << \" move constructor, sizeof(T): \"\n                  << sizeof(T) << '\\n';\n    }\n\n    myallocator &operator=(myallocator &&other) noexcept\n    {\n        std::cout << this << \" move assignment, sizeof(T): \"\n                  << sizeof(T) << '\\n';\n\n        m_pool = std::move(other.m_pool);\n        return *this;\n    }\n\n    myallocator(const myallocator &other) noexcept :\n        m_pool{other.m_pool}\n    {\n        std::cout << this << \" copy constructor, sizeof(T): \"\n                  << sizeof(T) << '\\n';\n    }\n\n    myallocator &operator=(const myallocator &other) noexcept\n    {\n        std::cout << this << \" copy assignment, sizeof(T): \"\n                  << sizeof(T) << '\\n';\n\n        m_pool = other.m_pool;\n        return *this;\n    }\n```", "```cpp\n    pointer allocate(size_type n)\n    {\n        if (n != 1) {\n            return static_cast<pointer>(malloc(sizeof(T) * n));\n        }\n\n        return static_cast<pointer>(m_pool->allocate());\n    }\n\n    void deallocate(pointer ptr, size_type n)\n    {\n        if (n != 1) {\n            free(ptr);\n        }\n\n        m_pool->deallocate(ptr);\n    }\n```", "```cpp\nprivate:\n\n    std::shared_ptr<pool> m_pool;\n\n    template <typename T1, typename T2>\n    friend bool operator==(const myallocator<T1> &lhs, const myallocator<T2> &rhs);\n\n    template <typename T1, typename T2>\n    friend bool operator!=(const myallocator<T1> &lhs, const myallocator<T2> &rhs);\n\n    template <typename U>\n    friend class myallocator;\n};\n\ntemplate <typename T1, typename T2>\nbool operator==(const myallocator<T1> &lhs, const myallocator<T2> &rhs)\n{ return lhs.m_pool.get() == rhs.m_pool.get(); }\n\ntemplate <typename T1, typename T2>\nbool operator!=(const myallocator<T1> &lhs, const myallocator<T2> &rhs)\n{ return lhs.m_pool.get() != rhs.m_pool.get(); }\n```", "```cpp\ntemplate<typename FUNC>\nauto benchmark(FUNC func) {\n    auto stime = std::chrono::high_resolution_clock::now();\n    func();\n    auto etime = std::chrono::high_resolution_clock::now();\n\n    return (etime - stime).count();\n}\n```", "```cpp\nconstexpr const auto num = 100000;\n\nstd::list<int> mylist1;\nstd::list<int, myallocator<int>> mylist2;\n\nauto time1 = benchmark([&]{\n    for (auto i = 0; i < num; i++) {\n        mylist1.emplace_back(42);\n    }\n});\n\nauto time2 = benchmark([&]{\n    for (auto i = 0; i < num; i++) {\n        mylist2.emplace_back(42);\n    }\n});\n\nstd::cout << \"[TEST] add many:\\n\";\nstd::cout << \" - time1: \" << time1 << '\\n';\nstd::cout << \" - time2: \" << time2 << '\\n';\n```", "```cpp\n0x7ffca71d7a00 constructor, sizeof(T): 24\n[TEST] add many:\n  - time1: 3921793\n  - time2: 1787499\n```", "```cpp\nconstexpr const auto num = 100000;\n\nstd::list<int> mylist1;\nstd::list<int, myallocator<int>> mylist2;\n\nfor (auto i = 0; i < num; i++) {\n    mylist1.emplace_back(42);\n    mylist2.emplace_back(42);\n}\n\nauto time1 = benchmark([&]{\n    for (auto i = 0; i < num; i++) {\n        mylist1.pop_front();\n    }\n});\n\nauto time2 = benchmark([&]{\n    for (auto i = 0; i < num; i++) {\n        mylist2.pop_front();\n    }\n});\n\nstd::cout << \"[TEST] remove many:\\n\";\nstd::cout << \" - time1: \" << time1 << '\\n';\nstd::cout << \" - time2: \" << time2 << '\\n';\n```", "```cpp\n0x7fff14709720 constructor, sizeof(T): 24\n[TEST] remove many:\n  - time1: 1046463\n  - time2: 1285248\n```", "```cpp\nconstexpr const auto num = 100000;\n\nstd::list<int, myallocator<int>> mylist;\n\nfor (auto i = 0; i < num; i++) {\n    mylist.emplace_back(i);\n}\n\nuint64_t total1{};\nuint64_t total2{};\n\nfor (auto i = 0; i < num; i++) {\n    total1 += i;\n    total2 += mylist.back();\n    mylist.pop_back();\n}\n\nstd::cout << \"[TEST] verify: \";\nif (total1 == total2) {\n    std::cout << \"success\\n\";\n}\nelse {\n    std::cout << \"failure\\n\";\n    std::cout << \" - total1: \" << total1 << '\\n';\n    std::cout << \" - total2: \" << total2 << '\\n';\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter09/\n> mkdir build\n> cd build\n\n> cmake -DCMAKE_BUILD_TYPE=Release ..\n> make\n```", "```cpp\n> ./example7\n```", "```cpp\n0x7ffca71d7a00 constructor, sizeof(T): 24\n[TEST] add many:\n  - time1: 3921793\n  - time2: 1787499\n0x7fff14709720 constructor, sizeof(T): 24\n[TEST] remove many:\n  - time1: 1046463\n  - time2: 1285248\n0x7fff5d8ad040 constructor, sizeof(T): 24\n[TEST] verify: success\n===============================================================================\ntest cases: 5 | 5 passed\nassertions: - none -\n```"]