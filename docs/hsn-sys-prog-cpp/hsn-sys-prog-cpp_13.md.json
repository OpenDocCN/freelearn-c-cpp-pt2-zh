["```cpp\nif (foo() != 0) {\n    std::cout << errno << '\\n';\n}\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nint myfunc(int val)\n{\n    if (val == 42) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return 0;\n}\n\nint main()\n{\n    if (myfunc(1) == 0) {\n        std::cout << \"success\\n\";\n    }\n    else {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n    }\n\n    if (myfunc(42) == 0) {\n        std::cout << \"success\\n\";\n    }\n    else {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nint myfunc(int val)\n{\n    if (val == 42) {\n        errno = EINVAL;\n        return 0;\n    }\n\n    return 42;\n}\n\nint main()\n{\n    if (auto handle = myfunc(1); handle != 0) {\n        std::cout << \"success: \" << handle << '\\n';\n    }\n    else {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n    }\n\n    if (auto handle = myfunc(42); handle != 0) {\n        std::cout << \"success: \" << handle << '\\n';\n    }\n    else {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success: 42\n// failure: Invalid argument\n```", "```cpp\n#include <utility>\n#include <cstring>\n#include <iostream>\n\nstd::pair<int, bool>\nmyfunc(int val)\n{\n    if (val == 42) {\n        errno = EINVAL;\n        return {0, false};\n    }\n\n    return {42, true};\n}\n\nint main()\n{\n    if (auto [handle, success] = myfunc(1); success) {\n        std::cout << \"success: \" << handle << '\\n';\n    }\n    else {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n    }\n\n    if (auto [handle, success] = myfunc(42); success) {\n        std::cout << \"success: \" << handle << '\\n';\n    }\n    else {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success: 42\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nint myfunc(int val, int &error)\n{\n    if (val == 42) {\n        error = EINVAL;\n        return 0;\n    }\n\n    return 42;\n}\n\nint main()\n{\n    int error = 0;\n\n    if (auto handle = myfunc(1, error); error == 0) {\n        std::cout << \"success: \" << handle << '\\n';\n    }\n    else {\n        std::cout << \"failure: \" << strerror(error) << '\\n';\n    }\n\n    if (auto handle = myfunc(42, error); error == 0) {\n        std::cout << \"success: \" << handle << '\\n';\n    }\n    else {\n        std::cout << \"failure: \" << strerror(error) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success: 42\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nint myfunc(int val)\n{\n    if (val == 42) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return 0;\n}\n\nint nested1(int val)\n{\n    if (auto ret = myfunc(val); ret != 0) {\n        std::cout << \"nested1 failure: \" << strerror(errno) << '\\n';\n        return ret;\n    }\n    else {\n        std::cout << \"nested1 success\\n\";\n    }\n\n    return 0;\n}\n\nint nested2(int val)\n{\n    if (auto ret = nested1(val); ret != 0) {\n        std::cout << \"nested2 failure: \" << strerror(errno) << '\\n';\n        return ret;\n    }\n    else {\n        std::cout << \"nested2 success\\n\";\n    }\n\n    return 0;\n}\n\nint main()\n{\n    if (nested2(1) == 0) {\n        std::cout << \"nested2(1) complete\\n\";\n    }\n    else {\n        std::cout << \"nested2(1) failure: \" << strerror(errno) << '\\n';\n    }\n\n    if (nested2(42) == 0) {\n        std::cout << \"nested2(42) complete\\n\";\n    }\n    else {\n        std::cout << \"nested2(42) complete: \" << strerror(errno) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// nested1 success\n// nested2 success\n// nested2(1) complete\n// nested1 failure: Invalid argument\n// nested2 failure: Invalid argument\n// nested2(42) failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nclass myclass\n{\npublic:\n    ~myclass()\n    {\n        std::cout << \"destructor called\\n\";\n    }\n};\n\nint myfunc(int val)\n{\n    myclass c{};\n\n    if (val == 42) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return 0;\n}\n\nint main()\n{\n    if (myfunc(1) == 0) {\n        std::cout << \"success\\n\";\n    }\n    else {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n    }\n\n    if (myfunc(42) == 0) {\n        std::cout << \"success\\n\";\n    }\n    else {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// destructor called\n// success\n// destructor called\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <csetjmp>\n\n#include <iostream>\n\nstd::jmp_buf jb;\n\nvoid myfunc(int val)\n{\n    if (val == 42) {\n        errno = EINVAL;   // Invalid argument\n        std::longjmp(jb, -42);\n    }\n}\n\nint main()\n{\n    if (setjmp(jb) == -42) {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n        std::exit(EXIT_FAILURE);\n    }\n\n    myfunc(1);\n    std::cout << \"success\\n\";\n\n    myfunc(42);\n    std::cout << \"success\\n\";\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <csetjmp>\n\n#include <iostream>\n\nstd::jmp_buf jb;\n\nint myfunc(int val)\n{\n    if (val == 42) {\n        errno = EINVAL;\n        std::longjmp(jb, -1);\n    }\n\n    return 42;\n}\n\nint main()\n{\n    if (setjmp(jb) == -1) {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n        std::exit(EXIT_FAILURE);\n    }\n\n    auto handle1 = myfunc(1);\n    std::cout << \"success: \" << handle1 << '\\n';\n\n    auto handle2 = myfunc(42);\n    std::cout << \"success: \" << handle2 << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success: 42\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <csetjmp>\n\n#include <iostream>\n\nstd::jmp_buf jb;\n\nvoid myfunc(int val)\n{\n    if (val == 42) {\n        errno = EINVAL;\n        std::longjmp(jb, -1);\n    }\n}\n\nvoid nested1(int val)\n{\n    myfunc(val);\n    std::cout << \"nested1 success\\n\";\n}\n\nvoid nested2(int val)\n{\n    nested1(val);\n    std::cout << \"nested2 success\\n\";\n}\n\nint main()\n{\n    if (setjmp(jb) == -1) {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n        exit(EXIT_FAILURE);\n    }\n\n    nested2(1);\n    std::cout << \"nested2(1) complete\\n\";\n\n    nested2(42);\n    std::cout << \"nested2(42) complete\\n\";\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// nested1 success\n// nested2 success\n// nested2(1) complete\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <csetjmp>\n\n#include <iostream>\n\nvoid myfunc(int val, jmp_buf &jb)\n{\n    if (val == 42) {\n        std::longjmp(jb, EINVAL);\n    }\n}\n\nint main()\n{\n    std::jmp_buf jb;\n\n    if (auto ret = setjmp(jb); ret > 0) {\n        std::cout << \"failure: \" << strerror(ret) << '\\n';\n        std::exit(EXIT_FAILURE);\n    }\n\n    myfunc(1, jb);\n    std::cout << \"success\\n\";\n\n    myfunc(42, jb);\n    std::cout << \"success\\n\";\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <csetjmp>\n\n#include <iostream>\n\njmp_buf jb;\n\nclass myclass\n{\npublic:\n    ~myclass()\n    {\n        std::cout << \"destructor called\\n\";\n    }\n};\n\nvoid myfunc(int val)\n{\n    myclass c{};\n\n    if (val == 42) {\n        errno = EINVAL;\n        std::longjmp(jb, -1);\n    }\n}\n\nint main()\n{\n    if (setjmp(jb) == -1) {\n        std::cout << \"failure: \" << strerror(errno) << '\\n';\n        exit(EXIT_FAILURE);\n    }\n\n    myfunc(1);\n    std::cout << \"success\\n\";\n\n    myfunc(42);\n    std::cout << \"success\\n\";\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// destructor called\n// success\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nvoid myfunc(int val)\n{\n    if (val == 42) {\n        throw EINVAL;\n    }\n}\n\nint main()\n{\n    try {\n        myfunc(1);\n        std::cout << \"success\\n\";\n\n        myfunc(42);\n        std::cout << \"success\\n\";\n    }\n    catch(int ret) {\n        std::cout << \"failure: \" << strerror(ret) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nint myfunc(int val)\n{\n    if (val == 42) {\n        throw EINVAL;\n    }\n\n    return 42;\n}\n\nint main()\n{\n    try {\n       auto handle1 = myfunc(1);\n        std::cout << \"success: \" << handle1 << '\\n';\n\n        auto handle2 = myfunc(42);\n        std::cout << \"success: \" << handle2 << '\\n';\n    }\n    catch(int ret) {\n        std::cout << \"failure: \" << strerror(ret) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success: 42\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\nvoid myfunc(int val)\n{\n    if (val == 42) {\n        throw EINVAL;\n    }\n}\n\nvoid nested1(int val)\n{\n    myfunc(val);\n    std::cout << \"nested1 success\\n\";\n}\n\nvoid nested2(int val)\n{\n    nested1(val);\n    std::cout << \"nested2 success\\n\";\n}\n\nmain()\n{\n    try {\n        nested2(1);\n        std::cout << \"nested2(1) complete\\n\";\n\n        nested2(42);\n        std::cout << \"nested2(42) complete\\n\";\n    }\n    catch(int ret) {\n        std::cout << \"failure: \" << strerror(ret) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// nested1 success\n// nested2 success\n// nested2(1) complete\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nclass myclass\n{\npublic:\n    ~myclass()\n    {\n        std::cout << \"destructor called\\n\";\n    }\n};\n\nvoid myfunc(int val)\n{\n    myclass c{};\n\n    if (val == 42) {\n        throw EINVAL;\n    }\n}\n\nmain()\n{\n    try {\n        myfunc(1);\n        std::cout << \"success\\n\";\n\n        myfunc(42);\n        std::cout << \"success\\n\";\n    }\n    catch(int ret) {\n        std::cout << \"failure: \" << strerror(ret) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// destructor called\n// success\n// destructor called\n// failure: Invalid argument\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nvoid myfunc(int val)\n{\n    if (val == 42) {\n        throw std::runtime_error(\"invalid val\");\n    }\n}\n\nint main()\n{\n    try {\n        myfunc(1);\n        std::cout << \"success\\n\";\n\n        myfunc(42);\n        std::cout << \"success\\n\";\n    }\n    catch(const std::runtime_error &e) {\n        std::cout << \"failure: \" << e.what() << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success\n// failure: invalid val\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nvoid myfunc(int val)\n{\n    if (val == 42) {\n        throw -1;\n    }\n}\n\nmain()\n{\n    try {\n        myfunc(1);\n        std::cout << \"success\\n\";\n\n        myfunc(42);\n        std::cout << \"success\\n\";\n    }\n    catch(...) {\n        std::cout << \"failure\\n\";\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success\n// failure\n```", "```cpp\n#include <cstring>\n#include <iostream>\n#include <stdexcept>\n\nvoid myfunc1(int val)\n{\n    if (val == 42) {\n        throw std::runtime_error(\"runtime_error\");\n    }\n}\n\nvoid myfunc2(int val)\n{\n    try {\n        myfunc1(val);\n    }\n    catch(...) {\n        auto e = std::current_exception();\n        std::rethrow_exception(e);\n    }\n}\n\nint main()\n{\n    try {\n        myfunc2(42);\n    }\n    catch(const std::exception& e) {\n        std::cout << \"caught: \" << e.what() << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// caught: runtime_error\n```", "```cpp\n#include <cstring>\n#include <iostream>\n#include <stdexcept>\n\nclass myexception : public std::exception\n{\n    int m_error{0};\n\npublic:\n\n    myexception(int error) noexcept :\n        m_error{error}\n    { }\n\n    const char *\n    what() const noexcept\n    {\n      return \"error\";\n    }\n\n    int error() const noexcept\n    {\n        return m_error;\n    }\n};\n\nvoid myfunc(int val)\n{\n    if (val == 42) {\n        throw myexception(42);\n    }\n}\n\nint main()\n{\n    try {\n        myfunc(1);\n        std::cout << \"success\\n\";\n\n        myfunc(42);\n        std::cout << \"success\\n\";\n    }\n    catch(const myexception &e) {\n        std::cout << \"failure: \" << std::to_string(e.error()) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success\n// failure: 42\n```", "```cpp\nconst char *\nwhat() const noexcept\n{\n    return (\"error: \" + std::to_string(m_error)).c_str();\n}\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nclass myexception : public std::runtime_error\n{\npublic:\n    myexception(int error) noexcept :\n        std::runtime_error(\"error: \" + std::to_string(42))\n    { }\n};\n\nvoid myfunc(int val)\n{\n    if (val == 42) {\n        throw myexception(42);\n    }\n}\n\nint main()\n{\n    try {\n        myfunc(1);\n        std::cout << \"success\\n\";\n\n        myfunc(42);\n        std::cout << \"success\\n\";\n    }\n    catch(const std::exception &e) {\n        std::cout << \"failure: \" << e.what() << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// success\n// failure: error: 42\n```", "```cpp\n#include <cstring>\n#include <iostream>\n\nclass myclass\n{\npublic:\n    ~myclass()\n    {\n        std::cout << \"uncaught_exceptions: \"\n                  << std::uncaught_exceptions() << '\\n';\n    }\n};\n\nvoid myfunc(int val)\n{\n    myclass c{};\n\n    if (val == 42) {\n        throw EINVAL;\n    }\n}\n\nint main()\n{\n    try {\n        myfunc(1);\n        std::cout << \"success\\n\";\n\n        myfunc(42);\n        std::cout << \"success\\n\";\n    }\n    catch(int ret) {\n        std::cout << \"failure: \" << strerror(ret) << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// uncaught_exceptions: 0\n// success\n// uncaught_exceptions: 1\n// failure: Invalid argument\n```", "```cpp\n#include <csetjmp>\n\n#include <chrono>\n#include <iostream>\n\n```", "```cpp\njmp_buf jb;\n```", "```cpp\ntemplate<typename FUNC>\nauto benchmark(FUNC func) {\n    auto stime = std::chrono::high_resolution_clock::now();\n    func();\n    auto etime = std::chrono::high_resolution_clock::now();\n\n    return (etime - stime).count();\n}\n```", "```cpp\nint myfunc1(int val)\n{\n    if (val >= 0x10000000) {\n        return -1;\n    }\n\n    if (val < 0x1000) {\n        if (auto ret = myfunc1(val + 1); ret == -1) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n```", "```cpp\nvoid myfunc2(int val)\n{\n    if (val >= 0x10000000) {\n        std::longjmp(jb, -1);\n    }\n\n    if (val < 0x1000) {\n        myfunc2(val + 1);\n    }\n}\n```", "```cpp\nvoid myfunc3(int val)\n{\n    if (val >= 0x10000000) {\n        throw -1;\n    }\n\n    if (val < 0x1000) {\n        myfunc3(val + 1);\n    }\n}\n```", "```cpp\nvoid test_func1()\n{\n    if (auto ret = myfunc1(0); ret == 0) {\n        std::cout << \"myfunc1: success\\n\";\n    }\n    else {\n        std::cout << \"myfunc1: failure\\n\";\n    }\n\n    if (auto ret = myfunc1(bad); ret == 0) {\n        std::cout << \"myfunc1: success\\n\";\n    }\n    else {\n        std::cout << \"myfunc1: failure\\n\";\n    }\n\n    uint64_t total = 0;\n    for (auto i = 0; i < num_iterations; i++) {\n        total += benchmark([&] {\n            myfunc1(0);\n        });\n    }\n\n    std::cout << \"time1: \" << total << '\\n';\n}\n```", "```cpp\nvoid test_func2()\n{\n    if (setjmp(jb) == -1) {\n        std::cout << \"myfunc2: failure\\n\";\n\n        uint64_t total = 0;\n        for (auto i = 0; i < num_iterations; i++) {\n            total += benchmark([&] {\n                myfunc2(0);\n            });\n        }\n\n        std::cout << \"time2: \" << total << '\\n';\n        return;\n    }\n\n    myfunc2(0);\n    std::cout << \"myfunc2: success\\n\";\n\n    myfunc2(bad);\n    std::cout << \"myfunc2: success\\n\";\n}\n```", "```cpp\nvoid test_func3()\n{\n    try {\n        myfunc3(0);\n        std::cout << \"myfunc3: success\\n\";\n\n        myfunc3(bad);\n        std::cout << \"myfunc3: success\\n\";\n    }\n    catch(...) {\n        std::cout << \"myfunc3: failure\\n\";\n    }\n\n    uint64_t total = 0;\n    for (auto i = 0; i < num_iterations; i++) {\n        total += benchmark([&] {\n            myfunc3(0);\n        });\n    }\n\n    std::cout << \"time3: \" << total << '\\n';\n}\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    test_func1();\n    test_func2();\n    test_func3();\n\n    return EXIT_SUCCESS;\n}\n```", "```cpp\nint\nmain(int argc, char **argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter13/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example1\nmyfunc1: success\nmyfunc1: failure\ntime1: 1750637978\nmyfunc2: success\nmyfunc2: failure\ntime2: 1609691756\nmyfunc3: success\nmyfunc3: failure\ntime3: 1593301696\n```"]