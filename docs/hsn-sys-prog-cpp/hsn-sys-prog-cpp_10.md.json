["```cpp\nint socket(int domain, int type, int protocol);\n```", "```cpp\nif (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {\n    throw std::runtime_error(strerror(errno));\n}\n```", "```cpp\nclass mytcpsocket\n{\npublic:\n    explicit mytcpsocket(uint16_t port)\n    {\n        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n\n    ~mytcpsocket()\n    {\n        close(m_fd);\n    }\n\n    auto descriptor() const\n    { return m_fd; }\n\nprivate:\n\n    int m_fd{};\n};\n```", "```cpp\nint bind(int socket, const struct sockaddr *address, socklen_t address_len);\n```", "```cpp\nint connect(int socket, const struct sockaddr *address, socklen_t address_len);\n```", "```cpp\nint listen(int socket, int backlog); \n```", "```cpp\nint accept(int socket, struct sockaddr *address, socklen_t *address_len);\n```", "```cpp\nssize_t send(int socket, const void *buffer, size_t length, int flags);\n```", "```cpp\nssize_t sendto(int socket, const void *buffer, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);\n```", "```cpp\nssize_t recv(int socket, void *buffer, size_t length, int flags);\n```", "```cpp\nssize_t recvfrom(int socket, void *restrict buffer, size_t length, int flags, struct sockaddr *restrict address, socklen_t *restrict address_len);\n```", "```cpp\n#define PORT 22000\n#define MAX_SIZE 0x10\n```", "```cpp\n#include <array>\n#include <iostream>\n#include <stdexcept>\n\n#include <unistd.h>\n#include <string.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n```", "```cpp\nclass myserver\n{\n    int m_fd{};\n    struct sockaddr_in m_addr{};\n    struct sockaddr_in m_client{};\n\npublic:\n```", "```cpp\n    explicit myserver(uint16_t port)\n    {\n        if (m_fd = ::socket(AF_INET, SOCK_DGRAM, 0); m_fd == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        m_addr.sin_family = AF_INET;\n        m_addr.sin_port = htons(port);\n        m_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n        if (this->bind() == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n```", "```cpp\n    int bind()\n    {\n        return ::bind(\n            m_fd,\n            reinterpret_cast<struct sockaddr *>(&m_addr),\n            sizeof(m_addr)\n        );\n    }\n```", "```cpp\n   ssize_t recv(std::array<char, MAX_SIZE> &buf)\n   {\n        socklen_t client_len = sizeof(m_client);\n\n        return ::recvfrom(\n            m_fd,\n            buf.data(),\n            buf.size(),\n            0,\n            (struct sockaddr *) &m_client,\n            &client_len\n        );\n    }\n```", "```cpp\n    ssize_t send(std::array<char, MAX_SIZE> &buf, ssize_t len)\n    {\n        if (len >= buf.size()) {\n            throw std::out_of_range(\"len >= buf.size()\");\n        }\n\n        return ::sendto(\n            m_fd,\n            buf.data(),\n            buf.size(),\n            0,\n            (struct sockaddr *) &m_client,\n            sizeof(m_client)\n        );\n    }\n```", "```cpp\nExpects(len < buf.size())\n```", "```cpp\n    void echo()\n    {\n        while(true)\n        {\n            std::array<char, MAX_SIZE> buf{};\n\n            if (auto len = recv(buf); len != 0) {\n                send(buf, len);\n            }\n            else {\n                break;\n            }\n        }\n    }\n```", "```cpp\n    ~myserver()\n    {\n        close(m_fd);\n    }\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myserver server{PORT};\n    server.echo();\n\n    return EXIT_SUCCESS;\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n#include <array>\n#include <string>\n#include <iostream>\n#include <stdexcept>\n\n#include <unistd.h>\n#include <string.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n```", "```cpp\nclass myclient\n{\n    int m_fd{};\n    struct sockaddr_in m_addr{};\n\npublic:\n```", "```cpp\n    explicit myclient(uint16_t port)\n    {\n        if (m_fd = ::socket(AF_INET, SOCK_DGRAM, 0); m_fd == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        m_addr.sin_family = AF_INET;\n        m_addr.sin_port = htons(port);\n        m_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n        if (connect() == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n```", "```cpp\n    int connect()\n    {\n        return ::connect(\n            m_fd,\n            reinterpret_cast<struct sockaddr *>(&m_addr),\n            sizeof(m_addr)\n        );\n    }\n```", "```cpp\n    ssize_t send(const std::string &buf)\n    {\n        return ::send(\n            m_fd,\n            buf.data(),\n            buf.size(),\n            0\n        );\n    }\n```", "```cpp\n    ssize_t send(const std::string &buf)\n    {\n        return ::write(\n            m_fd,\n            buf.data(),\n            buf.size()\n        );\n    }\n```", "```cpp\n    ssize_t recv(std::array<char, MAX_SIZE> &buf)\n    {\n        return ::recv(\n            m_fd,\n            buf.data(),\n            buf.size() - 1,\n            0\n        );\n    }\n```", "```cpp\n    void echo()\n    {\n        while(true) {\n            std::string sendbuf{};\n            std::array<char, MAX_SIZE> recvbuf{};\n\n            std::cin >> sendbuf;\n            if (sendbuf == \"exit\") {\n                send({});\n                break;\n            }\n\n            send(sendbuf);\n            recv(recvbuf);\n\n            std::cout << recvbuf.data() << '\\n';\n        }\n    }\n```", "```cpp\n    ~myclient()\n    {\n        close(m_fd);\n    }\n};\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myclient client{PORT};\n    client.echo();\n\n    return EXIT_SUCCESS;\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter10/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example1_server\n```", "```cpp\n> cd Hands-On-System-Programming-with-CPP/Chapter10/build\n> ./example1_client\nHello \u21b5\nHello\nWorld\nWorld \u21b5\nexit \u21b5\n```", "```cpp\n#define PORT 22000\n#define MAX_SIZE 0x10\n```", "```cpp\n#include <array>\n#include <iostream>\n\n#include <unistd.h>\n#include <string.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n```", "```cpp\nclass myserver\n{\n    int m_fd{};\n    int m_client{};\n    struct sockaddr_in m_addr{};\n\npublic:\n```", "```cpp\n    explicit myserver(uint16_t port)\n    {\n        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        m_addr.sin_family = AF_INET;\n        m_addr.sin_port = htons(port);\n        m_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n        if (this->bind() == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n```", "```cpp\n    int bind()\n    {\n        return ::bind(\n            m_fd,\n            reinterpret_cast<struct sockaddr *>(&m_addr),\n            sizeof(m_addr)\n        );\n    }\n```", "```cpp\n    ssize_t recv(std::array<char, MAX_SIZE> &buf)\n    {\n        return ::recv(\n            m_client,\n            buf.data(),\n            buf.size(),\n            0\n        );\n    }\n```", "```cpp\n    ssize_t send(std::array<char, MAX_SIZE> &buf, ssize_t len)\n    {\n        if (len >= buf.size()) {\n            throw std::out_of_range(\"len >= buf.size()\");\n        }\n\n        return ::send(\n            m_client,\n            buf.data(),\n            len,\n            0\n        );\n    }\n```", "```cpp\n    void echo()\n    {\n        if (::listen(m_fd, 0) == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        if (m_client = ::accept(m_fd, nullptr, nullptr); m_client == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        while(true)\n        {\n            std::array<char, MAX_SIZE> buf{};\n\n            if (auto len = recv(buf); len != 0) {\n                send(buf, len);\n            }\n            else {\n                break;\n            }\n        }\n\n        close(m_client);\n    }\n```", "```cpp\n    ~myserver()\n    {\n        close(m_fd);\n    }\n};\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myserver server{PORT};\n    server.echo();\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n#include <array>\n#include <string>\n#include <iostream>\n\n#include <unistd.h>\n#include <string.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n```", "```cpp\nclass myclient\n{\n    int m_fd{};\n    struct sockaddr_in m_addr{};\n\npublic:\n```", "```cpp\n    explicit myclient(uint16_t port)\n    {\n        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        m_addr.sin_family = AF_INET;\n        m_addr.sin_port = htons(port);\n        m_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n        if (connect() == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n```", "```cpp\n     int connect()\n    {\n        return ::connect(\n            m_fd,\n            reinterpret_cast<struct sockaddr *>(&m_addr),\n            sizeof(m_addr)\n        );\n    }\n\n    ssize_t send(const std::string &buf)\n    {\n        return ::send(\n            m_fd,\n            buf.data(),\n            buf.size(),\n            0\n        );\n    }\n\n    ssize_t recv(std::array<char, MAX_SIZE> &buf)\n    {\n        return ::recv(\n            m_fd,\n            buf.data(),\n            buf.size() - 1,\n            0\n        );\n    }\n```", "```cpp\n    void echo()\n    {\n        while(true) {\n            std::string sendbuf{};\n            std::array<char, MAX_SIZE> recvbuf{};\n\n            std::cin >> sendbuf;\n\n            send(sendbuf);\n            recv(recvbuf);\n\n            std::cout << recvbuf.data() << '\\n';\n        }\n    }\n```", "```cpp\n    ~myclient()\n    {\n        close(m_fd);\n    }\n};\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myclient client{PORT};\n    client.echo();\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter10/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example2_server\n```", "```cpp\n> cd Hands-On-System-Programming-with-CPP/Chapter10/build\n> ./example2_client\nHello \u21b5\nHello\nWorld\nWorld \u21b5\n<ctrl+c>\n```", "```cpp\nstd::fstream g_log{\"server_log.txt\", std::ios::out | std::ios::app};\n```", "```cpp\nclass myserver\n{\n    int m_fd{};\n    int m_client{};\n    struct sockaddr_in m_addr{};\n\npublic:\n    explicit myserver(uint16_t port)\n    {\n        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        m_addr.sin_family = AF_INET;\n        m_addr.sin_port = htons(port);\n        m_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n        if (this->bind() == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n\n    int bind()\n    {\n        return ::bind(\n            m_fd,\n            reinterpret_cast<struct sockaddr *>(&m_addr),\n            sizeof(m_addr)\n        );\n    }\n\n    ssize_t recv(std::array<char, MAX_SIZE> &buf)\n    {\n        return ::recv(\n            m_client, buf.data(), buf.size(), 0\n        );\n    }\n```", "```cpp\n    void log()\n    {\n        if (::listen(m_fd, 0) == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        if (m_client = ::accept(m_fd, nullptr, nullptr); m_client == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        while(true)\n        {\n            std::array<char, MAX_SIZE> buf{};\n\n            if (auto len = recv(buf); len != 0) {\n                g_log.write(buf.data(), len);\n                std::clog.write(buf.data(), len);\n            }\n            else {\n                break;\n            }\n        }\n\n        close(m_client);\n    }\n```", "```cpp\n    ~myserver()\n    {\n        close(m_fd);\n    }\n};\n\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myserver server{PORT};\n    server.log();\n\n    return EXIT_SUCCESS;\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n#ifdef DEBUG_LEVEL\nconstexpr auto g_debug_level = DEBUG_LEVEL;\n#else\nconstexpr auto g_debug_level = 0;\n#endif\n\n#ifdef NDEBUG\nconstexpr auto g_ndebug = true;\n#else\nconstexpr auto g_ndebug = false;\n#endif\n```", "```cpp\nclass myclient\n{\n    int m_fd{};\n    struct sockaddr_in m_addr{};\n\npublic:\n    explicit myclient(uint16_t port)\n    {\n        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        m_addr.sin_family = AF_INET;\n        m_addr.sin_port = htons(port);\n        m_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\n        if (connect() == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n\n    int connect()\n    {\n        return ::connect(\n            m_fd,\n            reinterpret_cast<struct sockaddr *>(&m_addr),\n            sizeof(m_addr)\n        );\n    }\n\n    ssize_t send(const std::string &buf)\n    {\n        return ::send(\n            m_fd,\n            buf.data(),\n            buf.size(),\n            0\n        );\n    }\n\n    ~myclient()\n    {\n        close(m_fd);\n    }\n};\n```", "```cpp\nmyclient g_client{PORT};\nstd::fstream g_log{\"client_log.txt\", std::ios::out | std::ios::app};\n```", "```cpp\ntemplate <std::size_t LEVEL>\nconstexpr void log(void(*func)()) {\n    if constexpr (!g_ndebug && (LEVEL <= g_debug_level)) {\n        std::stringstream buf;\n\n        auto g_buf = std::clog.rdbuf();\n        std::clog.rdbuf(buf.rdbuf());\n\n        func();\n\n        std::clog.rdbuf(g_buf);\n\n        std::clog << \"\\033[1;32mDEBUG\\033[0m: \";\n        std::clog << buf.str();\n\n        g_log << \"\\033[1;32mDEBUG\\033[0m: \";\n        g_log << buf.str();\n\n        g_client.send(\"\\033[1;32mDEBUG\\033[0m: \");\n        g_client.send(buf.str());\n    };\n}\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    log<0>([]{\n        std::clog << \"Hello World\\n\";\n    });\n\n    std::clog << \"Hello World\\n\";\n\n    return EXIT_SUCCESS;\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter10/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example3_server\n```", "```cpp\n> cd Hands-On-System-Programming-with-CPP/Chapter10/build\n> ./example3_client\nDebug: Hello World\nHello World\n\n> cat client_log.txt\nDebug: Hello World\n\n> cat server_log.txt\nDebug: Hello World\n\n```", "```cpp\nstruct packet\n{\n    uint64_t len;\n    char buf[MAX_SIZE];\n\n    uint64_t data1;\n    uint64_t data2;\n};\n```", "```cpp\nclass myserver\n{\n...\n\n    void recv_packet()\n    {\n        if (::listen(m_fd, 0) == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        if (m_client = ::accept(m_fd, nullptr, nullptr); m_client == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        packet p{};\n\n        if (auto len = recv(p); len != 0) {\n            auto msg = std::string(p.buf, p.len);\n\n            std::cout << \"data1: \" << p.data1 << '\\n';\n            std::cout << \"data2: \" << p.data2 << '\\n';\n            std::cout << \"msg: \\\"\" << msg << \"\\\"\\n\";\n            std::cout << \"len: \" << len << '\\n';\n        }\n\n        close(m_client);\n    }\n\n...\n};\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myserver server{PORT};\n    server.recv_packet();\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\nclass myclient\n{\n...\n\n    void send_packet()\n    {\n        auto msg = std::string(\"Hello World\");\n\n        packet p = {\n            42,\n            43,\n            msg.size(),\n            {}\n        };\n\n        memcpy(p.buf, msg.data(), msg.size());\n\n        send(p);\n    }\n\n...\n};\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myclient client{PORT};\n    client.send_packet();\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter10/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example4_server\n```", "```cpp\n> cd Hands-On-System-Programming-with-CPP/Chapter10/build\n> ./example4_client\n```", "```cpp\ndata1: 42\ndata2: 43\nmsg: \"Hello World\"\nlen: 280\n```", "```cpp\nlist(APPEND JSON_CMAKE_ARGS\n    -DBUILD_TESTING=OFF\n    -DCMAKE_INSTALL_PREFIX=${CMAKE_BINARY_DIR}\n)\n\nExternalProject_Add(\n    json\n    GIT_REPOSITORY https://github.com/nlohmann/json.git\n    GIT_SHALLOW 1\n    CMAKE_ARGS ${JSON_CMAKE_ARGS}\n    PREFIX ${CMAKE_BINARY_DIR}/external/json/prefix\n    TMP_DIR ${CMAKE_BINARY_DIR}/external/json/tmp\n    STAMP_DIR ${CMAKE_BINARY_DIR}/external/json/stamp\n    DOWNLOAD_DIR ${CMAKE_BINARY_DIR}/external/json/download\n    SOURCE_DIR ${CMAKE_BINARY_DIR}/external/json/src\n    BINARY_DIR ${CMAKE_BINARY_DIR}/external/json/build\n    UPDATE_DISCONNECTED 1\n)\n```", "```cpp\n#include <nlohmann/json.hpp>\nusing json = nlohmann::json;\n```", "```cpp\nclass myserver\n{\n...\n\n    void recv_packet()\n    {\n        std::array<char, MAX_SIZE> buf{};\n\n        if (::listen(m_fd, 0) == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        if (m_client = ::accept(m_fd, nullptr, nullptr); m_client == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        if (auto len = recv(buf); len != 0) {\n            auto j = json::parse(buf.data(), buf.data() + len);\n\n            std::cout << \"data1: \" << j[\"data1\"] << '\\n';\n            std::cout << \"data2: \" << j[\"data2\"] << '\\n';\n            std::cout << \"msg: \" << j[\"msg\"] << '\\n';\n            std::cout << \"len: \" << len << '\\n';\n        }\n\n        close(m_client);\n    }\n\n...\n};\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myserver server{PORT};\n    server.recv_packet();\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n#include <nlohmann/json.hpp>\nusing json = nlohmann::json;\n```", "```cpp\nclass myclient\n{\n...\n\n    void send_packet()\n    {\n        json j;\n\n        j[\"data1\"] = 42;\n        j[\"data2\"] = 43;\n        j[\"msg\"] = \"Hello World\";\n\n        send(j.dump());\n    }\n\n...\n};\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myclient client{PORT};\n    client.send_packet();\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter10/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example5_server\n```", "```cpp\n> cd Hands-On-System-Programming-with-CPP/Chapter10/build\n> ./example5_client\n```", "```cpp\ndata1: 42\ndata2: 43\nmsg: \"Hello World\"\nlen: 43\n```"]