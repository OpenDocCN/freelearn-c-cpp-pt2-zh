["```cpp\n#include <iostream>\n\nint bss_mem = 0;\nint data_mem = 42;\n\nint main()\n{\n    std::cout << bss_mem << '\\n';\n    std::cout << data_mem << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0\n// 42\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    int stack_mem = 42;\n    std::cout << stack_mem << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 42\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    int stack_mem[268435456];\n    std::cout << stack_mem[0] << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// Segmentation fault (core dumped)\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    auto ptr = new int;\n    std::cout << ptr << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5639c77e4e70\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    auto ptr = new int[42];\n    std::cout << ptr << '\\n';\n    delete [] ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5594a7d47e70\n```", "```cpp\n#include <iostream>\n\nclass myclass\n{\npublic:\n    ~myclass()\n    {\n        std::cout << \"my delete\\n\";\n    }\n};\n\nint main()\n{\n    auto ptr = new myclass[2];\n    std::cout << ptr << '\\n';\n    delete [] ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x56171064ae78\n// my delete\n// my delete\n```", "```cpp\n0x0ABCDEF123456789 // Unaligned\n0x0ABCDEF12345F000 // 4 Kb aligned\n```", "```cpp\n#include <iostream>\n\nalignas(0x1000) int ptr[42];\n\nint main()\n{\n    std::cout << ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x560809897000\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    alignas(0x1000) int ptr[42];\n    std::cout << ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x560809897000\n```", "```cpp\n> objdump -d | grep main\n...\n00000000000008da <main>:\n 8da: 4c 8d 54 24 08 lea 0x8(%rsp),%r10\n 8df: 48 81 e4 00 f0 ff ff and $0xfffffffffffff000,%rsp\n 8e6: 41 ff 72 f8 pushq -0x8(%r10)\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    char buffer[0x2000];\n    auto ptr1 = reinterpret_cast<uintptr_t>(buffer);\n    auto ptr2 = ptr1 - (ptr1 % 0x1000) + 0x1000;\n\n    std::cout << std::hex << std::showbase;\n    std::cout << ptr1 << '\\n';\n    std::cout << ptr2 << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x7ffd160dec20\n// 0x7ffd160df000\n```", "```cpp\n// ptr1 = 0x7ffd160dec20\n// ptr1 % 0x1000 = 0xc20\n// ptr1 - (ptr1 % 0x1000) = 0x7ffd160de000   \n// ptr1 - (ptr1 % 0x1000) + 0x1000 = 0x7ffd160df000 \n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    int *ptr;\n\n    if (posix_memalign(reinterpret_cast<void **>(&ptr), 0x1000, 42 * sizeof(int))) {\n        std::clog << \"ERROR: unable to allocate aligned memory\\n\";\n        ::exit(EXIT_FAILURE);\n    }\n\n    std::cout << ptr << '\\n';\n    free(ptr);\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55c5d31d1000\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    if (auto ptr = aligned_alloc(0x1000, 42 * sizeof(int))) {\n        std::cout << ptr << '\\n';\n        free(ptr);\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55c5d31d1000\n```", "```cpp\n#include <iostream>\n\nusing aligned_int alignas(0x1000) = int;\n\nint main()\n{\n    auto ptr = new aligned_int;\n    std::cout << ptr << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55e32ece1000\n```", "```cpp\n#include <iostream>\n\nusing aligned_int alignas(0x1000) = int;\n\nint main()\n{\n    auto ptr = new aligned_int[42];\n    std::cout << ptr << '\\n';\n    delete [] ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5649c0597000\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    auto ptr = new (std::nothrow) int;\n    std::cout << ptr << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55893e230e70\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    auto ptr = new (std::nothrow) int[42];\n    std::cout << ptr << '\\n';\n    delete [] ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5623076e9e70\n```", "```cpp\n#include <iostream>\n\nusing aligned_int alignas(0x1000) = int;\n\nint main()\n{\n    auto ptr = new (std::nothrow) aligned_int;\n    std::cout << ptr << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55e36201a000\n```", "```cpp\n#include <iostream>\n\nusing aligned_int alignas(0x1000) = int;\n\nint main()\n{\n    auto ptr = new (std::nothrow) aligned_int[42];\n    std::cout << ptr << '\\n';\n    delete [] ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x557222103000\n```", "```cpp\n#include <iostream>\n\nclass myclass\n{\npublic:\n    myclass()\n    {\n        throw std::runtime_error(\"the answer was not 42\");\n    }\n};\n\nint main()\n{\n    auto ptr = new (std::nothrow) myclass;\n    std::cout << ptr << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// terminate called after throwing an instance of 'std::runtime_error'\n// what(): the answer was not 42\n// Aborted (core dumped)\n```", "```cpp\n#include <iostream>\n\nchar buf[0x1000];\n\nint main()\n{\n    auto ptr = new (buf) int;\n    std::cout << ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5567b8884000\n```", "```cpp\n#include <iostream>\n\nchar buf[0x1000];\n\nint main()\n{\n    auto ptr1 = new (buf) int;\n    auto ptr2 = new (buf) int;\n    std::cout << ptr1 << '\\n';\n    std::cout << ptr2 << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x558044c66180\n// 0x558044c66180\n```", "```cpp\n#include <iostream>\n\nchar buf[0x1000];\n\nint main()\n{\n    auto ptr = new (buf) int[42];\n    std::cout << ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55594aff0000\n```", "```cpp\n#include <iostream>\n\nalignas(0x1000) char buf[0x1000];\n\nint main()\n{\n    auto ptr = new (buf) int;\n    std::cout << ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5567b8884000\n```", "```cpp\n#include <iostream>\n\nalignas(0x1000) char buf[0x1000];\n\nint main()\n{\n    auto ptr = new (buf) int[42];\n    std::cout << ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55594aff0000\n```", "```cpp\n#include <iostream>\n\nvoid *operator new (std::size_t count)\n{\n    // WARNING: Do not use std::cout here\n    return malloc(count);\n}\n\nvoid operator delete (void *ptr)\n{\n    // WARNING: Do not use std::cout here\n    return free(ptr);\n}\n\nint main()\n{\n    auto ptr = new int;\n    std::cout << ptr << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55f204617e70\n```", "```cpp\n#include <iostream>\n\nvoid *operator new[](std::size_t count)\n{\n    // WARNING: Do not use std::cout here\n    return malloc(count);\n}\n\nvoid operator delete[](void *ptr)\n{\n    // WARNING: Do not use std::cout here\n    return free(ptr);\n}\n\nint main()\n{\n    auto ptr = new int[42];\n    std::cout << ptr << '\\n';\n    delete [] ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55e5e2c62e70\n```", "```cpp\n#include <iostream>\n\nstd::size_t allocations = 0;\n\nvoid *operator new (std::size_t count)\n{\n    if (count >= 0x1000) {\n        allocations++;\n    }\n\n    return malloc(count);\n}\n\nvoid operator delete (void *ptr)\n{\n    return free(ptr);\n}\n\nint main()\n{\n    auto ptr = new int;\n    std::cout << allocations << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0\n```", "```cpp\n#include <iostream>\n\nstd::size_t allocations = 0;\n\nvoid *operator new (std::size_t count)\n{\n    if (count >= 0x1000) {\n        allocations++;\n    }\n\n    return malloc(count);\n}\n\nvoid operator delete (void *ptr)\n{\n    return free(ptr);\n}\n\nstruct mystruct\n{\n    char buf[0x1000];\n};\n\nint main()\n{\n    auto ptr = new mystruct;\n    std::cout << allocations << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 1\n```", "```cpp\n#include <iostream>\n\nclass myclass\n{\npublic:\n    void *operator new (std::size_t count)\n    {\n        std::cout << \"my new\\n\";\n        return ::operator new (count);\n    }\n\n    void operator delete (void *ptr)\n    {\n        std::cout << \"my delete\\n\";\n        return ::operator delete (ptr);\n    }\n};\n\nint main()\n{\n    auto ptr = new myclass;\n    std::cout << ptr << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// my new\n// 0x5561cac52280\n// my delete\n```", "```cpp\n#include <iostream>\n\nclass myclass\n{\npublic:\n    void *operator new[](std::size_t count, std::align_val_t al)\n    {\n        std::cout << \"my new\\n\";\n        return ::operator new (count, al);\n    }\n\n    void operator delete[](void *ptr, std::align_val_t al)\n    {\n        std::cout << \"my delete\\n\";\n        return ::operator delete (ptr, al);\n    }\n};\n\nusing aligned_myclass alignas(0x1000) = myclass;\n\nint main()\n{\n    auto ptr1 = new aligned_myclass;\n    auto ptr2 = new aligned_myclass[42];\n    std::cout << ptr1 << '\\n';\n    std::cout << ptr2 << '\\n';\n    delete ptr1;\n    delete [] ptr2;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// my new\n// 0x563b49b74000\n// 0x563b49b76000\n// my delete\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    auto ptr = new int;\n    std::cout << ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; valgrind ./a.out\n// ==8627== LEAK SUMMARY:\n// ==8627== definitely lost: 4 bytes in 1 blocks\n// ==8627== indirectly lost: 0 bytes in 0 blocks\n// ==8627== possibly lost: 0 bytes in 0 blocks\n// ==8627== still reachable: 0 bytes in 0 blocks\n// ==8627== suppressed: 0 bytes in 0 blocks\n// ==8627== Rerun with --leak-check=full to see details of leaked memory\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    auto ptr = new int[42];\n    std::cout << ptr << '\\n';\n    delete ptr;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; valgrind ./a.out\n// ==8656== Mismatched free() / delete / delete []\n// ==8656== at 0x4C2E60B: operator delete(void*) (vg_replace_malloc.c:576)\n// ==8656== by 0x108960: main (in /home/user/examples/chapter_7/a.out)\n// ==8656== Address 0x5aebc80 is 0 bytes inside a block of size 168 alloc'd\n// ==8656== at 0x4C2DC6F: operator new[](unsigned long) (vg_replace_malloc.c:423)\n// ==8656== by 0x10892B: main (in /home/user/examples/chapter_7/a.out)\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr = std::make_unique<int>(42);\n    std::cout << *ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 42\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nclass myclass\n{\npublic:\n    ~myclass()\n    {\n        std::cout << \"my delete\\n\";\n    }\n};\n\nint main()\n{\n    auto ptr = std::make_unique<myclass>();\n    std::cout << ptr.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5621eb029e70\n// my delete\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nclass myclass1\n{\npublic:\n    ~myclass1()\n    {\n        std::cout << \"my delete\\n\";\n    }\n};\n\nclass myclass2\n{\n    std::unique_ptr<myclass1> m_data;\n\npublic:\n    myclass2() :\n        m_data{std::make_unique<myclass1>()}\n    { }\n};\n\nint main()\n{\n    myclass2();\n    std::cout << \"complete\\n\";\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// my delete\n// complete\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nclass myclass1\n{\npublic:\n    ~myclass1()\n    {\n        std::cout << \"my delete\\n\";\n    }\n};\n\nint main()\n{\n    std::unique_ptr<myclass1[]>(new myclass1[2]);\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// my delete\n// my delete\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr = std::make_unique<int[]>(42);\n    std::cout << ptr.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55b25f224e70\n// my delete\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nclass int_deleter\n{\npublic:\n    void operator()(int *ptr) const\n    {\n        std::cout << \"my delete\\n\";\n        delete ptr;\n    };\n};\n\nint main()\n{\n    auto ptr = std::unique_ptr<int, int_deleter>(new int, int_deleter());\n    std::cout << ptr.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5615be977e70\n// my delete\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nusing aligned_int alignas(0x1000) = int;\n\nint main()\n{\n    auto ptr = std::unique_ptr<int>(new aligned_int);\n    std::cout << ptr.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x560eb6a0a000\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nstruct mystruct {\n    int data{42};\n};\n\nint main()\n{\n    auto ptr1 = std::make_unique<int>(42);\n    auto ptr2 = std::make_unique<mystruct>();\n    std::cout << *ptr1 << '\\n';\n    std::cout << ptr2->data << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 42\n// 42\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr = std::make_unique<int>();\n    std::cout << ptr.get() << '\\n';\n    ptr.reset();\n    std::cout << ptr.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55bcfa2b1e70\n// 0\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr = std::make_unique<int>(42);\n    if (ptr) {\n        std::cout << *ptr << '\\n';\n    }\n    ptr.reset();\n    if (ptr) {\n        std::cout << *ptr << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 42\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr = std::make_unique<int[]>(42);\n    std::cout << ptr[0] << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0\n```", "```cpp\n#include <memory>\n#include <iostream>\n\ntemplate<typename T> std::ostream &\noperator<<(std::ostream &os, const std::unique_ptr<T> &ptr)\n{\n    os << ptr.get();\n    return os;\n}\n\nint main()\n{\n    auto ptr = std::make_unique<int>();\n    std::cout << ptr << '\\n';\n    std::cout << ptr.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x55ed70997e70\n```", "```cpp\n#include <thread>\n#include <iostream>\n\nclass myclass\n{\n    int m_data{0};\n\npublic:\n\n    ~myclass()\n    {\n        std::cout << \"myclass deleted\\n\";\n    }\n\n    void inc()\n    { m_data++; }\n};\n\nstd::thread t1;\nstd::thread t2;\n\nvoid\nthread2(myclass *ptr)\n{\n    for (auto i = 0; i < 100000; i++) {\n        ptr->inc();\n    }\n\n    std::cout << \"thread2: complete\\n\";\n}\n\nvoid\nthread1()\n{\n    auto ptr = std::make_unique<myclass>();\n    t2 = std::thread(thread2, ptr.get());\n\n    for (auto i = 0; i < 10; i++) {\n        ptr->inc();\n    }\n\n    std::cout << \"thread1: complete\\n\";\n}\n\nint main()\n{\n    t1 = std::thread(thread1);\n\n    t1.join();\n    t2.join();\n}\n\n// > g++ -std=c++17 -lpthread scratchpad.cpp; ./a.out\n// thread1: complete\n// myclass deleted\n// thread2: complete\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr = std::make_shared<int>();\n    std::cout << ptr.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x562e6ba9ce80\n```", "```cpp\n#include <thread>\n#include <iostream>\n\nclass myclass\n{\n    int m_data{0};\n\npublic:\n\n    ~myclass()\n    {\n        std::cout << \"myclass deleted\\n\";\n    }\n\n    void inc()\n    { m_data++; }\n};\n\nstd::thread t1;\nstd::thread t2;\n\nvoid\nthread2(const std::shared_ptr<myclass> ptr)\n{\n    for (auto i = 0; i < 100000; i++) {\n        ptr->inc();\n    }\n\n    std::cout << \"thread2: complete\\n\";\n}\n\nvoid\nthread1()\n{\n    auto ptr = std::make_shared<myclass>();\n    t2 = std::thread(thread2, ptr);\n\n    for (auto i = 0; i < 10; i++) {\n        ptr->inc();\n    }\n\n    std::cout << \"thread1: complete\\n\";\n}\n\nint main()\n{\n    t1 = std::thread(thread1);\n\n    t1.join();\n    t2.join();\n}\n\n// > g++ -std=c++17 -lpthread scratchpad.cpp; ./a.out\n// thread1: complete\n// thread2: complete\n// myclass deleted\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr1 = std::make_shared<int>();\n    auto ptr2 = ptr1;\n    std::cout << ptr1.get() << '\\n';\n    std::cout << ptr2.get() << '\\n';\n    ptr2.reset();\n    std::cout << ptr1.get() << '\\n';\n    std::cout << ptr2.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x555b99574e80\n// 0x555b99574e80\n// 0x555b99574e80\n// 0\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr = std::shared_ptr<int>(new int[42]());\n    std::cout << ptr.get()[0] << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr1 = std::make_shared<int>();\n    auto ptr2 = ptr1;\n    std::cout << ptr1.get() << '\\n';\n    std::cout << ptr2.get() << '\\n';\n    std::cout << ptr1.use_count() << '\\n';\n    ptr2.reset();\n    std::cout << ptr1.get() << '\\n';\n    std::cout << ptr2.get() << '\\n';\n    std::cout << ptr1.use_count() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x5644edde7e80\n// 0x5644edde7e80\n// 2\n// 0x5644edde7e80\n// 0\n// 1\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nint main()\n{\n    auto ptr = std::make_shared<int>();\n    if (ptr) {\n        std::cout << \"before: \" << ptr.get() << '\\n';\n    }\n    ptr.reset();\n    if (ptr) {\n        std::cout << \"after: \"<< ptr.get() << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// before: 0x55ac226b5e80\n```", "```cpp\n\n#include <memory>\n#include <iostream>\n\nstruct mystruct {\n    int data;\n};\n\nint main()\n{\n    auto ptr = std::make_shared<mystruct>();\n    std::cout << ptr->data << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nclass myclass2;\n\nclass myclass1\n{\npublic:\n\n    ~myclass1()\n    {\n        std::cout << \"delete myclass1\\n\";\n    }\n\n    std::shared_ptr<myclass2> m;\n};\n\nclass myclass2\n{\npublic:\n\n    ~myclass2()\n    {\n        std::cout << \"delete myclass2\\n\";\n    }\n\n    std::shared_ptr<myclass1> m;\n};\n\nint main()\n{\n    auto ptr1 = std::make_shared<myclass1>();\n    auto ptr2 = std::make_shared<myclass2>();\n    ptr1->m = ptr2;\n    ptr2->m = ptr1;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n```", "```cpp\n#include <memory>\n#include <iostream>\n\nclass myclass2;\n\nclass myclass1\n{\npublic:\n\n    ~myclass1()\n    {\n        std::cout << \"delete myclass1\\n\";\n    }\n\n    std::weak_ptr<myclass2> m;\n};\n\nclass myclass2\n{\npublic:\n\n    ~myclass2()\n    {\n        std::cout << \"delete myclass2\\n\";\n    }\n\n    std::weak_ptr<myclass1> m;\n};\n\nint main()\n{\n    auto ptr1 = std::make_shared<myclass1>();\n    auto ptr2 = std::make_shared<myclass2>();\n    ptr1->m = ptr2;\n    ptr2->m = ptr1;\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// delete myclass2\n// delete myclass1\n```", "```cpp\nauto ptr = std::make_unique<int>();\nstd::shared_ptr<int> shared = std::move(ptr);\n```", "```cpp\n#include <iostream>\n#include <sys/mman.h>\n\nconstexpr auto PROT_RW = PROT_READ | PROT_WRITE;\nconstexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;\n\nint main()\n{\n    auto ptr = mmap(0, 0x1000, PROT_RW, MAP_ALLOC, -1, 0);\n    std::cout << ptr << '\\n';\n\n    munmap(ptr, 0x1000);\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x7feb41ab6000\n```", "```cpp\n#include <iostream>\n#include <sys/mman.h>\n\nconstexpr auto PROT_RW = PROT_READ | PROT_WRITE;\nconstexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;\n\nint main()\n{\n    auto ptr1 = mmap(0, 42, PROT_RW, MAP_ALLOC, -1, 0);\n    auto ptr2 = mmap(0, 42, PROT_RW, MAP_ALLOC, -1, 0);\n\n    std::cout << ptr1 << '\\n';\n    std::cout << ptr2 << '\\n';\n\n    munmap(ptr1, 42);\n    munmap(ptr2, 42);\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x7fc1637ad000\n// 0x7fc1637ac000\n```", "```cpp\n#include <iostream>\n#include <sys/mman.h>\n\nconstexpr auto PROT_RE = PROT_READ | PROT_EXEC;\nconstexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;\n\nint main()\n{\n    auto ptr = mmap(0, 0x1000, PROT_RE, MAP_ALLOC, -1, 0);\n    std::cout << ptr << '\\n';\n\n    munmap(ptr, 0x1000);\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x7feb41ab6000\n```", "```cpp\n#include <iostream>\n#include <sys/mman.h>\n\nconstexpr auto PROT_RW = PROT_READ | PROT_WRITE;\nconstexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;\n\nint main()\n{\n    auto ptr = mmap(0, 0x1000, PROT_RW, MAP_ALLOC, -1, 0);\n    std::cout << ptr << '\\n';\n\n    if (mprotect(ptr, 0x1000, PROT_READ) == -1) {\n        std::clog << \"ERROR: Failed to change memory permissions\\n\";\n        ::exit(EXIT_FAILURE);\n    }\n\n    munmap(ptr, 0x1000);\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 0x7fb05b4b6000\n```", "```cpp\n#include <memory>\n#include <iostream>\n\n#include <string.h>\n#include <sys/mman.h>\n\nconstexpr auto PROT_RW = PROT_READ | PROT_WRITE;\nconstexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;\n\nclass mmap_deleter\n{\n    std::size_t m_size;\n\npublic:\n    mmap_deleter(std::size_t size) :\n        m_size{size}\n    { }\n\n    void operator()(int *ptr) const\n    {\n        munmap(ptr, m_size);\n    }\n};\n\ntemplate<typename T, typename... Args>\nauto mmap_unique(Args&&... args)\n{\n    if (auto ptr = mmap(0, sizeof(T), PROT_RW, MAP_ALLOC, -1, 0)) {\n\n        auto obj = new (ptr) T(args...);\n        auto del = mmap_deleter(sizeof(T));\n\n        return std::unique_ptr<T, mmap_deleter>(obj, del);\n    }\n\n    throw std::bad_alloc();\n}\n\nint main()\n{\n    auto ptr = mmap_unique<int>(42);\n    std::cout << *ptr << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp; ./a.out\n// 42\n```", "```cpp\n#include <memory>\n#include <iostream>\n\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/mman.h>\n\nconstexpr auto PROT_RW = PROT_READ | PROT_WRITE;\n\nauto name = \"/shm\";\n```", "```cpp\nclass mmap_deleter\n{\n    std::size_t m_size;\n\npublic:\n    mmap_deleter(std::size_t size) :\n        m_size{size}\n    { }\n\n    void operator()(int *ptr) const\n    {\n        munmap(ptr, m_size);\n    }\n};\n```", "```cpp\ntemplate<typename T, typename... Args>\nauto mmap_unique_server(Args&&... args)\n{\n  if(int fd = shm_open(name, O_CREAT | O_RDWR, 0644); fd != -1) {\n      ftruncate(fd, sizeof(T));\n\n        if (auto ptr = mmap(0, sizeof(T), PROT_RW, MAP_SHARED, fd, 0)) {\n\n            auto obj = new (ptr) T(args...);\n            auto del = mmap_deleter(sizeof(T));\n\n            return std::unique_ptr<T, mmap_deleter>(obj, del);\n        }\n    }\n\n    throw std::bad_alloc();\n}\n```", "```cpp\ntemplate<typename T>\nauto mmap_unique_client()\n{\n  if(int fd = shm_open(name, O_RDWR, 0644); fd != -1) {\n      ftruncate(fd, sizeof(T));\n\n        if (auto ptr = mmap(0, sizeof(T), PROT_RW, MAP_SHARED, fd, 0)) {\n\n            auto obj = static_cast<T*>(ptr);\n            auto del = mmap_deleter(sizeof(T));\n\n            return std::unique_ptr<T, mmap_deleter>(obj, del);\n        }\n    }\n\n    throw std::bad_alloc();\n}\n```", "```cpp\nint main()\n{\n    auto ptr1 = mmap_unique_server<int>(42);\n    auto ptr2 = mmap_unique_client<int>();\n    std::cout << *ptr1 << '\\n';\n    std::cout << *ptr2 << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lrt; ./a.out\n// 42\n// 42\n```"]