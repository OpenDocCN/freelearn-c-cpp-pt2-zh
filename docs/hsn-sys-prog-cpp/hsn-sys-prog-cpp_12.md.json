["```cpp\n#include <iostream>\n#include <pthread.h>\n\nvoid *mythread(void *ptr)\n{\n    std::cout << \"Hello World\\n\";\n    return nullptr;\n}\n\nint main()\n{\n    pthread_t thread1;\n    pthread_t thread2;\n\n    pthread_create(&thread1, nullptr, mythread, nullptr);\n    pthread_create(&thread2, nullptr, mythread, nullptr);\n\n    pthread_join(thread1, nullptr);\n    pthread_join(thread2, nullptr);\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World\n// Hello World\n```", "```cpp\nint pthread_create(\n    pthread_t *thread, \n    const pthread_attr_t *attr, \n    void *(*start_routine)(void*), \n    void *arg\n);\n```", "```cpp\nint pthread_join(pthread_t thread, void **value_ptr);\n```", "```cpp\n#include <iostream>\n#include <pthread.h>\n\nvoid *mythread(void *ptr)\n{\n    std::cout << \"thread id: \" \n              << pthread_self() << '\\n';\n\n    return nullptr;\n}\n\nmain()\n{\n    pthread_t thread1;\n    pthread_t thread2;\n\n    pthread_create(&thread1, nullptr, mythread, nullptr);\n    pthread_create(&thread2, nullptr, mythread, nullptr);\n\n    pthread_join(thread1, nullptr);\n    pthread_join(thread2, nullptr);\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// thread id: 140232513570560\n// thread id: 140232505177856\n```", "```cpp\npthread_t pthread_self(void);\n```", "```cpp\n#include <iostream>\n#include <pthread.h>\n\nvoid *mythread(void *ptr)\n{\n    (*reinterpret_cast<int *>(ptr))++;\n    return ptr;\n}\n\nmain()\n{\n    int in_value = 42;\n    void *out_value = nullptr;\n\n    pthread_t thread1;\n    pthread_t thread2;\n\n    pthread_create(&thread1, nullptr, mythread, &in_value);\n    pthread_create(&thread2, nullptr, mythread, &in_value);\n\n    pthread_join(thread1, &out_value);\n    pthread_join(thread2, &out_value);\n\n    std::cout << \"value: \" \n              << *reinterpret_cast<int *>(out_value) << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// 44\n```", "```cpp\n#include <iostream>\n#include <pthread.h>\n\nvoid *mythread(void *ptr)\n{\n    while(true) {\n        std::clog << static_cast<char *>(ptr) << '\\n';\n        pthread_yield();\n    }\n}\n\nmain()\n{\n    char name1[9] = \"thread 1\";\n    char name2[9] = \"thread 2\";\n\n    pthread_t thread1;\n    pthread_t thread2;\n\n    pthread_create(&thread1, nullptr, mythread, name1);\n    pthread_create(&thread2, nullptr, mythread, name2);\n\n    pthread_join(thread1, nullptr);\n    pthread_join(thread2, nullptr);\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// thread 2\n// thread 2\n// thread 2\n// thread 1\n// thread 2\n// thread 2\n// thread 1\n// thread 1\n// thread 1\n```", "```cpp\nint pthread_yield(void)\n```", "```cpp\n#include <iostream>\n\n#include <unistd.h>\n#include <pthread.h>\n\nvoid *mythread(void *ptr)\n{\n    while (true) {\n        sleep(1);\n        std::cout << \"hello world\\n\";\n    }\n}\n\nmain()\n{\n    pthread_t thread;\n    pthread_create(&thread, nullptr, mythread, nullptr);\n    pthread_join(thread, nullptr);\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// hello world\n// hello world\n// hello world\n```", "```cpp\n#include <array>\n#include <iostream>\n#include <pthread.h>\n\nint count = 0;\n\nvoid *mythread(void *ptr)\n{\n    count++;\n}\n\nmain()\n{\n    while (true) {\n        count = 0;\n        for (auto i = 0; i < 1000; i++) {\n            std::array<pthread_t, 8> threads;\n\n            for (auto &t : threads) {\n                pthread_create(&t, nullptr, mythread, nullptr);\n            }\n\n            for (auto &t : threads) {\n                pthread_join(t, nullptr);\n            }\n        }\n\n        std::cout << \"count: \" << count << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 7992\n// count: 7996\n// count: 7998\n// count: 8000\n// count: 8000\n```", "```cpp\n#include <array>\n#include <iostream>\n#include <pthread.h>\n\nint count = 0;\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid *mythread(void *ptr)\n{\n    pthread_mutex_lock(&lock);\n    count++;\n    pthread_mutex_unlock(&lock);\n}\n\nmain()\n{\n    while (true) {\n        count = 0;\n        for (auto i = 0; i < 1000; i++) {\n            std::array<pthread_t, 8> threads;\n\n            for (auto &t : threads) {\n                pthread_create(&t, nullptr, mythread, nullptr);\n            }\n\n            for (auto &t : threads) {\n                pthread_join(t, nullptr);\n            }\n        }\n\n        std::cout << \"count: \" << count << '\\n';\n    }\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 8000\n// count: 8000\n// count: 8000\n// count: 8000\n// count: 8000\n```", "```cpp\n#include <iostream>\n#include <pthread.h>\n\nint count = 0;\npthread_mutex_t lock;\npthread_mutexattr_t attr;\n\nvoid *mythread(void *ptr)\n{\n    pthread_mutex_lock(&lock);\n    pthread_mutex_lock(&lock);\n    pthread_mutex_lock(&lock);\n    count++;\n    pthread_mutex_unlock(&lock);\n    pthread_mutex_unlock(&lock);\n    pthread_mutex_unlock(&lock);\n}\n\nint main()\n{\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    pthread_mutex_init(&lock, &attr);\n\n    pthread_t thread1;\n    pthread_t thread2;\n\n    pthread_create(&thread1, nullptr, mythread, nullptr);\n    pthread_create(&thread2, nullptr, mythread, nullptr);\n\n    pthread_join(thread1, nullptr);\n    pthread_join(thread2, nullptr);\n\n    std::cout << \"count: \" << count << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 2\n```", "```cpp\n#include <iostream>\n#include <pthread.h>\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid *mythread1(void *ptr)\n{\n    pthread_mutex_lock(&lock);\n    std::cout << \"Hello World: 1\\n\";\n    pthread_mutex_unlock(&lock);\n\n    return nullptr;\n}\n\nvoid *mythread2(void *ptr)\n{\n    pthread_mutex_lock(&lock);\n    std::cout << \"Hello World: 2\\n\";\n    pthread_mutex_unlock(&lock);\n\n    return nullptr;\n}\n\nmain()\n{\n    pthread_t thread1;\n    pthread_t thread2;\n\n    pthread_create(&thread2, nullptr, mythread2, nullptr);\n    pthread_create(&thread1, nullptr, mythread1, nullptr);\n\n    pthread_join(thread1, nullptr);\n    pthread_join(thread2, nullptr);\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World: 2\n// Hello World: 1\n```", "```cpp\n#include <iostream>\n#include <pthread.h>\n\nbool predicate = false;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\nvoid *mythread1(void *ptr)\n{\n    pthread_mutex_lock(&lock);\n    std::cout << \"Hello World: 1\\n\";\n    predicate = true;\n    pthread_mutex_unlock(&lock);\n    pthread_cond_signal(&cond);\n\n    return nullptr;\n}\n\nvoid *mythread2(void *ptr)\n{\n    pthread_mutex_lock(&lock);\n    while(!predicate) {\n        pthread_cond_wait(&cond, &lock);\n    }\n    std::cout << \"Hello World: 2\\n\";\n    pthread_mutex_unlock(&lock);\n\n    return nullptr;\n}\n\nmain()\n{\n    pthread_t thread1;\n    pthread_t thread2;\n\n    pthread_create(&thread2, nullptr, mythread2, nullptr);\n    pthread_create(&thread1, nullptr, mythread1, nullptr);\n\n    pthread_join(thread1, nullptr);\n    pthread_join(thread2, nullptr);\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World: 1\n// Hello World: 2\n```", "```cpp\nbool predicate = false;\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\nint pthread_cond_signal(pthread_cond_t *cond);\n```", "```cpp\n#include <thread>\n#include <iostream>\n\nvoid mythread()\n{\n    std::cout << \"Hello World\\n\";\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World\n// Hello World\n```", "```cpp\n#include <thread>\n#include <iostream>\n\nvoid mythread()\n{\n    std::cout << \"thread id: \" \n              << std::this_thread::get_id() << '\\n';\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    std::cout << \"thread1 id: \" << t1.get_id() << '\\n';\n    std::cout << \"thread2 id: \" << t2.get_id() << '\\n';\n\n    t1.join();\n    t2.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// thread1 id: 139960486229760\n// thread2 id: 139960477837056\n// thread id: 139960477837056\n// thread id: 139960486229760\n```", "```cpp\n#include <thread>\n#include <future>\n#include <iostream>\n\nint mythread(int value)\n{\n    return ++value;\n}\n\nint main()\n{\n    std::packaged_task<int(int)> task1(mythread);\n    std::packaged_task<int(int)> task2(mythread);\n\n    auto f1 = task1.get_future();\n    auto f2 = task2.get_future();\n\n    std::thread t1(std::move(task1), 42);\n    std::thread t2(std::move(task2), 42);\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"value1: \" << f1.get() << '\\n';\n    std::cout << \"value2: \" << f2.get() << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World\n// Hello World\n```", "```cpp\n#include <thread>\n#include <iostream>\n\nvoid mythread(const char *str)\n{\n    while(true) {\n        std::clog << str << '\\n';\n        std::this_thread::yield();\n    }\n}\n\nmain()\n{\n    std::thread t1{mythread, \"thread 1\"};\n    std::thread t2{mythread, \"thread 2\"};\n\n    t1.join();\n    t2.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// thread 2\n// thread 2\n// thread 1\n// thread 1\n// thread 1\n// thread 1\n// thread 1\n// thread 2\n// thread 1\n```", "```cpp\n#include <thread>\n#include <chrono>\n#include <iostream>\n\nusing namespace std::chrono_literals;\n\nvoid mythread()\n{\n    while (true) {\n        std::this_thread::sleep_for(1s);\n        std::cout << \"hello world\\n\";\n    }\n}\n\nmain()\n{\n    std::thread t{mythread};\n    t.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// hello world\n// hello world\n// hello world\n```", "```cpp\n#include <mutex>\n#include <thread>\n#include <iostream>\n\nint count = 0;\nstd::mutex mutex;\n\nvoid mythread()\n{\n    mutex.lock();\n    count++;\n    mutex.unlock();\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"count: \" << count << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 2\n```", "```cpp\nvoid mythread()\n{\n    mutex.lock();\n\n    if (count == 1) {\n        mutex.unlock();\n        return;\n    }\n\n    count++;\n    mutex.unlock();\n}\n```", "```cpp\n#include <mutex>\n#include <thread>\n#include <iostream>\n\nint count = 0;\nstd::mutex mutex;\n\nvoid mythread()\n{\n    std::lock_guard lock(mutex);\n\n    if (count == 1) {\n        return;\n    }\n\n    count++;\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"count: \" << count << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 1\n```", "```cpp\n#include <mutex>\n#include <thread>\n#include <iostream>\n\nint count = 0;\nstd::mutex mutex;\n\nvoid mythread()\n{\n    while(!mutex.try_lock());\n    count++;\n    mutex.unlock();\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"count: \" << count << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 2\n```", "```cpp\n#include <mutex>\n#include <thread>\n#include <chrono>\n#include <iostream>\n\nint count = 0;\nstd::mutex mutex;\n\nusing namespace std::chrono_literals;\n\nvoid mythread()\n{\n    std::unique_lock lock(mutex, std::defer_lock);\n\n    while(!lock.try_lock()) {\n        std::this_thread::sleep_for(1s);\n    }\n\n    count++;\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"count: \" << count << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 2\n```", "```cpp\n#include <mutex>\n#include <thread>\n#include <iostream>\n\nint count = 0;\nstd::recursive_mutex mutex;\n\nvoid mythread()\n{\n    std::lock_guard lock1(mutex);\n    std::lock_guard lock2(mutex);\n    count++;\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"count: \" << count << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 2\n```", "```cpp\n#include <mutex>\n#include <thread>\n#include <iostream>\n\nint count = 0;\nstd::mutex mutex1;\nstd::mutex mutex2;\n\nvoid mythread()\n{\n    std::scoped_lock lock(mutex1, mutex2);\n    count++;\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"count: \" << count << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 2\n```", "```cpp\n#include <shared_mutex>\n#include <thread>\n#include <iostream>\n\nint count = 0;\nstd::shared_mutex mutex;\n\nvoid mythread1()\n{\n    while(true) {\n        std::unique_lock lock(mutex);\n        count++;\n    }\n}\n\nvoid mythread2()\n{\n    while(true) {\n        std::shared_lock lock(mutex);\n        std::cout << \"count: \" << count << '\\n';\n    }\n}\n\nmain()\n{\n    std::thread t1{mythread1};\n    std::thread t2{mythread2};\n    std::thread t3{mythread2};\n\n    t1.join();\n    t2.join();\n    t3.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 999\n// count: 1000\n// count: 1000\n// count: 1000\n// count: 1000\n// count: 1000\n// count: count: 1000\n// count: 1000\n```", "```cpp\n#include <mutex>\n#include <thread>\n#include <iostream>\n\nint count = 0;\nstd::mutex mutex1;\nstd::mutex mutex2;\n\nvoid mythread()\n{\n    std::unique_lock lock1(mutex1, std::defer_lock);\n    std::unique_lock lock2(mutex2, std::defer_lock);\n\n    std::lock(lock1, lock2);\n\n    count++;\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n\n    std::cout << \"count: \" << count << '\\n';\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// count: 2\n```", "```cpp\n#include <mutex>\n#include <condition_variable>\n#include <thread>\n#include <iostream>\n\nstd::mutex mutex;\nstd::condition_variable cond;\n\nvoid mythread1()\n{\n    std::cout << \"Hello World: 1\\n\";\n    cond.notify_one();\n}\n\nvoid mythread2()\n{\n    std::unique_lock lock(mutex);\n    cond.wait(lock);\n    std::cout << \"Hello World: 2\\n\";\n}\n\nmain()\n{\n    std::thread t2{mythread2};\n    std::thread t1{mythread1};\n\n    t1.join();\n    t2.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World: 1\n// Hello World: 2\n```", "```cpp\n#include <mutex>\n#include <condition_variable>\n#include <thread>\n#include <iostream>\n\nstd::mutex mutex;\nstd::condition_variable cond;\n\nvoid mythread1()\n{\n    std::cout << \"Hello World: 1\\n\";\n    cond.notify_all();\n}\n\nvoid mythread2()\n{\n    std::unique_lock lock(mutex);\n    cond.wait(lock);\n    std::cout << \"Hello World: 2\\n\";\n    cond.notify_one();\n}\n\nmain()\n{\n    std::thread t2{mythread2};\n    std::thread t3{mythread2};\n    std::thread t1{mythread1};\n\n    t1.join();\n    t2.join();\n    t3.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World: 1\n// Hello World: 2\n// Hello World: 2\n```", "```cpp\n#include <shared_mutex>\n#include <condition_variable>\n#include <thread>\n#include <iostream>\n\nstd::shared_mutex mutex;\nstd::condition_variable_any cond;\n\nvoid mythread1()\n{\n    std::unique_lock lock(mutex);\n    std::cout << \"Hello World: 1\\n\";\n\n    cond.notify_all();\n}\n\nvoid mythread2()\n{\n    std::shared_lock lock(mutex);\n    cond.wait(lock);\n\n    std::cout << \"Hello World: 2\\n\";\n}\n\nmain()\n{\n    std::thread t2{mythread2};\n    std::thread t3{mythread2};\n    std::thread t1{mythread1};\n\n    t1.join();\n    t2.join();\n    t3.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World: 1\n// Hello World: 2\n// Hello World: 2\n```", "```cpp\n#include <mutex>\n#include <thread>\n#include <iostream>\n\nstd::once_flag flag;\n\nvoid mythread()\n{\n    std::call_once(flag, [] {\n        std::cout << \"Hello World\\n\";\n    });\n}\n\nmain()\n{\n    std::thread t1{mythread};\n    std::thread t2{mythread};\n\n    t1.join();\n    t2.join();\n}\n\n// > g++ -std=c++17 scratchpad.cpp -lpthread; ./a.out\n// Hello World\n```", "```cpp\n#include <list>\n#include <mutex>\n#include <thread>\n#include <iostream>\n#include <algorithm>\n\n#include <gsl/gsl>\nusing namespace gsl;\n\nusing namespace std::string_literals;\n```", "```cpp\n\nclass primes\n{\n    std::list<int> m_primes;\n    mutable std::mutex m_mutex;\n\npublic:\n\n    void add(int prime)\n    {\n        std::unique_lock lock(m_mutex);\n        m_primes.push_back(prime);\n    }\n\n    void print()\n    {\n        std::unique_lock lock(m_mutex);\n        m_primes.sort();\n\n        for (const auto prime : m_primes) {\n            std::cout << prime << ' ';\n        }\n\n        std::cout << '\\n';\n    }\n};\n\nprimes g_primes;\n```", "```cpp\nvoid check_prime(int num)\n{\n    for (auto i = 2; i < num; i++) {\n        if (num % i == 0) {\n            return;\n        }\n    }\n\n    g_primes.add(num);\n}\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    auto args = make_span(argv, argc);\n\n    if (args.size() != 4) {\n        std::cerr << \"wrong number of arguments\\n\";\n        ::exit(1);\n    }\n```", "```cpp\n    int max_prime = std::stoi(args.at(1));\n    int max_threads = std::stoi(args.at(2));\n\n    if (max_prime < 3) {\n        std::cerr << \"max_prime must be 2 or more\\n\";\n        ::exit(1);\n    }\n\n    if (max_threads < 1) {\n        std::cerr << \"max_threads must be 1 or more\\n\";\n        ::exit(1);\n    }\n```", "```cpp\n    for (auto i = 2; i < max_prime; i += max_threads) {\n\n        std::list<std::thread> threads;\n        for (auto t = 0; t < max_threads; t++) {\n            threads.push_back(std::thread{check_prime, i + t});\n        }\n\n        for (auto &thread : threads) {\n            thread.join();\n        }\n    }\n```", "```cpp\n\n    if (args.at(3) == \"print\"s) {\n        g_primes.print();\n    }\n\n    return EXIT_SUCCESS;\n}\n```", "```cpp\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter12/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> time ./example1 20 4 print\n2 3 5 7 11 13 17 19\n```", "```cpp\n> time ./example1 50000 4 no\nreal 0m2.180s\nuser 0m0.908s\nsys 0m3.280s\n\n> time ./example1 50000 2 no\nreal 0m2.900s\nuser 0m1.073s\nsys 0m3.230s\n\n> time ./example1 50000 1 no\nreal 0m4.546s\nuser 0m0.910s\nsys 0m3.615s\n```", "```cpp\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <iostream>\n\n#include <gsl/gsl>\nusing namespace gsl;\n```", "```cpp\nint count = 0;\nbool enable_counter = true;\n\nstd::mutex mutex;\nstd::condition_variable cond;\n```", "```cpp\nvoid tick()\n{\n    cond.notify_one();\n\n    while (enable_counter) {\n        count++;\n    }\n}\n```", "```cpp\ntemplate<typename FUNC>\nauto timer(FUNC func) {\n    std::thread timer{tick};\n\n    std::unique_lock lock(mutex);\n    cond.wait(lock);\n\n    func();\n\n    enable_counter = false;\n    timer.join();\n\n    return count;\n}\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    auto args = make_span(argv, argc);\n\n    if (args.size() != 2) {\n        std::cerr << \"wrong number of arguments\\n\";\n        ::exit(1);\n    }\n\n    auto ticks = timer([&] {\n        for (auto i = 0; i < std::stoi(args.at(1)); i++) {\n        }\n    });\n\n    std::cout << \"ticks: \" << ticks << '\\n';\n\n    return EXIT_SUCCESS;\n}\n```", "```cpp\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter12/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example2 1000000\nticks: 103749316\n```", "```cpp\n#define PORT 22000\n#define MAX_SIZE 0x1000\n```", "```cpp\n#include <array>\n#include <unordered_map>\n\n#include <sstream>\n#include <fstream>\n#include <iostream>\n\n#include <mutex>\n#include <thread>\n\n#include <unistd.h>\n#include <string.h>\n\n#include <sys/socket.h>\n#include <netinet/in.h>\n```", "```cpp\nstd::mutex log_mutex;\nstd::fstream g_log{\"server_log.txt\", std::ios::out | std::ios::app};\n```", "```cpp\nssize_t\nrecv(int handle, std::array<char, MAX_SIZE> &buf)\n{\n    return ::recv(\n        handle,\n        buf.data(),\n        buf.size(),\n        0\n    );\n}\n```", "```cpp\nvoid\nlog(int handle)\n{\n    while(true)\n    {\n        std::array<char, MAX_SIZE> buf{};\n\n        if (auto len = recv(handle, buf); len != 0) {\n\n            std::unique_lock lock(log_mutex);\n\n            g_log.write(buf.data(), len);\n            std::clog.write(buf.data(), len);\n\n            g_log.flush();\n        }\n        else {\n            break;\n        }\n    }\n\n    close(handle);\n}\n```", "```cpp\nclass myserver\n{\n    int m_fd{};\n    struct sockaddr_in m_addr{};\n\npublic:\n\n    myserver(uint16_t port)\n    {\n        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        m_addr.sin_family = AF_INET;\n        m_addr.sin_port = htons(port);\n        m_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n        if (bind() == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n\n    int bind()\n    {\n        return ::bind(\n            m_fd,\n            reinterpret_cast<struct sockaddr *>(&m_addr),\n            sizeof(m_addr)\n        );\n    }\n```", "```cpp\n    void listen()\n    {\n        if (::listen(m_fd, 0) == -1) {\n            throw std::runtime_error(strerror(errno));\n        }\n\n        while (true) {\n            if (int c = ::accept(m_fd, nullptr, nullptr); c != -1) {\n\n                std::thread t{log, c};\n                t.detach();\n\n                continue;\n            }\n\n            throw std::runtime_error(strerror(errno));\n        }\n    }\n```", "```cpp\nint\nprotected_main(int argc, char** argv)\n{\n    (void) argc;\n    (void) argv;\n\n    myserver server{PORT};\n    server.listen();\n}\n\nint\nmain(int argc, char** argv)\n{\n    try {\n        return protected_main(argc, argv);\n    }\n    catch (const std::exception &e) {\n        std::cerr << \"Caught unhandled exception:\\n\";\n        std::cerr << \" - what(): \" << e.what() << '\\n';\n    }\n    catch (...) {\n        std::cerr << \"Caught unknown exception\\n\";\n    }\n\n    return EXIT_FAILURE;\n}\n```", "```cpp\n> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git\n> cd Hands-On-System-Programming-with-CPP/Chapter12/\n> mkdir build\n> cd build\n\n> cmake ..\n> make\n```", "```cpp\n> ./example3_server\n```", "```cpp\n> cd Hands-On-System-Programming-with-CPP/Chapter12/build\n> ./example3_client\nDebug: Hello World\nHello World\n\n> ./example3_client\nDebug: Hello World\nHello World\n\n> cat client_log.txt\nDebug: Hello World\nDebug: Hello World\n\n> cat server_log.txt\nDebug: Hello World\nDebug: Hello World\n\n```"]