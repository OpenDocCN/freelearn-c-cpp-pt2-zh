["```cpp\n#include <iostream>\n\nint main(void)\n{\n    if (auto i = 42; i > 0) {\n        std::cout << \"Hello World\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n```", "```cpp\n#include <iostream>\n\nint main(void)\n{\n    switch(auto i = 42) {\n        case 42:\n            std::cout << \"Hello World\\n\";\n            break;\n\n        default:\n            break;\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n```", "```cpp\n#include <iostream>\n\nconstexpr const auto val = true;\n\nint main(void)\n{\n    if (val) {\n        std::cout << \"Hello World\\n\";\n    }\n}\n```", "```cpp\npush %rbp\nmov %rsp,%rbp\nlea 0x100(%rip),%rsi\nlea 0x200814(%rip),%rdi\ncallq 6c0 <...cout...>\nmov $0x0,%eax\npop %rbp\nretq\n```", "```cpp\n#include <iostream>\n\nint main(void)\n{\n    if constexpr (constexpr const auto i = 42; i > 0) {\n        std::cout << \"Hello World\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n```", "```cpp\npush %rbp\nmov %rsp,%rbp\nsub $0x10,%rsp\nmovl $0x2a,-0x4(%rbp)\nlea 0x104(%rip),%rsi \nlea 0x200809(%rip),%rdi \ncallq 6c0 <...cout...>\nmov $0x0,%eax\nleaveq\nretq\n```", "```cpp\n#include <iostream>\n\nint main(void)\n{\n    static_assert(42 == 42, \"the answer\");\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// \n```", "```cpp\n#include <iostream>\n\nint main(void)\n{\n    static_assert(42 == 42);\n}\n\n// > g++ scratchpad.cpp; ./a.out\n//\n```", "```cpp\n#include <iostream>\n\nnamespace X \n{\nnamespace Y\n{\nnamespace Z \n{\n    auto msg = \"Hello World\\n\";\n}\n}\n}\n\nint main(void)\n{\n    std::cout << X::Y::Z::msg;\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n```", "```cpp\n#include <iostream>\n\nnamespace X::Y::Z \n{\n    auto msg = \"Hello World\\n\";\n}\n\nint main(void)\n{\n    std::cout << X::Y::Z::msg;\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n```", "```cpp\n#include <utility>\n#include <iostream>\n\nstd::pair<const char *, int>\ngive_me_a_pair()\n{\n    return {\"The answer is: \", 42};\n}\n\nint main(void)\n{\n    auto p = give_me_a_pair();\n    std::cout << std::get<0>(p) << std::get<1>(p) << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// The answer is: 42\n```", "```cpp\n#include <iostream>\n\nstd::pair<const char *, int>\ngive_me_a_pair()\n{\n    return {\"The answer is: \", 42};\n}\n\nint main(void)\n{\n    auto [msg, answer] = give_me_a_pair();\n    std::cout << msg << answer << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// The answer is: 42\n```", "```cpp\n#include <iostream>\n\nstruct mystruct\n{\n    const char *msg;\n    int answer;\n};\n\nmystruct\ngive_me_a_struct()\n{\n    return {\"The answer is: \", 42};\n}\n\nint main(void)\n{\n    auto [msg, answer] = give_me_a_struct();\n    std::cout << msg << answer << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// The answer is: 42\n```", "```cpp\n#include <iostream>\n\ninline auto msg = \"Hello World\\n\";\n\nint main(void)\n{\n    std::cout << msg;\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n```", "```cpp\nextern const char *msg;\n```", "```cpp\nconst char *msg = \"Hello World\\n\";\n```", "```cpp\n#include <iostream>\n#include <string_view>\n\nint main(void)\n{\n    std::string_view str(\"Hello World\\n\");\n    std::cout << str;\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n```", "```cpp\n#include <iostream>\n#include <string_view>\n\nint main(void)\n{\n    std::string_view str(\"Hello World\");\n\n    std::cout << str.front() << '\\n';\n    std::cout << str.back() << '\\n';\n    std::cout << str.at(1) << '\\n';\n    std::cout << str.data() << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// H\n// d\n// e\n// Hello World\n```", "```cpp\n#include <iostream>\n#include <string_view>\n\nint main(void)\n{\n    std::string_view str(\"Hello World\");\n\n    std::cout << str.size() << '\\n';\n    std::cout << str.max_size() << '\\n';\n    std::cout << str.empty() << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// 11\n// 4611686018427387899\n// 0\n```", "```cpp\n#include <iostream>\n#include <string_view>\n\nint main(void)\n{\n    std::string_view str(\"Hello World\");\n\n    str.remove_prefix(1);\n    str.remove_suffix(1);\n    std::cout << str << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// ello Worl\n```", "```cpp\n#include <iostream>\n#include <string_view>\n\nint main(void)\n{\n    std::string_view str(\"Hello World\");\n    std::cout << str.substr(0, 5) << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello\n```", "```cpp\n#if SNIPPET13\n\n#include <iostream>\n#include <string_view>\n\nint main(void)\n{\n    std::string_view str(\"Hello World\");\n\n    if (str.compare(\"Hello World\") == 0) {\n        std::cout << \"Hello World\\n\";\n    }\n\n    std::cout << str.compare(\"Hello\") << '\\n';\n    std::cout << str.compare(\"World\") << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n// 6\n// -1\n```", "```cpp\n#include <iostream>\n\nint main(void)\n{\n    std::string_view str(\"Hello this is a test of Hello World\");\n\n    std::cout << str.find(\"Hello\") << '\\n';\n    std::cout << str.rfind(\"Hello\") << '\\n';\n    std::cout << str.find_first_of(\"Hello\") << '\\n';\n    std::cout << str.find_last_of(\"Hello\") << '\\n';\n    std::cout << str.find_first_not_of(\"Hello\") << '\\n';\n    std::cout << str.find_last_not_of(\"Hello\") << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// 0\n// 24\n// 0\n// 33\n// 5\n// 34\n```", "```cpp\n#include <iostream>\n#include <any>\n\nstruct mystruct {\n    int data;\n};\n\nint main(void)\n{\n    auto myany = std::make_any<int>(42);\n    std::cout << std::any_cast<int>(myany) << '\\n';\n\n    myany = 4.2;\n    std::cout << std::any_cast<double>(myany) << '\\n';\n\n    myany = mystruct{42};\n    std::cout << std::any_cast<mystruct>(myany).data << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// 42\n// 4.2\n// 42\n```", "```cpp\n#include <iostream>\n#include <variant>\n\nint main(void)\n{\n    std::variant<int, double> v = 42;\n    std::cout << std::get<int>(v) << '\\n';\n\n    v = 4.2;\n    std::cout << std::get<double>(v) << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// 42\n// 4.2\n```", "```cpp\n#include <iostream>\n#include <optional>\n\nclass myclass\n{\npublic:\n    int val;\n\n    myclass(int v) :\n        val{v}\n    {\n        std::cout << \"constructed\\n\";\n    }\n};\n\nint main(void)\n{\n    std::optional<myclass> o;\n    std::cout << \"created, but not constructed\\n\";\n\n    if (o) {\n        std::cout << \"Attempt #1: \" << o->val << '\\n';\n    }\n\n    o = myclass{42};\n\n    if (o) {\n        std::cout << \"Attempt #2: \" << o->val << '\\n';\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// created, but not constructed\n// constructed\n// Attempt #2: 42\n```", "```cpp\n#include <iostream>\n\nclass myclass\n{\npublic:\n    myclass()\n    {\n        std::cout << \"Hello from constructor\\n\";\n    }\n\n    ~myclass()\n    {\n        std::cout << \"Hello from destructor\\n\";\n    }\n};\n\nint main(void)\n{\n    myclass c;\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello from constructor\n// Hello from destructor\n```", "```cpp\n#include <iostream>\n\nclass myclass\n{\n    int *ptr;\n\npublic:\n    myclass() :\n        ptr{new int(42)}\n    { }\n\n    ~myclass()\n    {\n        delete ptr;\n    }\n\n    int get()\n    {\n        return *ptr;\n    }\n};\n\nint main(void)\n{\n    myclass c;\n    std::cout << \"The answer is: \" << c.get() << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// The answer is: 42\n```", "```cpp\n#include <iostream>\n\nclass myclass\n{\n    FILE *m_file;\n\npublic:\n    myclass(const char *filename) :\n        m_file{fopen(filename, \"rb\")}\n    {\n        if (m_file == 0) {\n            throw std::runtime_error(\"unable to open file\");\n        }\n    }\n\n    ~myclass()\n    {\n        fclose(m_file);\n        std::clog << \"Hello from destructor\\n\";\n    }\n};\n\nint main(void)\n{\n    myclass c1(\"test.txt\");\n\n    try {\n        myclass c2(\"does_not_exist.txt\");\n    }\n    catch(const std::exception &e) {\n        std::cout << \"exception: \" << e.what() << '\\n';\n    }\n}\n\n// > g++ scratchpad.cpp; touch test.txt; ./a.out\n// exception: unable to open file\n// Hello from destructor\n```", "```cpp\nvoid init(int *p)\n{\n    *p = 0;\n}\n\nint main(void)\n{\n    auto p = new int;\n    init(p);\n    delete p;\n}\n\n// > g++ scratchpad.cpp; ./a.out\n//\n```", "```cpp\n#include <gsl/gsl>\n\nvoid init(int *p)\n{\n    *p = 0;\n}\n\nint main(void)\n{\n    gsl::owner<int *> p = new int;\n    init(p);\n    delete p;\n}\n\n// > g++ scratchpad.cpp; ./a.out\n//\n```", "```cpp\n#include <gsl/gsl>\n\ngsl::not_null<int *>\ntest(gsl::not_null<int *> p)\n{\n    return p;\n}\n\nint main(void)\n{\n    auto p1 = std::make_unique<int>();\n    auto p2 = test(gsl::not_null(p1.get()));\n}\n\n// > g++ scratchpad.cpp; ./a.out\n//\n```", "```cpp\nint array[10];\n\nauto r1 = array + 1;\nauto r2 = *(array + 1);\nauto r3 = array[1];\n```", "```cpp\n#define GSL_THROW_ON_CONTRACT_VIOLATION\n#include <gsl/gsl>\n#include <iostream>\n\nint main(void)\n{\n    int array[5] = {1, 2, 3, 4, 5};\n    auto span = gsl::span(array);\n\n    for (const auto &elem : span) {\n        std::clog << elem << '\\n';\n    }\n\n    for (auto i = 0; i < 5; i++) {\n        std::clog << span[i] << '\\n';\n    }\n\n    try {\n        std::clog << span[5] << '\\n';\n    }\n    catch(const gsl::fail_fast &e) {\n        std::cout << \"exception: \" << e.what() << '\\n';\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// 1\n// 2\n// 3\n// 4\n// 5\n// 1\n// 2\n// 3\n// 4\n// 5\n// exception: GSL: Precondition failure at ...\n```", "```cpp\n#include <gsl/gsl>\n#include <iostream>\n\nint main(void)\n{\n    gsl::cstring_span<> str = gsl::ensure_z(\"Hello World\\n\");\n    std::cout << str.data();\n\n    for (const auto &elem : str) {\n        std::clog << elem;\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n// Hello World\n```", "```cpp\n#define GSL_THROW_ON_CONTRACT_VIOLATION\n#include <gsl/gsl>\n#include <iostream>\n\nint main(void)\n{\n    try {\n        Expects(false);\n    }\n    catch(const gsl::fail_fast &e) {\n        std::cout << \"exception: \" << e.what() << '\\n';\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// exception: GSL: Precondition failure at ...\n```", "```cpp\n#define GSL_THROW_ON_CONTRACT_VIOLATION\n#include <gsl/gsl>\n#include <iostream>\n\nint\ntest(int i)\n{\n    Expects(i >= 0 && i < 41);\n    i++;\n\n    Ensures(i < 42);\n    return i;\n}\n\nint main(void)\n{\n    test(0);\n\n    try {\n        test(42);\n    }\n    catch(const gsl::fail_fast &e) {\n        std::cout << \"exception: \" << e.what() << '\\n';\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// exception: GSL: Precondition failure at ...\n```", "```cpp\n#define concat1(a,b) a ## b\n#define concat2(a,b) concat1(a,b)\n#define ___ concat2(dont_care, __COUNTER__)\n\n#include <gsl/gsl>\n#include <iostream>\n\nint main(void)\n{\n    auto ___ = gsl::finally([]{\n        std::cout << \"Hello World\\n\";\n    });\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n```", "```cpp\n#include <gsl/gsl>\n#include <iostream>\n\nint main(void)\n{\n    uint64_t val = 42;\n\n    auto val1 = gsl::narrow<uint32_t>(val);\n    auto val2 = gsl::narrow_cast<uint32_t>(val);\n}\n\n// > g++ scratchpad.cpp; ./a.out\n//\n```", "```cpp\n#endif\n\n#if SNIPPET30\n\n#define GSL_THROW_ON_CONTRACT_VIOLATION\n#include <gsl/gsl>\n#include <iostream>\n\nint main(void)\n{\n    uint64_t val = 0xFFFFFFFFFFFFFFFF;\n\n    try {\n        gsl::narrow<uint32_t>(val);\n    }\n    catch(...) {\n        std::cout << \"narrow failed\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// narrow failed\n```"]