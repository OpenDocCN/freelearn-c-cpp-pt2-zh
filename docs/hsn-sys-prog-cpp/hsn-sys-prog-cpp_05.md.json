["```cpp\nhigh |----------| <- top of stack\n     |          |\n     |   Used   |\n     |          |\n     |----------| <- Current frame (rbp)\n     |          | <- Stack pointer (rsp)\n     |----------|\n     |          |\n     |  Unused  |\n     |          |\n low |----------|\n```", "```cpp\nhigh |----------| \n     |   ....   |\n     |----------| \n     |   arg8   | \n     |----------| \n     |   arg7   | \n     |----------| \n     | ret addr | \n     |----------| <- Stack pointer (rbp)\n     |          |\n low |----------|\n```", "```cpp\nint test()\n{\n    int i = 1;\n    int j = 2;\n\n    return i + j;\n}\n\nint main(void)\n{\n    test();\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// \n```", "```cpp\n...\n00000000000005fa <_Z4testv>:\n push %rbp\n mov %rsp,%rbp\n movl $0x1,-0x8(%rbp)\n movl $0x2,-0x4(%rbp)\n mov -0x8(%rbp),%edx\n mov -0x4(%rbp),%eax\n add %edx,%eax\n pop %rbp\n retq\n...\n```", "```cpp\n...\n00000000000005fa <_Z4testv>:\n push %rbp\n mov %rsp,%rbp\n sub $0x10,%rsp\n movl $0x1,-0x8(%rbp)\n movl $0x2,-0x4(%rbp)\n mov -0x8(%rbp),%edx\n mov -0x4(%rbp),%eax\n add %edx,%eax\n leaveq\n retq\n...\n```", "```cpp\n0000000000000630 <__libc_csu_init>:\npush %r15\npush %r14\nmov %rdx,%r15\npush %r13\npush %r12\n```", "```cpp\n__libc_csu_init (int argc, char **argv, char **envp)\n```", "```cpp\npop %rbx\npop %rbp\npop %r12\npop %r13\npop %r14\npop %r15\nretq\n```", "```cpp\nint test(int val1, int val2)\n{\n    return val1 + val2;\n}\n\nint main(void)\n{\n    auto ret = test(42, 42);\n}\n\n// > g++ scratchpad.cpp; ./a.out\n//\n```", "```cpp\n000000000000060e <main>:\npush %rbp\nmov %rsp,%rbp\nsub $0x10,%rsp\nmov $0x2a,%esi\nmov $0x2a,%edi\ncallq 5fa <_Z4testii>\nmov %eax,-0x4(%rbp)\nmov $0x0,%eax\nleaveq\nretq\n```", "```cpp\n00000000000005fa <_Z4testii>:\npush %rbp\nmov %rsp,%rbp\nmov %edi,-0x4(%rbp)\nmov %esi,-0x8(%rbp)\nmov -0x4(%rbp),%edx\nmov -0x8(%rbp),%eax\nadd %edx,%eax\npop %rbp\nretq\n```", "```cpp\n#include <cstdint>\n\nstruct mystruct\n{\n    uint64_t data1;\n    uint64_t data2;\n};\n\nmystruct test()\n{\n    return {1, 2};\n}\n\nint main(void)\n{\n    auto ret = test();\n}\n\n// > g++ scratchpad.cpp; ./a.out\n//\n```", "```cpp\n00000000000005fa <_Z4testv>:\npush %rbp\nmov %rsp,%rbp\nmov $0x1,%eax\nmov $0x2,%edx\npop %rbp\nretq\n```", "```cpp\n#include <iostream>\n#include <exception>\n\nvoid test(int i)\n{\n    if (i == 42) {\n        throw 42;\n    }\n}\n\nint main(void)\n{\n    try {\n        test(1);\n        std::cout << \"attempt #1: passed\\n\";\n\n        test(21);\n        std::cout << \"attempt #2: passed\\n\";\n    }\n    catch(...) {\n        std::cout << \"exception catch\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// attempt #1: passed\n// exception catch\n```", "```cpp\n0000000000000c11 <main>:\npush %rbp\nmov %rsp,%rbp\npush %rbx\nsub $0x8,%rsp\nmov $0x1,%edi\ncallq b9a <test>\n...\ncallq a30 <std::cout>\n...\nmov $0x0,%eax\njmp c90\n...\ncallq 9f0 <__cxa_begin_catch@plt>\n...\ncallq a70 <_Unwind_Resume@plt>\nadd $0x8,%rsp     \npop %rbx\npop %rbp\nretq\n```", "```cpp\n0000000000000a6a <_Z4testi>:\npush %rbp\nmov %rsp,%rbp\nsub $0x10,%rsp\nmov %edi,-0x4(%rbp)\ncmpl $0x2a,-0x4(%rbp)\njne a9f\nmov $0x4,%edi\ncallq 8e0 <__cxa_allocate_exception@plt>\n...\ncallq 930 <__cxa_throw@plt>\nnop\nleaveq\nretq\n```", "```cpp\n> readelf -SW a.out\nThere are 31 section headers, starting at offset 0x2d18:\n\nSection Headers:\n...\n  [18] .eh_frame PROGBITS 0000000000000ca8 000ca8 000190 00 A 0 0 8\n...\n```", "```cpp\n> readelf --debug-dump=frames a.out\n...\n00000088 000000000000001c 0000005c FDE ...\n  DW_CFA_advance_loc: 1 to 0000000000000a6b\n  DW_CFA_def_cfa_offset: 16\n  DW_CFA_offset: r6 (rbp) at cfa-16\n  DW_CFA_advance_loc: 3 to 0000000000000a6e\n  DW_CFA_def_cfa_register: r6 (rbp)\n  DW_CFA_advance_loc: 51 to 0000000000000aa1\n  DW_CFA_def_cfa: r7 (rsp) ofs 8\n  DW_CFA_nop\n  DW_CFA_nop\n  DW_CFA_nop\n...\n```", "```cpp\nint main(void)\n{\n}\n\n// > g++ scratchpad.cpp; ./a.out\n//\n```", "```cpp\n> hexdump -C a.out\n00000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 |.ELF............|\n00000010 03 00 3e 00 01 00 00 00 f0 04 00 00 00 00 00 00 |..>.............|\n00000020 40 00 00 00 00 00 00 00 e8 18 00 00 00 00 00 00 |@...............|\n00000030 00 00 00 00 40 00 38 00 09 00 40 00 1c 00 1b 00 |....@.8...@.....|\n```", "```cpp\n> readelf -hW a.out\nELF Header:\n  Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class: ELF64\n  Data: 2's complement, little endian\n  Version: 1 (current)\n  OS/ABI: UNIX - System V\n  ABI Version: 0\n  Type: DYN (Shared object file)\n  Machine: Advanced Micro Devices X86-64\n  Version: 0x1\n  Entry point address: 0x4f0\n  Start of program headers: 64 (bytes into file)\n  Start of section headers: 6376 (bytes into file)\n  Flags: 0x0\n  Size of this header: 64 (bytes)\n  Size of program headers: 56 (bytes)\n  Number of program headers: 9\n  Size of section headers: 64 (bytes)\n  Number of section headers: 28\n  Section header string table index: 27\n```", "```cpp\n   Segments       Sections\n|------------| |------------|\n|   Header   | |   Header   |\n|------------| |------------|\n|            | |            |\n|            | |------------|\n|            | |            |\n|            | |            |\n|------------| |------------|\n|            | |            |\n|            | |------------|\n|            | |            |\n|------------| |------------|\n```", "```cpp\n> readelf -SW a.out\n```", "```cpp\n> g++ scratchpad.cpp -v\n...\n/usr/lib/gcc/x86_64-linux-gnu/7/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper -plugin-opt=-fresolution=/tmp/ccmBVeIh.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/7 -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/7/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/7/../../.. /tmp/ccZU6K8e.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/7/../../../x86_64-linux-gnu/crtn.o\n...\n```", "```cpp\n#include <iostream>\n\nint main(void)\n{\n    std::cout << \"The answer is: 42\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// The answer is: 42\n```", "```cpp\n> hexdump -C a.out | grep \"The\" -B1 -A1\n000008f0 f3 c3 00 00 48 83 ec 08 48 83 c4 08 c3 00 00 00 |....H...H.......|\n00000900 01 00 02 00 00 54 68 65 20 61 6e 73 77 65 72 20 |.....The answer |\n00000910 69 73 3a 20 34 32 0a 00 01 1b 03 3b 4c 00 00 00 |is: 42.....;L...|\n```", "```cpp\n> cat /etc/fstab\nUUID=... / ext4 ...\nUUID=... /boot/efi vfat ...\n```", "```cpp\n> ls /dev/null\n/dev/null\n```", "```cpp\n> echo \"Hello World\" > /dev/null\n> hexdump -n16 /dev/null\n<nothing>\n```", "```cpp\n> hexdump -n16 /dev/zero\n0000000 0000 0000 0000 0000 0000 0000 0000 0000\n0000010\n```", "```cpp\n> hexdump -n16 /dev/random\n0000000 3ed9 25c2 ad88 bf62 d3b3 0f72 b32a 32b3\n0000010\n```", "```cpp\n> ls -al\ntotal 40\ndrwxrwxr-x 3  user user ... .\ndrwxrwxr-x 16 user user ... ..\n-rwxrwxr-x 1  user user ... a.out\ndrwxrwxr-x 3  user user ... build\n-rw-rw-r-- 1  user user ... CMakeLists.txt\n-rw-rw-r-- 1  user user ... scratchpad.cpp\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    fork();\n    std::cout << \"Hello World\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n// Hello World\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    if (fork() != 0) {\n        std::cout << \"Hello\\n\";\n    }\n    else {\n        std::cout << \"World\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello\n// World\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint data = 0;\n\nint main(void)\n{\n    if (fork() != 0)\n    {\n        data = 42;\n    }\n\n    std::cout << \"The answer is: \" << data << '\\n';\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// The answer is: 42\n// The answer is: 0\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    fork();\n    fork();\n    std::cout << \"Hello World\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n// Hello World\n// Hello World\n// Hello World\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    auto id1 = fork();\n    std::cout << \"id1: \" << id1 << '\\n';\n\n    auto id2 = fork();\n    std::cout << \"id2: \" << id2 << '\\n';\n    std::cout << \"-----------\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// id1: 14181\n// id2: 14182\n// -----------\n// id1: 0\n// id2: 14183\n// -----------\n// id2: 0\n// -----------\n// id2: 0\n// -----------\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    fork();\n    fork();\n    fork();\n    std::cout << \"Hello World\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n// Hello World\n// Hello World\n// Hello World\n// Hello World\n// Hello World\n// Hello World\n// Hello World\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    if (fork() != 0) {\n        std::cout << \"The\\n\";\n    }\n    else {\n        if (fork() != 0) {\n            std::cout << \"answer\\n\";\n        }\n        else {\n            if (fork() != 0) {\n                std::cout << \"is\\n\";\n            }\n            else {\n                std::cout << 42 << '\\n';\n            }\n        }\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// The\n// answer\n// is\n// 42\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n#include <sys/wait.h>\n\nint main(void)\n{\n    if (fork() != 0) {\n        std::cout << \"parent\\n\";\n        wait(nullptr);\n    }\n    else {\n        std::cout << \"child\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// parent\n// child\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n#include <sys/wait.h>\n\nint main(void)\n{\n    int id;\n\n    auto id1 = fork();\n    auto id2 = fork();\n    auto id3 = fork();\n\n    while(1)\n    {\n        id = wait(nullptr);\n\n        if (id == -1)\n            break;\n\n        if (id == id1)\n            std::cout << \"child #1 finished\\n\";\n\n        if (id == id2)\n            std::cout << \"child #2 finished\\n\";\n\n        if (id == id3)\n            std::cout << \"child #3 finished\\n\";\n    }\n\n    if (id1 != 0 && id2 != 0 && id3 != 0)\n        std::cout << \"parent done\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// child #3 finished\n// child #3 finished\n// child #3 finished\n// child #3 finished\n// child #2 finished\n// child #2 finished\n// child #1 finished\n// parent done\n```", "```cpp\nchild #3 finished\nchild #3 finished\nchild #3 finished\nchild #2 finished\nchild #2 finished\nchild #3 finished\nchild #1 finished\nparent done\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n#include <sys/wait.h>\n\nint main(void)\n{\n    if (fork() != 0) {\n        std::cout << \"parent\\n\";\n        wait(nullptr);\n    }\n    else {\n        std::cout << \"child\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// parent\n// child\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n#include <sys/wait.h>\n\nint main(void)\n{\n    if (fork() != 0) {\n        sleep(1);\n        std::cout << \"parent\\n\";\n        wait(nullptr);\n    }\n    else {\n        std::cout << \"child\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// child\n// parent\n```", "```cpp\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#include <array>\n#include <iostream>\n#include <string_view>\n\nclass mypipe\n{\n    std::array<int, 2> m_handles;\n\npublic:\n    mypipe()\n    {\n        if (pipe(m_handles.data()) < 0) {\n            exit(1);\n        }\n    }\n\n    ~mypipe()\n    {\n        close(m_handles.at(0));\n        close(m_handles.at(1));\n    }\n\n    std::string\n    read()\n    {\n        std::array<char, 256> buf;\n        std::size_t bytes = ::read(m_handles.at(0), buf.data(), buf.size());\n\n        if (bytes > 0) {\n            return {buf.data(), bytes};\n        }\n\n        return {};\n    }\n\n    void\n    write(const std::string &msg)\n    {\n        ::write(m_handles.at(1), msg.data(), msg.size());\n    }\n};\n\nint main(void)\n{\n    mypipe p;\n\n    if (fork() != 0) {\n        sleep(1);\n        std::cout << \"parent\\n\";\n\n        p.write(\"done\");\n        wait(nullptr);\n    }\n    else {\n        auto msg = p.read();\n\n        std::cout << \"child\\n\";\n        std::cout << \"msg: \" << msg << '\\n';\n    }\n}\n\n// > g++ scratchpad.cpp -std=c++17; ./a.out\n// parent\n// child\n// msg: done\n```", "```cpp\nmypipe()\n{\n    if (pipe(m_handles.data()) < 0) {\n        exit(1);\n    }\n}\n```", "```cpp\n~mypipe()\n{\n    close(m_handles.at(0));\n    close(m_handles.at(1));\n}\n```", "```cpp\nstd::string\nread()\n{\n    std::array<char, 256> buf;\n    std::size_t bytes = ::read(m_handles.at(0), buf.data(), buf.size());\n\n    if (bytes > 0) {\n        return {buf.data(), bytes};\n    }\n\n    return {};\n}\n```", "```cpp\nvoid\nwrite(const std::string &msg)\n{\n    ::write(m_handles.at(1), msg.data(), msg.size());\n}\n```", "```cpp\nsleep(1);\nstd::cout << \"parent\\n\";\n\np.write(\"done\");\nwait(nullptr);\n```", "```cpp\nauto msg = p.read();\n\nstd::cout << \"child\\n\";\nstd::cout << \"msg: \" << msg << '\\n';\n```", "```cpp\n#include <string.h>\n#include <unistd.h>\n#include <sys/shm.h>\n#include <sys/wait.h>\n\n#include <iostream>\n\nchar *\nget_shared_memory()\n{\n    auto key = ftok(\"myfile\", 42);\n    auto shm = shmget(key, 0x1000, 0666 | IPC_CREAT);\n\n    return static_cast<char *>(shmat(shm, nullptr, 0));\n}\n\nint main(void)\n{\n    if (fork() != 0) {\n        sleep(1);\n        std::cout << \"parent\\n\";\n\n        auto msg = get_shared_memory();\n        msg[0] = 42;\n\n        wait(nullptr);\n    }\n    else {\n auto msg = get_shared_memory();\n while(msg[0] != 42);\n\n std::cout << \"child\\n\";\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// parent\n// child\n```", "```cpp\nchar *\nget_shared_memory()\n{\n    auto key = ftok(\"myfile\", 42);\n    auto shm = shmget(key, 0x1000, 0666 | IPC_CREAT);\n\n    return static_cast<char *>(shmat(shm, nullptr, 0));\n}\n```", "```cpp\nsleep(1);\nstd::cout << \"parent\\n\";\n\nauto msg = get_shared_memory();\nmsg[0] = 42;\n\nwait(nullptr);\n```", "```cpp\nauto msg = get_shared_memory();\nwhile(msg[0] != 42);\n\nstd::cout << \"child\\n\";\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    execl(\"/bin/ls\", \"ls\", nullptr);\n    std::cout << \"Hello World\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls>\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    system(\"ls\");\n    std::cout << \"Hello World\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls -al>\n// Hello World\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n#include <sys/wait.h>\n\nvoid\nmysystem(const char *command)\n{\n    if (fork() == 0) {\n        execlp(command, command, nullptr);\n    }\n    else {\n        wait(nullptr);\n    }\n}\n\nint main(void)\n{\n    mysystem(\"ls\");\n    std::cout << \"Hello World\\n\";\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls>\n// Hello World\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    execl(\"/bin/ls\", \"ls\", \"-al\", nullptr);\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls -al>\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    const char *envp[] = {\"ENV1=1\", \"ENV2=2\", nullptr};\n    execle(\"/bin/ls\", \"ls\", nullptr, envp);\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls>\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    execlp(\"ls\", \"ls\", nullptr);\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls>\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    const char *argv[] = {\"ls\", nullptr};\n    execv(\"/bin/ls\", const_cast<char **>(argv));\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls>\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    const char *argv[] = {\"ls\", nullptr};\n    const char *envp[] = {\"ENV1=1\", \"ENV2=2\", nullptr};\n\n    execve(\n        \"/bin/ls\",\n        const_cast<char **>(argv),\n        const_cast<char **>(envp)\n    );\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls>\n```", "```cpp\n\\#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    const char *argv[] = {\"ls\", nullptr};\n    execvp(\"ls\", const_cast<char **>(argv));\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls>\n```", "```cpp\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#include <array>\n#include <iostream>\n#include <string_view>\n\nclass mypipe\n{\n    std::array<int, 2> m_handles;\n\npublic:\n    mypipe()\n    {\n        if (pipe(m_handles.data()) < 0) {\n            exit(1);\n        }\n    }\n\n    ~mypipe()\n    {\n        close(m_handles.at(0));\n        close(m_handles.at(1));\n    }\n\n    std::string\n    read()\n    {\n        std::array<char, 256> buf;\n        std::size_t bytes = ::read(m_handles.at(0), buf.data(), buf.size());\n\n        if (bytes > 0) {\n            return {buf.data(), bytes};\n        }\n\n        return {};\n    }\n\n    void\n    redirect()\n    {\n        dup2(m_handles.at(1), STDOUT_FILENO);\n        close(m_handles.at(0));\n        close(m_handles.at(1));\n    }\n};\n\nint main(void)\n{\n    mypipe p;\n\n    if(fork() == 0) {\n        p.redirect();\n        execlp(\"ls\", \"ls\", nullptr);\n    }\n    else {\n        wait(nullptr);\n        std::cout << p.read() << '\\n';\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// <output of ls>\n```", "```cpp\nvoid\nredirect()\n{\n    dup2(m_handles.at(1), STDOUT_FILENO);\n    close(m_handles.at(0));\n    close(m_handles.at(1));\n}\n```", "```cpp\nif(fork() == 0) {\n    p.redirect();\n    execlp(\"ls\", \"ls\", nullptr);\n}\nelse {\n    wait(nullptr);\n    std::cout << p.read() << '\\n';\n}\n```", "```cpp\n#include <unistd.h>\n#include <iostream>\n\nint main(void)\n{\n    while(true) {\n        std::cout << \"Hello World\\n\";\n        sleep(1);\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n// Hello World\n// Hello World\n// ...\n// ^C\n```", "```cpp\n#include <signal.h>\n#include <unistd.h>\n#include <iostream>\n\nvoid handler(int sig)\n{\n    if (sig == SIGINT)\n    {\n        std::cout << \"handler called\\n\";\n    }\n}\n\nint main(void)\n{\n    signal(SIGINT, handler);\n\n    for (auto i = 0; i < 10; i++)\n    {\n        std::cout << \"Hello World\\n\";\n        sleep(1);\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n// Hello World\n// ^Chandler called\n// Hello World\n// ^Chandler called\n// Hello World\n// ^Chandler called\n// Hello World\n// ^Chandler called\n// Hello World\n// Hello World\n// Hello World\n// Hello World\n// Hello World\n```", "```cpp\n#include <signal.h>\n#include <unistd.h>\n#include <iostream>\n\nauto loop = true;\n\nvoid handler(int sig)\n{\n    if (sig == SIGINT)\n    {\n        std::cout << \"handler called\\n\";\n        loop = false;\n    }\n}\n\nint main(void)\n{\n    signal(SIGINT, handler);\n\n    while(loop) {\n        std::cout << \"Hello World\\n\";\n        sleep(1);\n    }\n}\n\n// > g++ scratchpad.cpp; ./a.out\n// Hello World\n// Hello World\n// ^Chandler called\n```", "```cpp\n#include <signal.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n#include <iostream>\n\nvoid\nmysystem(const char *command)\n{\n    if(auto id = fork(); id > 0) {\n        sleep(2);\n        kill(id, SIGINT);\n    }\n    else {\n        execlp(command, command, nullptr);\n    }\n}\n\nint main(void)\n{\n    mysystem(\"b.out\");\n}\n\n// > g++ scratchpad.cpp -std=c++17; ./a.out\n// \n```"]