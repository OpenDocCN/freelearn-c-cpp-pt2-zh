["```cpp\ndeclare i32 @printf(i8*, ...)\n@hellostr = private unnamed_addr constant [13 x i8] c\"Hello \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0world\\0A\\00\"\ndefine i32 @main(i32 %argc, i8** %argv) {\n\u00a0\u00a0%res = call i32 (i8*, ...) @printf(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i8* getelementptr inbounds ([13 x i8],\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[13 x i8]* @hellostr, i64 0, i64 0))\n\u00a0\u00a0ret i32 0\n}\n```", "```cpp\n$ lli hello.ll\nHello world\n```", "```cpp\n#include <stdio.h>\nvoid greetings() {\n\u00a0\u00a0puts(\"Hi!\");\n}\n```", "```cpp\n$ clang \u2013fPIC \u2013shared \u2013o greetings.so greetings.c\n```", "```cpp\n$ clang \u2013c \u2013o greetings.o greetings.c\n```", "```cpp\ndeclare void @greetings(...)\ndefine dso_local i32 @main(i32 %argc, i8** %argv) {\n\u00a0\u00a0call void (...) @greetings()\n\u00a0\u00a0ret i32 0\n}\n```", "```cpp\n$ lli main.ll\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\n```", "```cpp\n$ lli \u2013load ./greetings.so main.ll\nHi!\n```", "```cpp\n$ lli \u2013extra-object greetings.o main.ll\nHi!\n```", "```cpp\n    Error jitmain(std::unique_ptr<Module> M,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::unique_ptr<LLVMContext> Ctx, int \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0argc,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char *argv[]) {\n    ```", "```cpp\n    \u00a0\u00a0auto JIT = orc::LLJITBuilder().create();\n    \u00a0\u00a0if (!JIT)\n    \u00a0\u00a0\u00a0\u00a0return JIT.takeError();\n    ```", "```cpp\n    \u00a0\u00a0if (auto Err = (*JIT)->addIRModule(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0orc::ThreadSafeModule(std::move(M),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(Ctx))))\n    \u00a0\u00a0\u00a0\u00a0return Err;\n    ```", "```cpp\n    \u00a0\u00a0const DataLayout &DL = (*JIT)->getDataLayout();\n    \u00a0\u00a0auto DLSG = orc::DynamicLibrarySearchGenerator::\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetForCurrentProcess(DL.getGlobalPrefix());\n    \u00a0\u00a0if (!DLSG)\n    \u00a0\u00a0\u00a0\u00a0return DLSG.takeError();\n    ```", "```cpp\n    \u00a0\u00a0(*JIT)->getMainJITDylib().addGenerator(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(*DLSG));\n    ```", "```cpp\n    \u00a0\u00a0auto MainSym = (*JIT)->lookup(\"main\");\n    \u00a0\u00a0if (!MainSym)\n    \u00a0\u00a0\u00a0\u00a0return MainSym.takeError();\n    ```", "```cpp\n    \u00a0\u00a0auto *Main = (int (*)(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int, char **))MainSym->getAddress();\n    ```", "```cpp\n    \u00a0\u00a0(void)Main(argc, argv);\n    ```", "```cpp\n    \u00a0\u00a0return Error::success();\n    }\n    ```", "```cpp\n    #include \"llvm/ExecutionEngine/Orc/LLJIT.h\"\n    #include \"llvm/IRReader/IRReader.h\"\n    #include \"llvm/Support/CommandLine.h\"\n    #include \"llvm/Support/InitLLVM.h\"\n    #include \"llvm/Support/TargetSelect.h\"\n    ```", "```cpp\n    using namespace llvm;\n    ```", "```cpp\n    static cl::opt<std::string>\n    \u00a0\u00a0\u00a0\u00a0InputFile(cl::Positional, cl::Required,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cl::desc(\"<input-file>\"));\n    ```", "```cpp\n    std::unique_ptr<Module>\n    loadModule(StringRef Filename, LLVMContext &Ctx,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *ProgName) {\n    \u00a0\u00a0SMDiagnostic Err;\n    \u00a0\u00a0std::unique_ptr<Module> Mod =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parseIRFile(Filename, Err, Ctx);\n    \u00a0\u00a0if (!Mod.get()) {\n    \u00a0\u00a0\u00a0\u00a0Err.print(ProgName, errs());\n    \u00a0\u00a0\u00a0\u00a0exit(-1);\n    \u00a0\u00a0}\n    \u00a0\u00a0return std::move(Mod);\n    }\n    ```", "```cpp\n    Error jitmain(\u2026) { \u2026 }\n    ```", "```cpp\n    int main(int argc, char *argv[]) {\n    \u00a0\u00a0InitLLVM X(argc, argv);\n    \u00a0\u00a0InitializeNativeTarget();\n    \u00a0\u00a0InitializeNativeTargetAsmPrinter();\n    \u00a0\u00a0InitializeNativeTargetAsmParser();\n    \u00a0\u00a0cl::ParseCommandLineOptions(argc, argv,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"JIT\\n\");\n    ```", "```cpp\n    \u00a0\u00a0auto Ctx = std::make_unique<LLVMContext>();\n    ```", "```cpp\n    \u00a0\u00a0std::unique_ptr<Module> M =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0loadModule(InputFile, *Ctx, argv[0]);\n    ```", "```cpp\n    \u00a0\u00a0ExitOnError ExitOnErr(std::string(argv[0]) + \": \");\n    \u00a0\u00a0ExitOnErr(jitmain(std::move(M), std::move(Ctx),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0argc, argv));\n    ```", "```cpp\n    \u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    cmake_minimum_required (VERSION 3.13.4)\n    project (\"jit\")\n    ```", "```cpp\n    find_package(LLVM REQUIRED CONFIG)\n    list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})\n    include(ChooseMSVCCRT)\n    ```", "```cpp\n    add_definitions(${LLVM_DEFINITIONS})\n    include_directories(SYSTEM ${LLVM_INCLUDE_DIRS})\n    llvm_map_components_to_libnames(llvm_libs Core OrcJIT\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Support \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0native)\n    ```", "```cpp\n    add_executable(JIT JIT.cpp)\n    target_link_libraries(JIT ${llvm_libs})\n    ```", "```cpp\n    $ cmake \u2013G Ninja <path to source directory>\n    $ ninja\n    ```", "```cpp\n$ JIT hello.ll\nHello world\n```", "```cpp\n    #ifndef JIT_H\n    #define JIT_H\n    ```", "```cpp\n    #include \"llvm/Analysis/AliasAnalysis.h\"\n    #include \"llvm/ExecutionEngine/JITSymbol.h\"\n    #include \"llvm/ExecutionEngine/Orc/CompileUtils.h\"\n    #include \"llvm/ExecutionEngine/Orc/Core.h\"\n    #include \"llvm/ExecutionEngine/Orc/ExecutionUtils.h\"\n    #include \"llvm/ExecutionEngine/Orc/IRCompileLayer.h\"\n    #include \"llvm/ExecutionEngine/Orc/IRTransformLayer.h\"\n    #include \u00a0\u00a0\u00a0\u00a0\"llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h\"\n    #include \"llvm/ExecutionEngine/Orc/Mangling.h\"\n    #include \u00a0\u00a0\u00a0\u00a0\"llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h\"\n    #include \u00a0\u00a0\u00a0\u00a0\"llvm/ExecutionEngine/Orc/TargetProcessControl.h\"\n    #include \"llvm/ExecutionEngine/SectionMemoryManager.h\"\n    #include \"llvm/Passes/PassBuilder.h\"\n    #include \"llvm/Support/Error.h\"\n    ```", "```cpp\n    class JIT {\n    ```", "```cpp\n    \u00a0\u00a0std::unique_ptr<llvm::orc::TargetProcessControl> \n    \u00a0\u00a0\u00a0\u00a0TPC;\n    \u00a0\u00a0std::unique_ptr<llvm::orc::ExecutionSession> ES;\n    \u00a0\u00a0llvm::DataLayout DL;\n    \u00a0\u00a0llvm::orc::MangleAndInterner Mangle;\n    \u00a0\u00a0std::unique_ptr<llvm::orc::RTDyldObjectLinkingLayer>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ObjectLinkingLayer;\n    \u00a0\u00a0std::unique_ptr<llvm::orc::IRCompileLayer>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CompileLayer;\n    \u00a0\u00a0std::unique_ptr<llvm::orc::IRTransformLayer>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OptIRLayer;\n    \u00a0\u00a0llvm::orc::JITDylib &MainJITDylib;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0static llvm::Expected<std::unique_ptr<JIT>> create() {\n    \u00a0\u00a0\u00a0\u00a0auto SSP =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::make_shared<llvm::orc::SymbolStringPool>();\n    \u00a0\u00a0\u00a0\u00a0auto TPC =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::SelfTargetProcessControl::Create(SSP);\n    \u00a0\u00a0\u00a0\u00a0if (!TPC)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return TPC.takeError();\n    \u00a0\u00a0\u00a0\u00a0llvm::orc::JITTargetMachineBuilder JTMB(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(*TPC)->getTargetTriple());\n    \u00a0\u00a0\u00a0\u00a0auto DL = JTMB.getDefaultDataLayoutForTarget();\n    \u00a0\u00a0\u00a0\u00a0if (!DL)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return DL.takeError();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0auto ES =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::make_unique<llvm::orc::ExecutionSession>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(SSP));\n    \u00a0\u00a0\u00a0\u00a0return std::make_unique<JIT>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(*TPC), std::move(ES), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(*DL),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(JTMB));\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0JIT(std::unique_ptr<llvm::orc::TargetProcessControl>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TPCtrl,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::unique_ptr<llvm::orc::ExecutionSession> ExeS,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::DataLayout DataL,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::JITTargetMachineBuilder JTMB)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: TPC(std::move(TPCtrl)), ES(std::move(ExeS)),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DL(std::move(DataL)), Mangle(*ES, DL),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ObjectLinkingLayer(std::move(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0createObjectLinkingLayer(*ES, JTMB))),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CompileLayer(std::move(createCompileLayer(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*ES, *ObjectLinkingLayer, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(JTMB)))),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OptIRLayer(std::move(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0createOptIRLayer(*ES, *CompileLayer))),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MainJITDylib(ES->createBareJITDylib(\"<main>\")) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0MainJITDylib.addGenerator(llvm::cantFail(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::DynamicLibrarySearchGenerator::\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GetForCurrentProcess(DL.getGlobalPrefix())));\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0static std::unique_ptr<\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::RTDyldObjectLinkingLayer>\n    \u00a0\u00a0createObjectLinkingLayer(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::ExecutionSession &ES,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::JITTargetMachineBuilder &JTMB) {\n    \u00a0\u00a0\u00a0\u00a0auto GetMemoryManager = []() {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::make_unique<\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::SectionMemoryManager>();\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0auto OLLayer = std::make_unique<\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::RTDyldObjectLinkingLayer>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ES, GetMemoryManager);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (JTMB.getTargetTriple().isOSBinFormatCOFF()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OLLayer\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->setOverrideObjectFlagsWithResponsibilityFlags(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0true);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OLLayer\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->setAutoClaimResponsibilityForObjectSymbols(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0true);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return std::move(OLLayer);\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0static std::unique_ptr<llvm::orc::IRCompileLayer>\n    \u00a0\u00a0createCompileLayer(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::ExecutionSession &ES,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::RTDyldObjectLinkingLayer &OLLayer,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::JITTargetMachineBuilder JTMB) {\n    \u00a0\u00a0\u00a0\u00a0auto IRCompiler = std::make_unique<\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::ConcurrentIRCompiler>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(JTMB));\n    \u00a0\u00a0\u00a0\u00a0auto IRCLayer =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::make_unique<llvm::orc::IRCompileLayer>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ES, OLLayer, std::move(IRCompiler));\n    \u00a0\u00a0\u00a0\u00a0return std::move(IRCLayer);\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0static std::unique_ptr<llvm::orc::IRTransformLayer>\n    \u00a0\u00a0createOptIRLayer(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::ExecutionSession &ES,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::IRCompileLayer &CompileLayer) {\n    \u00a0\u00a0\u00a0\u00a0auto OptIRLayer =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::make_unique<llvm::orc::IRTransformLayer>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ES, CompileLayer,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0optimizeModule);\n    \u00a0\u00a0\u00a0\u00a0return std::move(OptIRLayer);\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0static llvm::Expected<llvm::orc::ThreadSafeModule>\n    \u00a0\u00a0optimizeModule(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::ThreadSafeModule TSM,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const llvm::orc::MaterializationResponsibility\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&R) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0TSM.withModuleDo([](llvm::Module &M) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool DebugPM = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::PassBuilder PB(DebugPM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::LoopAnalysisManager LAM(DebugPM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::FunctionAnalysisManager FAM(DebugPM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::CGSCCAnalysisManager CGAM(DebugPM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::ModuleAnalysisManager MAM(DebugPM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FAM.registerPass(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[&] { return PB.buildDefaultAAPipeline(); });\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PB.registerModuleAnalyses(MAM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PB.registerCGSCCAnalyses(CGAM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PB.registerFunctionAnalyses(FAM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PB.registerLoopAnalyses(LAM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::ModulePassManager MPM =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PB.buildPerModuleDefaultPipeline(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::PassBuilder::OptimizationLevel::O2,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DebugPM);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MPM.run(M, MAM);\n    \u00a0\u00a0\u00a0\u00a0});\n    \u00a0\u00a0\u00a0\u00a0return std::move(TSM);\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0llvm::Error addIRModule(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::ThreadSafeModule TSM,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::orc::ResourceTrackerSP RT = nullptr) {\n    \u00a0\u00a0\u00a0\u00a0if (!RT)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0RT = MainJITDylib.getDefaultResourceTracker();\n    \u00a0\u00a0\u00a0\u00a0return OptIRLayer->add(RT, std::move(TSM));\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0llvm::Expected<llvm::JITEvaluatedSymbol>\n    \u00a0\u00a0lookup(llvm::StringRef Name) {\n    \u00a0\u00a0\u00a0\u00a0return ES->lookup({&MainJITDylib},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Mangle(Name.str()));\n    \u00a0\u00a0}\n    ```", "```cpp\n\u00a0\u00a0if (auto *Const = llvm::dyn_cast<ConstantAccess>(Expr)) {\n\u00a0\u00a0\u00a0\u00a0// Do something with the constant.\n\u00a0\u00a0}\n```"]