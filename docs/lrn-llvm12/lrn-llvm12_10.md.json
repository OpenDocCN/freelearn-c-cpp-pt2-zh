["```cpp\n    #ifndef LLVM_TRANSFORMS_COUNTIR_COUNTIR_H\n    #define LLVM_TRANSFORMS_COUNTIR_COUNTIR_H\n    #include \"llvm/IR/PassManager.h\"\n    ```", "```cpp\n    namespace llvm {\n    class CountIRPass : public PassInfoMixin<CountIRPass> {\n    ```", "```cpp\n    public:\n    \u00a0\u00a0PreservedAnalyses run(Function &F,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FunctionAnalysisManager &AM);\n    ```", "```cpp\n    };\n    } // namespace llvm\n    #endif\n    ```", "```cpp\n    #include \"llvm/Transforms/CountIR/CountIR.h\"\n    #include \"llvm/ADT/Statistic.h\"\n    #include \"llvm/Support/Debug.h\"\n    ```", "```cpp\n    using namespace llvm;\n    ```", "```cpp\n    #define DEBUG_TYPE \"countir\"\n    ```", "```cpp\n    STATISTIC(NumOfInst, \"Number of instructions.\");\n    STATISTIC(NumOfBB, \"Number of basic blocks.\");\n    ```", "```cpp\n    PreservedAnalyses\n    CountIRPass::run(Function &F,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FunctionAnalysisManager &AM) {\n    \u00a0\u00a0for (BasicBlock &BB : F) {\n    \u00a0\u00a0\u00a0\u00a0++NumOfBB;\n    \u00a0\u00a0\u00a0\u00a0for (Instruction &I : BB) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(void)I;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++NumOfInst;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    \u00a0\u00a0return PreservedAnalyses::all();\n    }\n    ```", "```cpp\n    add_llvm_component_library(LLVMCountIR\n    \u00a0\u00a0CountIR.cpp\n    \u00a0\u00a0LINK_COMPONENTS Core Support )\n    ```", "```cpp\n    add_subdirectory(CountIR)\n    ```", "```cpp\n    #include \"llvm/Transforms/CountIR/CountIR.h\"\n    ```", "```cpp\n    FUNCTION_PASS(\"countir\", CountIRPass())\n    ```", "```cpp\n    define internal i32 @func() {\n    \u00a0\u00a0ret i32 0\n    }\n    define dso_local i32 @main() {\n    \u00a0\u00a0%1 = call i32 @func()\n    \u00a0\u00a0ret i32 %1\n    }\n    ```", "```cpp\n    $ bin/opt --disable-output --passes=\"countir\" \u2013-stats demo.ll\n    ===--------------------------------------------------------===\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0... Statistics Collected ...\n    ===--------------------------------------------------------===\n    2 countir - Number of basic blocks.\n    3 countir - Number of instructions. \n    ```", "```cpp\n    |-- CMakeLists.txt\n    |-- include\n    |\u00a0\u00a0\u00a0`-- CountIR.h\n    |-- lib\n    \u00a0\u00a0\u00a0\u00a0|-- CMakeLists.txt\n    \u00a0\u00a0\u00a0\u00a0`-- CountIR.cpp\n    ```", "```cpp\n    #ifndef COUNTIR_H\n    #define COUNTIR_H\n    #include \"llvm/IR/PassManager.h\"\n    class CountIRPass\n    \u00a0\u00a0\u00a0\u00a0: public llvm::PassInfoMixin<CountIRPass> {\n    public:\n    \u00a0\u00a0llvm::PreservedAnalyses\n    \u00a0\u00a0run(llvm::Function &F,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::FunctionAnalysisManager &AM);\n    };\n    #endif\n    ```", "```cpp\n    #include \"CountIR.h\"\n    ```", "```cpp\n    #include \"llvm/Passes/PassBuilder.h\"\n    #include \"llvm/Passes/PassPlugin.h\"\n    ```", "```cpp\n    bool PipelineParsingCB(\n    \u00a0\u00a0\u00a0\u00a0StringRef Name, FunctionPassManager &FPM,\n    \u00a0\u00a0\u00a0\u00a0ArrayRef<PassBuilder::PipelineElement>) {\n    \u00a0\u00a0if (Name == \"countir\") {\n    \u00a0\u00a0\u00a0\u00a0FPM.addPass(CountIRPass());\n    \u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0}\n    \u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    void RegisterCB(PassBuilder &PB) {\n    \u00a0\u00a0PB.registerPipelineParsingCallback(PipelineParsingCB);\n    }\n    ```", "```cpp\n    extern \"C\" ::llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK\n    llvmGetPassPluginInfo() {\n    \u00a0\u00a0return {LLVM_PLUGIN_API_VERSION, \"CountIR\", \"v0.1\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0RegisterCB};\n    }\n    ```", "```cpp\n    extern \"C\" ::llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK\n    llvmGetPassPluginInfo() {\n    \u00a0\u00a0return {LLVM_PLUGIN_API_VERSION, \"CountIR\", \"v0.1\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[](PassBuilder &PB) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PB.registerPipelineParsingCallback(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[](StringRef Name, FunctionPassManager \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&FPM,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ArrayRef<PassBuilder::PipelineElement>)\u00a0\u00a0\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (Name == \"countir\") {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FPM.addPass(CountIRPass());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0});\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}};\n    }\n    ```", "```cpp\n    add_llvm_library(CountIR MODULE CountIR.cpp)\n    ```", "```cpp\n    cmake_minimum_required(VERSION 3.4.3)\n    project(countirpass)\n    set(LLVM_EXPORTED_SYMBOL_FILE ON)\n    ```", "```cpp\n    find_package(LLVM REQUIRED CONFIG)\n    message(STATUS \"Found LLVM ${LLVM_PACKAGE_VERSION}\")\n    message(STATUS \"Using LLVMConfig.cmake in: ${LLVM_DIR}\")\n    ```", "```cpp\n    list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})\n    include(ChooseMSVCCRT)\n    include(AddLLVM)\n    ```", "```cpp\n    include_directories(\"${LLVM_INCLUDE_DIR}\")\n    add_definitions(\"${LLVM_DEFINITIONS}\")\n    link_directories(\"${LLVM_LIBRARY_DIR}\")\n    ```", "```cpp\n    include_directories(BEFORE include)\n    add_subdirectory(lib)\n    ```", "```cpp\n    $ cmake \u2013G Ninja ../countirpass\n    ```", "```cpp\n    $ ninja\n    ```", "```cpp\n    $ opt --load-pass-plugin=lib/CountIR.so --passes=\"countir\"\\\n    \u00a0\u00a0--disable-output \u2013-stats demo.ll\n    ```", "```cpp\n    #include \"llvm/Pass.h\"\n    ```", "```cpp\n    class CountIRLegacyPass : public llvm::FunctionPass {\n    public:\n    \u00a0\u00a0static char ID;\n    \u00a0\u00a0CountIRLegacyPass() : llvm::FunctionPass(ID) {}\n    ```", "```cpp\n    \u00a0\u00a0bool runOnFunction(llvm::Function &F) override;\n    \u00a0\u00a0void getAnalysisUsage(llvm::AnalysisUsage &AU) const \u00a0\u00a0\u00a0\u00a0override;\n    };\n    ```", "```cpp\n    void runCounting(Function &F) {\n    \u00a0\u00a0for (BasicBlock &BB : F) {\n    \u00a0\u00a0\u00a0\u00a0++NumOfBB;\n    \u00a0\u00a0\u00a0\u00a0for (Instruction &I : BB) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(void)I;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++NumOfInst;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    PreservedAnalyses\n    CountIRPass::run(Function &F, FunctionAnalysisManager &AM) {\n    \u00a0\u00a0runCounting(F);\n    \u00a0\u00a0return PreservedAnalyses::all();\n    }\n    ```", "```cpp\n    bool CountIRLegacyPass::runOnFunction(Function &F) {\n    \u00a0\u00a0runCounting(F);\n    \u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    void CountIRLegacyPass::getAnalysisUsage(\n    \u00a0\u00a0\u00a0\u00a0AnalysisUsage &AU) const {\n    \u00a0\u00a0AU.setPreservesAll();\n    }\n    ```", "```cpp\n    char CountIRLegacyPass::ID = 0;\n    ```", "```cpp\n    static RegisterPass<CountIRLegacyPass>\n    \u00a0\u00a0\u00a0\u00a0X(\"countir\", \"CountIR Pass\");\n    ```", "```cpp\n    $ ninja\n    ```", "```cpp\n    $ opt --load lib/CountIR.so --countir \u2013-stats\\\n    \u00a0\u00a0--disable-output demo.ll\n    ```", "```cpp\n    #include \"llvm/Passes/PassBuilder.h\"\n    #include \"llvm/Passes/PassPlugin.h\"\n    #include \"llvm/Analysis/TargetTransformInfo.h\"\n    ```", "```cpp\n    static cl::opt<bool>\n    \u00a0\u00a0\u00a0\u00a0DebugPM(\"debug-pass-manager\", cl::Hidden,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cl::desc(\"Print PM debugging \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0information\"));\n    static cl::opt<std::string> PassPipeline(\n    \u00a0\u00a0\u00a0\u00a0\"passes\",\n    \u00a0\u00a0\u00a0\u00a0cl::desc(\"A description of the pass pipeline\"));\n    static cl::list<std::string> PassPlugins(\n    \u00a0\u00a0\u00a0\u00a0\"load-pass-plugin\",\n    \u00a0\u00a0\u00a0\u00a0cl::desc(\"Load passes from plugin library\"));\n    ```", "```cpp\n    static cl::opt<signed char> OptLevel(\n    \u00a0\u00a0\u00a0\u00a0cl::desc(\"Setting the optimization level:\"),\n    \u00a0\u00a0\u00a0\u00a0cl::ZeroOrMore,\n    \u00a0\u00a0\u00a0\u00a0cl::values(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clEnumValN(3, \"O\", \"Equivalent to -O3\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clEnumValN(0, \"O0\", \"Optimization level 0\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clEnumValN(1, \"O1\", \"Optimization level 1\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clEnumValN(2, \"O2\", \"Optimization level 2\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clEnumValN(3, \"O3\", \"Optimization level 3\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clEnumValN(-1, \"Os\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Like -O2 with extra \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0optimizations \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"for size\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clEnumValN(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-2, \"Oz\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Like -Os but reduces code size further\")),\n    \u00a0\u00a0\u00a0\u00a0cl::init(0));\n    ```", "```cpp\n    #define HANDLE_EXTENSION(Ext)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\\n    \u00a0\u00a0llvm::PassPluginLibraryInfo get##Ext##PluginInfo();\n    #include \"llvm/Support/Extension.def\"\n    ```", "```cpp\n    bool emit(StringRef Argv0, llvm::Module *M,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::TargetMachine *TM,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef InputFilename) {\n    \u00a0\u00a0PassBuilder PB(TM);\n    ```", "```cpp\n    \u00a0\u00a0for (auto &PluginFN : PassPlugins) {\n    \u00a0\u00a0\u00a0\u00a0auto PassPlugin = PassPlugin::Load(PluginFN);\n    \u00a0\u00a0\u00a0\u00a0if (!PassPlugin) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WithColor::error(errs(), Argv0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \"Failed to load passes from '\" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< PluginFN\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \"'. Request ignored.\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0PassPlugin->registerPassBuilderCallbacks(PB);\n    \u00a0\u00a0}\n    ```", "```cpp\n    #define HANDLE_EXTENSION(Ext)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\\n    \u00a0\u00a0get##Ext##PluginInfo().RegisterPassBuilderCallbacks( \\\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PB);\n    #include \"llvm/Support/Extension.def\"\n    ```", "```cpp\n    \u00a0\u00a0LoopAnalysisManager LAM(DebugPM);\n    \u00a0\u00a0FunctionAnalysisManager FAM(DebugPM);\n    \u00a0\u00a0CGSCCAnalysisManager CGAM(DebugPM);\n    \u00a0\u00a0ModuleAnalysisManager MAM(DebugPM);\n    ```", "```cpp\n    \u00a0\u00a0FAM.registerPass(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[&] { return PB.buildDefaultAAPipeline(); });\n    \u00a0\u00a0PB.registerModuleAnalyses(MAM);\n    \u00a0\u00a0PB.registerCGSCCAnalyses(CGAM);\n    \u00a0\u00a0PB.registerFunctionAnalyses(FAM);\n    \u00a0\u00a0PB.registerLoopAnalyses(LAM);\n    \u00a0\u00a0PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);\n    ```", "```cpp\n    \u00a0\u00a0ModulePassManager MPM(DebugPM);\n    ```", "```cpp\n    \u00a0\u00a0if (!PassPipeline.empty()) {\n    \u00a0\u00a0\u00a0\u00a0if (auto Err = PB.parsePassPipeline(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MPM, PassPipeline)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WithColor::error(errs(), Argv0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< toString(std::move(Err)) << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0else {\n    \u00a0\u00a0\u00a0\u00a0StringRef DefaultPass;\n    \u00a0\u00a0\u00a0\u00a0switch (OptLevel) {\n    \u00a0\u00a0\u00a0\u00a0case 0: DefaultPass = \"default<O0>\"; break;\n    \u00a0\u00a0\u00a0\u00a0case 1: DefaultPass = \"default<O1>\"; break;\n    \u00a0\u00a0\u00a0\u00a0case 2: DefaultPass = \"default<O2>\"; break;\n    \u00a0\u00a0\u00a0\u00a0case 3: DefaultPass = \"default<O3>\"; break;\n    \u00a0\u00a0\u00a0\u00a0case -1: DefaultPass = \"default<Os>\"; break;\n    \u00a0\u00a0\u00a0\u00a0case -2: DefaultPass = \"default<Oz>\"; break;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (auto Err = PB.parsePassPipeline(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MPM, DefaultPass)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WithColor::error(errs(), Argv0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< toString(std::move(Err)) << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0std::error_code EC;\n    \u00a0\u00a0sys::fs::OpenFlags OpenFlags = sys::fs::OF_None;\n    \u00a0\u00a0CodeGenFileType FileType = codegen::getFileType();\n    \u00a0\u00a0if (FileType == CGFT_AssemblyFile)\n    \u00a0\u00a0\u00a0\u00a0OpenFlags |= sys::fs::OF_Text;\n    \u00a0\u00a0auto Out = std::make_unique<llvm::ToolOutputFile>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0outputFilename(InputFilename), EC, OpenFlags);\n    \u00a0\u00a0if (EC) {\n    \u00a0\u00a0\u00a0\u00a0WithColor::error(errs(), Argv0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< EC.message() << '\\n';\n    \u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0legacy::PassManager CodeGenPM;\n    \u00a0\u00a0CodeGenPM.add(createTargetTransformInfoWrapperPass(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TM->getTargetIRAnalysis()));\n    ```", "```cpp\n    \u00a0\u00a0if (FileType == CGFT_AssemblyFile && EmitLLVM) {\n    \u00a0\u00a0\u00a0\u00a0CodeGenPM.add(createPrintModulePass(Out->os()));\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0else {\n    \u00a0\u00a0\u00a0\u00a0if (TM->addPassesToEmitFile(CodeGenPM, Out->os(),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nullptr, FileType)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WithColor::error()\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \"No support for file type\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0MPM.run(*M, MAM);\n    \u00a0\u00a0CodeGenPM.run(*M);\n    \u00a0\u00a0Out->keep();\n    \u00a0\u00a0return true;\n    }\n    ```", "```cpp\n    set(LLVM_LINK_COMPONENTS ${LLVM_TARGETS_TO_BUILD}\n    \u00a0\u00a0AggressiveInstCombine Analysis AsmParser\n    \u00a0\u00a0BitWriter CodeGen Core Coroutines IPO IRReader\n    \u00a0\u00a0InstCombine Instrumentation MC ObjCARCOpts Remarks\n    \u00a0\u00a0ScalarOpts Support Target TransformUtils Vectorize\n    \u00a0\u00a0Passes)\n    ```", "```cpp\n    add_tinylang_tool(tinylang Driver.cpp SUPPORT_PLUGINS)\n    ```", "```cpp\n    target_link_libraries(tinylang\n    \u00a0\u00a0PRIVATE tinylangBasic tinylangCodeGen\n    \u00a0\u00a0tinylangLexer tinylangParser tinylangSema)\n    ```", "```cpp\n    $ ninja\n    ```", "```cpp\nPB.registerPipelineStartEPCallback(\n\u00a0\u00a0\u00a0\u00a0[](ModulePassManager &MPM) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MPM.addPass(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0createModuleToFunctionPassAdaptor(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CountIRPass());\n\u00a0\u00a0\u00a0\u00a0});\n```", "```cpp\n    static cl::opt<std::string> PipelineStartEPPipeline(\n    \u00a0\u00a0\u00a0\u00a0\"passes-ep-pipeline-start\",\n    \u00a0\u00a0\u00a0\u00a0cl::desc(\"Pipeline start extension point));\n    ```", "```cpp\n    \u00a0\u00a0PB.registerPipelineStartEPCallback(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[&PB, Argv0](ModulePassManager &PM) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (auto Err = PB.parsePassPipeline(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PM, PipelineStartEPPipeline)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WithColor::error(errs(), Argv0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \"Could not parse pipeline \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< PipelineStartEPPipeline.ArgStr \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \": \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< toString(std::move(Err)) << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0});\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0PassBuilder::OptimizationLevel Olevel = \u2026;\n    \u00a0\u00a0\u00a0\u00a0if (OLevel == PassBuilder::OptimizationLevel::O0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MPM.addPass(AlwaysInlinerPass());\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MPM = PB.buildPerModuleDefaultPipeline(OLevel, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DebugPM);\n    ```"]