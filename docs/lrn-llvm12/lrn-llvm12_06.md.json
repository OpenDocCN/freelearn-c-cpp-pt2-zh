["```cpp\ncompilationUnit\n\u00a0\u00a0: \"MODULE\" identifier \";\" ( import )* block identifier \".\" ;\nImport : ( \"FROM\" identifier )? \"IMPORT\" identList \";\" ;\nBlock\n\u00a0\u00a0: ( declaration )* ( \"BEGIN\" statementSequence )? \"END\" ;\n```", "```cpp\ndeclaration\n\u00a0\u00a0: \"CONST\" ( constantDeclaration \";\" )*\n\u00a0\u00a0| \"VAR\" ( variableDeclaration \";\" )*\n\u00a0\u00a0| procedureDeclaration \";\" ;\n```", "```cpp\nconstantDeclaration : identifier \"=\" expression ;\n```", "```cpp\nvariableDeclaration : identList \":\" qualident ;\nqualident : identifier ( \".\" identifier )* ;\nidentList : identifier ( \",\" identifier)* ;\n```", "```cpp\nprocedureDeclaration\n\u00a0\u00a0: \"PROCEDURE\" identifier ( formalParameters )? \";\"\n\u00a0\u00a0\u00a0\u00a0block identifier ;\nformalParameters\n\u00a0\u00a0: \"(\" ( formalParameterList )? \")\" ( \":\" qualident )? ;\nformalParameterList\n\u00a0\u00a0: formalParameter (\";\" formalParameter )* ;\nformalParameter : ( \"VAR\" )? identList \":\" qualident ;\n```", "```cpp\nstatementSequence\n\u00a0\u00a0: statement ( \";\" statement )* ;\n```", "```cpp\nstatement\n\u00a0\u00a0: qualident ( \":=\" expression | ( \"(\" ( expList )? \")\" )? )\n\u00a0\u00a0| ifStatement | whileStatement | \"RETURN\" ( expression )? ;\n```", "```cpp\nifStatement\n\u00a0\u00a0: \"IF\" expression \"THEN\" statementSequence\n\u00a0\u00a0\u00a0\u00a0( \"ELSE\" statementSequence )? \"END\" ;\n```", "```cpp\nwhileStatement\n\u00a0\u00a0: \"WHILE\" expression \"DO\" statementSequence \"END\" ;\n```", "```cpp\nexpList\n\u00a0\u00a0: expression ( \",\" expression )* ;\nexpression\n\u00a0\u00a0: simpleExpression ( relation simpleExpression )? ;\nrelation\n\u00a0\u00a0: \"=\" | \"#\" | \"<\" | \"<=\" | \">\" | \">=\" ;\nsimpleExpression\n\u00a0\u00a0: ( \"+\" | \"-\" )? term ( addOperator term )* ;\naddOperator\n\u00a0\u00a0: \"+\" | \"-\" | \"OR\" ;\nterm\n\u00a0\u00a0: factor ( mulOperator factor )* ;\nmulOperator\n\u00a0\u00a0: \"*\" | \"/\" | \"DIV\" | \"MOD\" | \"AND\" ;\nfactor\n\u00a0\u00a0: integer_literal | \"(\" expression \")\" | \"NOT\" factor\n\u00a0\u00a0| qualident ( \"(\" ( expList )? \")\" )? ; \n```", "```cpp\n#ifndef DIAG\n#define DIAG(ID, Level, Msg)\n#endif\nDIAG(err_sym_declared, Error, \"symbol {0} already declared\")\n#undef DIAG\n```", "```cpp\n#ifndef TINYLANG_BASIC_DIAGNOSTIC_H\n#define TINYLANG_BASIC_DIAGNOSTIC_H\n#include \"tinylang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <utility>\nnamespace tinylang {\n```", "```cpp\nnamespace diag {\nenum {\n#define DIAG(ID, Level, Msg) ID,\n#include \"tinylang/Basic/Diagnostic.def\"\n};\n} // namespace diag\n```", "```cpp\nclass DiagnosticsEngine {\n\u00a0\u00a0static const char *getDiagnosticText(unsigned DiagID);\n\u00a0\u00a0static SourceMgr::DiagKind\n\u00a0\u00a0getDiagnosticKind(unsigned DiagID);\n```", "```cpp\n\u00a0\u00a0SourceMgr &SrcMgr;\n\u00a0\u00a0unsigned NumErrors;\npublic:\n\u00a0\u00a0DiagnosticsEngine(SourceMgr &SrcMgr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: SrcMgr(SrcMgr), NumErrors(0) {}\n\u00a0\u00a0unsigned nunErrors() { return NumErrors; }\n```", "```cpp\n\u00a0\u00a0template <typename... Args>\n\u00a0\u00a0void report(SMLoc Loc, unsigned DiagID,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Args &&... Arguments) {\n\u00a0\u00a0\u00a0\u00a0std::string Msg =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::formatv(getDiagnosticText(DiagID),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::forward<Args>(Arguments)...)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.str();\n\u00a0\u00a0\u00a0\u00a0SourceMgr::DiagKind Kind = getDiagnosticKind(DiagID);\n\u00a0\u00a0\u00a0\u00a0SrcMgr.PrintMessage(Loc, Kind, Msg);\n\u00a0\u00a0\u00a0\u00a0NumErrors += (Kind == SourceMgr::DK_Error);\n\u00a0\u00a0}\n};\n} // namespace tinylang\n#endif\n```", "```cpp\n#include \"tinylang/Basic/Diagnostic.h\"\nusing namespace tinylang;\nnamespace {\nconst char *DiagnosticText[] = {\n#define DIAG(ID, Level, Msg) Msg,\n#include \"tinylang/Basic/Diagnostic.def\"\n};\n```", "```cpp\nSourceMgr::DiagKind DiagnosticKind[] = {\n#define DIAG(ID, Level, Msg) SourceMgr::DK_##Level,\n#include \"tinylang/Basic/Diagnostic.def\"\n};\n} // namespace\n```", "```cpp\nconst char *\nDiagnosticsEngine::getDiagnosticText(unsigned DiagID) {\n\u00a0\u00a0return DiagnosticText[DiagID];\n}\nSourceMgr::DiagKind\nDiagnosticsEngine::getDiagnosticKind(unsigned DiagID) {\n\u00a0\u00a0return DiagnosticKind[DiagID];\n}\n```", "```cpp\n#ifndef TOK\n#define TOK(ID)\n#endif\n#ifndef PUNCTUATOR\n#define PUNCTUATOR(ID, SP) TOK(ID)\n#endif\n#ifndef KEYWORD\n#define KEYWORD(ID, FLAG) TOK(kw_ ## ID)\n#endif\nTOK(unknown)\nTOK(eof)\nTOK(identifier)\nTOK(integer_literal)\nPUNCTUATOR(plus,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"+\")\nPUNCTUATOR(minus,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"-\")\n// \u2026\nKEYWORD(BEGIN\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0, KEYALL)\nKEYWORD(CONST\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0, KEYALL)\n// \u2026\n#undef KEYWORD\n#undef PUNCTUATOR\n#undef TOK\n```", "```cpp\n#ifndef TINYLANG_BASIC_TOKENKINDS_H\n#define TINYLANG_BASIC_TOKENKINDS_H\nnamespace tinylang {\nnamespace tok {\nenum TokenKind : unsigned short {\n#define TOK(ID) ID,\n#include \"TokenKinds.def\"\n\u00a0\u00a0NUM_TOKENS\n};\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0const char *getTokenName(TokenKind Kind);\n\u00a0\u00a0\u00a0\u00a0const char *getPunctuatorSpelling(TokenKind Kind);\n\u00a0\u00a0\u00a0\u00a0const char *getKeywordSpelling(TokenKind Kind);\n\u00a0\u00a0}\n}\n#endif\n```", "```cpp\n#include \"tinylang/Basic/TokenKinds.h\"\n#include \"llvm/Support/ErrorHandling.h\"\nusing namespace tinylang;\nstatic const char * const TokNames[] = {\n#define TOK(ID) #ID,\n#define KEYWORD(ID, FLAG) #ID,\n#include \"tinylang/Basic/TokenKinds.def\"\n\u00a0\u00a0nullptr\n};\n```", "```cpp\nconst char *tok::getTokenName(TokenKind Kind) {\n\u00a0\u00a0return TokNames[Kind];\n}\n```", "```cpp\nconst char *tok::getPunctuatorSpelling(TokenKind Kind) {\n\u00a0\u00a0switch (Kind) {\n#define PUNCTUATOR(ID, SP) case ID: return SP;\n#include \"tinylang/Basic/TokenKinds.def\"\n\u00a0\u00a0\u00a0\u00a0default: break;\n\u00a0\u00a0}\n\u00a0\u00a0return nullptr;\n}\nconst char *tok::getKeywordSpelling(TokenKind Kind) {\n\u00a0\u00a0switch (Kind) {\n#define KEYWORD(ID, FLAG) case kw_ ## ID: return #ID;\n#include \"tinylang/Basic/TokenKinds.def\"\n\u00a0\u00a0\u00a0\u00a0default: break;\n\u00a0\u00a0}\n\u00a0\u00a0return nullptr;\n}\n```", "```cpp\nclass Token {\n\u00a0\u00a0friend class Lexer;\n\u00a0\u00a0const char *Ptr;\n\u00a0\u00a0size_t Length;\n\u00a0\u00a0tok::TokenKind Kind;\npublic:\n\u00a0\u00a0tok::TokenKind getKind() const { return Kind; }\n\u00a0\u00a0size_t getLength() const { return Length; }\n```", "```cpp\n\u00a0\u00a0SMLoc getLocation() const {\n\u00a0\u00a0\u00a0\u00a0return SMLoc::getFromPointer(Ptr);\n\u00a0\u00a0}\n```", "```cpp\n\u00a0\u00a0StringRef getIdentifier() {\n\u00a0\u00a0\u00a0\u00a0assert(is(tok::identifier) &&\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Cannot get identfier of non-identifier\");\n\u00a0\u00a0\u00a0\u00a0return StringRef(Ptr, Length);\n\u00a0\u00a0}\n\u00a0\u00a0StringRef getLiteralData() {\n\u00a0\u00a0\u00a0\u00a0assert(isOneOf(tok::integer_literal,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tok::string_literal) &&\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Cannot get literal data of non-literal\");\n\u00a0\u00a0\u00a0\u00a0return StringRef(Ptr, Length);\n\u00a0\u00a0}\n};\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0case '<':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (*(CurPtr + 1) == '=')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0formTokenWithChars(token, CurPtr + 2, tok::lessequal);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0formTokenWithChars(token, CurPtr + 1, tok::less);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n```", "```cpp\n    class KeywordFilter {\n    \u00a0\u00a0llvm::StringMap<tok::TokenKind> HashTable;\n    \u00a0\u00a0void addKeyword(StringRef Keyword,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tok::TokenKind TokenCode);\n    public:\n    \u00a0\u00a0void addKeywords();\n    ```", "```cpp\n    \u00a0\u00a0tok::TokenKind getKeyword(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef Name,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tok::TokenKind DefaultTokenCode = tok::unknown) {\n    \u00a0\u00a0\u00a0\u00a0auto Result = HashTable.find(Name);\n    \u00a0\u00a0\u00a0\u00a0if (Result != HashTable.end())\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Result->second;\n    \u00a0\u00a0\u00a0\u00a0return DefaultTokenCode;\n    \u00a0\u00a0}\n    };\n    ```", "```cpp\n    void KeywordFilter::addKeyword(StringRef Keyword,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tok::TokenKind TokenCode) \n    {\n    \u00a0\u00a0HashTable.insert(std::make_pair(Keyword, TokenCode));\n    }\n    void KeywordFilter::addKeywords() {\n    #define KEYWORD(NAME, FLAGS)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n    addKeyword(StringRef(#NAME), tok::kw_##NAME);\n    #include \"tinylang/Basic/TokenKinds.def\"\n    }\n    ```", "```cpp\nifStatement\n\u00a0\u00a0: \"IF\" expression \"THEN\" statementSequence\n\u00a0\u00a0\u00a0\u00a0( \"ELSE\" statementSequence )? \"END\" ;\n```", "```cpp\nvoid Parser::parseIfStatement() {\n\u00a0\u00a0consume(tok::kw_IF);\n\u00a0\u00a0parseExpression();\n\u00a0\u00a0consume(tok::kw_THEN);\n\u00a0\u00a0parseStatementSequence();\n\u00a0\u00a0if (Tok.is(tok::kw_ELSE)) {\n\u00a0\u00a0\u00a0\u00a0advance();\n\u00a0\u00a0\u00a0\u00a0parseStatementSequence();\n\u00a0\u00a0}\n\u00a0\u00a0consume(tok::kw_END);\n}\n```", "```cpp\nexpression : expression \"+\" term ;\n```", "```cpp\nVoid Parser::parseExpression() {\n\u00a0\u00a0parseExpression();\n\u00a0\u00a0consume(tok::plus);\n\u00a0\u00a0parseTerm();\n}\n```", "```cpp\nusingStmt : \"using\" (ident \"=\")? ident \";\"\n```", "```cpp\nusingStmt : \"using\" ( ident \"=\" ident | ident ) \";\" ;\n```", "```cpp\nusingStmt : \"using\" ident (\"=\" ident)? \";\" ;\n```", "```cpp\nif (Tok.is(tok::ident) && Lex.peek(0).is(tok::equal)) {\n\u00a0\u00a0advance();\n\u00a0\u00a0consume(tok::equal);\n}\nconsume(tok::ident);\n```", "```cpp\nbool Parser::parseIfStatement() {\n\u00a0\u00a0auto _errorhandler = [this] {\n\u00a0\u00a0\u00a0\u00a0return SkipUntil(tok::semi, tok::kw_ELSE, tok::kw_END);\n\u00a0\u00a0};\n\u00a0\u00a0if (consume(tok::kw_IF))\n\u00a0\u00a0\u00a0\u00a0return _errorhandler();\n\u00a0\u00a0if (parseExpression(E))\n\u00a0\u00a0\u00a0\u00a0return _errorhandler();\n\u00a0\u00a0if (consume(tok::kw_THEN))\n\u00a0\u00a0\u00a0\u00a0return _errorhandler();\n\u00a0\u00a0if (parseStatementSequence(IfStmts))\n\u00a0\u00a0\u00a0\u00a0return _errorhandler();\n\u00a0\u00a0if (Tok.is(tok::kw_ELSE)) {\n\u00a0\u00a0\u00a0\u00a0advance();\n\u00a0\u00a0\u00a0\u00a0if (parseStatementSequence(ElseStmts))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return _errorhandler();\n\u00a0\u00a0}\n\u00a0\u00a0if (expect(tok::kw_END))\n\u00a0\u00a0\u00a0\u00a0return _errorhandler();\n\u00a0\u00a0return false;\n}\n```", "```cpp\n%require \"3.2\"\n%language \"c++\"\n%defines \"Parser.h\"\n%define api.namespace {tinylang}\n%define api.parser.class {Parser}\n%define api.token.prefix {T_}\n%token\n\u00a0\u00a0identifier integer_literal string_literal\n\u00a0\u00a0PLUS MINUS STAR SLASH \n```", "```cpp\n%%\ncompilationUnit\n\u00a0\u00a0: MODULE identifier SEMI imports block identifier PERIOD ;\nimports : %empty | import imports ;\nimport\n\u00a0\u00a0: FROM identifier IMPORT identList SEMI\n\u00a0\u00a0| IMPORT identList SEMI ;\n```", "```cpp\nifStatement\n\u00a0\u00a0: IF expression THEN statementSequence\n\u00a0\u00a0\u00a0\u00a0elseStatement END ;\nelseStatement : %empty | ELSE statementSequence ;\n```", "```cpp\n$ bison tinylang.yy\n```", "```cpp\n%{\n#include \"Parser.h\"\n%}\n%option noyywrap nounput noinput batch\nid\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a-zA-Z_][a-zA-Z_0-9]*\ndigit\u00a0\u00a0\u00a0\u00a0[0-9]\nhexdigit [0-9A-F]\nspace\u00a0\u00a0\u00a0\u00a0[ \\t\\r]\n```", "```cpp\n%%\n{space}+\n{digit}+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tinylang::Parser::token::T_integer_literal;\n```", "```cpp\n\"+\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return tinylang::Parser::token::T_PLUS;\n\"-\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return tinylang::Parser::token::T_MINUS;\n\"*\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return tinylang::Parser::token::T_STAR;\n\"/\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return tinylang::Parser::token::T_SLASH;\n```", "```cpp\n\"VAR\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return tinylang::Parser::token::T_VAR;\n\"WHILE\"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return tinylang::Parser::token::T_WHILE;\n{id}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return tinylang::Parser::token::T_identifier;\n```", "```cpp\n$ flex \u2013c++ tinylang.l\n```", "```cpp\nVAR B, X: INTEGER;\n```", "```cpp\nPROCEDURE Proc;\nVAR B: BOOLEAN;\nBEGIN\n\u00a0\u00a0(* Statements *)\nEND Proc;\n```", "```cpp\n#ifndef TINYLANG_SEMA_SCOPE_H\n#define TINYLANG_SEMA_SCOPE_H\n#include \"tinylang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\nnamespace tinylang {\nclass Decl;\nclass Scope {\n\u00a0\u00a0Scope *Parent;\n\u00a0\u00a0StringMap<Decl *> Symbols;\npublic:\n\u00a0\u00a0Scope(Scope *Parent = nullptr) : Parent(Parent) {}\n\u00a0\u00a0bool insert(Decl *Declaration);\n\u00a0\u00a0Decl *lookup(StringRef Name);\n\u00a0\u00a0Scope *getParent() { return Parent; }\n};\n} // namespace tinylang\n#endif\n```", "```cpp\n#include \"tinylang/Sema/Scope.h\"\n#include \"tinylang/AST/AST.h\"\nusing namespace tinylang;\nbool Scope::insert(Decl *Declaration) {\n\u00a0\u00a0return Symbols\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.insert(std::pair<StringRef, Decl *>(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Declaration->getName(), Declaration))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.second;\n}\n```", "```cpp\nDecl *Scope::lookup(StringRef Name) {\n\u00a0\u00a0Scope *S = this;\n\u00a0\u00a0while (S) {\n\u00a0\u00a0\u00a0\u00a0StringMap<Decl *>::const_iterator I =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S->Symbols.find(Name);\n\u00a0\u00a0\u00a0\u00a0if (I != S->Symbols.end())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return I->second;\n\u00a0\u00a0\u00a0\u00a0S = S->getParent();\n\u00a0\u00a0}\n\u00a0\u00a0return nullptr;\n}\n```", "```cpp\nclass Decl {\npublic:\n\u00a0\u00a0enum DeclKind { DK_Module, DK_Const, DK_Type,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DK_Var, DK_Param, DK_Proc };\nprivate:\n\u00a0\u00a0const DeclKind Kind;\npublic:\n\u00a0\u00a0DeclKind getKind() const { return Kind; }\n};\n```", "```cpp\nstatic bool classof(const Decl *D) {\n\u00a0\u00a0return D->getKind() == DK_Var;\n}\n```", "```cpp\nclass Decl {\npublic:\n\u00a0\u00a0enum DeclKind { DK_Module, DK_Const, DK_Type,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DK_Var, DK_Param, DK_Proc };\nprivate:\n\u00a0\u00a0const DeclKind Kind;\nprotected:\n\u00a0\u00a0Decl *EnclosingDecL;\n\u00a0\u00a0SMLoc Loc;\n\u00a0\u00a0StringRef Name;\npublic:\n\u00a0\u00a0Decl(DeclKind Kind, Decl *EnclosingDecL, SMLoc Loc,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef Name)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Kind(Kind), EnclosingDecL(EnclosingDecL), Loc(Loc),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Name(Name) {}\n\u00a0\u00a0DeclKind getKind() const { return Kind; }\n\u00a0\u00a0SMLoc getLocation() { return Loc; }\n\u00a0\u00a0StringRef getName() { return Name; }\n\u00a0\u00a0Decl *getEnclosingDecl() { return EnclosingDecL; }\n};\n```", "```cpp\nclass TypeDeclaration;\nclass VariableDeclaration : public Decl {\n\u00a0\u00a0TypeDeclaration *Ty;\npublic:\n\u00a0\u00a0VariableDeclaration(Decl *EnclosingDecL, SMLoc Loc,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef Name, TypeDeclaration *Ty)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Decl(DK_Var, EnclosingDecL, Loc, Name), Ty(Ty) {}\n\u00a0\u00a0TypeDeclaration *getType() { return Ty; }\n\u00a0\u00a0static bool classof(const Decl *D) {\n\u00a0\u00a0\u00a0\u00a0return D->getKind() == DK_Var;\n\u00a0\u00a0}\n};\n```", "```cpp\nbool Parser::parseVariableDeclaration(DeclList &Decls) {\n\u00a0\u00a0auto _errorhandler = [this] {\n\u00a0\u00a0\u00a0\u00a0while (!Tok.is(tok::semi)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0advance();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (Tok.is(tok::eof)) return true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0};\n\u00a0\u00a0Decl *D = nullptr; IdentList Ids;\n\u00a0\u00a0if (parseIdentList(Ids)) return _errorhandler();\n\u00a0\u00a0if (consume(tok::colon)) return _errorhandler();\n\u00a0\u00a0if (parseQualident(D)) return _errorhandler();\n\u00a0\u00a0Actions.actOnVariableDeclaration(Decls, Ids, D);\n\u00a0\u00a0return false;\n}\n```", "```cpp\nvoid Sema::actOnVariableDeclaration(DeclList &Decls,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IdentList &Ids,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Decl *D) {\n\u00a0\u00a0if (TypeDeclaration *Ty = dyn_cast<TypeDeclaration>(D)) {\n\u00a0\u00a0\u00a0\u00a0for (auto I = Ids.begin(), E = Ids.end(); I != E; ++I) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SMLoc Loc = I->first;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef Name = I->second;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0VariableDeclaration *Decl = new VariableDeclaration(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CurrentDecl, Loc, Name, Ty);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (CurrentScope->insert(Decl))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Decls.push_back(Decl);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Diags.report(Loc, diag::err_symbold_declared, Name);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0} else if (!Ids.empty()) {\n\u00a0\u00a0\u00a0\u00a0SMLoc Loc = Ids.front().first;\n\u00a0\u00a0\u00a0\u00a0Diags.report(Loc, diag::err_vardecl_requires_type);\n\u00a0\u00a0}\n}\n```", "```cpp\nvoid Sema::enterScope(Decl *D) {\n\u00a0\u00a0CurrentScope = new Scope(CurrentScope);\n\u00a0\u00a0CurrentDecl = D;\n}\nvoid Sema::leaveScope() {\n\u00a0\u00a0Scope *Parent = CurrentScope->getParent();\n\u00a0\u00a0delete CurrentScope;\n\u00a0\u00a0CurrentScope = Parent;\n\u00a0\u00a0CurrentDecl = CurrentDecl->getEnclosingDecl();\n}\n```", "```cpp\nclass EnterDeclScope {\n\u00a0\u00a0Sema &Semantics;\npublic:\n\u00a0\u00a0EnterDeclScope(Sema &Semantics, Decl *D)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Semantics(Semantics) {\n\u00a0\u00a0\u00a0\u00a0Semantics.enterScope(D);\n\u00a0\u00a0}\n\u00a0\u00a0~EnterDeclScope() { Semantics.leaveScope(); }\n};\n```", "```cpp\nbool Parser::parseProcedureDeclaration(/* \u2026 */) {\n\u00a0\u00a0/* \u2026 */\n\u00a0\u00a0if (consume(tok::kw_PROCEDURE)) return _errorhandler();\n\u00a0\u00a0if (expect(tok::identifier)) return _errorhandler();\n\u00a0\u00a0ProcedureDeclaration *D =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Actions.actOnProcedureDeclaration(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Tok.getLocation(), Tok.getIdentifier());\n\u00a0\u00a0EnterDeclScope S(Actions, D);\n\u00a0\u00a0/* \u2026 */\n}\n```", "```cpp\nProcedureDeclaration *\nSema::actOnProcedureDeclaration(SMLoc Loc, StringRef Name) {\n\u00a0\u00a0ProcedureDeclaration *P =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new ProcedureDeclaration(CurrentDecl, Loc, Name);\n\u00a0\u00a0if (!CurrentScope->insert(P))\n\u00a0\u00a0\u00a0\u00a0Diags.report(Loc, diag::err_symbold_declared, Name);\n\u00a0\u00a0return P;\n}\n```", "```cpp\nvoid Sema::actOnProcedureDeclaration(\n\u00a0\u00a0\u00a0\u00a0ProcedureDeclaration *ProcDecl, SMLoc Loc,\n\u00a0\u00a0\u00a0\u00a0StringRef Name, FormalParamList &Params, Decl *RetType,\n\u00a0\u00a0\u00a0\u00a0DeclList &Decls, StmtList &Stmts) {\n\u00a0\u00a0if (Name != ProcDecl->getName()) {\n\u00a0\u00a0\u00a0\u00a0Diags.report(Loc, diag::err_proc_identifier_not_equal);\n\u00a0\u00a0\u00a0\u00a0Diags.report(ProcDecl->getLocation(),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0diag::note_proc_identifier_declaration);\n\u00a0\u00a0}\n\u00a0\u00a0ProcDecl->setDecls(Decls);\n\u00a0\u00a0ProcDecl->setStmts(Stmts);\n\u00a0\u00a0auto RetTypeDecl =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dyn_cast_or_null<TypeDeclaration>(RetType);\n\u00a0\u00a0if (!RetTypeDecl && RetType)\n\u00a0\u00a0\u00a0\u00a0Diags.report(Loc, diag::err_returntype_must_be_type,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Name);\n\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0ProcDecl->setRetType(RetTypeDecl);\n}\n```", "```cpp\nvoid Sema::initialize() {\n\u00a0\u00a0CurrentScope = new Scope();\n\u00a0\u00a0CurrentDecl = nullptr;\n\u00a0\u00a0IntegerType =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new TypeDeclaration(CurrentDecl, SMLoc(), \"INTEGER\");\n\u00a0\u00a0BooleanType =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new TypeDeclaration(CurrentDecl, SMLoc(), \"BOOLEAN\");\n\u00a0\u00a0TrueLiteral = new BooleanLiteral(true, BooleanType);\n\u00a0\u00a0FalseLiteral = new BooleanLiteral(false, BooleanType);\n\u00a0\u00a0TrueConst = new ConstantDeclaration(CurrentDecl, SMLoc(),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"TRUE\", TrueLiteral);\n\u00a0\u00a0FalseConst = new ConstantDeclaration(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CurrentDecl, SMLoc(), \"FALSE\", FalseLiteral);\n\u00a0\u00a0CurrentScope->insert(IntegerType);\n\u00a0\u00a0CurrentScope->insert(BooleanType);\n\u00a0\u00a0CurrentScope->insert(TrueConst);\n\u00a0\u00a0CurrentScope->insert(FalseConst);\n}\n```", "```cpp\n#include \"tinylang/Basic/Diagnostic.h\"\n#include \"tinylang/Basic/Version.h\"\n#include \"tinylang/Parser/Parser.h\"\n#include \"llvm/Support/InitLLVM.h\"\n#include \"llvm/Support/raw_ostream.h\"\nusing namespace tinylang;\nint main(int argc_, const char **argv_) {\n\u00a0\u00a0llvm::InitLLVM X(argc_, argv_);\n\u00a0\u00a0llvm::SmallVector<const char *, 256> argv(argv_ + 1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0argv_ + argc_);\n\u00a0\u00a0llvm::outs() << \"Tinylang \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< tinylang::getTinylangVersion() << \"\\n\";\n\u00a0\u00a0for (const char *F : argv) {\n\u00a0\u00a0\u00a0\u00a0llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FileOrErr = llvm::MemoryBuffer::getFile(F);\n\u00a0\u00a0\u00a0\u00a0if (std::error_code BufferError =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FileOrErr.getError()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::errs() << \"Error reading \" << F << \": \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< BufferError.message() << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0llvm::SourceMgr SrcMgr;\n\u00a0\u00a0\u00a0\u00a0DiagnosticsEngine Diags(SrcMgr);\n\u00a0\u00a0\u00a0\u00a0SrcMgr.AddNewSourceBuffer(std::move(*FileOrErr),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::SMLoc());\n\u00a0\u00a0\u00a0\u00a0auto lexer = Lexer(SrcMgr, Diags);\n\u00a0\u00a0\u00a0\u00a0auto sema = Sema(Diags);\n\u00a0\u00a0\u00a0\u00a0auto parser = Parser(lexer, sema);\n\u00a0\u00a0\u00a0\u00a0parser.parse();\n\u00a0\u00a0}\n}\n```", "```cpp\nMODULE Gcd;\nPROCEDURE GCD(a, b: INTEGER):INTEGER;\nVAR t: INTEGER;\nBEGIN\n\u00a0\u00a0IF b = 0 THEN RETURN a; END;\n\u00a0\u00a0WHILE b # 0 DO\n\u00a0\u00a0\u00a0\u00a0t := a MOD b;\n\u00a0\u00a0\u00a0\u00a0a := b;\n\u00a0\u00a0\u00a0\u00a0b := t;\n\u00a0\u00a0END;\n\u00a0\u00a0RETURN a;\nEND GCD;\nEND Gcd.\n```", "```cpp\n$ tinylang Gcm.mod\nTinylang 0.1\n```"]