["```cpp\n#include <stdlib.h>\n#include <string.h>\nint main(int argc, char *argv[]) {\n\u00a0\u00a0char *p = malloc(12);\n\u00a0\u00a0memset(p, 0, 14);\n\u00a0\u00a0return (int)*p;\n}\n```", "```cpp\n$ clang -fsanitize=address -g outofbounds.c -o outofbounds\n```", "```cpp\n$ ./outofbounds\n=================================================================\n==1067==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000001c at pc 0x00000023a6ef bp 0x7fffffffeb10 sp 0x7fffffffe2d8\nWRITE of size 14 at 0x60200000001c thread T0\n\u00a0\u00a0\u00a0\u00a0#0 0x23a6ee in __asan_memset /usr/src/contrib/llvm-project/compiler-rt/lib/asan/asan_interceptors_memintrinsics.cpp:26:3\n\u00a0\u00a0\u00a0\u00a0#1 0x2b2a03 in main /home/kai/sanitizers/outofbounds.c:6:3\n\u00a0\u00a0\u00a0\u00a0#2 0x23331f in _start /usr/src/lib/csu/amd64/crt1.c:76:7\n```", "```cpp\n\u00a0\u00a0memset(p, 0, 12);\n\u00a0\u00a0free(p);\n```", "```cpp\n$ clang -fsanitize=address -g useafterfree.c -o useafterfree\n$ ./useafterfree\n=================================================================\n==1118==ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000010 at pc 0x0000002b2a5c bp 0x7fffffffeb00 sp 0x7fffffffeaf8\nREAD of size 1 at 0x602000000010 thread T0\n\u00a0\u00a0\u00a0\u00a0#0 0x2b2a5b in main /home/kai/sanitizers/useafterfree.c:8:15\n\u00a0\u00a0\u00a0\u00a0#1 0x23331f in _start /usr/src/lib/csu/amd64/crt1.c:76:7\n```", "```cpp\n$ ASAN_OPTIONS=detect_leaks=1 ./useafterfree\n```", "```cpp\nint main(int argc, char *argv[]) {\n\u00a0\u00a0int x;\n\u00a0\u00a0return x;\n}\n```", "```cpp\n$ clang -fsanitize=memory -g memory.c -o memory\n$ ./memory\n==1206==WARNING: MemorySanitizer: use-of-uninitialized-value\n\u00a0\u00a0\u00a0\u00a0#0 0x10a8f49 in main /home/kai/sanitizers/memory.c:3:3\n\u00a0\u00a0\u00a0\u00a0#1 0x1053481 in _start /usr/src/lib/csu/amd64/crt1.c:76:7\nSUMMARY: MemorySanitizer: use-of-uninitialized-value /home/kai/sanitizers/memory.c:3:3 in main\nExiting\n```", "```cpp\n#include <pthread.h>\nint data = 0;\nvoid *producer(void *x) {\n\u00a0\u00a0for (int i = 0; i < 10000; ++i) ++data;\n\u00a0\u00a0return x;\n}\nvoid *consumer(void *x) {\n\u00a0\u00a0for (int i = 0; i < 10000; ++i) --data;\n\u00a0\u00a0return x;\n}\nint main() {\n\u00a0\u00a0pthread_t t1, t2;\n\u00a0\u00a0pthread_create(&t1, NULL, producer, NULL);\n\u00a0\u00a0pthread_create(&t2, NULL, consumer, NULL);\n\u00a0\u00a0pthread_join(t1, NULL);\n\u00a0\u00a0pthread_join(t2, NULL);\n\u00a0\u00a0return data;\n}\n```", "```cpp\n$ clang -fsanitize=thread -g thread.c -o thread -lpthread\n$ ./thread\n==================\nWARNING: ThreadSanitizer: data race (pid=1474)\n\u00a0\u00a0Write of size 4 at 0x000000cdf8f8 by thread T2:\n\u00a0\u00a0\u00a0\u00a0#0 consumer /home/kai/sanitizers/thread.c:11:35 (thread+0x2b0fb2)\n\u00a0\u00a0Previous write of size 4 at 0x000000cdf8f8 by thread T1:\n\u00a0\u00a0\u00a0\u00a0#0 producer /home/kai/sanitizers/thread.c:6:35 (thread+0x2b0f22)\n\u00a0\u00a0Location is global 'data' of size 4 at 0x000000cdf8f8 (thread+0x000000cdf8f8)\n\u00a0\u00a0Thread T2 (tid=100437, running) created by main thread at:\n\u00a0\u00a0\u00a0\u00a0#0 pthread_create /usr/src/contrib/llvm-project/compiler-rt/lib/tsan/rtl/tsan_interceptors_posix.cpp:962:3 (thread+0x271703)\n\u00a0\u00a0\u00a0\u00a0#1 main /home/kai/sanitizers/thread.c:18:3 (thread+0x2b1040)\n\u00a0\u00a0Thread T1 (tid=100436, finished) created by main thread at:\n\u00a0\u00a0\u00a0\u00a0#0 pthread_create /usr/src/contrib/llvm-project/compiler-rt/lib/tsan/rtl/tsan_interceptors_posix.cpp:962:3 (thread+0x271703)\n\u00a0\u00a0\u00a0\u00a0#1 main /home/kai/sanitizers/thread.c:17:3 (thread+0x2b1021)\nSUMMARY: ThreadSanitizer: data race /home/kai/sanitizers/thread.c:11:35 in consumer\n==================\nThreadSanitizer: reported 1 warnings\n```", "```cpp\n#include <stdint.h>\n#include <stdlib.h>\nint count(const uint8_t *Data, size_t Size) {\n\u00a0\u00a0int cnt = 0;\n\u00a0\u00a0if (Size)\n\u00a0\u00a0\u00a0\u00a0while (Data[cnt] >= '0' && Data[cnt] <= '9') ++cnt;\n\u00a0\u00a0return cnt;\n}\nint LLVMFuzzerTestOneInput(const uint8_t *Data, size_t \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Size) {\n\u00a0\u00a0count(Data, Size);\n\u00a0\u00a0return 0;\n}\n```", "```cpp\n$ clang -fsanitize=fuzzer,address -g fuzzer.c -o fuzzer\n```", "```cpp\n    INFO: Seed: 1297394926\n    ```", "```cpp\n    INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes\n    ```", "```cpp\n    INFO: A corpus is not provided, starting from an empty corpus\n    ```", "```cpp\n    #28\u00a0\u00a0\u00a0\u00a0\u00a0NEW\u00a0\u00a0\u00a0\u00a0cov: 6 ft: 9 corp: 6/19b lim: 4 exec/s: 0 rss: 29Mb L: 4/4 MS: 4 CopyPart-PersAutoDict-CopyPart-ChangeByte- DE: \"1\\x00\"-\n    ```", "```cpp\n    artifact_prefix='./'; Test unit written to ./crash-17ba0791499db908433b80f37c5fbc89b870084b\n    ```", "```cpp\n$ ./fuzzer crash-17ba0791499db908433b80f37c5fbc89b870084b\n```", "```cpp\n$ mkdir corpus\n$ printf \"012345\\0\" >corpus/12345.txt\n$ printf \"987\\0\" >corpus/987.txt\n```", "```cpp\n$ ./fuzzer corpus/\n```", "```cpp\nINFO: seed corpus: files: 2 min: 4b max: 7b total: 11b rss: 29Mb\n```", "```cpp\nkw1=\"if\"\n```", "```cpp\n#include <unistd.h>\nvoid func1() { usleep(10); }\nvoid func2(int n) {\n\u00a0\u00a0if (n % 2) func1();\n\u00a0\u00a0else usleep(100);\n}\nint main(int argc, char *argv[]) {\n\u00a0\u00a0for (int i = 0; i < 100; i++) { func1(); func2(i); }\n\u00a0\u00a0return 0;\n}\n```", "```cpp\nvoid func1() __attribute__((xray_always_instrument));\n```", "```cpp\n$ clang -fxray-instrument -fxray-instruction-threshold=1 -g\\\n\u00a0\u00a0xraydemo.c -o xraydemo\n```", "```cpp\n$ XRAY_OPTIONS= \"patch_premain=true xray_mode=xray-basic \"\\\n\u00a0\u00a0./xraydemo\n```", "```cpp\n$ llvm-xray account xray-log.xraydemo.xVsWiE -sort=count\\\n\u00a0\u00a0-sortorder=dsc -instr_map ./xraydemo\nFunctions with latencies: 3\n\u00a0\u00a0\u00a0funcid\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum\u00a0\u00a0function\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0150\u00a0\u00a0\u00a00.166002\u00a0\u00a0demo.c:4:0: func1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0100\u00a0\u00a0\u00a00.543103\u00a0\u00a0demo.c:9:0: func2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a00.655643\u00a0\u00a0demo.c:17:0: main\n```", "```cpp\n$ llvm-xray stack xray-log.xraydemo.xVsWiE -instr_map\\\n\u00a0\u00a0./xraydemo\nUnique Stacks: 3\nTop 10 Stacks by leaf sum:\nSum: 1325516912\nlvl\u00a0\u00a0\u00a0function\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum\n#0\u00a0\u00a0\u00a0\u00a0main\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01777862705\n#1\u00a0\u00a0\u00a0\u00a0func2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a050\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01325516912\nTop 10 Stacks by leaf count:\nCount: 100\nlvl\u00a0\u00a0\u00a0function\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0count\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum\n#0\u00a0\u00a0\u00a0\u00a0main\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01777862705\n#1\u00a0\u00a0\u00a0\u00a0func1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0100\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0303596276\n```", "```cpp\n$ llvm-xray stack xray-log.xraydemo.xVsWiE -all-stacks\\\n\u00a0\u00a0-stack-format=flame --aggregation-type=time\\\n\u00a0\u00a0-instr_map ./xraydemo | flamegraph.pl >flame.svg\n```", "```cpp\n$ llvm-xray convert -output-format=trace_event\\\n\u00a0\u00a0-output=xray.evt -symbolize \u2013sort\\\n\u00a0\u00a0-instr_map=./xraydemo xray-log.xraydemo.xVsWiE\n```", "```cpp\nint divbyzero(int a, int b) { return a / b; }\nint bug() { return divbyzero(5, 0); }\n```", "```cpp\n$ scan-build clang -c div.c\nscan-build: Using '/usr/local/llvm12/bin/clang-12' for static analysis\ndiv.c:2:12: warning: Division by zero [core.DivideZero]\n\u00a0\u00a0return a / b;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0~~^~~\n1 warning generated.\nscan-build: Analysis run complete.\nscan-build: 1 bug found.\nscan-build: Run 'scan-view /tmp/scan-build-2021-03-01-023401-8721-1' to examine bug reports.\n```", "```cpp\ndef IconvChecker : Checker<\"Iconv\">,\n\u00a0\u00a0HelpText<\"Check handling of iconv functions\">,\n\u00a0\u00a0Documentation<NotDocumented>;\n```", "```cpp\n    #include \"clang/StaticAnalyzer/Checkers/\n    BuiltinCheckerRegistration.h\"\n    #include \"clang/StaticAnalyzer/Core/Checker.h\"\n    #include \"clang/StaticAnalyzer/Core/\n    PathSensitive/CallEvent.h\"\n    #include \"clang/StaticAnalyzer/Core/PathSensitive/\n    CheckerContext.h\"\n    ```", "```cpp\n    using namespace clang;\n    using namespace ento;\n    ```", "```cpp\n    namespace {\n    struct IconvState {\n    \u00a0\u00a0const bool IsOpen;\n    public:\n    \u00a0\u00a0IconvState(bool IsOpen) : IsOpen(IsOpen) {}\n    \u00a0\u00a0bool isOpen() const { return IsOpen; }\n    \u00a0\u00a0bool operator==(const IconvState &O) const {\n    \u00a0\u00a0\u00a0\u00a0return IsOpen == O.IsOpen;\n    \u00a0\u00a0}\n    \u00a0\u00a0void Profile(llvm::FoldingSetNodeID &ID) const {\n    \u00a0\u00a0\u00a0\u00a0ID.AddInteger(IsOpen);\n    \u00a0\u00a0}\n    };\n    }\n    ```", "```cpp\n    REGISTER_MAP_WITH_PROGRAMSTATE(IconvStateMap, SymbolRef,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IconvState)\n    ```", "```cpp\n    namespace {\n    class IconvChecker\n    \u00a0\u00a0\u00a0\u00a0: public Checker<check::PostCall, check::PreCall,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0check::DeadSymbols,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0check::PointerEscape> {\n    ```", "```cpp\n    \u00a0\u00a0CallDescription IconvOpenFn, IconvFn, IconvCloseFn;\n    ```", "```cpp\n    \u00a0\u00a0void\n    \u00a0\u00a0report(ArrayRef<SymbolRef> Syms, const BugType &Bug,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef Desc, CheckerContext &C,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ExplodedNode *ErrNode,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Optional<SourceRange> Range = None) const {\n    \u00a0\u00a0\u00a0\u00a0for (SymbolRef Sym : Syms) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto R = std::make_unique\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<PathSensitiveBugReport>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Bug, Desc, ErrNode);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0R->markInteresting(Sym);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (Range)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0R->addRange(*Range);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C.emitReport(std::move(R));\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    ```", "```cpp\n    public:\n    \u00a0\u00a0IconvChecker()\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: IconvOpenFn(\"iconv_open\"), IconvFn(\"iconv\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IconvCloseFn(\"iconv_close\", 1) {}\n    ```", "```cpp\n    \u00a0\u00a0void checkPostCall(const CallEvent &Call,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CheckerContext &C) const {\n    \u00a0\u00a0\u00a0\u00a0if (!Call.isGlobalCFunction() ||\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0!Call.isCalled(IconvOpenFn))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (SymbolRef Handle =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Call.getReturnValue().getAsSymbol()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ProgramStateRef State = C.getState();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = State->set<IconvStateMap>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Handle, IconvState(true));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C.addTransition(State);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0void checkPreCall(const CallEvent &Call,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CheckerContext &C) const {\n    \u00a0\u00a0\u00a0\u00a0if (!Call.isGlobalCFunction() ||\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0!Call.isCalled(IconvCloseFn))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (SymbolRef Handle =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Call.getArgSVal(0).getAsSymbol()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ProgramStateRef State = C.getState();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (const IconvState *St =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State->get<IconvStateMap>(Handle)) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!St->isOpen()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (ExplodedNode *N = C.generateErrorNode()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BugType DoubleCloseBugType(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this, \"Double iconv_close\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"iconv API Error\");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0report({Handle}, DoubleCloseBugType,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Closing a previous closed iconv \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"descriptor\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C, N, Call.getSourceRange());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = State->set<IconvStateMap>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Handle, IconvState(false));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C.addTransition(State);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0void checkDeadSymbols(SymbolReaper &SymReaper,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CheckerContext &C) const {\n    \u00a0\u00a0\u00a0\u00a0ProgramStateRef State = C.getState();\n    \u00a0\u00a0\u00a0\u00a0SmallVector<SymbolRef, 8> LeakedSyms;\n    \u00a0\u00a0\u00a0\u00a0for (auto SymbolState :\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State->get<IconvStateMap>()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SymbolRef Sym = SymbolState.first;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IconvState &St = SymbolState.second;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (SymReaper.isDead(Sym)) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (St.isOpen()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool IsLeaked = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (const llvm::APSInt *Val =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State->getConstraintManager()\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.getSymVal(State, Sym))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IsLeaked = Val->getExtValue() != -1;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (IsLeaked)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LeakedSyms.push_back(Sym);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = State->remove<IconvStateMap>(Sym);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (ExplodedNode *N =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C.generateNonFatalErrorNode(State)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BugType LeakBugType(this, \"Resource Leak\",\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"iconv API Error\", true);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0report(LeakedSyms, LeakBugType,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Opened iconv descriptor not closed\", C,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0N);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0ProgramStateRef\n    \u00a0\u00a0checkPointerEscape(ProgramStateRef State,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const InvalidatedSymbols &Escaped,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const CallEvent *Call,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PointerEscapeKind Kind) const {\n    \u00a0\u00a0\u00a0\u00a0if (Kind == PSK_DirectEscapeOnCall &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Call->isCalled(IconvFn))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return State;\n    \u00a0\u00a0\u00a0\u00a0for (SymbolRef Sym : Escaped)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0State = State->remove<IconvStateMap>(Sym);\n    \u00a0\u00a0\u00a0\u00a0return State;\n    \u00a0\u00a0}\n    };\n    }\n    ```", "```cpp\n    void ento::registerIconvChecker(CheckerManager &Mgr) {\n    \u00a0\u00a0Mgr.registerChecker<IconvChecker>();\n    }\n    bool ento::shouldRegisterIconvChecker(\n    \u00a0\u00a0\u00a0\u00a0const CheckerManager &Mgr) {\n    \u00a0\u00a0return true;\n    }\n    ```", "```cpp\nadd_clang_library(clangStaticAnalyzerCheckers\n\u2026\n\u00a0\u00a0IconvChecker.cpp\n\u2026)\n```", "```cpp\n$ ninja \n```", "```cpp\n#include <iconv.h>\nvoid doconv() {\n\u00a0\u00a0iconv_t id = iconv_open(\"Latin1\", \"UTF-16\");\n\u00a0\u00a0iconv_close(id);\n\u00a0\u00a0iconv_close(id);\n}\n```", "```cpp\n    #include \"clang/AST/ASTConsumer.h\"\n    #include \"clang/Frontend/CompilerInstance.h\"\n    #include \"clang/Frontend/FrontendPluginRegistry.h\"\n    ```", "```cpp\n    using namespace clang;\n    namespace {\n    ```", "```cpp\n    class NamingASTConsumer : public ASTConsumer {\n    \u00a0\u00a0CompilerInstance &CI;\n    public:\n    \u00a0\u00a0NamingASTConsumer(CompilerInstance &CI) : CI(CI) {}\n    ```", "```cpp\n    \u00a0\u00a0bool HandleTopLevelDecl(DeclGroupRef DG) override {\n    \u00a0\u00a0\u00a0\u00a0for (DeclGroupRef::iterator I = DG.begin(),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E = DG.end();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0I != E; ++I) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const Decl *D = *I;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (const FunctionDecl *FD =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dyn_cast<FunctionDecl>(D)) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::string Name =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FD->getNameInfo().getName().getAsString();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assert(Name.length() > 0 &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Unexpected empty identifier\");\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char &First = Name.at(0);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!(First >= 'a' && First <= 'z')) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DiagnosticsEngine &Diag = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CI.getDiagnostics();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned ID = Diag.getCustomDiagID(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DiagnosticsEngine::Warning,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Function name should start with \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"lowercase letter\");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Diag.Report(FD->getLocation(), ID);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0}\n    };\n    ```", "```cpp\n    class PluginNamingAction : public PluginASTAction {\n    public:\n    ```", "```cpp\n    \u00a0\u00a0std::unique_ptr<ASTConsumer>\n    \u00a0\u00a0CreateASTConsumer(CompilerInstance &CI,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef file) override {\n    \u00a0\u00a0\u00a0\u00a0return std::make_unique<NamingASTConsumer>(CI);\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0bool ParseArgs(const CompilerInstance &CI,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::vector<std::string> &args) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0override {\n    \u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0PluginASTAction::ActionType getActionType() override {\n    \u00a0\u00a0\u00a0\u00a0return AddAfterMainAction;\n    \u00a0\u00a0}\n    ```", "```cpp\n    };\n    }\n    ```", "```cpp\n    static FrontendPluginRegistry::Add<PluginNamingAction>\n    \u00a0\u00a0\u00a0\u00a0X(\"naming-plugin\", \"naming plugin\");\n    ```", "```cpp\n    cmake_minimum_required(VERSION 3.13.4)\n    project(naminglugin)\n    ```", "```cpp\n    find_package(LLVM REQUIRED CONFIG)\n    ```", "```cpp\n    list(APPEND CMAKE_MODULE_PATH ${LLVM_DIR})\n    include(ChooseMSVCCRT)\n    include(AddLLVM)\n    include(HandleLLVMOptions)\n    ```", "```cpp\n    find_package(Clang REQUIRED)\n    ```", "```cpp\n    include_directories(\"${LLVM_INCLUDE_DIR}\"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"${CLANG_INCLUDE_DIRS}\")\n    add_definitions(\"${LLVM_DEFINITIONS}\")\n    link_directories(\"${LLVM_LIBRARY_DIR}\")\n    ```", "```cpp\n    add_llvm_library(NamingPlugin MODULE NamingPlugin.cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PLUGIN_TOOL clang)\n    ```", "```cpp\n    if(LLVM_ENABLE_PLUGINS AND (WIN32 OR CYGWIN))\n    \u00a0\u00a0set(LLVM_LINK_COMPONENTS Support)\n    \u00a0\u00a0clang_target_link_libraries(NamingPlugin PRIVATE\n    \u00a0\u00a0\u00a0\u00a0clangAST clangBasic clangFrontend clangLex)\n    endif()\n    ```", "```cpp\n    $ mkdir build-naming-plugin\n    $ cd build-naming-plugin\n    $ cmake \u2013G Ninja ../NamingPlugin\n    $ ninja\n    ```", "```cpp\nint Func1() { return 0; }\nint main() { return Func1(); }\n```", "```cpp\n$ clang -fplugin=./NamingPlugin.so\u00a0\u00a0naming.c\nnaming.c:1:5: warning: Function name should start with lowercase letter\nint Func1() { return 0; }\n\u00a0\u00a0\u00a0\u00a0^\n1 warning generated.\n```", "```cpp\n$ clang -cc1 -load ./NamingPlugin.so -plugin naming-plugin\\\n\u00a0\u00a0naming.c\n```", "```cpp\n    #include \"clang/AST/RecursiveASTVisitor.h\"\n    ```", "```cpp\n    class NamingVisitor\n    \u00a0\u00a0\u00a0\u00a0: public RecursiveASTVisitor<NamingVisitor> {\n    private:\n    \u00a0\u00a0ASTContext &ASTCtx;\n    public:\n    \u00a0\u00a0explicit NamingVisitor(CompilerInstance &CI)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: ASTCtx(CI.getASTContext()) {}\n    ```", "```cpp\n    \u00a0\u00a0virtual bool VisitFunctionDecl(FunctionDecl *FD) {\n    \u00a0\u00a0\u00a0\u00a0std::string Name =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FD->getNameInfo().getName().getAsString();\n    \u00a0\u00a0\u00a0\u00a0assert(Name.length() > 0 &&\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Unexpected empty identifier\");\n    \u00a0\u00a0\u00a0\u00a0char &First = Name.at(0);\n    \u00a0\u00a0\u00a0\u00a0if (!(First >= 'a' && First <= 'z')) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DiagnosticsEngine &Diag = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASTCtx.getDiagnostics();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned ID = Diag.getCustomDiagID(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DiagnosticsEngine::Warning,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Function name should start with \"\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"lowercase letter\");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Diag.Report(FD->getLocation(), ID);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0}\n    };\n    ```", "```cpp\n    \u00a0\u00a0std::unique_ptr<NamingVisitor> Visitor;\n    public:\n    \u00a0\u00a0NamingASTConsumer(CompilerInstance &CI)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Visitor(std::make_unique<NamingVisitor>(CI)) {}\n    ```", "```cpp\n    \u00a0\u00a0void\n    \u00a0\u00a0HandleTranslationUnit(ASTContext &ASTCtx) override {\n    \u00a0\u00a0\u00a0\u00a0Visitor->TraverseDecl(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASTCtx.getTranslationUnitDecl());\n    \u00a0\u00a0}\n    ```"]