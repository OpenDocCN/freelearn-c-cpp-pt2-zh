["```cpp\nwith a, b: a * (4 + b)\n```", "```cpp\ncalc : (\"with\" ident (\",\" ident)* \":\")? expr ;\nexpr : term (( \"+\" | \"-\" ) term)* ;\nterm : factor (( \"*\" | \"/\") factor)* ;\nfactor : ident | number | \"(\" expr \")\" ;\nident : ([a-zAZ])+ ;\nnumber : ([0-9])+ ;\n```", "```cpp\n#ifndef LEXER_H\n#define LEXER_H\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n```", "```cpp\n    class Lexer;\n    class Token {\n    \u00a0\u00a0friend class Lexer;\n    public:\n    \u00a0\u00a0enum TokenKind : unsigned short {\n    \u00a0\u00a0\u00a0\u00a0eoi, unknown, ident, number, comma, colon, plus, \n    \u00a0\u00a0\u00a0\u00a0minus, star, slash, l_paren, r_paren, KW_with\n    \u00a0\u00a0};\n    ```", "```cpp\n    private:\n    \u00a0\u00a0TokenKind Kind;\n    \u00a0\u00a0llvm::StringRef Text;\n    public:\n    \u00a0\u00a0TokenKind getKind() const { return Kind; }\n    \u00a0\u00a0llvm::StringRef getText() const { return Text; }\n    ```", "```cpp\n    \u00a0\u00a0bool is(TokenKind K) const { return Kind == K; }\n    \u00a0\u00a0bool isOneOf(TokenKind K1, TokenKind K2) const {\n    \u00a0\u00a0\u00a0\u00a0return is(K1) || is(K2);\n    \u00a0\u00a0}\n    \u00a0\u00a0template <typename... Ts>\n    \u00a0\u00a0bool isOneOf(TokenKind K1, TokenKind K2, Ts... Ks) const {\n    \u00a0\u00a0\u00a0\u00a0return is(K1) || isOneOf(K2, Ks...);\n    \u00a0\u00a0}\n    };\n    ```", "```cpp\n    class Lexer {\n    \u00a0\u00a0const char *BufferStart;\n    \u00a0\u00a0const char *BufferPtr;\n    public:\n    \u00a0\u00a0Lexer(const llvm::StringRef &Buffer) {\n    \u00a0\u00a0\u00a0\u00a0BufferStart = Buffer.begin();\n    \u00a0\u00a0\u00a0\u00a0BufferPtr = BufferStart;\n    \u00a0\u00a0}\n    \u00a0\u00a0void next(Token &token);\n    private:\n    \u00a0\u00a0void formToken(Token &Result, const char *TokEnd,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Token::TokenKind Kind);\n    };\n    #endif\n    ```", "```cpp\n    #include \"Lexer.h\"\n    namespace charinfo {\n    LLVM_READNONE inline bool isWhitespace(char c) {\n    \u00a0\u00a0return c == ' ' || c == '\\t' || c == '\\f' ||\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c == '\\v' ||\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c == '\\r' || c == '\\n';\n    }\n    LLVM_READNONE inline bool isDigit(char c) {\n    \u00a0\u00a0return c >= '0' && c <= '9';\n    }\n    LLVM_READNONE inline bool isLetter(char c) {\n    \u00a0\u00a0return (c >= 'a' && c <= 'z') ||\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(c >= 'A' && c <= 'Z');\n    }\n    }\n    ```", "```cpp\n    void Lexer::next(Token &token) {\n    \u00a0\u00a0while (*BufferPtr &&\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0charinfo::isWhitespace(*BufferPtr)) {\n    \u00a0\u00a0\u00a0\u00a0++BufferPtr;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0if (!*BufferPtr) {\n    \u00a0\u00a0\u00a0\u00a0token.Kind = Token::eoi;\n    \u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0if (charinfo::isLetter(*BufferPtr)) {\n    \u00a0\u00a0\u00a0\u00a0const char *end = BufferPtr + 1;\n    \u00a0\u00a0\u00a0\u00a0while (charinfo::isLetter(*end))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++end;\n    \u00a0\u00a0\u00a0\u00a0llvm::StringRef Name(BufferPtr, end - BufferPtr);\n    \u00a0\u00a0\u00a0\u00a0Token::TokenKind kind =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Name == \"with\" ? Token::KW_with : Token::ident;\n    \u00a0\u00a0\u00a0\u00a0formToken(token, end, kind);\n    \u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0else if (charinfo::isDigit(*BufferPtr)) {\n    \u00a0\u00a0\u00a0\u00a0const char *end = BufferPtr + 1;\n    \u00a0\u00a0\u00a0\u00a0while (charinfo::isDigit(*end))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++end;\n    \u00a0\u00a0\u00a0\u00a0formToken(token, end, Token::number);\n    \u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0else {\n    \u00a0\u00a0\u00a0\u00a0switch (*BufferPtr) {\n    #define CASE(ch, tok) \\\n    case ch: formToken(token, BufferPtr + 1, tok); break\n    CASE('+', Token::plus);\n    CASE('-', Token::minus);\n    CASE('*', Token::star);\n    CASE('/', Token::slash);\n    CASE('(', Token::Token::l_paren);\n    CASE(')', Token::Token::r_paren);\n    CASE(':', Token::Token::colon);\n    CASE(',', Token::Token::comma);\n    #undef CASE\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0default:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0formToken(token, BufferPtr + 1, Token::unknown);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    void Lexer::formToken(Token &Tok, const char *TokEnd,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Token::TokenKind Kind) {\n    \u00a0\u00a0Tok.Kind = Kind;\n    \u00a0\u00a0Tok.Text = llvm::StringRef(BufferPtr, TokEnd - \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BufferPtr);\n    \u00a0\u00a0BufferPtr = TokEnd;\n    }\n    ```", "```cpp\n#ifndef PARSER_H\n#define PARSER_H\n#include \"AST.h\"\n#include \"Lexer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n```", "```cpp\n    class Parser {\n    \u00a0\u00a0Lexer &Lex;\n    \u00a0\u00a0Token Tok;\n    \u00a0\u00a0bool HasError;\n    ```", "```cpp\n    \u00a0\u00a0void error() {\n    \u00a0\u00a0\u00a0\u00a0llvm::errs() << \"Unexpected: \" << Tok.getText()\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0HasError = true;\n    \u00a0\u00a0}\n    \u00a0\u00a0void advance() { Lex.next(Tok); }\n    \u00a0\u00a0bool expect(Token::TokenKind Kind) {\n    \u00a0\u00a0\u00a0\u00a0if (Tok.getKind() != Kind) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0error();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0}\n    \u00a0\u00a0bool consume(Token::TokenKind Kind) {\n    \u00a0\u00a0\u00a0\u00a0if (expect(Kind))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0AST *parseCalc();\n    \u00a0\u00a0Expr *parseExpr();\n    \u00a0\u00a0Expr *parseTerm();\n    \u00a0\u00a0Expr *parseFactor();\n    ```", "```cpp\n    public:\n    \u00a0\u00a0Parser(Lexer &Lex) : Lex(Lex), HasError(false) {\n    \u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0bool hasError() { return HasError; }\n    ```", "```cpp\n    \u00a0\u00a0AST *parse();\n    };\n    #endif\n    ```", "```cpp\n    #include \"Parser.h\"\n    AST *Parser::parse() {\n    \u00a0\u00a0AST *Res = parseCalc();\n    \u00a0\u00a0expect(Token::eoi);\n    \u00a0\u00a0return Res;\n    }\n    ```", "```cpp\n    calc : (\"with\" ident (\",\" ident)* \":\")? expr ;\n    ```", "```cpp\n    AST *Parser::parseCalc() {\n    \u00a0\u00a0Expr *E;\n    \u00a0\u00a0llvm::SmallVector<llvm::StringRef, 8> Vars;\n    ```", "```cpp\n    \u00a0\u00a0if (Tok.is(Token::KW_with)) {\n    \u00a0\u00a0\u00a0\u00a0advance();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (expect(Token::ident))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto _error;\n    \u00a0\u00a0\u00a0\u00a0Vars.push_back(Tok.getText());\n    \u00a0\u00a0\u00a0\u00a0advance();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0while (Tok.is(Token::comma)) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (expect(Token::ident))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto _error;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Vars.push_back(Tok.getText());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (consume(Token::colon))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto _error;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0E = parseExpr();\n    ```", "```cpp\n    \u00a0\u00a0if (Vars.empty()) return E;\n    \u00a0\u00a0else return new WithDecl(Vars, E);\n    ```", "```cpp\n    _error:\n    \u00a0\u00a0while (!Tok.is(Token::eoi))\n    \u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0return nullptr;\n    }\n    ```", "```cpp\n    Expr *Parser::parseExpr() {\n    \u00a0\u00a0Expr *Left = parseTerm();\n    \u00a0\u00a0while (Tok.isOneOf(Token::plus, Token::minus)) {\n    \u00a0\u00a0\u00a0\u00a0BinaryOp::Operator Op =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Tok.is(Token::plus) ? BinaryOp::Plus :\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BinaryOp::Minus;\n    \u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0\u00a0\u00a0Expr *Right = parseTerm();\n    \u00a0\u00a0\u00a0\u00a0Left = new BinaryOp(Op, Left, Right);\n    \u00a0\u00a0}\n    \u00a0\u00a0return Left;\n    }\n    ```", "```cpp\n    Expr *Parser::parseTerm() {\n    \u00a0\u00a0Expr *Left = parseFactor();\n    \u00a0\u00a0while (Tok.isOneOf(Token::star, Token::slash)) {\n    \u00a0\u00a0\u00a0\u00a0BinaryOp::Operator Op =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Tok.is(Token::star) ? BinaryOp::Mul : \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BinaryOp::Div;\n    \u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0\u00a0\u00a0Expr *Right = parseFactor();\n    \u00a0\u00a0\u00a0\u00a0Left = new BinaryOp(Op, Left, Right);\n    \u00a0\u00a0}\n    \u00a0\u00a0return Left;\n    }\n    ```", "```cpp\n    Expr *Parser::parseFactor() {\n    \u00a0\u00a0Expr *Res = nullptr;\n    \u00a0\u00a0switch (Tok.getKind()) {\n    \u00a0\u00a0case Token::number:\n    \u00a0\u00a0\u00a0\u00a0Res = new Factor(Factor::Number, Tok.getText());\n    \u00a0\u00a0\u00a0\u00a0advance(); break;\n    ```", "```cpp\n    \u00a0\u00a0case Token::ident:\n    \u00a0\u00a0\u00a0\u00a0Res = new Factor(Factor::Ident, Tok.getText());\n    \u00a0\u00a0\u00a0\u00a0advance(); break;\n    \u00a0\u00a0case Token::l_paren:\n    \u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0\u00a0\u00a0Res = parseExpr();\n    \u00a0\u00a0\u00a0\u00a0if (!consume(Token::r_paren)) break;\n    \u00a0\u00a0default:\n    \u00a0\u00a0\u00a0\u00a0if (!Res) error();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0while (!Tok.isOneOf(Token::r_paren, Token::star,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Token::plus, Token::minus,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Token::slash, Token::eoi))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0advance();\n    \u00a0\u00a0}\n    \u00a0\u00a0return Res;\n    }\n    ```", "```cpp\n    #ifndef AST_H\n    #define AST_H\n    #include \"llvm/ADT/SmallVector.h\"\n    #include \"llvm/ADT/StringRef.h\"\n    class AST;\n    class Expr;\n    class Factor;\n    class BinaryOp;\n    class WithDecl;\n    class ASTVisitor {\n    public:\n    \u00a0\u00a0virtual void visit(AST &){};\n    \u00a0\u00a0virtual void visit(Expr &){};\n    \u00a0\u00a0virtual void visit(Factor &) = 0;\n    \u00a0\u00a0virtual void visit(BinaryOp &) = 0;\n    \u00a0\u00a0virtual void visit(WithDecl &) = 0;\n    };\n    ```", "```cpp\n    class AST {\n    public:\n    \u00a0\u00a0virtual ~AST() {}\n    \u00a0\u00a0virtual void accept(ASTVisitor &V) = 0;\n    };\n    ```", "```cpp\n    class Expr : public AST {\n    public:\n    \u00a0\u00a0Expr() {}\n    };\n    ```", "```cpp\n    class Factor : public Expr {\n    public:\n    \u00a0\u00a0enum ValueKind { Ident, Number };\n    private:\n    \u00a0\u00a0ValueKind Kind;\n    \u00a0\u00a0llvm::StringRef Val;\n    public:\n    \u00a0\u00a0Factor(ValueKind Kind, llvm::StringRef Val)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Kind(Kind), Val(Val) {}\n    \u00a0\u00a0ValueKind getKind() { return Kind; }\n    \u00a0\u00a0llvm::StringRef getVal() { return Val; }\n    \u00a0\u00a0virtual void accept(ASTVisitor &V) override {\n    \u00a0\u00a0\u00a0\u00a0V.visit(*this);\n    \u00a0\u00a0}\n    };\n    ```", "```cpp\n    class BinaryOp : public Expr {\n    public:\n    \u00a0\u00a0enum Operator { Plus, Minus, Mul, Div };\n    private:\n    \u00a0\u00a0Expr *Left;\n    \u00a0\u00a0Expr *Right;\n    \u00a0\u00a0Operator Op;\n    public:\n    \u00a0\u00a0BinaryOp(Operator Op, Expr *L, Expr *R)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Op(Op), Left(L), Right(R) {}\n    \u00a0\u00a0Expr *getLeft() { return Left; }\n    \u00a0\u00a0Expr *getRight() { return Right; }\n    \u00a0\u00a0Operator getOperator() { return Op; }\n    \u00a0\u00a0virtual void accept(ASTVisitor &V) override {\n    \u00a0\u00a0\u00a0\u00a0V.visit(*this);\n    \u00a0\u00a0}\n    };\n    ```", "```cpp\n    class WithDecl : public AST {\n    \u00a0\u00a0using VarVector =\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::SmallVector<llvm::StringRef, 8>;\n    \u00a0\u00a0VarVector Vars;\n    \u00a0\u00a0Expr *E;\n    public:\n    \u00a0\u00a0WithDecl(llvm::SmallVector<llvm::StringRef, 8> Vars,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Expr *E)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: Vars(Vars), E(E) {}\n    \u00a0\u00a0VarVector::const_iterator begin() \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ return Vars.begin(); }\n    \u00a0\u00a0VarVector::const_iterator end() { return Vars.end(); }\n    \u00a0\u00a0Expr *getExpr() { return E; }\n    \u00a0\u00a0virtual void accept(ASTVisitor &V) override {\n    \u00a0\u00a0\u00a0\u00a0V.visit(*this);\n    \u00a0\u00a0}\n    };\n    #endif\n    ```", "```cpp\n#ifndef SEMA_H\n#define SEMA_H\n#include \"AST.h\"\n#include \"Lexer.h\"\nclass Sema {\npublic:\n\u00a0\u00a0bool semantic(AST *Tree);\n};\n#endif\n```", "```cpp\n#include \"Sema.h\"\n#include \"llvm/ADT/StringSet.h\"\nnamespace {\nclass DeclCheck : public ASTVisitor {\n\u00a0\u00a0llvm::StringSet<> Scope;\n\u00a0\u00a0bool HasError;\n\u00a0\u00a0enum ErrorType { Twice, Not };\n\u00a0\u00a0void error(ErrorType ET, llvm::StringRef V) {\n\u00a0\u00a0\u00a0\u00a0llvm::errs() << \"Variable \" << V << \" \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< (ET == Twice ? \"already\" : \"not\")\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \" declared\\n\";\n\u00a0\u00a0\u00a0\u00a0HasError = true;\n\u00a0\u00a0}\npublic:\n\u00a0\u00a0DeclCheck() : HasError(false) {}\n\u00a0\u00a0bool hasError() { return HasError; }\n```", "```cpp\n\u00a0\u00a0virtual void visit(Factor &Node) override {\n\u00a0\u00a0\u00a0\u00a0if (Node.getKind() == Factor::Ident) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (Scope.find(Node.getVal()) == Scope.end())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0error(Not, Node.getVal());\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0};\n```", "```cpp\n\u00a0\u00a0virtual void visit(BinaryOp &Node) override {\n\u00a0\u00a0\u00a0\u00a0if (Node.getLeft())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node.getLeft()->accept(*this);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0HasError = true;\n\u00a0\u00a0\u00a0\u00a0if (Node.getRight())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node.getRight()->accept(*this);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0HasError = true;\n\u00a0\u00a0};\n```", "```cpp\n\u00a0\u00a0virtual void visit(WithDecl &Node) override {\n\u00a0\u00a0\u00a0\u00a0for (auto I = Node.begin(), E = Node.end(); I != E;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++I) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!Scope.insert(*I).second)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0error(Twice, *I);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (Node.getExpr())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node.getExpr()->accept(*this);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0HasError = true;\n\u00a0\u00a0};\n};\n}\n```", "```cpp\nbool Sema::semantic(AST *Tree) {\n\u00a0\u00a0if (!Tree)\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0DeclCheck Check;\n\u00a0\u00a0Tree->accept(Check);\n\u00a0\u00a0return Check.hasError();\n}\n```", "```cpp\n    declare i32 @calc_read(i8*)\n    declare void @calc_write(i32)\n    ```", "```cpp\n    @a.str = private constant [2 x i8] c\"a\\00\"\n    ```", "```cpp\n    define i32 @main(i32, i8**) {\n    ```", "```cpp\n    entry:\n    ```", "```cpp\n    \u00a0\u00a0%2 = call i32 @calc_read(i8* getelementptr inbounds\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([2 x i8], [2 x i8]* @a.str, i32 0, i32 0))\n    ```", "```cpp\n    \u00a0\u00a0%3 = mul nsw i32 3, %2\n    ```", "```cpp\n    \u00a0\u00a0call void @calc_write(i32 %3)\n    ```", "```cpp\n    \u00a0\u00a0ret i32 0\n    }\n    ```", "```cpp\n#ifndef CODEGEN_H\n#define CODEGEN_H\n#include \"AST.h\"\nclass CodeGen\n{\npublic:\n void compile(AST *Tree);\n};\n#endif\n```", "```cpp\n    #include \"CodeGen.h\"\n    #include \"llvm/ADT/StringMap.h\"\n    #include \"llvm/IR/IRBuilder.h\"\n    #include \"llvm/IR/LLVMContext.h\"\n    #include \"llvm/Support/raw_ostream.h\"\n    ```", "```cpp\n    using namespace llvm;\n    ```", "```cpp\n    namespace {\n    class ToIRVisitor : public ASTVisitor {\n    \u00a0\u00a0Module *M;\n    \u00a0\u00a0IRBuilder<> Builder;\n    \u00a0\u00a0Type *VoidTy;\n    \u00a0\u00a0Type *Int32Ty;\n    \u00a0\u00a0Type *Int8PtrTy;\n    \u00a0\u00a0Type *Int8PtrPtrTy;\n    \u00a0\u00a0Constant *Int32Zero;\n    \u00a0\u00a0Value *V;\n    \u00a0\u00a0StringMap<Value *> nameMap;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0ToIRVisitor(Module *M) : M(M), Builder(M->getContext()) \n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0VoidTy = Type::getVoidTy(M->getContext());\n    \u00a0\u00a0\u00a0\u00a0Int32Ty = Type::getInt32Ty(M->getContext());\n    \u00a0\u00a0\u00a0\u00a0Int8PtrTy = Type::getInt8PtrTy(M->getContext());\n    \u00a0\u00a0\u00a0\u00a0Int8PtrPtrTy = Int8PtrTy->getPointerTo();\n    \u00a0\u00a0\u00a0\u00a0Int32Zero = ConstantInt::get(Int32Ty, 0, true);\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0void run(AST *Tree) {\n    \u00a0\u00a0\u00a0\u00a0FunctionType *MainFty = FunctionType::get(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Int32Ty, {Int32Ty, Int8PtrPtrTy}, false);\n    \u00a0\u00a0\u00a0\u00a0Function *MainFn = Function::Create(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MainFty, GlobalValue::ExternalLinkage,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"main\", M);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0BasicBlock *BB = BasicBlock::Create(M->getContext(),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"entry\", MainFn);\n    \u00a0\u00a0\u00a0\u00a0Builder.SetInsertPoint(BB);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0Tree->accept(*this);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0FunctionType *CalcWriteFnTy =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FunctionType::get(VoidTy, {Int32Ty}, false);\n    \u00a0\u00a0\u00a0\u00a0Function *CalcWriteFn = Function::Create(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CalcWriteFnTy, GlobalValue::ExternalLinkage,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"calc_write\", M);\n    \u00a0\u00a0\u00a0\u00a0Builder.CreateCall(CalcWriteFnTy, CalcWriteFn, {V});\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0Builder.CreateRet(Int32Zero);\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0virtual void visit(WithDecl &Node) override {\n    \u00a0\u00a0\u00a0\u00a0FunctionType *ReadFty =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FunctionType::get(Int32Ty, {Int8PtrTy}, false);\n    \u00a0\u00a0\u00a0\u00a0Function *ReadFn = Function::Create(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ReadFty, GlobalValue::ExternalLinkage, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"calc_read\", M);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0for (auto I = Node.begin(), E = Node.end(); I != E;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++I) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef Var = *I;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Constant *StrText = ConstantDataArray::getString(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0M->getContext(), Var);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GlobalVariable *Str = new GlobalVariable(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*M, StrText->getType(),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/*isConstant=*/true, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GlobalValue::PrivateLinkage,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StrText, Twine(Var).concat(\".str\"));\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Value *Ptr = Builder.CreateInBoundsGEP(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Str, {Int32Zero, Int32Zero}, \"ptr\");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CallInst *Call =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Builder.CreateCall(ReadFty, ReadFn, {Ptr});\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nameMap[Var] = Call;\n    \u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0Node.getExpr()->accept(*this);\n    \u00a0\u00a0};\n    ```", "```cpp\n    \u00a0\u00a0virtual void visit(Factor &Node) override {\n    \u00a0\u00a0\u00a0\u00a0if (Node.getKind() == Factor::Ident) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = nameMap[Node.getVal()];\n    \u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int intval;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Node.getVal().getAsInteger(10, intval);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = ConstantInt::get(Int32Ty, intval, true);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0};\n    ```", "```cpp\n    \u00a0\u00a0virtual void visit(BinaryOp &Node) override {\n    \u00a0\u00a0\u00a0\u00a0Node.getLeft()->accept(*this);\n    \u00a0\u00a0\u00a0\u00a0Value *Left = V;\n    \u00a0\u00a0\u00a0\u00a0Node.getRight()->accept(*this);\n    \u00a0\u00a0\u00a0\u00a0Value *Right = V;\n    \u00a0\u00a0\u00a0\u00a0switch (Node.getOperator()) {\n    \u00a0\u00a0\u00a0\u00a0case BinaryOp::Plus:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = Builder.CreateNSWAdd(Left, Right); break;\n    \u00a0\u00a0\u00a0\u00a0case BinaryOp::Minus:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = Builder.CreateNSWSub(Left, Right); break;\n    \u00a0\u00a0\u00a0\u00a0case BinaryOp::Mul:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = Builder.CreateNSWMul(Left, Right); break;\n    \u00a0\u00a0\u00a0\u00a0case BinaryOp::Div:\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0V = Builder.CreateSDiv(Left, Right); break;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0};\n    };\n    }\n    ```", "```cpp\n    void CodeGen::compile(AST *Tree) {\n    \u00a0\u00a0LLVMContext Ctx;\n    \u00a0\u00a0Module *M = new Module(\"calc.expr\", Ctx);\n    \u00a0\u00a0ToIRVisitor ToIR(M);\n    \u00a0\u00a0ToIR.run(Tree);\n    \u00a0\u00a0M->print(outs(), nullptr);\n    }\n    ```", "```cpp\n    #include \"CodeGen.h\"\n    #include \"Parser.h\"\n    #include \"Sema.h\"\n    #include \"llvm/Support/CommandLine.h\"\n    #include \"llvm/Support/InitLLVM.h\"\n    #include \"llvm/Support/raw_ostream.h\"\n    ```", "```cpp\n    static llvm::cl::opt<std::string>\n    \u00a0\u00a0\u00a0\u00a0Input(llvm::cl::Positional,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::cl::desc(\"<input expression>\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::cl::init(\"\"));\n    ```", "```cpp\n    int main(int argc, const char **argv) {\n    \u00a0\u00a0llvm::InitLLVM X(argc, argv);\n    \u00a0\u00a0llvm::cl::ParseCommandLineOptions(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0argc, argv, \"calc - the expression compiler\\n\");\n    ```", "```cpp\n    \u00a0\u00a0Lexer Lex(Input);\n    \u00a0\u00a0Parser Parser(Lex);\n    \u00a0\u00a0AST *Tree = Parser.parse();\n    \u00a0\u00a0if (!Tree || Parser.hasError()) {\n    \u00a0\u00a0\u00a0\u00a0llvm::errs() << \"Syntax errors occured\\n\";\n    \u00a0\u00a0\u00a0\u00a0return 1;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0Sema Semantic;\n    \u00a0\u00a0if (Semantic.semantic(Tree)) {\n    \u00a0\u00a0\u00a0\u00a0llvm::errs() << \"Semantic errors occured\\n\";\n    \u00a0\u00a0\u00a0\u00a0return 1;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0CodeGen CodeGenerator;\n    \u00a0\u00a0CodeGenerator.compile(Tree);\n    \u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n#include <stdio.h>\n#include <stdlib.h>\nvoid calc_write(int v)\n{\n\u00a0\u00a0printf(\"The result is: %d\\n\", v);\n}\n```", "```cpp\nint calc_read(char *s)\n{\n\u00a0\u00a0char buf[64];\n\u00a0\u00a0int val;\n\u00a0\u00a0printf(\"Enter a value for %s: \", s);\n\u00a0\u00a0fgets(buf, sizeof(buf), stdin);\n\u00a0\u00a0if (EOF == sscanf(buf, \"%d\", &val))\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0printf(\"Value %s is invalid\\n\", buf);\n\u00a0\u00a0\u00a0\u00a0exit(1);\n\u00a0\u00a0}\n\u00a0\u00a0return val;\n}\n```", "```cpp\n$ calc \"with a: a*3\" | llc \u2013filetype=obj \u2013o=expr.o\n$ clang \u2013o expr expr.o rtcalc.c\n$ expr\nEnter a value for a: 4\nThe result is: 12\n```", "```cpp\n$ calc \"with a: a*3\" | llc \u2013filetype=obj \u2013o=expr.obj\n$ cl expr.obj rtcalc.c\n$ expr\nEnter a value for a: 4\nThe result is: 12\n```"]