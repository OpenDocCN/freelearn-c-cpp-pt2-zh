["```cpp\nunsigned gcd(unsigned a, unsigned b) {\n\u00a0\u00a0if (b == 0)\n\u00a0\u00a0\u00a0\u00a0return a;\n\u00a0\u00a0while (b != 0) {\n\u00a0\u00a0\u00a0\u00a0unsigned t = a % b;\n\u00a0\u00a0\u00a0\u00a0a = b;\n\u00a0\u00a0\u00a0\u00a0b = t;\n\u00a0\u00a0}\n\u00a0\u00a0return a;\n}\n```", "```cpp\n$ clang --target=aarch64-linux-gnu \u2013O1 -S -emit-llvm gcd.c\n```", "```cpp\n; ModuleID = 'gcd.c'\nsource_filename = \"gcd.c\"\ntarget datalayout = \"e-m:e-i8:8:32-i16:16:32-i64:64-\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i128:128-n32:64-S128\"\ntarget triple = \"aarch64-unknown-linux-gnu\"\n```", "```cpp\ndefine i32 @gcd(i32 %a, i32 %b) {\n```", "```cpp\nentry:\n\u00a0\u00a0%cmp = icmp eq i32 %b, 0\n\u00a0\u00a0br i1 %cmp, label %return, label %while.body\n```", "```cpp\nwhile.body:\n\u00a0\u00a0%b.addr.010 = phi i32 [ %rem, %while.body ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ %b, %entry ]\n\u00a0\u00a0%a.addr.09 = phi i32 [ %b.addr.010, %while.body ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ %a, %entry ]\n\u00a0\u00a0%rem = urem i32 %a.addr.09, %b.addr.010\n\u00a0\u00a0%cmp1 = icmp eq i32 %rem, 0\n\u00a0\u00a0br i1 %cmp1, label %return, label %while.body\n```", "```cpp\nreturn:\n\u00a0\u00a0%retval.0 = phi i32 [ %a, %entry ],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[ %b.addr.010, %while.body ]\n\u00a0\u00a0ret i32 %retval.0\n}\n```", "```cpp\n$ clang --target=aarch64-linux-gnu -S -emit-llvm gcd.c\n```", "```cpp\ndefine i32 @gcd(i32, i32) {\n\u00a0\u00a0%3 = alloca i32, align 4\n\u00a0\u00a0%4 = alloca i32, align 4\n\u00a0\u00a0%5 = alloca i32, align 4\n\u00a0\u00a0%6 = alloca i32, align 4\n\u00a0\u00a0store i32 %0, i32* %4, align 4\n\u00a0\u00a0store i32 %1, i32* %5, align 4\n\u00a0\u00a0%7 = load i32, i32* %5, align 4\n\u00a0\u00a0%8 = icmp eq i32 %7, 0\n\u00a0\u00a0br i1 %8, label %9, label %11\n```", "```cpp\nvoid emitStmt(WhileStatement *Stmt) {\n\u00a0\u00a0llvm::BasicBlock *WhileCondBB = llvm::BasicBlock::Create(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0getLLVMCtx(), \"while.cond\", Fn);\n\u00a0\u00a0llvm::BasicBlock *WhileBodyBB = llvm::BasicBlock::Create(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0getLLVMCtx(), \"while.body\", Fn);\n\u00a0\u00a0llvm::BasicBlock *AfterWhileBB = \n\u00a0\u00a0\u00a0\u00a0llvm::BasicBlock::Create(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0getLLVMCtx(), \"after.while\", Fn);\n```", "```cpp\n\u00a0\u00a0Builder.CreateBr(WhileCondBB);\n```", "```cpp\n\u00a0\u00a0setCurr(WhileCondBB);\n\u00a0\u00a0llvm::Value *Cond = emitExpr(Stmt->getCond());\n\u00a0\u00a0Builder.CreateCondBr(Cond, WhileBodyBB, AfterWhileBB);\n```", "```cpp\n\u00a0\u00a0setCurr(WhileBodyBB);\n\u00a0\u00a0emit(Stmt->getWhileStmts());\n\u00a0\u00a0Builder.CreateBr(WhileCondBB);\n```", "```cpp\n\u00a0\u00a0setCurr(AfterWhileBB);\n}\n```", "```cpp\nstruct BasicBlockDef {\nllvm::DenseMap<Decl *, llvm::TrackingVH<llvm::Value>> Defs;\n// ...\n};\n```", "```cpp\nllvm::DenseMap<llvm::BasicBlock *, BasicBlockDef> \n\u00a0\u00a0CurrentDef;\n```", "```cpp\nvoid writeLocalVariable(llvm::BasicBlock *BB, Decl *Decl,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::Value *Val) {\n\u00a0\u00a0CurrentDef[BB].Defs[Decl] = Val;\n}\n```", "```cpp\nllvm::Value *\nreadLocalVariable(llvm::BasicBlock *BB, Decl *Decl) {\n\u00a0\u00a0auto Val = CurrentDef[BB].Defs.find(Decl);\n\u00a0\u00a0if (Val != CurrentDef[BB].Defs.end())\n\u00a0\u00a0\u00a0\u00a0return Val->second;\n\u00a0\u00a0return readLocalVariableRecursive(BB, Decl);\n}\n```", "```cpp\n    llvm::DenseMap<llvm::PHINode *, Decl *> \n    \u00a0\u00a0IncompletePhis;\n    unsigned Sealed : 1;\n    ```", "```cpp\n    llvm::Value *readLocalVariableRecursive(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::BasicBlock *BB,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Decl *Decl) {\n    \u00a0\u00a0llvm::Value *Val = nullptr;\n    \u00a0\u00a0if (!CurrentDef[BB].Sealed) {\n    \u00a0\u00a0\u00a0\u00a0llvm::PHINode *Phi = addEmptyPhi(BB, Decl);\n    \u00a0\u00a0\u00a0\u00a0CurrentDef[BB].IncompletePhis[Phi] = Decl;\n    \u00a0\u00a0\u00a0\u00a0Val = Phi;\n    \u00a0\u00a0} else if (auto *PredBB = BB\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->getSinglePredecessor()) {\n    \u00a0\u00a0\u00a0\u00a0Val = readLocalVariable(PredBB, Decl);\n    \u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0llvm::PHINode *Phi = addEmptyPhi(BB, Decl);\n    \u00a0\u00a0\u00a0\u00a0Val = Phi;\n    \u00a0\u00a0\u00a0\u00a0writeLocalVariable(BB, Decl, Val);\n    \u00a0\u00a0\u00a0\u00a0addPhiOperands(BB, Decl, Phi);\n    \u00a0\u00a0}\n    \u00a0\u00a0writeLocalVariable(BB, Decl, Val);\n    \u00a0\u00a0return Val;\n    }\n    ```", "```cpp\n    llvm::PHINode *addEmptyPhi(llvm::BasicBlock *BB, Decl *Decl) {\n    \u00a0\u00a0return BB->empty()\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? llvm::PHINode::Create(mapType(Decl), 0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"\", BB)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: llvm::PHINode::Create(mapType(Decl), 0, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"\", &BB->front());\n    }\n    ```", "```cpp\n    void addPhiOperands(llvm::BasicBlock *BB, Decl *Decl,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::PHINode *Phi) {\n    \u00a0\u00a0for (auto I = llvm::pred_begin(BB),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E = llvm::pred_end(BB);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0I != E; ++I) {\n    \u00a0\u00a0\u00a0\u00a0Phi->addIncoming(readLocalVariable(*I, Decl), *I);\n    \u00a0\u00a0}\n    \u00a0\u00a0optimizePhi(Phi);\n    }\n    ```", "```cpp\n    void optimizePhi(llvm::PHINode *Phi) {\n    \u00a0\u00a0llvm::Value *Same = nullptr;\n    \u00a0\u00a0for (llvm::Value *V : Phi->incoming_values()) {\n    \u00a0\u00a0\u00a0\u00a0if (V == Same || V == Phi)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0if (Same && V != Same)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0\u00a0\u00a0Same = V;\n    \u00a0\u00a0}\n    \u00a0\u00a0if (Same == nullptr)\n    \u00a0\u00a0\u00a0\u00a0Same = llvm::UndefValue::get(Phi->getType());\n    ```", "```cpp\n    \u00a0\u00a0llvm::SmallVector<llvm::PHINode *, 8> CandidatePhis;\n    \u00a0\u00a0for (llvm::Use &U : Phi->uses()) {\n    \u00a0\u00a0\u00a0\u00a0if (auto *P =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::dyn_cast<llvm::PHINode>(U.getUser()))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CandidatePhis.push_back(P);\n    \u00a0\u00a0}\n    \u00a0\u00a0Phi->replaceAllUsesWith(Same);\n    \u00a0\u00a0Phi->eraseFromParent();\n    \u00a0\u00a0for (auto *P : CandidatePhis)\n    \u00a0\u00a0\u00a0\u00a0optimizePhi(P);\n    }\n    ```", "```cpp\nvoid sealBlock(llvm::BasicBlock *BB) {\n\u00a0\u00a0for (auto PhiDecl : CurrentDef[BB].IncompletePhis) {\n\u00a0\u00a0\u00a0\u00a0addPhiOperands(BB, PhiDecl.second, PhiDecl.first);\n\u00a0\u00a0}\n\u00a0\u00a0CurrentDef[BB].IncompletePhis.clear();\n\u00a0\u00a0CurrentDef[BB].Sealed = true;\n}\n```", "```cpp\nllvm::Value *CGProcedure::readVariable(llvm::BasicBlock \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*BB,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Decl *D) {\n\u00a0\u00a0if (auto *V = llvm::dyn_cast<VariableDeclaration>(D)) {\n\u00a0\u00a0\u00a0\u00a0if (V->getEnclosingDecl() == Proc)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return readLocalVariable(BB, D);\n\u00a0\u00a0\u00a0\u00a0else if (V->getEnclosingDecl() ==\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CGM.getModuleDeclaration()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Builder.CreateLoad(mapType(D),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CGM.getGlobal(D));\n\u00a0\u00a0\u00a0\u00a0} else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::report_fatal_error(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Nested procedures not yet supported\");\n\u00a0\u00a0} else if (auto *FP =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::dyn_cast<FormalParameterDeclaration>(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0D)) {\n\u00a0\u00a0\u00a0\u00a0if (FP->isVar()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return Builder.CreateLoad(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mapType(FP)->getPointerElementType(),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FormalParams[FP]);\n\u00a0\u00a0\u00a0\u00a0} else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return readLocalVariable(BB, D);\n\u00a0\u00a0} else\n\u00a0\u00a0\u00a0\u00a0llvm::report_fatal_error(\"Unsupported declaration\");\n}\n```", "```cpp\nstd::string CGModule::mangleName(Decl *D) {\n\u00a0\u00a0std::string Mangled;\n\u00a0\u00a0llvm::SmallString<16> Tmp;\n\u00a0\u00a0while (D) {\n\u00a0\u00a0\u00a0\u00a0llvm::StringRef Name = D->getName();\n\u00a0\u00a0\u00a0\u00a0Tmp.clear();\n\u00a0\u00a0\u00a0\u00a0Tmp.append(llvm::itostr(Name.size()));\n\u00a0\u00a0\u00a0\u00a0Tmp.append(Name);\n\u00a0\u00a0\u00a0\u00a0Mangled.insert(0, Tmp.c_str());\n\u00a0\u00a0\u00a0\u00a0D = D->getEnclosingDecl();\n\u00a0\u00a0}\n\u00a0\u00a0Mangled.insert(0, \"_t\");\n\u00a0\u00a0return Mangled;\n}\n```", "```cpp\nllvm::Type *convertType(TypeDeclaration *Ty) {\n\u00a0\u00a0if (Ty->getName() == \"INTEGER\")\n\u00a0\u00a0\u00a0\u00a0return Int64Ty;\n\u00a0\u00a0if (Ty->getName() == \"BOOLEAN\")\n\u00a0\u00a0\u00a0\u00a0return Int1Ty;\n\u00a0\u00a0llvm::report_fatal_error(\"Unsupported type\");\n}\n```", "```cpp\nllvm::Type *mapType(Decl *Decl) {\n\u00a0\u00a0if (auto *FP = llvm::\n\u00a0\u00a0\u00a0\u00a0dyn_cast<FormalParameterDeclaration>(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Decl)) {\n\u00a0\u00a0\u00a0\u00a0llvm::Type *Ty = convertType(FP->getType());\n\u00a0\u00a0\u00a0\u00a0if (FP->isVar())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Ty = Ty->getPointerTo();\n\u00a0\u00a0\u00a0\u00a0return Ty;\n\u00a0\u00a0}\n\u00a0\u00a0if (auto *V = llvm::dyn_cast<VariableDeclaration>(Decl))\n\u00a0\u00a0\u00a0\u00a0return convertType(V->getType());\n\u00a0\u00a0return convertType(llvm::cast<TypeDeclaration>(Decl));\n}\n```", "```cpp\nllvm::FunctionType *createFunctionType(\n\u00a0\u00a0\u00a0\u00a0ProcedureDeclaration *Proc) {\n\u00a0\u00a0llvm::Type *ResultTy = VoidTy;\n\u00a0\u00a0if (Proc->getRetType()) {\n\u00a0\u00a0\u00a0\u00a0ResultTy = mapType(Proc->getRetType());\n\u00a0\u00a0}\n\u00a0\u00a0auto FormalParams = Proc->getFormalParams();\n\u00a0\u00a0llvm::SmallVector<llvm::Type *, 8> ParamTypes;\n\u00a0\u00a0for (auto FP : FormalParams) {\n\u00a0\u00a0\u00a0\u00a0llvm::Type *Ty = mapType(FP);\n\u00a0\u00a0\u00a0\u00a0ParamTypes.push_back(Ty);\n\u00a0\u00a0}\n\u00a0\u00a0return llvm::FunctionType::get(ResultTy, ParamTypes,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* IsVarArgs */ false);\n}\n```", "```cpp\nllvm::Function *\ncreateFunction(ProcedureDeclaration *Proc,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::FunctionType *FTy) {\n\u00a0\u00a0llvm::Function *Fn = llvm::Function::Create(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Fty, llvm::GlobalValue::ExternalLinkage,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mangleName(Proc), getModule());\n```", "```cpp\n\u00a0\u00a0size_t Idx = 0;\n\u00a0\u00a0for (auto I = Fn->arg_begin(), E = Fn->arg_end(); I != E;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++I, ++Idx) {\n\u00a0\u00a0\u00a0\u00a0llvm::Argument *Arg = I;\n\u00a0\u00a0\u00a0\u00a0FormalParameterDeclaration *FP =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Proc->getFormalParams()[Idx];\n\u00a0\u00a0\u00a0\u00a0if (FP->isVar()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::AttrBuilder Attr;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::TypeSize Sz =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CGM.getModule()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->getDataLayout().getTypeStoreSize(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CGM.convertType(FP->getType()));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Attr.addDereferenceableAttr(Sz);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Attr.addAttribute(llvm::Attribute::NoCapture);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Arg->addAttrs(Attr);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0Arg->setName(FP->getName());\n\u00a0\u00a0}\n\u00a0\u00a0return Fn;\n}\n```", "```cpp\n    void run(ProcedureDeclaration *Proc) {\n    \u00a0\u00a0this->Proc = Proc;\n    \u00a0\u00a0Fty = createFunctionType(Proc);\n    \u00a0\u00a0Fn = createFunction(Proc, Fty);\n    ```", "```cpp\n    \u00a0\u00a0llvm::BasicBlock *BB = llvm::BasicBlock::Create(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CGM.getLLVMCtx(), \"entry\", Fn);\n    \u00a0\u00a0setCurr(BB);\n    ```", "```cpp\n    \u00a0\u00a0size_t Idx = 0;\n    \u00a0\u00a0auto &Defs = CurrentDef[BB];\n    \u00a0\u00a0for (auto I = Fn->arg_begin(), E = Fn->arg_end(); I != \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E; ++I, ++Idx) {\n    \u00a0\u00a0\u00a0\u00a0llvm::Argument *Arg = I;\n    \u00a0\u00a0\u00a0\u00a0FormalParameterDeclaration *FP = Proc->\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0getParams()[Idx];\n    \u00a0\u00a0\u00a0\u00a0FormalParams[FP] = Arg;\n    \u00a0\u00a0\u00a0\u00a0Defs.Defs.insert(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::pair<Decl *, llvm::Value *>(FP, Arg));\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0auto Block = Proc->getStmts();\n    \u00a0\u00a0emit(Proc->getStmts());\n    ```", "```cpp\n    \u00a0\u00a0sealBlock(Curr);\n    \u00a0\u00a0if (!Curr->getTerminator()) {\n    \u00a0\u00a0\u00a0\u00a0Builder.CreateRetVoid();\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\nvoid CGModule::run(ModuleDeclaration *Mod) {\n\u00a0\u00a0for (auto *Decl : Mod->getDecls()) {\n\u00a0\u00a0\u00a0\u00a0if (auto *Var =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::dyn_cast<VariableDeclaration>(Decl)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::GlobalVariable *V = new llvm::GlobalVariable(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*M, convertType(Var->getType()),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/*isConstant=*/false,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::GlobalValue::PrivateLinkage, nullptr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mangleName(Var));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Globals[Var] = V;\n\u00a0\u00a0\u00a0\u00a0} else if (auto *Proc =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::dyn_cast<ProcedureDeclaration>(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Decl)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CGProcedure CGP(*this);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CGP.run(Proc);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```cpp\nInt64Ty = llvm::Type::getInt64Ty(getLLVMCtx());\n```", "```cpp\nvoid CodeGenerator::run(ModuleDeclaration *Mod, std::string FileName) {\n\u00a0\u00a0llvm::Module *M = new llvm::Module(FileName, Ctx);\n\u00a0\u00a0M->setTargetTriple(TM->getTargetTriple().getTriple());\n\u00a0\u00a0M->setDataLayout(TM->createDataLayout());\n\u00a0\u00a0CGModule CGM(M);\n\u00a0\u00a0CGM.run(Mod);\n}\n```", "```cpp\nCodeGenerator *CodeGenerator::create(llvm::TargetMachine *TM) {\n\u00a0\u00a0return new CodeGenerator(TM);\n}\n```", "```cpp\n#include \"llvm/CodeGen/CommandFlags.h\"\n```", "```cpp\nstatic cl::opt<std::string>\n\u00a0\u00a0\u00a0\u00a0MTriple(\"mtriple\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cl::desc(\"Override target triple for module\"));\n```", "```cpp\n    llvm::TargetMachine *\n    createTargetMachine(const char *Argv0) {\n    ```", "```cpp\n    \u00a0\u00a0llvm::Triple = llvm::Triple(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0!MTriple.empty()\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? llvm::Triple::normalize(MTriple)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: llvm::sys::getDefaultTargetTriple());\n    \u00a0\u00a0llvm::TargetOptions =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0codegen::InitTargetOptionsFromCodeGenFlags(Triple);\n    \u00a0\u00a0std::string CPUStr = codegen::getCPUStr();\n    \u00a0\u00a0std::string FeatureStr = codegen::getFeaturesStr();\n    ```", "```cpp\n    \u00a0\u00a0std::string Error;\n    \u00a0\u00a0const llvm::Target *Target =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::TargetRegistry::lookupTarget(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0codegen::getMArch(), Triple, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Error);\n    \u00a0\u00a0if (!Target) {\n    \u00a0\u00a0\u00a0\u00a0llvm::WithColor::error(llvm::errs(), Argv0) << \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Error;\n    \u00a0\u00a0\u00a0\u00a0return nullptr;\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0llvm::TargetMachine *TM = Target->\n    \u00a0\u00a0\u00a0\u00a0createTargetMachine(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Triple.getTriple(), CPUStr, FeatureStr, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TargetOptions, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::Optional<llvm::Reloc::Model>(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0codegen::getRelocModel()));\n    \u00a0\u00a0return TM;\n    }\n    ```", "```cpp\n#include \"llvm/IR/IRPrintingPasses.h\"\n#include \"llvm/IR/LegacyPassManager.h\"\n#include \"llvm/Support/ToolOutputFile.h\"\n```", "```cpp\nstatic cl::opt<bool>\n\u00a0\u00a0\u00a0\u00a0EmitLLVM(\"emit-llvm\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cl::desc(\"Emit IR code instead of assembler\"),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cl::init(false));\n```", "```cpp\nbool emit(StringRef Argv0, llvm::Module *M,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0llvm::TargetMachine *TM,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0StringRef InputFilename) {\n\u00a0\u00a0CodeGenFileType FileType = codegen::getFileType();\n\u00a0\u00a0std::string OutputFilename;\n\u00a0\u00a0if (InputFilename == \"-\") {\n\u00a0\u00a0\u00a0\u00a0OutputFilename = \"-\";\n\u00a0\u00a0}\n```", "```cpp\n\u00a0\u00a0else {\n\u00a0\u00a0\u00a0\u00a0if (InputFilename.endswith(\".mod\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OutputFilename = InputFilename.drop_back(4).str();\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OutputFilename = InputFilename.str();\n\u00a0\u00a0\u00a0\u00a0switch (FileType) {\n\u00a0\u00a0\u00a0\u00a0case CGFT_AssemblyFile:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OutputFilename.append(EmitLLVM ? \".ll\" : \".s\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0case CGFT_ObjectFile:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OutputFilename.append(\".o\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0case CGFT_Null:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OutputFilename.append(\".null\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n```", "```cpp\n\u00a0\u00a0std::error_code EC;\n\u00a0\u00a0sys::fs::OpenFlags = sys::fs::OF_None;\n\u00a0\u00a0if (FileType == CGFT_AssemblyFile)\n\u00a0\u00a0\u00a0\u00a0OpenFlags |= sys::fs::OF_Text;\n\u00a0\u00a0auto Out = std::make_unique<llvm::ToolOutputFile>(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0OutputFilename, EC, OpenFlags);\n\u00a0\u00a0if (EC) {\n\u00a0\u00a0\u00a0\u00a0WithColor::error(errs(), Argv0) << EC.message() << \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'\\n';\n\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n```", "```cpp\n\u00a0\u00a0legacy::PassManager PM;\n\u00a0\u00a0if (FileType == CGFT_AssemblyFile && EmitLLVM) {\n\u00a0\u00a0\u00a0\u00a0PM.add(createPrintModulePass(Out->os()));\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0if (TM->addPassesToEmitFile(PM, Out->os(), nullptr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FileType)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WithColor::error() << \"No support for file type\\n\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n```", "```cpp\n\u00a0\u00a0PM.run(*M);\n```", "```cpp\n\u00a0\u00a0Out->keep();\n```", "```cpp\n\u00a0\u00a0return true;\n}\n```", "```cpp\n$ tinylang \u2013filetype=obj gcd.mod\n```", "```cpp\n$ tinylang \u2013filetype=asm \u2013emit-llvm \u2013o \u2013 gcd.mod\n```"]