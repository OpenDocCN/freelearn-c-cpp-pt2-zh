["```cpp\nLogContentBrowser: Native class hierarchy updated for 'HierarchicalLODOutliner' in 0.0011 seconds. Added 1 classes and 2 folders.\nLogLoad: Full Startup: 8.88 seconds (BP compile: 0.07 seconds)\nLogStreaming:Warning: Failed to read file '../../../Engine/Content/Editor/Slate/Common/Selection_16x.png' error.\nLogExternalProfiler: Found external profiler: VSPerf\n```", "```cpp\nUE_LOG( LogTemp, Warning, TEXT( \"Message %d\" ), 1 );\n```", "```cpp\n    DECLARE_LOG_CATEGORY_EXTERN( LogPong, Log, All ); // Pong.h\n    ```", "```cpp\n    DEFINE_LOG_CATEGORY( LogPong ); // Pong.cpp\n    ```", "```cpp\n    UE_LOG( LogPong, Display, TEXT( \"A display message, log is working\" ) ); // shows in gray\n    UE_LOG( LogPong, Warning, TEXT( \"A warning message\" ) );\n    UE_LOG( LogPong, Error, TEXT( \"An error message \" ) );\n    ```", "```cpp\nLog LogName off // Stop LogName from displaying at the output\nLog LogName Log // Turn LogName's output on again\n```", "```cpp\n    #define LOCTEXT_NAMESPACE \"Chapter12Namespace\"\n    ```", "```cpp\n    extern FName LoggerName;\n    extern FMessageLog Logger;\n    ```", "```cpp\n    #define FTEXT(x) LOCTEXT(x, x)\n    FName LoggerName( \"Chapter12Log\" );\n    FMessageLog CreateLog( FName name )\n    {\n      FMessageLogModule& MessageLogModule = \n      FModuleManager::LoadModuleChecked<FMessageLogModule>\n      (\"MessageLog\");\n      FMessageLogInitializationOptions InitOptions;\n      InitOptions.bShowPages = true;// Don't forget this!\n      InitOptions.bShowFilters = true;\n      FText LogListingName = FTEXT( \"Chapter 12's Log Listing\" );\n      MessageLogModule.RegisterLogListing( LoggerName, LogListingName, InitOptions );\n    }\n    // Somewhere early in your program startup\n    // (eg in your GameMode constructor)\n    AChapter12GameMode::AChapter12GameMode()\n    {\n      CreateLogger( LoggerName );\n      // Retrieve the Log by using the LoggerName.\n      FMessageLog logger( LoggerName );\n      logger.Warning(\n      FTEXT( \"A warning message from gamemode ctor\" ) );\n    }\n    ```", "```cpp\n    #define FTEXT(x) LOCTEXT(x, x)\n    ```", "```cpp\n    Logger.Info( FTEXT( \"Info to log\" ) );\n    Logger.Warning( FTEXT( \"Warning text to log\" ) );\n    Logger.Error( FTEXT( \"Error text to log\" ) );\n    ```", "```cpp\n    FMessageLog( LoggerName ).Info( FTEXT( \"An info message\" ) );\n    ```", "```cpp\n    FRotator( float InPitch, float InYaw, float InRoll );\n    ```", "```cpp\n    FRotator rotator( 0, GetWorld()->TimeSeconds, 0 );\n    ```", "```cpp\n    FRotator rotator( 0, GetWorld()->TimeSeconds, 0 );\n    SetActorRotation( rotation );\n    ```", "```cpp\n    FQuat( FVector Axis, float AngleRad );\n    ```", "```cpp\nFQuat( FVector( 1, 0, 0 ), PI/4.f ) *\nFQuat( FVector( 0, 1, 0 ), PI/4.f );\n```", "```cpp\n    FVector toFollow = target->GetActorLocation() - GetActorLocation();\n    FMatrix rotationMatrix = FRotationMatrix::MakeFromXZ( toTarget, GetActorUpVector() );\n    SetActorRotation( rotationMatrix.Rotator() );\n    ```", "```cpp\nFRotationMatrix rotationMatrix = FRotationMatrix::MakeFromXY( lookAlong, right );\nactor->SetActorRotation( rotationMatrix.Rotator() );\n```", "```cpp\n        TArray<ALandscape*> AChapter12GameMode::GetLandscapes()\n        {\n          TArray<ALandscape*> landscapes;\n          ULevel *level = GetLevel();\n          for( int i = 0; i < level->Actors.Num(); i++ )\n          if( ALandscape* land = Cast<ALandscape>(level->Actors[i]) )\n          landscapes.Push( land );\n          return landscapes;\n        }\n        ```", "```cpp\n        ULandscapeInfo::RecreateLandscapeInfo( GetWorld(), 1 );\n        ```", "```cpp\n        // a) REQUIRED STEP: Call static function\n        // ULandscapeInfo::RecreateLandscapeInfo().\n        // What this does is populate the Landscape object with\n        // data values so you don't get nulls for your \n        // ULandscapeInfo objects on retrieval.\n        ULandscapeInfo::RecreateLandscapeInfo( GetWorld(), 1 );\n\n        // b) Assuming landscape is your landscape object pointer,\n        // get extents of landscape, to compute # height values\n        FIntRect landscapeBounds = landscape->GetBoundingRect();\n\n        // c) Create height values.\n        // LandscapeEditorUtils::SetHeightmapData() adds one to \n        // each dimension because the boundary edges may be used.\n        int32 numHeights = (rect.Width()+1)*(rect.Height()+1);\n        TArray<uint16> Data;\n        Data.Init( 0, numHeights );\n        for( int i = 0; i < Data.Num(); i++ ) {\n          float nx = (i % cols) / cols; // normalized x value\n          float ny = (i / cols) / rows; // normalized y value\n          Data[i] = PerlinNoise2D( nx, ny, 16, 4, 4 );\n        }\n\n        // d) Set values in with call:\n        LandscapeEditorUtils::SetHeightmapData( landscape, Data );\n        ```", "```cpp\nuint16 AChapter12GameMode::PerlinNoise2D( float x, float y,\n  float amp, int32 octaves, int32 px, int32 py )\n{\n  float noise = 0.f;\n  for( int octave = 1; octave < octaves; octave *= 2 )\n  {\n    // Add in fractions of faster varying noise at lower \n    // amplitudes for higher octaves. Assuming x is normalized, \n    // WHEN octave==px  you get full period. Higher frequencies \n    // will go out and also meet period.\n    noise += Noise1234::pnoise( x*px*octave, y*py*octave, px, py ) / octave;\n  }\n  return USHRT_MAX/2.f + amp*noise;\n}\n```", "```cpp\nvoid AWarrior::SetupPlayerInputComponent( UInputComponent* Input )\n{\n  Super::SetupPlayerInputComponent( Input );\n  // Connect the class's AbilitySystemComponent\n  // to the actor's input component\n  AbilitySystemComponent->BindToInputComponent( Input );\n\n  // Go thru each BindInfo in the gameplayAbilitySet.\n  // Give & try and activate each on the AbilitySystemComponent.\n  for( const FGameplayAbilityBindInfo& BindInfo : \n  gameplayAbilitySet->Abilities )\n  {\n    // BindInfo has 2 members:\n    //   .Command (enum value)\n    //   .GameplayAbilityClass (UClass of a UGameplayAbility)\n    if( !BindInfo.GameplayAbilityClass )\n    {\n      Error( FS( \"GameplayAbilityClass %d not set\",\n      (int32)BindInfo.Command ) );\n      continue;\n    }\n\n    FGameplayAbilitySpec spec(\n    // Gets you an instance of the UClass\n    BindInfo.GameplayAbilityClass->\n    GetDefaultObject<UGameplayAbility>(),\n    1, (int32)BindInfo.Command ) ;\n\n // STORE THE ABILITY HANDLE FOR LATER INVOKATION\n // OF THE ABILITY\n    FGameplayAbilitySpecHandle abilityHandle = \n    AbilitySystemComponent->GiveAbility( spec );\n\n    // The integer id that invokes the ability \n    // (ith value in enum listing)\n    int32 AbilityID = (int32)BindInfo.Command;\n\n    // CONSTRUCT the inputBinds object, which will\n    // allow us to wire-up an input event to the\n    // InputPressed() / InputReleased() events of\n    // the GameplayAbility.\n    FGameplayAbiliyInputBinds inputBinds(\n      // These are supposed to be unique strings that define\n      // what kicks off the ability for the actor instance.\n      // Using strings of the format \n      // \"ConfirmTargetting_Player0_AbilityClass\"\n      FS( \"ConfirmTargetting_%s_%s\", *GetName(), \n        *BindInfo.GameplayAbilityClass->GetName() ),\n      FS( \"CancelTargetting_%s_%s\", *GetName(), \n        *BindInfo.GameplayAbilityClass->GetName() ),\n      \"EGameplayAbilityInputBinds\", // The name of the ENUM that \n      // has the abilities listing (GameplayAbilitySet.h).\n      AbilityID, AbilityID\n    );\n // MUST BIND EACH ABILITY TO THE INPUTCOMPONENT, OTHERWISE\n // THE ABILITY CANNOT \"HEAR\" INPUT EVENTS.\n    // Enables triggering of InputPressed() / InputReleased() \n    // events, which you can in-turn use to call \n    // TryActivateAbility() if you so choose.\n    AbilitySystemComponent->BindAbilityActivationToInputComponent(\n      Input, inputBinds\n    );\n\n    // Test-kicks the ability to active state.\n    // You can try invoking this manually via your\n    // own hookups to keypresses in this Warrior class\n    // TryActivateAbility() calls ActivateAbility() if\n    // the ability is indeed invokable at this time according\n    // to rules internal to the Ability's class (such as cooldown\n    // is ready and cost is met)\n    AbilitySystemComponent->TryActivateAbility( \n      abilityHandle, 1 );\n  }\n}\n```", "```cpp\n    #include \"Runtime/GameplayAbilities/Public/AttributeSet.h\"\n    #include \"GameUnitAttributeSet.generated.h\"\n\n    UCLASS(Blueprintable, BlueprintType)\n    class CHAPTER12_API UGameUnitAttributeSet : public UAttributeSet\n    {\n      GENERATED_BODY()\n      public:\n      UGameUnitAttributeSet( const FObjectInitializer& PCIP );\n      UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes )  float Hp;\n      UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes )  float Mana;\n      UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = GameUnitAttributes )  float Speed;\n    };\n    ```", "```cpp\n    AbilitySystemComponent->InitStats( \n      UGameUnitAttributeSet::StaticClass(), NULL );\n    ```", "```cpp, and then `Log LogAbilitySystem` `All`.\n\nThis will display much more information from `AbilitySystem` in the **Output Log**, making it easier to see what's going on within the system.\n\n## How to do it\u2026\n\nIn the following steps, we'll construct a quick `GameplayEffect` that heals `50 hp` to the selected unit's `AttributeSet`:\n\n1.  Construct your `UGameplayEffect` class object using the `CONSTRUCT_CLASS` macro with the following line of code:\n\n    ```", "```cpp\n\n2.  Use the `AddModifier` function to change the `Hp` field of `GameUnitAttributeSet`, as follows:\n\n    ```", "```cpp\n\n3.  Fill in the other properties of `GameplayEffect`, including fields such as `DurationPolicy` and `ChanceToApplyToTarget` or any other fields that you'd like to modify, as follows:\n\n    ```", "```cpp\n\n4.  Apply the effect to an `AbilitySystemComponent` of your choice. The underlying `UAttributeSet` will be affected and modified by your call, as shown in the following piece of code:\n\n    ```", "```cpp\n\n## How it works\u2026\n\n`GameplayEffects` are simply little objects that effect changes to an actor's `AttributeSet`. `GameplayEffects` can occur once, or repeatedly, in intervals over a `Period`. You can program-in effects pretty quickly and the `GameplayEffect` class creation is intended to be inline.\n\n## There's more\u2026\n\nOnce the `GameplayEffect` is active, you will receive an `FActiveGameplayEffectHandle`. You can use this handle to attach a function delegate to run when the effect is over using the `OnRemovedDelegate` member of the `FActiveGameplayEffectHandle`. For example, you might call:\n\n```", "```cpp\n\n# GameplayTags API \u2013 Attaching GameplayTags to an Actor\n\n`GameplayTags` are just small bits of text that describes states (or buffs) for the player or attributes that can attach to things such as `GameplayAbilities` and also to describe `GameplayEffects`, as well as states that clear those effects. So, we can have `GameplayTags`, such as `Healing` or `Stimmed`, that trigger various `GameplayAbilities` or `GameplayEffects` to our liking. We can also search for things via `GameplayTags` and attach them to our `AbilitySystemComponents` if we choose.\n\n## How to do it\u2026\n\nThere are several steps to getting `GameplayTags` to work correctly inside your engine build; they are as follows:\n\n1.  First, we will need to create a Data Table asset to carry all of our game's tag names. Right-click on **Content Browser** and select **Miscellaneous** | **Data Table**. Select a table class structure deriving from `GameplayTagTableRow`.![How to do it\u2026](img/00303.jpeg)\n\n    List all tags available inside your game under that data structure.\n\n2.  Add `UPROPERTY() TArray<FString>` to your `GameMode` object to list the names of the `TagTableNames` that you want to load into the `GameplayTags` module manager:\n\n    ```", "```cpp\n\n3.  In your GameMode's `PostInitializeComponents` function, or later, load the tags in the tables of your choice using `GetGameplayTagsManager`:\n\n    ```", "```cpp\n\n4.  Use your `GameplayTags`. Inside each of your GameplayAbility objects, you can modify the blockedness, cancelability, and activation requirements for each GameplayAbility using tag attachment or removal.![How to do it\u2026](img/00304.jpeg)\n\nYou do have to rebuild your engine in order to get your tags to load within the editor. The patch to the engine source that is proposed allows you to hook in a call to `IGameplayTagsModule::Get().GetGameplayTagsManager().LoadGameplayTagTable( GameplayTagTableNames )`.\n\nTo get this call embedded into the editor's startup, you will need to edit the engine's source.\n\n# GameplayTasks API \u2013 Making things happen with GameplayTasks\n\n`GameplayTasks` are used to wrap up some gameplay functionality in a reusable object. All you have to do to use them is derive from the `UGameplayTask` base class and override some of the member functions that you prefer to implement.\n\n## Getting ready\n\nGo in the UE4 Editor and navigate to **Class Viewer**. Ensure that you have linked in the `GameplayTasks` API into your `ProjectName.Build.cs` file and search with **Actors Only** tickbox off for the `GameplayTask` object type.\n\n## How to do it\u2026\n\n1.  Ensure that you have linked `GameplayTasks` API into your `ProjectName.Build.cs` file.\n2.  Click on **File** | **Add C++ Class\u2026** Choose to derive from `GameplayTask`. To do so, you must first tick **Show All Classes**, and then type `gameplaytask` into the filter box. Click on **Next**, name your C++ class (something like `GameplayTask_TaskName` is the convention) then add the class to your project. The example spawns a particle emitter and is called `GameplayTask_CreateParticles`.\n3.  Once your `GameplayTask_CreateParticles.h` and `.cpp` pair are created, navigate to the `.h` file and declare a static constructor that creates a `GameplayTask_CreateParticles` object for you:\n\n    ```", "```cpp\n\n4.  Override the `UGameplayTask_CreateEmitter::Activate()` function, which contains code that runs when `GameplayTask` is effected, as follows:\n\n    ```", "```cpp\n\n5.  Add `GameplayTasksComponent` to your `Actor` class derivative, which is available in the **Components** dropdown of the **Components** tab in the Blueprint editor.\n6.  Create and add an instance of your `GameplayTask` inside your `Actor` derivative instance using the following code:\n\n    ```", "```cpp\n\n7.  This code runs anywhere in your `Actor` class derivative, any time after `GameplayTasksComponent` is initialized (any time after `PostInitializeComponents()`).\n\n## How it works\u2026\n\n`GameplayTasks` simply register with the `GameplayTasksComponent` situated inside an `Actor` class derivative of your choice. You can activate any number of `GameplayTasks` at any time during gameplay to trigger their effects.\n\n`GameplayTasks` can also kick off `GameplayEffects` to change attributes of `AbilitySystemsComponents` if you wish.\n\n## There's more\u2026\n\nYou can derive `GameplayTasks` for any number of events in your game. What's more is that you can override a few more virtual functions to hook into additional functionality.\n\n# HTTP API \u2013 Web request\n\nWhen you're maintaining scoreboards or other such things that require regular HTTP request access to servers, you can use the HTTP API to perform such web request tasks.\n\n## Getting ready\n\nHave a server to which you're allowed to request data via HTTP. You can use a public server of any type to try out HTTP requests if you'd like.\n\n## How to do it\u2026\n\n1.  Link to the HTTP API in your `ProjectName.Build.cs` file.\n2.  In the file in which you will send your web request, include the `HttpModule.h` header file, the `HttpManager.h` header file, and the `HttpRetrySystem.h` file, as shown in the following code snippet:\n\n    ```", "```cpp\n\n3.  Construct an `IHttpRequest` object from `FHttpModule` using the following code:\n\n    ```", "```cpp\n\n    ### Tip\n\n    `FHttpModule` is a singleton object. One copy of it exists for the entire program that you are meant to use for all interactions with the `FHttpModule` class.\n\n4.  Attach your function to run to the `IHttpRequest` object's `FHttpRequestCompleteDelegate`, which has a signature as follows:\n\n    ```", "```cpp\n\n5.  The delegate is found inside of the `IHttpRequest` object as `http->OnProcessRequestComplete()`:\n\n    ```", "```cpp\n\n    There are a few ways to attach a callback function to the delegate. You can use the following:\n\n    *   A lambda using `delegate.BindLambda()`:\n\n        ```", "```cpp\n\n    *   Any UObject's member function:\n\n        ```", "```cpp\n\n        ### Tip\n\n        You cannot attach to `UFunction` directly here as the `.BindUFunction()` command requests arguments that are all `UCLASS`, `USTRUCT` or `UENUM`.\n\n    *   Any plain old C++ object's member function using `.BindRaw`:\n\n        ```", "```cpp\n\n        ### Tip\n\n        You have to ensure that your `plainObject` refers to a valid object in memory at the time the HTTP request completes. This means that you cannot use `TAutoPtr` on `plainObject`, because that will deallocate `plainObject` at the end of the block in which it is declared, but that may be before the HTTP request completes.\n\n    *   A global C-style static function:\n\n        ```", "```cpp\n\n    ### Note\n\n    When using a delegate callback with an object, be sure that the object instance that you're calling back on lives on at least until the point at which the `HttpResponse` arrives back from the server. Processing the `HttpRequest` takes real time to run. It is a web request after all\u2014think of waiting for a web page to load.\n\n    You have to be sure that the object instance on which you're calling the callback function has not deallocated on you between the time of the initial call and the invocation of your `HttpHandler` function. The object must still be in memory when the callback returns after the HTTP request completes.\n\n    You cannot simply expect that the `HttpResponse` function happens immediately after you attach the callback function and call `ProcessRequest()`! Using a reference counted `UObject` instance to attach the `HttpHandler` member function is a good idea to ensure that the object stays in memory until the HTTP request completes.\n\n6.  Specify the URL of the site you'd like to hit:\n\n    ```", "```cpp\n\n7.  Process the request by calling `ProcessRequest`:\n\n    ```", "```cpp\n\n## How it works\u2026\n\nThe HTTP object is all you need to send off HTTP requests to a server and get HTTP responses. You can use the HTTP request/response for anything that you wish; for example, submitting scores to a high scores table or to retrieve text to display in-game from a server.\n\nThey are decked out with a URL to visit and a function callback to run when the request is complete. Finally, they are sent off via `FManager`. When the web server responds, your callback is called and the results of your HTTP response can be shown.\n\n## There's more\u2026\n\nYou can set additional HTTP request parameters via the following member functions:\n\n*   `SetVerb()` to change whether you are using the `GET` or `POST` method in your HTTP request\n*   `SetHeaders()` to modify any general header settings you would like\n\n# HTTP API \u2013 Progress bars\n\nThe `IHttpRequest` object from HTTP API will report HTTP download progress via a callback on a `FHttpRequestProgressDelegate` accessible via `OnRequestProgress()`. The signature of the function we can attach to the `OnRequestProgress()` delegate is as follows:\n\n```", "```cpp\n\nThe three parameters of the function you may write include: the original `IHttpRequest` object, the bytes sent, and the bytes received so far. This function gets called back periodically until the `IHttpRequest` object completes, which is when the function you attach to `OnProcessRequestComplete()` gets called. You can use the values passed to your `HandleRequestProgress` function to advance a progress bar that you will create in UMG.\n\n## Getting ready\n\nYou will need an internet connection to use this recipe. We will be requesting a file from a public server. You can use a public server or your own private server for your HTTP request if you'd like.\n\nIn this recipe, we will bind a callback function to just the `OnRequestProgress()` delegate to display the download progress of a file from a server. Have a project ready where we can write a piece of code that will perform `IHttpRequest,` and a nice interface on which to display percentage progress.\n\n## How to do it\u2026\n\n1.  Link to the `UMG` and `HTTP` APIs in your `ProjectName.Build.cs` file.\n2.  Build a small UMG UI with `ProgressBar` to display your HTTP request's progress.\n3.  Construct an `IHttpRequest` object using the following code:\n\n    ```", "```cpp\n\n4.  Provide a callback function to call when the request progresses, which updates a visual GUI element:\n\n    ```"]