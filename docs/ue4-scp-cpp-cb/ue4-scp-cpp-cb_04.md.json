["```cpp\n    MyFirstActor.h\n    #pragma once\n\n    #include \"GameFramework/Actor.h\"\n    #include \"MyFirstActor.generated.h\"\n\n    UCLASS()\n    class UE4COOKBOOK_API AMyFirstActor : public AActor\n    {\n      GENERATED_BODY()\n      public:\n      AMyFirstActor(); \n    };\n    MyFirstActor.cpp\n    #include \"UE4Cookbook.h\"\n    #include \"MyFirstActor.h\"\n    AMyFirstActor::AMyFirstActor()\n    {\n      PrimaryActorTick.bCanEverTick = true;\n    }\n    ```", "```cpp\n    virtual void BeginPlay() override;\n    ```", "```cpp\n    void AUE4CookbookGameMode::BeginPlay()\n    {\n      Super::BeginPlay();\n      GEngine->AddOnScreenDebugMessage(-1, -1, FColor::Red, TEXT(\"Actor Spawning\"));\n\n      FTransform SpawnLocation;\n      GetWorld()->SpawnActor<AMyFirstActor>( AMyFirstActor::StaticClass(), &SpawnLocation);\n    }\n    ```", "```cpp\n    UPROPERTY()\n    AMyFirstActor* SpawnedActor;\n    UFUNCTION()\n    void DestroyActorFunction();\n    ```", "```cpp\n    SpawnedActor = GetWorld()->SpawnActor<AMyFirstActor> (AMyFirstActor::StaticClass(), SpawnLocation);\n    ```", "```cpp\n    FTimerHandle Timer;\n    GetWorldTimerManager().SetTimer(Timer, this, &AUE4CookbookGameMode::DestroyActorFunction, 10);\n    ```", "```cpp\n    void AUE4CookbookGameMode::DestroyActorFunction()\n    {\n      if (SpawnedActor != nullptr)\n      {\n        SpawnedActor->Destroy();\n      }\n    }\n    ```", "```cpp\n    UPROPERTY()\n    AMyFirstActor* SpawnedActor;\n    UFUNCTION()\n    void DestroyActorFunction();\n    ```", "```cpp\n    SpawnedActor = GetWorld()->SpawnActor<AMyFirstActor> (AMyFirstActor::StaticClass(), SpawnLocation);\n    ```", "```cpp\n    FTimerHandle Timer;\n    GetWorldTimerManager().SetTimer(Timer, this, &AUE4CookbookGameMode::DestroyActorFunction, 10);\n    ```", "```cpp\n    void AUE4CookbookGameMode::DestroyActorFunction()\n    {\n      if (SpawnedActor != nullptr)\n    }\n    ```", "```cpp\n    SpawnedActor->Destroy();\n    ```", "```cpp\n    SetLifeSpan(10);\n    ```", "```cpp\n    UPROPERTY()\n    UStaticMeshComponent* Mesh;\n    ```", "```cpp\n    Mesh = CreateDefaultSubobject<UStaticMeshComponent>(\"BaseMeshComponent\");\n    ```", "```cpp\n    UCLASS()\n    class UE4COOKBOOK_API AMyFirstActor : public AActor\n    {\n      GENERATED_BODY()\n      public:\n      AMyFirstActor();\n\n      UPROPERTY() \n      UStaticMeshComponent* Mesh;\n    };\n\n    #include \"UE4Cookbook.h\"\n    #include \"MyFirstActor.h\"\n    AMyFirstActor::AMyFirstActor()\n    {\n      PrimaryActorTick.bCanEverTick = true;\n\n      Mesh = CreateDefaultSubobject<UStaticMeshComponent>(\"BaseMeshComponent\");\n    }\n    ```", "```cpp\n    UPROPERTY()\n    UStaticMeshComponent* Mesh;\n    ```", "```cpp\n    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n    if (MeshAsset.Object != nullptr)\n    {\n      Mesh->SetStaticMesh(MeshAsset.Object);\n    }\n    ```", "```cpp\n    ConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n    ```", "```cpp\n    AMyGameState(); \n\n    UFUNCTION()\n    void SetScore(int32 NewScore);\n\n    UFUNCTION()\n    int32 GetScore();\n    private:\n    UPROPERTY()\n    int32 CurrentScore;\n    ```", "```cpp\n    AMyGameState::AMyGameState()\n    {\n      CurrentScore = 0;\n    }\n\n    int32 AMyGameState::GetScore()\n    {\n      return CurrentScore;\n    }\n\n    void AMyGameState::SetScore(int32 NewScore)\n    {\n      CurrentScore = NewScore;\n    }\n    ```", "```cpp\n    MyGameState.h\n    #pragma once\n\n    #include \"GameFramework/GameState.h\"\n    #include \"MyGameState.generated.h\"\n\n    /**\n    *\n    */\n    UCLASS()\n    class UE4COOKBOOK_API AMyGameState : public AGameState\n    {\n      GENERATED_BODY()\n      public:\n      AMyGameState();\n\n      UPROPERTY()\n      int32 CurrentScore;\n\n      UFUNCTION()\n      int32 GetScore();\n\n      UFUNCTION()\n      void SetScore(uint32 NewScore);\n    };\n    MyGameState.cpp\n    #include \"UE4Cookbook.h\"\n    #include \"MyGameState.h\"\n\n    AMyGameState::AMyGameState()\n    {\n      CurrentScore = 0;\n    }\n\n    int32 AMyGameState::GetScore()\n    {\n      return CurrentScore;\n    }\n\n    void AMyGameState::SetScore(uint32 NewScore)\n    {\n      CurrentScore = NewScore;\n    }\n    ```", "```cpp\n    AMyGameState();\n    ```", "```cpp\n    AMyGameState::AMyGameState()\n    {\n      CurrentScore = 0;\n    }\n    ```", "```cpp\n    UPROPERTY()\n    int32 CurrentScore;\n    ```", "```cpp\n    UPROPERTY()\n    USceneComponent* Root;\n    UPROPERTY()\n    USceneComponent* ChildSceneComponent;\n    UPROPERTY()\n    UStaticMeshComponent* BoxOne;\n    UPROPERTY()\n    UStaticMeshComponent* BoxTwo;\n    ```", "```cpp\n    Root = CreateDefaultSubobject<USceneComponent>(\"Root\");\n    ChildSceneComponent = CreateDefaultSubobject<USceneComponent>(\"ChildSceneComponent\");\n    BoxOne = CreateDefaultSubobject<UStaticMeshComponent>(\"BoxOne\");\n    BoxTwo = CreateDefaultSubobject<UStaticMeshComponent>(\"BoxTwo\");\n\n    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n    if (MeshAsset.Object != nullptr)\n    {\n      BoxOne->SetStaticMesh(MeshAsset.Object);\n      BoxTwo->SetStaticMesh(MeshAsset.Object);\n    }\n    RootComponent = Root;\n    BoxOne->AttachTo(Root);\n    BoxTwo->AttachTo(ChildSceneComponent);\n    ChildSceneComponent->AttachTo(Root);\n    ChildSceneComponent->SetRelativeTransform(FTransform(FRotator(0, 0, 0), FVector(250, 0, 0), FVector(0.1f)));\n    ```", "```cpp\n    HierarchyActor.h\n    #pragma once\n\n    #include \"GameFramework/Actor.h\"\n    #include \"HierarchyActor.generated.h\"\n\n    UCLASS()\n    class UE4COOKBOOK_API AHierarchyActor : public AActor\n    {\n      GENERATED_BODY()\n      public:\n      AHierarchyActor();\n      virtual void BeginPlay() override;\n      virtual void Tick( float DeltaSeconds ) override;\n      UPROPERTY()\n      USceneComponent* Root;\n      UPROPERTY()\n      USceneComponent* ChildSceneComponent;\n      UPROPERTY()\n      UStaticMeshComponent* BoxOne;\n      UPROPERTY()\n      UStaticMeshComponent* BoxTwo;\n    };\n    HierarchyActor.cpp\n\n    #include \"UE4Cookbook.h\"\n    #include \"HierarchyActor.h\"\n\n    AHierarchyActor::AHierarchyActor()\n    {\n      PrimaryActorTick.bCanEverTick = true;\n      Root = CreateDefaultSubobject<USceneComponent>(\"Root\");\n      ChildSceneComponent = CreateDefaultSubobject<USceneComponent>(\"ChildSceneComponent\");\n      BoxOne = CreateDefaultSubobject<UStaticMeshComponent>(\"BoxOne\");\n      BoxTwo = CreateDefaultSubobject<UStaticMeshComponent>(\"BoxTwo\");\n      auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n      if (MeshAsset.Object != nullptr)\n      {\n        BoxOne->SetStaticMesh(MeshAsset.Object);\n        BoxOne->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n        BoxTwo->SetStaticMesh(MeshAsset.Object);\n        BoxTwo->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\t\n      }\n      RootComponent = Root;\n      BoxOne->AttachTo(Root);\n      BoxTwo->AttachTo(ChildSceneComponent);\n      ChildSceneComponent->AttachTo(Root);\n      ChildSceneComponent->SetRelativeTransform(FTransform(FRotator(0, 0, 0), FVector(250, 0, 0), FVector(0.1f)));\n    }\n    void AHierarchyActor::BeginPlay()\n    {\n      Super::BeginPlay();\n    }\n    void AHierarchyActor::Tick( float DeltaTime )\n    {\n      Super::Tick( DeltaTime );\n    }\n    ```", "```cpp\n    UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\n    ```", "```cpp\n    UPROPERTY()\n    float MovementRadius;\n    ```", "```cpp\n    MovementRadius = 0;\n    ```", "```cpp\n    AActor* Parent = GetOwner();\n    if (Parent)\n    {\n      Parent->SetActorLocation(\n      Parent->GetActorLocation() +\n      FVector(\n      FMath::FRandRange(-1, 1)* MovementRadius,\n      FMath::FRandRange(-1, 1)* MovementRadius,\n      FMath::FRandRange(-1, 1)* MovementRadius));\n    }\n    ```", "```cpp\n    #pragma once\n    #include \"Components/ActorComponent.h\"\n    #include \"RandomMovementComponent.generated.h\"\n    UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\n    class UE4COOKBOOK_API URandomMovementComponent : public UActorComponent\n    {\n      GENERATED_BODY()\n      public:\n      URandomMovementComponent();\n      virtual void BeginPlay() override;\n      virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;\n      UPROPERTY()\n      float MovementRadius;\n    };\n\n    #include \"UE4Cookbook.h\"\n    #include \"RandomMovementComponent.h\"\n    URandomMovementComponent::URandomMovementComponent()\n    {\n      bWantsBeginPlay = true;\n      PrimaryComponentTick.bCanEverTick = true;\n      MovementRadius = 5;\n    }\n\n    void URandomMovementComponent::BeginPlay()\n    {\n      Super::BeginPlay();\n    }\n\n    void URandomMovementComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )\n    {\n      Super::TickComponent( DeltaTime, TickType, ThisTickFunction );\n      AActor* Parent = GetOwner();\n      if (Parent)\n      {\n        Parent->SetActorLocation(\n        Parent->GetActorLocation() +\n        FVector(\n        FMath::FRandRange(-1, 1)* MovementRadius,\n        FMath::FRandRange(-1, 1)* MovementRadius,\n        FMath::FRandRange(-1, 1)* MovementRadius));\n      }\n    }\n    ```", "```cpp\n    UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\n    ```", "```cpp\n    UPROPERTY()\n    float MovementRadius;\n    ```", "```cpp\n    MovementRadius =5;\n    ```", "```cpp\n    AActor* Parent = GetOwner();\n    if (Parent)\n    {\n      Parent->SetActorLocation(\n      Parent->GetActorLocation() +\n      FVector(\n      FMath::FRandRange(-1, 1)* MovementRadius,\n      FMath::FRandRange(-1, 1)* MovementRadius,\n      FMath::FRandRange(-1, 1)* MovementRadius)\n      );\n    }\n    ```", "```cpp\n    UFUNCTION()\n    void Spawn();\n    UPROPERTY()\n    TSubclassOf<AActor> ActorToSpawn;\n    ```", "```cpp\n    void UActorSpawnerComponent::Spawn()\n    {\n      UWorld* TheWorld = GetWorld();\n      if (TheWorld != nullptr)\n      {\n        FTransform ComponentTransform(this->GetComponentTransform());\n        TheWorld->SpawnActor(ActorToSpawn,&ComponentTransform);\n      }\n    }\n    ```", "```cpp\n    ActorSpawnerComponent.h\n    #pragma once\n\n    #include \"Components/SceneComponent.h\"\n    #include \"ActorSpawnerComponent.generated.h\"\n\n    UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\n    class UE4COOKBOOK_API UActorSpawnerComponent : public USceneComponent\n    {\n      GENERATED_BODY()\n\n      public:\n      UActorSpawnerComponent();\n\n      virtual void BeginPlay() override;\n\n      virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;\n\n      UFUNCTION(BlueprintCallable, Category=Cookbook)\n      void Spawn();\n\n      UPROPERTY(EditAnywhere)\n      TSubclassOf<AActor> ActorToSpawn;\n\n    };\n    ActorSpawnerComponent.cpp\n    #include \"UE4Cookbook.h\"\n    #include \"ActorSpawnerComponent.h\"\n\n    UActorSpawnerComponent::UActorSpawnerComponent()\n    {\n      bWantsBeginPlay = true;\n      PrimaryComponentTick.bCanEverTick = true;\n    }\n\n    void UActorSpawnerComponent::BeginPlay()\n    {\n      Super::BeginPlay();\n    }\n\n    void UActorSpawnerComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )\n    {\n      Super::TickComponent( DeltaTime, TickType, ThisTickFunction );\n    }\n\n    void UActorSpawnerComponent::Spawn()\n    {\n      UWorld* TheWorld = GetWorld();\n      if (TheWorld != nullptr)\n      {\n        FTransform ComponentTransform(this->GetComponentTransform());\n        TheWorld->SpawnActor(ActorToSpawn,&ComponentTransform);\n      }\n    }\n    ```", "```cpp\n    UCLASS(ClassGroup=Experimental, meta = (BlueprintSpawnableComponent))\n    public:\n    virtual FPrimitiveSceneProxy* CreateSceneProxy() override;\n    TArray<int32> Indices;\n    TArray<FVector> Vertices;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Materials)\n    UMaterial* TheMaterial;\n    ```", "```cpp\n    FPrimitiveSceneProxy* UMyMeshComponent::CreateSceneProxy()\n    {\n      FPrimitiveSceneProxy* Proxy = NULL;\n      Proxy = new FMySceneProxy(this);\n      return Proxy;\n    }\n    ```", "```cpp\n    class FMySceneProxy : public FPrimitiveSceneProxy\n    {\n      public:\n      FMySceneProxy(UMyMeshComponent* Component)\n      :FPrimitiveSceneProxy(Component),\n      Indices(Component->Indices),\n      TheMaterial(Component->TheMaterial)\n      {\n        VertexBuffer = FMyVertexBuffer();\n        IndexBuffer = FMyIndexBuffer();\n        for (FVector Vertex : Component->Vertices)\n        {\n          Vertices.Add(FDynamicMeshVertex(Vertex));\n        }\n      };\n      UPROPERTY()\n      UMaterial* TheMaterial;\n      virtual FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View) \u00a0const override\n      {\n        FPrimitiveViewRelevance Result;\n        Result.bDynamicRelevance = true;\n        Result.bDrawRelevance = true;\n        Result.bNormalTranslucencyRelevance = true;\n        return Result;\n      }\n      virtual void GetDynamicMeshElements(const TArray<const FSceneView*>& Views, const FSceneViewFamily& ViewFamily, uint32 VisibilityMap, FMeshElementCollector& Collector) const override\n      {\n        for (int32 ViewIndex = 0; ViewIndex < Views.Num(); ViewIndex++)\n        {\n          FDynamicMeshBuilder MeshBuilder;\n          if (Vertices.Num() == 0)\n          {\n            return;\n          }\n          MeshBuilder.AddVertices(Vertices);\n          MeshBuilder.AddTriangles(Indices);\n          MeshBuilder.GetMesh(FMatrix::Identity, new FColoredMaterialRenderProxy(TheMaterial->GetRenderProxy(false), FLinearColor::Gray), GetDepthPriorityGroup(Views[ViewIndex]), true, true, ViewIndex, Collector);\n        }\n      }\n      uint32 FMySceneProxy::GetMemoryFootprint(void) const override\n      {\n        return sizeof(*this);\n      }\n      virtual ~FMySceneProxy() {};\n      private:\n      TArray<FDynamicMeshVertex> Vertices;\n      TArray<int32> Indices;\n      FMyVertexBuffer VertexBuffer;\n      FMyIndexBuffer IndexBuffer;\n    };\n    ```", "```cpp\n    class FMyVertexBuffer : public FVertexBuffer\n    {\n      public:\n      TArray<FVector> Vertices;\n      virtual void InitRHI() override\n      {\n        FRHIResourceCreateInfo CreateInfo;\n        VertexBufferRHI = RHICreateVertexBuffer(Vertices.Num() * sizeof(FVector), BUF_Static, CreateInfo);\n        void* VertexBufferData = RHILockVertexBuffer(VertexBufferRHI, 0, Vertices.Num() * sizeof(FVector), RLM_WriteOnly);\n        FMemory::Memcpy(VertexBufferData, Vertices.GetData(), Vertices.Num() * sizeof(FVector));\n        RHIUnlockVertexBuffer(VertexBufferRHI);\n      }\n    };\n    class FMyIndexBuffer : public FIndexBuffer\n    {\n      public:\n      TArray<int32> Indices;\n      virtual void InitRHI() override\n      {\n        FRHIResourceCreateInfo CreateInfo;\n        IndexBufferRHI = RHICreateIndexBuffer(sizeof(int32), Indices.Num() * sizeof(int32), BUF_Static, CreateInfo);\n        void* Buffer = RHILockIndexBuffer(IndexBufferRHI, 0, Indices.Num() * sizeof(int32), RLM_WriteOnly);\n        FMemory::Memcpy(Buffer, Indices.GetData(), Indices.Num() * sizeof(int32));\n        RHIUnlockIndexBuffer(IndexBufferRHI);\n      }\n    };\n    ```", "```cpp\n    UMyMeshComponent::UMyMeshComponent()\n    {\n      static ConstructorHelpers::FObjectFinder<UMaterial> Material(TEXT(\"Material'/Engine/BasicShapes/BasicShapeMaterial'\"));\n      if (Material.Object != NULL)\n      {\n        TheMaterial = (UMaterial*)Material.Object;\n      }\n      Vertices.Add(FVector(10, 0, 0));\n      Vertices.Add(FVector(0, 10, 0));\n      Vertices.Add(FVector(0, 0, 10));\n      Indices.Add(0);\n      Indices.Add(1);\n      Indices.Add(2);\n    }\n    ```", "```cpp\n    #pragma once\n\n    #include \"Components/MeshComponent.h\"\n    #include \"MyMeshComponent.generated.h\"\n\n    UCLASS(ClassGroup = Experimental, meta = (BlueprintSpawnableComponent))\n    class UE4COOKBOOK_API UMyMeshComponent : public UMeshComponent\n    {\n      GENERATED_BODY()\n      public:\n      virtual FPrimitiveSceneProxy* CreateSceneProxy() override;\n      TArray<int32> Indices;\n      TArray<FVector> Vertices;\n\n      UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Materials)\n      UMaterial* TheMaterial;\n      UMyMeshComponent();\n    };\n\n    #include \"UE4Cookbook.h\"\n    #include \"MyMeshComponent.h\"\n    #include <VertexFactory.h>\n    #include \"DynamicMeshBuilder.h\"\n\n    class FMyVertexBuffer : public FVertexBuffer\n    {\n      public:\n      TArray<FVector> Vertices;\n\n      virtual void InitRHI() override\n      {\n        FRHIResourceCreateInfo CreateInfo;\n        VertexBufferRHI = RHICreateVertexBuffer(Vertices.Num() * sizeof(FVector), BUF_Static, CreateInfo);\n\n        void* VertexBufferData = RHILockVertexBuffer(VertexBufferRHI, 0, Vertices.Num() * sizeof(FVector), RLM_WriteOnly);\n        FMemory::Memcpy(VertexBufferData, Vertices.GetData(), Vertices.Num() * sizeof(FVector));\n        RHIUnlockVertexBuffer(VertexBufferRHI);\n      }\n    };\n\n    class FMyIndexBuffer : public FIndexBuffer\n    {\n      public:\n      TArray<int32> Indices;\n\n      virtual void InitRHI() override\n      {\n        FRHIResourceCreateInfo CreateInfo;\n        IndexBufferRHI = RHICreateIndexBuffer(sizeof(int32), Indices.Num() * sizeof(int32), BUF_Static, CreateInfo);\n\n        void* Buffer = RHILockIndexBuffer(IndexBufferRHI, 0, Indices.Num() * sizeof(int32), RLM_WriteOnly);\n        FMemory::Memcpy(Buffer, Indices.GetData(), Indices.Num() * sizeof(int32));\n        RHIUnlockIndexBuffer(IndexBufferRHI);\n      }\n    };\n    class FMySceneProxy : public FPrimitiveSceneProxy\n    {\n      public:\n      FMySceneProxy(UMyMeshComponent* Component)\n      :FPrimitiveSceneProxy(Component),\n      Indices(Component->Indices),\n      TheMaterial(Component->TheMaterial)\n      {\n        VertexBuffer = FMyVertexBuffer();\n        IndexBuffer = FMyIndexBuffer();\n\n        for (FVector Vertex : Component->Vertices)\n        {\n          Vertices.Add(FDynamicMeshVertex(Component->GetComponentLocation() + Vertex));\n        }\n      };\n\n    UPROPERTY()\n      UMaterial* TheMaterial;\n\n      virtual FPrimitiveViewRelevance GetViewRelevance(const FSceneView* View)  const override\n      {\n        FPrimitiveViewRelevance Result;\n        Result.bDynamicRelevance = true;\n        Result.bDrawRelevance = true;\n        Result.bNormalTranslucencyRelevance = true;\n        return Result;\n      }\n\n      virtual void GetDynamicMeshElements(const TArray<const FSceneView*>& Views, const FSceneViewFamily& ViewFamily, uint32 VisibilityMap, FMeshElementCollector& Collector) const override\n      {\n        for (int32 ViewIndex = 0; ViewIndex < Views.Num(); ViewIndex++)\n        {\n          FDynamicMeshBuilder MeshBuilder;\n          if (Vertices.Num() == 0)\n          {\n            return;\n          }\n          MeshBuilder.AddVertices(Vertices);\n          MeshBuilder.AddTriangles(Indices);\n\n          MeshBuilder.GetMesh(FMatrix::Identity, new FColoredMaterialRenderProxy(TheMaterial->GetRenderProxy(false), FLinearColor::Gray), GetDepthPriorityGroup(Views[ViewIndex]), true, true, ViewIndex, Collector);\n\n        }\n      }\n\n      void FMySceneProxy::OnActorPositionChanged() override\n      {\n        VertexBuffer.ReleaseResource();\n        IndexBuffer.ReleaseResource();\n      }\n\n      uint32 FMySceneProxy::GetMemoryFootprint(void) const override\n      {\n        return sizeof(*this);\n      }\n      virtual ~FMySceneProxy() {};\n      private:\n      TArray<FDynamicMeshVertex> Vertices;\n      TArray<int32> Indices;\n      FMyVertexBuffer VertexBuffer;\n      FMyIndexBuffer IndexBuffer;\n    };\n\n    FPrimitiveSceneProxy* UMyMeshComponent::CreateSceneProxy()\n    {\n      FPrimitiveSceneProxy* Proxy = NULL;\n      Proxy = new FMySceneProxy(this);\n      return Proxy;\n    }\n\n    UMyMeshComponent::UMyMeshComponent()\n    {\n      static ConstructorHelpers::FObjectFinder<UMaterial> Material(TEXT(\"Material'/Engine/BasicShapes/BasicShapeMaterial'\"));\n\n      if (Material.Object != NULL)\n      {\n        TheMaterial = (UMaterial*)Material.Object;\n      }\n      Vertices.Add(FVector(10, 0, 0));\n      Vertices.Add(FVector(0, 10, 0));\n      Vertices.Add(FVector(0, 0, 10));\n      Indices.Add(0);\n      Indices.Add(1);\n      Indices.Add(2);\n    }\n    ```", "```cpp\n    UPROPERTY()\n    TArray<AInventoryActor*> CurrentInventory;\n    UFUNCTION()\n    int32 AddToInventory(AInventoryActor* ActorToAdd);\n\n    UFUNCTION()\n    void RemoveFromInventory(AInventoryActor* ActorToRemove);\n    ```", "```cpp\n    int32 UInventoryComponent::AddToInventory(AInventoryActor* ActorToAdd)\n    {\n      return CurrentInventory.Add(ActorToAdd);\n    }\n\n    void UInventoryComponent::RemoveFromInventory(AInventoryActor* ActorToRemove)\n    {\n      CurrentInventory.Remove(ActorToRemove);\n    }\n    ```", "```cpp\n    virtual void PickUp();\n    virtual void PutDown(FTransform TargetLocation);\n    ```", "```cpp\n    void AInventoryActor::PickUp()\n    {\n      SetActorTickEnabled(false);\n      SetActorHiddenInGame(true);\n      SetActorEnableCollision(false);\n    }\n\n    void AInventoryActor::PutDown(FTransform TargetLocation)\n    {\n      SetActorTickEnabled(true);\n      SetActorHiddenInGame(false);\n      SetActorEnableCollision(true);\n      SetActorLocation(TargetLocation.GetLocation());\n    }\n    ```", "```cpp\n    AInventoryActor::AInventoryActor()\n    :Super()\n    {\n      PrimaryActorTick.bCanEverTick = true;\n      auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n      if (MeshAsset.Object != nullptr)\n      {\n        GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);\n        GetStaticMeshComponent()->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n      }\n      GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);\n      SetActorEnableCollision(true);\n    }\n    ```", "```cpp\n    UPROPERTY()\n    UInventoryComponent* MyInventory;\n\n    UFUNCTION()\n    virtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n\n    UFUNCTION()\n    void DropItem();\n    UFUNCTION()\n    void TakeItem(AInventoryActor* InventoryItem);\n\n    UFUNCTION()\n    virtual void NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit) override;\n    ```", "```cpp\n    MyInventory = CreateDefaultSubobject<UInventoryComponent>(\"MyInventory\");\n    ```", "```cpp\n    void AInventoryCharacter::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n    {\n      Super::SetupPlayerInputComponent(InputComponent);\n      InputComponent->BindAction(\"DropItem\", EInputEvent::IE_Pressed, this, &AInventoryCharacter::DropItem);\n    }\n    ```", "```cpp\n    void AInventoryCharacter::DropItem()\n    {\n      if (MyInventory->CurrentInventory.Num() == 0)\n      {\n        return;\n      }\n\n      AInventoryActor* Item = MyInventory->CurrentInventory.Last();\n      MyInventory->RemoveFromInventory(Item);\n      FVector ItemOrigin;\n      FVector ItemBounds;\n      Item->GetActorBounds(false, ItemOrigin, ItemBounds);\n      FTransform PutDownLocation = GetTransform() + FTransform(RootComponent->GetForwardVector() * ItemBounds.GetMax());\n      Item->PutDown(PutDownLocation);\n    }\n\n    void AInventoryCharacter::NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit)\n    {\n      AInventoryActor* InventoryItem = Cast<AInventoryActor>(Other);\n      if (InventoryItem != nullptr)\n      {\n        TakeItem(InventoryItem);\n      }\n    }\n\n    void AInventoryCharacter::TakeItem(AInventoryActor* InventoryItem)\n    {\n      InventoryItem->PickUp();\n      MyInventory->AddToInventory(InventoryItem);\n    }\n    ```", "```cpp\n    DefaultPawnClass = AInventoryCharacter::StaticClass();\n    ```", "```cpp\n    #pragma once\n\n    #include \"GameFramework/Character.h\"\n    #include \"InventoryComponent.h\"\n    #include \"InventoryCharacter.generated.h\"\n\n    UCLASS()\n    class UE4COOKBOOK_API AInventoryCharacter : public ACharacter\n    {\n      GENERATED_BODY()\n\n      public:\n      AInventoryCharacter();\n      virtual void BeginPlay() override;\n      virtual void Tick( float DeltaSeconds ) override;\n      virtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n\n      UPROPERTY()\n      UInventoryComponent* MyInventory;\n      UPROPERTY()\n      UCameraComponent* MainCamera;\n      UFUNCTION()\n      void TakeItem(AInventoryActor* InventoryItem);\n      UFUNCTION()\n      void DropItem();\n      void MoveForward(float AxisValue);\n      void MoveRight(float AxisValue);\n      void PitchCamera(float AxisValue);\n      void YawCamera(float AxisValue);\n\n      UFUNCTION()\n      virtual void NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit) override;\n      private:\n      FVector MovementInput;\n      FVector CameraInput;\n    };\n\n    #include \"UE4Cookbook.h\"\n    #include \"InventoryCharacter.h\"\n\n    AInventoryCharacter::AInventoryCharacter()\n    :Super()\n    {\n      PrimaryActorTick.bCanEverTick = true;\n      MyInventory = CreateDefaultSubobject<UInventoryComponent>(\"MyInventory\");\n      MainCamera = CreateDefaultSubobject<UCameraComponent>(\"MainCamera\");\n      MainCamera->bUsePawnControlRotation = 0;\n    }\n\n    void AInventoryCharacter::BeginPlay()\n    {\n      Super::BeginPlay();\n      MainCamera->AttachTo(RootComponent);\n    }\n\n    void AInventoryCharacter::Tick( float DeltaTime )\n    {\n      Super::Tick( DeltaTime );\n      if (!MovementInput.IsZero())\n      {\n        MovementInput *= 100;\n        FVector InputVector = FVector(0,0,0);\n        InputVector += GetActorForwardVector()* MovementInput.X * DeltaTime;\n        InputVector += GetActorRightVector()* MovementInput.Y * DeltaTime;\n        GetCharacterMovement()->AddInputVector(InputVector);\n        GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, FString::Printf(TEXT(\"x- %f, y - %f, z - %f\"),InputVector.X, InputVector.Y, InputVector.Z));\n      }\n\n      if (!CameraInput.IsNearlyZero())\n      {\n        FRotator NewRotation = GetActorRotation();\n        NewRotation.Pitch += CameraInput.Y;\n        NewRotation.Yaw += CameraInput.X;\n        APlayerController* MyPlayerController =Cast<APlayerController>(GetController());\n        if (MyPlayerController != nullptr)\n        {\n          MyPlayerController->AddYawInput(CameraInput.X);\n          MyPlayerController->AddPitchInput(CameraInput.Y);\n        }\n        SetActorRotation(NewRotation);\n      }\n    }\n    void AInventoryCharacter::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n    {\n      Super::SetupPlayerInputComponent(InputComponent);\n      InputComponent->BindAxis(\"MoveForward\", this, &AInventoryCharacter::MoveForward);\n      InputComponent->BindAxis(\"MoveRight\", this, &AInventoryCharacter::MoveRight);\n      InputComponent->BindAxis(\"CameraPitch\", this, &AInventoryCharacter::PitchCamera);\n      InputComponent->BindAxis(\"CameraYaw\", this, &AInventoryCharacter::YawCamera);\n      InputComponent->BindAction(\"DropItem\", EInputEvent::IE_Pressed, this, &AInventoryCharacter::DropItem);\n    }\n    void AInventoryCharacter::DropItem()\n    {\n      if (MyInventory->CurrentInventory.Num() == 0)\n      {\n        return;\n      }\n      AInventoryActor* Item = MyInventory->CurrentInventory.Last();\n      MyInventory->RemoveFromInventory(Item);\n      FVector ItemOrigin;\n      FVector ItemBounds;\n      Item->GetActorBounds(false, ItemOrigin, ItemBounds);\n      FTransform PutDownLocation = GetTransform() + FTransform(RootComponent->GetForwardVector() * ItemBounds.GetMax());\n      Item->PutDown(PutDownLocation);\n    }\n\n    void AInventoryCharacter::MoveForward(float AxisValue)\n    {\n      MovementInput.X = FMath::Clamp<float>(AxisValue, -1.0f, 1.0f);\n    }\n\n    void AInventoryCharacter::MoveRight(float AxisValue)\n    {\n      MovementInput.Y = FMath::Clamp<float>(AxisValue, -1.0f, 1.0f);\n    }\n\n    void AInventoryCharacter::PitchCamera(float AxisValue)\n    {\n      CameraInput.Y = AxisValue;\n    }\n    void AInventoryCharacter::YawCamera(float AxisValue)\n    {\n      CameraInput.X = AxisValue;\n    }\n    void AInventoryCharacter::NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& Hit)\n    {\n      AInventoryActor* InventoryItem = Cast<AInventoryActor>(Other);\n      if (InventoryItem != nullptr)\n      {\n        TakeItem(InventoryItem);\n      }\n    }\n    void AInventoryCharacter::TakeItem(AInventoryActor* InventoryItem)\n    {\n      InventoryItem->PickUp();\n      MyInventory->AddToInventory(InventoryItem);\n    }\n\n    #pragma once\n\n    #include \"Components/ActorComponent.h\"\n    #include \"InventoryActor.h\"\n    #include \"InventoryComponent.generated.h\"\n\n    UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent))\n    class UE4COOKBOOK_API UInventoryComponent : public UActorComponent\n    {\n      GENERATED_BODY()\n\n      public:\n      UInventoryComponent();\n      virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;\n\n      UPROPERTY()\n      TArray<AInventoryActor*> CurrentInventory;\n      UFUNCTION()\n      int32 AddToInventory(AInventoryActor* ActorToAdd);\n\n      UFUNCTION()\n      void RemoveFromInventory(AInventoryActor* ActorToRemove);\n    };\n    #include \"UE4Cookbook.h\"\n    #include \"InventoryComponent.h\"\n\n    UInventoryComponent::UInventoryComponent()\n    {\n      bWantsBeginPlay = true;\n      PrimaryComponentTick.bCanEverTick = true;\n    }\n    void UInventoryComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )\n    {\n      Super::TickComponent( DeltaTime, TickType, ThisTickFunction );\n    }\n\n    int32 UInventoryComponent::AddToInventory(AInventoryActor* ActorToAdd)\n    {\n      return CurrentInventory.Add(ActorToAdd);\n    }\n\n    void UInventoryComponent::RemoveFromInventory(AInventoryActor* ActorToRemove)\n    {\n      CurrentInventory.Remove(ActorToRemove);\n    }\n\n    #pragma once\n\n    #include \"GameFramework/GameMode.h\"\n    #include \"UE4CookbookGameMode.generated.h\"\n\n    UCLASS()\n    class UE4COOKBOOK_API AUE4CookbookGameMode : public AGameMode\n    {\n      GENERATED_BODY()\n\n      public:\n      AUE4CookbookGameMode();\n      };\n\n    #include \"UE4Cookbook.h\"\n    #include \"MyGameState.h\"\n    #include \"InventoryCharacter.h\"\n    #include \"UE4CookbookGameMode.h\"\n\n    AUE4CookbookGameMode::AUE4CookbookGameMode()\n    {\n      DefaultPawnClass = AInventoryCharacter::StaticClass();\n      GameStateClass = AMyGameState::StaticClass();\n    }\n    ```", "```cpp\n    UPROPERTY()\n    bool RotateToFaceOutwards;\n    UPROPERTY()\n    float RotationSpeed;\n    UPROPERTY()\n    float OrbitDistance;\n    float CurrentValue;\n    ```", "```cpp\n    RotationSpeed = 5;\n    OrbitDistance = 100;\n    CurrentValue = 0;\n    RotateToFaceOutwards = true;\n    ```", "```cpp\n    float CurrentValueInRadians = FMath::DegreesToRadians<float>(CurrentValue);\n    SetRelativeLocation(FVector(OrbitDistance * FMath::Cos(CurrentValueInRadians), OrbitDistance * FMath::Sin(CurrentValueInRadians), RelativeLocation.Z));\n    if (RotateToFaceOutwards)\n    {\n      FVector LookDir = (RelativeLocation).GetSafeNormal();\n      FRotator LookAtRot = LookDir.Rotation();\n      SetRelativeRotation(LookAtRot);\n    }\n    CurrentValue = FMath::Fmod(CurrentValue + (RotationSpeed* DeltaTime) ,360);\n    ```", "```cpp\n    #pragma once\n    #include \"Components/SceneComponent.h\"\n    #include \"OrbitingMovementComponent.generated.h\"\n\n    UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )\n    class UE4COOKBOOK_API UOrbitingMovementComponent : public USceneComponent\n    {\n      GENERATED_BODY()\n      public:\n      // Sets default values for this component's properties\n      UOrbitingMovementComponent();\n\n      // Called when the game starts\n      virtual void BeginPlay() override;\n      // Called every frame\n      virtual void TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction ) override;\n\n      UPROPERTY()\n      bool RotateToFaceOutwards;\n      UPROPERTY()\n      float RotationSpeed;\n      UPROPERTY()\n      float OrbitDistance;\n      float CurrentValue;\n    };\n    #include \"UE4Cookbook.h\"\n    #include \"OrbitingMovementComponent.h\"\n    // Sets default values for this component's properties\n    UOrbitingMovementComponent::UOrbitingMovementComponent()\n    {\n      // Set this component to be initialized when the game starts, and to be ticked every frame. You can turn these features\n      // off to improve performance if you don't need them.\n      bWantsBeginPlay = true;\n      PrimaryComponentTick.bCanEverTick = true;\n      RotationSpeed = 5;\n      OrbitDistance = 100;\n      CurrentValue = 0;\n      RotateToFaceOutwards = true;\n      //...\n    }\n\n    // Called when the game starts\n    void UOrbitingMovementComponent::BeginPlay()\n    {\n      Super::BeginPlay();\n      //...\n    }\n    // Called every frame\n    void UOrbitingMovementComponent::TickComponent( float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction )\n    {\n      Super::TickComponent( DeltaTime, TickType, ThisTickFunction );\n      float CurrentValueInRadians = FMath::DegreesToRadians<float>(CurrentValue);\n      SetRelativeLocation(\n      FVector(OrbitDistance * FMath::Cos(CurrentValueInRadians),\n      OrbitDistance * FMath::Sin(CurrentValueInRadians),\n      RelativeLocation.Z));\n      if (RotateToFaceOutwards)\n      {\n        FVector LookDir = (RelativeLocation).GetSafeNormal();\n        FRotator LookAtRot = LookDir.Rotation();\n        SetRelativeRotation(LookAtRot);\n      }\n      CurrentValue = FMath::Fmod(CurrentValue + (RotationSpeed* DeltaTime) ,360);\n      //...\n    }\n    ```", "```cpp\n    UPROPERTY()\n    UStaticMeshComponent* BuildingMesh;\n    UPROPERTY()\n    UParticleSystemComponent* SpawnPoint;\n\n    UPROPERTY()\n    UClass* UnitToSpawn;\n\n    UPROPERTY()\n    float SpawnInterval;\n\n    UFUNCTION()\n    void SpawnUnit();\n\n    UFUNCTION()\n    void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\n    UPROPERTY()\n    FTimerHandle SpawnTimerHandle;\n    ```", "```cpp\n    BuildingMesh = CreateDefaultSubobject<UStaticMeshComponent>(\"BuildingMesh\");\n    SpawnPoint = CreateDefaultSubobject<UParticleSystemComponent>(\"SpawnPoint\");\n    SpawnInterval = 10;\n    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n    if (MeshAsset.Object != nullptr)\n    {\n      BuildingMesh->SetStaticMesh(MeshAsset.Object);\n      BuildingMesh->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n\n    }\n    auto ParticleSystem =\n    ConstructorHelpers::FObjectFinder<UParticleSystem>(TEXT(\"ParticleSystem'/Engine/Tutorial/SubEditors/TutorialAssets/TutorialParticleSystem.TutorialParticleSystem'\"));\n    if (ParticleSystem.Object != nullptr)\n    {\n      SpawnPoint->SetTemplate(ParticleSystem.Object);\n    }\n    SpawnPoint->SetRelativeScale3D(FVector(0.5, 0.5, 0.5));\n    UnitToSpawn = ABarracksUnit::StaticClass();\n    ```", "```cpp\n    RootComponent = BuildingMesh;\n    SpawnPoint->AttachTo(RootComponent);\n    SpawnPoint->SetRelativeLocation(FVector(150, 0, 0));\n    GetWorld()->GetTimerManager().SetTimer(SpawnTimerHandle, this, &ABarracks::SpawnUnit, SpawnInterval, true);\n    ```", "```cpp\n    void ABarracks::SpawnUnit()\n    {\n      FVector SpawnLocation = SpawnPoint->GetComponentLocation();\n      GetWorld()->SpawnActor(UnitToSpawn, &SpawnLocation);\n    }\n    ```", "```cpp\n    void ABarracks::EndPlay(const EEndPlayReason::Type EndPlayReason)\n    {\n      Super::EndPlay(EndPlayReason);\n      GetWorld()->GetTimerManager().ClearTimer(SpawnTimerHandle);\n    }\n    ```", "```cpp\n    UPROPERTY()\n    UParticleSystemComponent* VisualRepresentation;\n    ```", "```cpp\n    VisualRepresentation = CreateDefaultSubobject<UParticleSystemComponent>(\"SpawnPoint\");\n    auto ParticleSystem =ConstructorHelpers::FObjectFinder<UParticleSystem>(TEXT(\"ParticleSystem'/Engine/Tutorial/SubEditors/TutorialAssets/TutorialParticleSystem.TutorialParticleSystem'\"));\n    if (ParticleSystem.Object != nullptr)\n    {\n      SpawnPoint->SetTemplate(ParticleSystem.Object);\n    }\n    SpawnPoint->SetRelativeScale3D(FVector(0.5, 0.5, 0.5));\n    SpawnCollisionHandlingMethod = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n    ```", "```cpp\n    void ABarracksUnit::BeginPlay()\n    {\n      Super::BeginPlay();\n      SpawnPoint->AttachTo(RootComponent);\n    }\n    ```", "```cpp\n    SetActorLocation(GetActorLocation() + FVector(10, 0, 0));\n    ```", "```cpp\n    #pragma once\n    #include \"GameFramework/Actor.h\"\n    #include \"Barracks.generated.h\"\n    UCLASS()\n    class UE4COOKBOOK_API ABarracks : public AActor\n    {\n      GENERATED_BODY()\n      public:\n      ABarracks();\n      virtual void BeginPlay() override;\n      virtual void Tick( float DeltaSeconds ) override;\n\n      UPROPERTY()\n      UStaticMeshComponent* BuildingMesh;\n      UPROPERTY()\n      UParticleSystemComponent* SpawnPoint;\n\n      UPROPERTY()\n      UClass* UnitToSpawn;\n\n      UPROPERTY()\n      float SpawnInterval;\n\n      UFUNCTION()\n      void SpawnUnit();\n      UFUNCTION()\n      void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\n      UPROPERTY()\n      FTimerHandle SpawnTimerHandle;\n    };\n\n    #include \"UE4Cookbook.h\"\n    #include \"BarracksUnit.h\"\n    #include \"Barracks.h\"\n\n    // Sets default values\n    ABarracks::ABarracks()\n    {\n      // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n      PrimaryActorTick.bCanEverTick = true;\n      BuildingMesh = CreateDefaultSubobject<UStaticMeshComponent>(\"BuildingMesh\");\n      SpawnPoint = CreateDefaultSubobject<UParticleSystemComponent>(\"SpawnPoint\");\n      SpawnInterval = 10;\n      auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n      if (MeshAsset.Object != nullptr)\n      {\n        BuildingMesh->SetStaticMesh(MeshAsset.Object);\n        BuildingMesh->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n\n      }\n      auto ParticleSystem = ConstructorHelpers::FObjectFinder<UParticleSystem>(TEXT(\"ParticleSystem'/Engine/Tutorial/SubEditors/TutorialAssets/TutorialParticleSystem.TutorialParticleSystem'\"));\n      if (ParticleSystem.Object != nullptr)\n      {\n        SpawnPoint->SetTemplate(ParticleSystem.Object);\n      }\n      SpawnPoint->SetRelativeScale3D(FVector(0.5, 0.5, 0.5));\n      UnitToSpawn = ABarracksUnit::StaticClass();\n    }\n    void ABarracks::BeginPlay()\n    {\n      Super::BeginPlay();\n      RootComponent = BuildingMesh;\n      SpawnPoint->AttachTo(RootComponent);\n      SpawnPoint->SetRelativeLocation(FVector(150, 0, 0));\n      GetWorld()->GetTimerManager().SetTimer(SpawnTimerHandle, this, &ABarracks::SpawnUnit, SpawnInterval, true);\n    }\n\n    void ABarracks::Tick( float DeltaTime )\n    {\n      Super::Tick( DeltaTime );\n    }\n    void ABarracks::SpawnUnit()\n    {\n      FVector SpawnLocation = SpawnPoint->GetComponentLocation();\n      GetWorld()->SpawnActor(UnitToSpawn, &SpawnLocation);\n    }\n\n    void ABarracks::EndPlay(const EEndPlayReason::Type EndPlayReason)\n    {\n      Super::EndPlay(EndPlayReason);\n      GetWorld()->GetTimerManager().ClearTimer(SpawnTimerHandle);\n    }\n\n    #pragma once\n\n    #include \"GameFramework/Character.h\"\n    #include \"BarracksUnit.generated.h\"\n\n    UCLASS()\n    class UE4COOKBOOK_API ABarracksUnit : public ACharacter\n    {\n      GENERATED_BODY()\n\n      public:\n      ABarracksUnit();\n\n      virtual void BeginPlay() override;\n      virtual void Tick( float DeltaSeconds ) override;\n\n      virtual void SetupPlayerInputComponent(class UInputComponent* InputComponent) override;\n\n      UPROPERTY()\n      UParticleSystemComponent* SpawnPoint;\n    };\n\n    #include \"UE4Cookbook.h\"\n    #include \"BarracksUnit.h\"\n\n    ABarracksUnit::ABarracksUnit()\n    {\n      PrimaryActorTick.bCanEverTick = true;\n      SpawnPoint = CreateDefaultSubobject<UParticleSystemComponent>(\"SpawnPoint\");\n      auto ParticleSystem =ConstructorHelpers::FObjectFinder<UParticleSystem>(TEXT(\"ParticleSystem'/Engine/Tutorial/SubEditors/TutorialAssets/TutorialParticleSystem.TutorialParticleSystem'\"));\n      if (ParticleSystem.Object != nullptr)\n      {\n        SpawnPoint->SetTemplate(ParticleSystem.Object);\n      }\n      SpawnPoint->SetRelativeScale3D(FVector(0.5, 0.5, 0.5));\n      SpawnCollisionHandlingMethod = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;\n    }\n    void ABarracksUnit::BeginPlay()\n    {\n      Super::BeginPlay();\n      SpawnPoint->AttachTo(RootComponent);\n    }\n\n    void ABarracksUnit::Tick( float DeltaTime )\n    {\n      Super::Tick( DeltaTime );\n      SetActorLocation(GetActorLocation() + FVector(10, 0, 0));\n    }\n    void ABarracksUnit::SetupPlayerInputComponent(class UInputComponent* InputComponent)\n    {\n      Super::SetupPlayerInputComponent(InputComponent);\n    }\n    ```"]