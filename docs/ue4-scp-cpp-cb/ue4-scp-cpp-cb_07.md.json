["```cpp\n    #include \"MyInterface.generated.h\"\n    /**  */\n    UINTERFACE()\n    class UE4COOKBOOK_API UMyInterface: public UInterface\n    {\n      GENERATED_BODY()\n    };\n\n    /**  */\n    class UE4COOKBOOK_API IMyInterface\n    {\n      GENERATED_BODY()\n\n      public:\n      virtualFStringGetTestName();\n    };\n    ```", "```cpp\n    #include \"UE4Cookbook.h\"\n    #include \"MyInterface.h\"\n\n    FString IMyInterface::GetTestName()\n    {\n      unimplemented();\n      return FString();\n    }\n    ```", "```cpp\n    class UE4COOKBOOK_API ASingleInterfaceActor : public AActor, public IMyInterface\n    ```", "```cpp\n    FStringGetTestName() override;\n    ```", "```cpp\n    FStringASingleInterfaceActor::GetTestName()\n    {\n      return IMyInterface::GetTestName();\n    }\n    ```", "```cpp\n    FTransformSpawnLocation;\n    ASingleInterfaceActor* SpawnedActor = GetWorld()->SpawnActor<ASingleInterfaceActor> (ASingleInterfaceActor::StaticClass(), SpawnLocation);\n    if (SpawnedActor->GetClass()->ImplementsInterface(UMyInterface::StaticClass()))\n    {\n      GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, TEXT(\"Spawned actor implements interface!\"));\n    }\n    ```", "```cpp\n    UPROPERTY()\n    TArray<IMyInterface*>MyInterfaceInstances;\n    ```", "```cpp\n    for (TActorIterator<AActor> It(GetWorld(), AActor::StaticClass()); It; ++It)\n    {\n      AActor* Actor = *It;\n      IMyInterface* MyInterfaceInstance = Cast<IMyInterface>(Actor);\n      if (MyInterfaceInstance)\n      {\n        MyInterfaceInstances.Add(MyInterfaceInstance);\n      }\n    }\n    GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, FString::Printf(TEXT(\"%d actors implement the interface\"), MyInterfaceInstances.Num()));\n    ```", "```cpp\n    explicitTActorIterator( UWorld* InWorld, TSubclassOf<ActorType>InClass = ActorType::StaticClass() )\n    : Super(InWorld, InClass )\n    ```", "```cpp\n    for (iterator-constructor;iterator;++iterator)\n    ```", "```cpp\n    UPROPERTY()\n    UBoxComponent* CollisionComponent;\n    ```", "```cpp\n    virtual void NotifyActorBeginOverlap(AActor* OtherActor) override;\n    virtual void NotifyActorEndOverlap(AActor* OtherActor) override;\n    ```", "```cpp\n    voidAAntiGravityVolume::NotifyActorBeginOverlap(AActor* OtherActor)\n    {\n      IGravityObject* GravityObject = Cast<IGravityObject>(OtherActor);\n      if (GravityObject != nullptr)\n      {\n        GravityObject->DisableGravity();\n      }\n    }\n\n    voidAAntiGravityVolume::NotifyActorEndOverlap(AActor* OtherActor)\n    {\n      IGravityObject* GravityObject = Cast<IGravityObject>(OtherActor);\n      if (GravityObject != nullptr)\n      {\n        GravityObject->EnableGravity();\n      }\n    }\n    ```", "```cpp\n    AAntiGravityVolume::AAntiGravityVolume()\n    {\n      PrimaryActorTick.bCanEverTick = true;\n      CollisionComponent = CreateDefaultSubobject<UBoxComponent>(\"CollisionComponent\");\n      CollisionComponent->SetBoxExtent(FVector(200, 200, 400));\n      RootComponent = CollisionComponent;\n\n    }\n    ```", "```cpp\n    virtual void EnableGravity();\n    virtual void DisableGravity();\n    ```", "```cpp\n    voidIGravityObject::EnableGravity()\n    {\n      AActor* ThisAsActor = Cast<AActor>(this);\n      if (ThisAsActor != nullptr)\n      {\n        TArray<UPrimitiveComponent*>PrimitiveComponents;\n        ThisAsActor->GetComponents(PrimitiveComponents);\n        for (UPrimitiveComponent* Component : PrimitiveComponents)\n        {\n          Component->SetEnableGravity(true);\n        }\n      }\n    }\n\n    voidIGravityObject::DisableGravity()\n    {\n      AActor* ThisAsActor = Cast<AActor>(this);\n      if (ThisAsActor != nullptr)\n      {\n        TArray<UPrimitiveComponent*>PrimitiveComponents;\n        ThisAsActor->GetComponents(PrimitiveComponents);\n        for (UPrimitiveComponent* Component : PrimitiveComponents)\n        {\n          Component->SetEnableGravity(false);\n        }\n      }\n    }\n    ```", "```cpp\n    UPROPERTY()\n    UStaticMeshComponent* MyMesh;\n    ```", "```cpp\n    MyMesh = CreateDefaultSubobject<UStaticMeshComponent>(\"MyMesh\");\n    autoMeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n    if (MeshAsset.Object != nullptr)\n    {\n      MyMesh->SetStaticMesh(MeshAsset.Object);\n    }\n    MyMesh->SetMobility(EComponentMobility::Movable);\n    MyMesh->SetSimulatePhysics(true);\n    SetActorEnableCollision(true);\n    ```", "```cpp\n    class UE4COOKBOOK_API APhysicsCube : public AActor, public IGravityObject\n    ```", "```cpp\n    template<class T, class AllocatorType>\n    voidGetComponents(TArray<T*, AllocatorType>&OutComponents) const\n    ```", "```cpp\n    UFUNCTION(BlueprintCallable, Category=Killable)\n    virtual bool IsDead();\n    UFUNCTION(BlueprintCallable, Category = Killable)\n    virtual void Die();\n    ```", "```cpp\n    boolIKillable::IsDead()\n    {\n      return false;\n    }\n\n    voidIKillable::Die()\n    {\n      GEngine->AddOnScreenDebugMessage(-1,1, FColor::Red,\"Arrrgh\");\n      AActor* Me = Cast<AActor>(this);\n      if (Me)\n      {\n        Me->Destroy();\n      }\n\n    }\n    ```", "```cpp\n    UINTERFACE()\n    class UE4COOKBOOK_API UUndead: public UKillable\n    {\n      GENERATED_BODY()\n    };\n\n    /**  */\n    class UE4COOKBOOK_API IUndead: public IKillable\n    {\n      GENERATED_BODY()\n\n    };\n    ```", "```cpp\n    virtual bool IsDead() override;\n    virtual void Die() override;\n    virtual void Turn();\n    virtual void Banish();\n    ```", "```cpp\n    boolIUndead::IsDead()\n    {\n      return true;\n    }\n\n    voidIUndead::Die()\n    {\n      GEngine->AddOnScreenDebugMessage(-1,1, FColor::Red,\"You can't kill what is already dead. Mwahaha\");\n    }\n\n    voidIUndead::Turn()\n    {\n      GEngine->AddOnScreenDebugMessage(-1,1, FColor::Red, \"I'm fleeing!\");\n\n    }\n\n    voidIUndead::Banish()\n    {\n      AActor* Me = Cast<AActor>(this);\n      if (Me)\n      {\n        Me->Destroy();\n      }\n    }\n    ```", "```cpp\n    virtual bool IsSelectable();\n\n    virtual bool TrySelect();\n\n    virtual void Deselect();\n    ```", "```cpp\n    boolISelectable::IsSelectable()\n    {\n      GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Selectable\");\n      return true;\n    }\n\n    boolISelectable::TrySelect()\n    {\n      GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Accepting Selection\");\n      return true;\n    }\n\n    voidISelectable::Deselect()\n    {\n      unimplemented();\n    }\n    ```", "```cpp\n    class UE4COOKBOOK_API ASelectableCube : public APhysicsCube, public ISelectable\n    ```", "```cpp\n    ASelectableCube();\n    virtual void NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVectorHitLocation, FVectorHitNormal, FVectorNormalImpulse, constFHitResult& Hit) override;\n    ```", "```cpp\n    ASelectableCube::ASelectableCube()\n    : Super()\n    {\n      MyMesh->SetNotifyRigidBodyCollision(true);\n    }\n\n    voidASelectableCube::NotifyHit(class UPrimitiveComponent* MyComp, AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVectorHitLocation, FVectorHitNormal, FVectorNormalImpulse, constFHitResult& Hit)\n    {\n      if (IsSelectable())\n      {\n        TrySelect();\n      }\n    }\n    ```", "```cpp\n    virtual bool IsSelectable() override;\n\n    virtual bool TrySelect() override;\n\n    virtual void Deselect() override;\n    ```", "```cpp\n    boolANonSelectableCube::IsSelectable()\n    {\n      GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Not Selectable\");\n      return false;\n    }\n\n    boolANonSelectableCube::TrySelect()\n    {\n      GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"Refusing Selection\");\n      return false;\n    }\n\n    voidANonSelectableCube::Deselect()\n    {\n      unimplemented();\n    }\n    ```", "```cpp\n    UFUNCTION(BlueprintCallable, Category=Test)\n    virtual void OnPostBeginPlay();\n    ```", "```cpp\n    voidIPostBeginPlay::OnPostBeginPlay()\n    {\n      GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, \"PostBeginPlay called\");\n    }\n    ```", "```cpp\n    UCLASS()\n    class UE4COOKBOOK_API APostBeginPlayTest : public AActor, public IPostBeginPlay\n    ```", "```cpp\n    UFUNCTION(BlueprintImplementableEvent, BlueprintCallable, Category = AttackAvoider)\n    voidAttackIncoming(AActor* AttackActor);\n    ```", "```cpp\n    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Wearable)\n    int32GetStrengthRequirement();\n    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Wearable)\n    boolCanEquip(APawn* Wearer);\n    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Wearable)\n    voidOnEquip(APawn* Wearer);\n    ```", "```cpp\n    int32 IWearable::GetStrengthRequirement_Implementation()\n    {\n      return 0;\n    }\n\n    Bool IWearable::CanEquip_Implementation(APawn* Wearer)\n    {\n      return true;\n    }\n\n    Void IWearable::OnEquip_Implementation(APawn* Wearer)\n    {\n\n    }\n    ```", "```cpp\n    UCLASS()\n    class UE4COOKBOOK_API ABoots : public AActor, public IWearable\n    ```", "```cpp\n    virtual void OnEquip_Implementation(APawn* Wearer) override\n    {\n      IWearable::OnEquip_Implementation(Wearer);\n    }\n    virtual bool CanEquip_Implementation(APawn* Wearer) override\n    {\n      return IWearable::CanEquip_Implementation(Wearer);\n    }\n    virtual int32 GetStrengthRequirement_Implementation() override\n    {\n      return IWearable::GetStrengthRequirement_Implementation();\n    }\n    ```", "```cpp\n    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Talk)\n    void StartTalking();\n    ```", "```cpp\n    void ITalker::StartTalking_Implementation()\n    {\n\n    }\n    ```", "```cpp\n    #include \"Talker.h\"\n    class UE4COOKBOOK_API ATalkingMesh : public AStaticMeshActor, public ITalker\n    ```", "```cpp\n    void StartTalking_Implementation();\n    ```", "```cpp\n    ATalkingMesh::ATalkingMesh()\n    :Super()\n    {\n      autoMeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n      if (MeshAsset.Object != nullptr)\n      {\n        GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);\n        //GetStaticMeshComponent()->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n        GetStaticMeshComponent()->bGenerateOverlapEvents = true;\n      }\n      GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);\n      SetActorEnableCollision(true);\n    }\n    Implmement the default implementation of our StartTalking function:\n    voidATalkingMesh::StartTalking_Implementation()\n    {\n      GEngine->AddOnScreenDebugMessage(-1, 1, FColor::Red, TEXT(\"Hello there. What is your name?\"));\n    }\n    ```", "```cpp\n    UPROPERTY()\n    UBoxComponent* TalkCollider;\n    UFUNCTION()\n    voidOnTalkOverlap(AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, constFHitResult&SweepResult);\n    ```", "```cpp\n    ATalkingPawn::ATalkingPawn()\n    :Super()\n    {\n      // Set this character to call Tick() every frame. You can turn this off to improve performance if you don't need it.\n      PrimaryActorTick.bCanEverTick = true;\n      TalkCollider = CreateDefaultSubobject<UBoxComponent>(\"TalkCollider\"); \n      TalkCollider->SetBoxExtent(FVector(200, 200, 100));\n      TalkCollider->OnComponentBeginOverlap.AddDynamic(this, &ATalkingPawn::OnTalkOverlap);\n      TalkCollider->AttachTo(RootComponent);\n    }\n    ```", "```cpp\n    voidATalkingPawn::OnTalkOverlap(AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, constFHitResult&SweepResult)\n    {\n      if (OtherActor->GetClass()->ImplementsInterface(UTalker::StaticClass()))\n      {\n        ITalker::Execute_StartTalking(OtherActor);\n      }\n    }\n    ```", "```cpp\n    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category=Interactable)\n    boolCanInteract();\n    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = Interactable)\n    voidPerformInteract();\n    ```", "```cpp\n    boolIInteractable::CanInteract_Implementation()\n    {\n      return true;\n    }\n\n    voidIInteractable::PerformInteract_Implementation()\n    {\n\n    }\n    ```", "```cpp\n    UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category=Openable)\n    void Open();\n    ```", "```cpp\n    voidIOpenable::Open_Implementation()\n    {\n    }\n    ```", "```cpp\n    virtual bool CanInteract_Implementation() override;\n    virtual void PerformInteract_Implementation() override;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    AActor* DoorToOpen;\n    private:\n    boolHasBeenPushed;\n    ```", "```cpp\n    HasBeenPushed = false;\n    autoMeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n    if (MeshAsset.Object != nullptr)\n    {\n      GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);\n      //GetStaticMeshComponent()->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n      GetStaticMeshComponent()->bGenerateOverlapEvents = true;\n    }\n    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);\n    GetStaticMeshComponent()-> SetWorldScale3D(FVector(0.5, 0.5, 0.5));\n    SetActorEnableCollision(true);\n\n    DoorToOpen = nullptr;\n    ```", "```cpp\n    boolADoorBell::CanInteract_Implementation()\n    {\n      return !HasBeenPushed;\n    }\n\n    voidADoorBell::PerformInteract_Implementation()\n    {\n      HasBeenPushed = true;\n      if (DoorToOpen->GetClass()->ImplementsInterface(UOpenable::StaticClass()))\n      {\n        IOpenable::Execute_Open(DoorToOpen);\n      }\n    }\n    ```", "```cpp\n    class UE4COOKBOOK_API ADoor : public AStaticMeshActor, public IInteractable, public IOpenable\n    ```", "```cpp\n    UFUNCTION()\n    virtual bool CanInteract_Implementation() override { return IInteractable::CanInteract_Implementation(); };\n    UFUNCTION()\n    virtual void PerformInteract_Implementation() override;\n\n    UFUNCTION()\n    virtual void Open_Implementation() override;\n    ```", "```cpp\n    autoMeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"StaticMesh'/Engine/BasicShapes/Cube.Cube'\"));\n    if (MeshAsset.Object != nullptr)\n    {\n      GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);\n      //GetStaticMeshComponent()->SetCollisionProfileName(UCollisionProfile::Pawn_ProfileName);\n      GetStaticMeshComponent()->bGenerateOverlapEvents = true;\n    }\n    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);\n    GetStaticMeshComponent()->SetWorldScale3D(FVector(0.3, 2, 3));\n    SetActorEnableCollision(true);\n    ```", "```cpp\n    voidADoor::PerformInteract_Implementation()\n    {\n      GEngine->AddOnScreenDebugMessage(-1, 5, FColor::Red, TEXT(\"The door refuses to budge. Perhaps there is a hidden switch nearby?\"));\n    }\n\n    voidADoor::Open_Implementation()\n    {\n      AddActorLocalOffset(FVector(0, 0, 200));\n    }\n    ```", "```cpp\n    voidTryInteract();\n\n    private:\n    virtual void SetupPlayerInputComponent(UInputComponent* InInputComponent) override;\n    ```", "```cpp\n    voidAInteractingPawn::TryInteract()\n    {\n      APlayerController* MyController = Cast<APlayerController>(Controller);\n      if (MyController)\n      {\n        APlayerCameraManager* MyCameraManager = MyController->PlayerCameraManager;\n        autoStartLocation = MyCameraManager->GetCameraLocation();\n        autoEndLocation = MyCameraManager->GetCameraLocation() + (MyCameraManager->GetActorForwardVector() * 100);\n        FHitResultHitResult;\n        GetWorld()->SweepSingleByObjectType(HitResult, StartLocation, EndLocation, FQuat::Identity, \n        FCollisionObjectQueryParams(FCollisionObjectQueryParams::AllObjects),FCollisionShape::MakeSphere(25),\n        FCollisionQueryParams(FName(\"Interaction\"),true,this));\n        if (HitResult.Actor != nullptr)\n        {\n          if (HitResult.Actor->GetClass()->ImplementsInterface(UInteractable::StaticClass()))\n          {\n            if (IInteractable::Execute_CanInteract(HitResult.Actor.Get()))\n            {\n              IInteractable::Execute_PerformInteract(HitResult.Actor.Get());\n            }\n          }\n        }\n      }\n    }\n    voidAInteractingPawn::SetupPlayerInputComponent(UInputComponent* InInputComponent)\n    {\n      Super::SetupPlayerInputComponent(InInputComponent);\n      InInputComponent->BindAction(\"Interact\", IE_Released, this, &AInteractingPawn::TryInteract);\n    }\n    ```"]