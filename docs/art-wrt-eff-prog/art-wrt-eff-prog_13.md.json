["```cpp\nstd::vector<int> v;\n\u2026 fill v with data \u2026 \nfor (int& x : v) ++x;\n```", "```cpp\nint v[16];\n\u2026 fill v with data \u2026 \nfor (int& x : v) ++x;\n```", "```cpp\nconstexpr size_t N = 16;\nstd::vector<int> v(N);\n\u2026 fill v with data \u2026 \nfor (int& x : v) ++x;\n```", "```cpp\nconstexpr size_t N = 16;\nstd::vector<int> v(N);\n\u2026 fill v with data \u2026 \nassert(v.size() == N); // if (v.size() != N) abort();\nfor (int& x : v) ++x;\n```", "```cpp\ndouble f(int& i, double x) {\n\u00a0\u00a0double res = g(x);\n\u00a0\u00a0++i;\n\u00a0\u00a0res += h(x);\n\u00a0\u00a0res += g(x);\n\u00a0\u00a0++i;\n\u00a0\u00a0res += h(x);\n\u00a0\u00a0return res;\n}\n```", "```cpp\ndouble f(int& i, double x) {\n\u00a0\u00a0i += 2;\n\u00a0\u00a0return 2*(g(x) + h(x));\n}\n```", "```cpp\ndouble f(int& i, double x) {\n\u00a0\u00a0double res = x + 1; // g(x);\n\u00a0\u00a0++i;\n\u00a0\u00a0res += x \u2013 1; // h(x);\n\u00a0\u00a0res += x + 1; // g(x)\n\u00a0\u00a0++i;\n\u00a0\u00a0res += x \u2013 1; // h(x);\n\u00a0\u00a0return res;\n}\n```", "```cpp\ndouble f(int& i, double x) {\n\u00a0\u00a0i += 2;\n\u00a0\u00a0return 4*x;\n}\n```", "```cpp\nfor (auto it = crbegin(); it != crend(); ++it) it->~T();\n```", "```cpp\nstruct S {\n\u00a0\u00a0long a;\n\u00a0\u00a0double x;\n};\nstd::vector<S> v;\n```", "```cpp\nstruct S {\n\u00a0\u00a0long a;\n\u00a0\u00a0double x;\n\u00a0\u00a0~S() = default;\n};\n```", "```cpp\nstruct S {\n\u00a0\u00a0long a;\n\u00a0\u00a0double x;\n\u00a0\u00a0~S() {}\u00a0\u00a0\u00a0\u00a0\u00a0// Probably optimized away\n};\n```", "```cpp\nstruct S {\n\u00a0\u00a0long a;\n\u00a0\u00a0double x;\n\u00a0\u00a0~S();\n};\n```", "```cpp\nbool pred(int i) { return i == 0; }\n\u00a0\u00a0\u2026 \nstd::vector<int> v = \u2026 fill vector with data \u2026;\nauto it = std::find_if(v.begin(), v.end(), pred);\n```", "```cpp\n bool pred(int i) { return i == 0; }\n\u00a0\u00a0\u2026 \nstd::vector<int> v = \u2026 fill vector with data \u2026;\nauto it = std::find_if(v.begin(), v.end(), \n\u00a0\u00a0[&](int i) { return pred(i); });\n```", "```cpp\nint g(int a);\nint f(const std::vector<int>& v, bool b) {\n\u00a0\u00a0int sum = 0;\n\u00a0\u00a0for (int a : v) {\n\u00a0\u00a0\u00a0\u00a0if (b) sum += g(a);\n\u00a0\u00a0}\n\u00a0\u00a0return sum;\n} \n```", "```cpp\nint f(const std::vector<int>& v, bool b) {\n\u00a0\u00a0if (!b) return 0;\n\u00a0\u00a0int sum = 0;\n\u00a0\u00a0for (int a : v) {\n\u00a0\u00a0\u00a0\u00a0sum += g(a);\n\u00a0\u00a0}\n\u00a0\u00a0return sum;\n} \n```", "```cpp\nint g(int a);\nint f(const std::vector<int>& v, const bool& b) {\n\u00a0\u00a0int sum = 0;\n\u00a0\u00a0for (int a : v) {\n\u00a0\u00a0\u00a0\u00a0if (b) sum += g(a);\n\u00a0\u00a0}\n\u00a0\u00a0return sum;\n} \n```", "```cpp\nbool flag = false;\nint g(int a) {\n\u00a0\u00a0flag = a == 0;\n\u00a0\u00a0return \u2013a;\n}\nint f(const std::vector<int>& v, const bool& b) {\n\u00a0\u00a0int sum = 0;\n\u00a0\u00a0for (int a : v) {\n\u00a0\u00a0\u00a0\u00a0if (b) sum += g(a);\n\u00a0\u00a0}\n\u00a0\u00a0return sum;\n} \nint main() {\n\u00a0\u00a0f({0, 1, 2, 3, 4}, flag);\n}\n```", "```cpp\ntemplate <typename T>\nint f(const std::vector<int>& v, const T& t) {\n\u00a0\u00a0const bool b = bool(t);\n\u00a0\u00a0int sum = 0;\n\u00a0\u00a0for (int a: v) {\n\u00a0\u00a0\u00a0\u00a0if (b) sum += g(a);\n\u00a0\u00a0}\n\u00a0\u00a0return sum;\n} \n```", "```cpp\nvoid init(char* a, char* b, size_t N) {\n\u00a0\u00a0for (size_t i = 0; i < N; ++i) {\n\u00a0\u00a0\u00a0\u00a0a[i] = '0';\n\u00a0\u00a0\u00a0\u00a0b[i] = '1';\n\u00a0\u00a0}\n}\n```", "```cpp\nvoid init(char* a, char* b, size_t N) {\n\u00a0\u00a0std::memset(a, '0', N);\n\u00a0\u00a0std::memset(b, '1', N);\n}\n```", "```cpp\nvoid do_work(int& a, int& b, int& x) {\n\u00a0\u00a0if (x < 0) x = -x;\n\u00a0\u00a0a += x;\n\u00a0\u00a0b += x;\n}\n```", "```cpp\nvoid init(char* restrict a, char* restrict b, size_t N);\n```", "```cpp\nvoid do_work(int& a, int& b, int& x) {\n\u00a0\u00a0if (x < 0) x = -x;\n\u00a0\u00a0const int y = x;\n\u00a0\u00a0a += y;\n\u00a0\u00a0b += y;\n}\n```", "```cpp\ntemplate <typename T>\nvoid my_swap(T* p, T* q) {\n\u00a0\u00a0\u00a0\u00a0if (p && q) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0using std::swap;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0swap(*p, *q);\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nvoid f(int* p, int* q) {\n\u00a0\u00a0\u00a0\u00a0if (p && q) my_swap(p, q);\n}\n```", "```cpp\nif (p) delete p; \n```", "```cpp\nenum op_t { do_shrink, do_grow };\nvoid process(std::vector<Shape>& v, op_t op) {\n\u00a0\u00a0for (Shape& s : v) {\n\u00a0\u00a0\u00a0\u00a0if (op == do_shrink) s.shrink();\n\u00a0\u00a0\u00a0\u00a0else s.grow();\n\u00a0\u00a0}\n}\n```", "```cpp\ntemplate <op_t op>\nvoid process(std::vector<Shape>& v) {\n\u00a0\u00a0for (Shape& s : v) {\n\u00a0\u00a0\u00a0\u00a0if (op == do_shrink) s.shrink();\n\u00a0\u00a0\u00a0\u00a0else s.grow();\n\u00a0\u00a0}\n}\nvoid process(std::vector<Shape>& v, op_t op) {\n\u00a0\u00a0if (op == do_shrink) process<do_shrink>(v);\n\u00a0\u00a0else process<do_grow>(v);\n}\n```", "```cpp\nvoid measure(const std::vector<Shape>& s,\n\u00a0\u00a0double* length, double* width, double* depth,\n\u00a0\u00a0double* volume, double* weight);\n```", "```cpp\ntemplate <bool use_length, bool use_width, \u2026>\nvoid measure(const std::vector<Shape>& v,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0double* length, \u2026 );\nvoid measure(const std::vector<Shape>& v,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0double* length, \u2026 ) {\n\u00a0\u00a0const int key = ((length != nullptr) << 0) |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((width\u00a0\u00a0!= nullptr) << 1) |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((depth\u00a0\u00a0!= nullptr) << 2) |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((volume != nullptr) << 3) |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((weight != nullptr) << 4);\n\u00a0\u00a0switch (key) {\n\u00a0\u00a0\u00a0\u00a0case 0x01: measure<true , false, \u2026 >(v, length, \u2026 );\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0case 0x02: measure<false, true , \u2026 >(v, length, \u2026 );\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u2026\n\u00a0\u00a0\u00a0\u00a0default:; // Programming error, assert\n }\n}\n```"]