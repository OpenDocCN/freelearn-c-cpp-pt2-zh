["```cpp\nT& operator[](size_t i) { return \u2026 i-th element \u2026; }\n```", "```cpp\ncontainer<T> cont;\n\u2026 add some data to cont \u2026\nfor (size_t i = 0; i != cont.size(); ++i) {\n\u00a0\u00a0T& element_i = cont[i];\n\u00a0\u00a0\u2026 do some work on the i-th element \u2026\n}\n```", "```cpp\nfor (auto it = cont.begin(); it != cont.end(); ++it) {\n\u00a0\u00a0T& element = *it;\n\u00a0\u00a0\u2026 do some work on the element \u2026\n}\n```", "```cpp\nvoid BM_index(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0const unsigned int N = state.range(0);\n\u00a0\u00a0\u00a0\u00a0\u00a0std::deque<unsigned long> d(N);\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(d[i]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0state.SetItemsProcessed(N*state.iterations());\n}\nvoid BM_iter(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0const unsigned int N = state.range(0);\n\u00a0\u00a0\u00a0\u00a0\u00a0std::deque<unsigned long> d(N);\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto it = d.cbegin(), it0 = d.cend(); \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0it != it0; ++it) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(*it);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0state.SetItemsProcessed(N*state.iterations());\n}\n```", "```cpp\ntemplate<typename T> struct compare_ptr {\n\u00a0\u00a0bool operator()(const T* a, const T* b) const {\n\u00a0\u00a0\u00a0\u00a0\u00a0return *a < *b;\n\u00a0\u00a0}\n};\ntemplate <typename T> class index_tree {\n\u00a0\u00a0public:\n\u00a0\u00a0void insert(const T& t) { \n\u00a0\u00a0\u00a0\u00a0\u00a0data_.push_back(t);\n\u00a0\u00a0\u00a0\u00a0\u00a0idx_.insert(&(data_[data_.size() - 1]));\n\u00a0\u00a0}\n\u00a0\u00a0private:\n\u00a0\u00a0std::set<T*, compare_ptr<T>> idx_;\n\u00a0\u00a0std::vector<T> data_;\n};\n```", "```cpp\ntemplate <typename T> class index_tree {\n\u00a0\u00a0using idx_t = typename std::set<T*, compare_ptr<T>>;\n\u00a0\u00a0using idx_iter_t = typename idx_t::const_iterator;\n\u00a0\u00a0public:\n\u00a0\u00a0class const_iterator {\n\u00a0\u00a0\u00a0\u00a0\u00a0idx_iter_t it_;\n\u00a0\u00a0\u00a0\u00a0\u00a0public:\n\u00a0\u00a0\u00a0\u00a0\u00a0const_iterator(idx_iter_t it) : it_(it) {}\n\u00a0\u00a0\u00a0\u00a0\u00a0const_iterator operator++() { ++it_; return *this; }\n\u00a0\u00a0\u00a0\u00a0\u00a0const T& operator*() const { return *(*it_); }\n\u00a0\u00a0\u00a0\u00a0\u00a0friend bool operator!=(const const_iterator& a,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const const_iterator& b) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return a.it_ != b.it_;\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0};\n\u00a0\u00a0const_iterator cbegin() const { return idx_.cbegin(); }\n\u00a0\u00a0const_iterator cend() const { return idx_.cend(); }\n\u00a0\u00a0\u2026\n};\n```", "```cpp\ntemplate <typename C, typename F> bool find(const C& c, F f) {\n\u00a0\u00a0for (auto it = c.cbegin(), i0 = c.cend(); it != i0; ++it) {\n\u00a0\u00a0\u00a0\u00a0\u00a0if (f(*it)) return true;\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```", "```cpp\ntemplate <typename T> class index_tree {\n\u00a0\u00a0\u2026\n\u00a0\u00a0template <typename F> bool find(F f) const {\n\u00a0\u00a0\u00a0\u00a0\u00a0for (const T& x : data_) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (f(x)) return true;\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0}\n};\n```", "```cpp\ntemplate <typename T> class index_tree {\n\u00a0\u00a0public:\n\u00a0\u00a0void insert(const T& t) {\n\u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard guard(m_);\n\u00a0\u00a0\u00a0\u00a0\u00a0data_.push_back(t);\n\u00a0\u00a0\u00a0\u00a0\u00a0idx_.insert(&(data_[data_.size() - 1]));\n\u00a0\u00a0}\n\u00a0\u00a0private:\n\u00a0\u00a0std::set<T*, compare_ptr<T>> idx_;\n\u00a0\u00a0std::vector<T> data_;\n\u00a0\u00a0std::mutex m_;\n};\n```", "```cpp\ntemplate <typename T> class index_tree {\n\u00a0\u00a0public:\n\u00a0\u00a0explicit index_tree(bool lock) : lock_(lock) {}\n\u00a0\u00a0void insert(const T& t) {\n\u00a0\u00a0\u00a0\u00a0\u00a0optional_lock_guard guard(lock_ ? &m_ : nullptr);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\n\u00a0\u00a0}\n\u00a0\u00a0private:\n\u00a0\u00a0\u2026\n\u00a0\u00a0std::mutex m_;\n\u00a0\u00a0const bool lock_;\n};\n```", "```cpp\ntemplate <typename L> class optional_lock_guard {\n\u00a0\u00a0L* lock_;\n\u00a0\u00a0public:\n\u00a0\u00a0explicit optional_lock_guard(L* lock) : lock_(lock) {\n\u00a0\u00a0\u00a0\u00a0\u00a0if (lock_) lock_->lock();\n\u00a0\u00a0}\n\u00a0\u00a0~optional_lock_guard() {\n\u00a0\u00a0\u00a0\u00a0\u00a0if (lock_) lock_->unlock();\n\u00a0\u00a0}\n\u00a0\u00a0optional_lock_guard(const optional_lock_guard&) = delete;\n\u00a0\u00a0// Handle other copy/move operations.\n};\n```", "```cpp\ntemplate <typename T, typename LP> class index_tree {\n\u00a0\u00a0public:\n\u00a0\u00a0void insert(const T& t) {\n\u00a0\u00a0\u00a0\u00a0\u00a0LP guard;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\n\u00a0\u00a0}\n};\n```", "```cpp\nstruct locking_policy {\n\u00a0\u00a0locking_policy() { m_.lock(); }\n\u00a0\u00a0~locking_policy() { m_.unlock(); }\n\u00a0\u00a0std::mutex m_;\n};\nstruct non_locking_policy {};\n```", "```cpp\nindex_tree<int, locking_policy> strong_ts_tree;\nindex_tree<int, non_locking_policy> weak_ts_tree;\n```", "```cpp\ntemplate <typename T> class index_tree_ts :\n\u00a0\u00a0private index_tree<T> \n{\n\u00a0\u00a0public:\n\u00a0\u00a0using index_tree<T>::index_tree;\n\u00a0\u00a0void insert(const T& t) {\n\u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard guard(m_);\n\u00a0\u00a0\u00a0\u00a0\u00a0index_tree<T>::insert(t);\n\u00a0\u00a0}\n\u00a0\u00a0private:\n\u00a0\u00a0std::mutex m_;\n};\n```", "```cpp\nstruct point {\n\u00a0\u00a0double x, y, z;\n\u00a0\u00a0int color;\n\u00a0\u00a0\u2026 maybe more data \u2026\n};\n```", "```cpp\nclass point {\n\u00a0\u00a0double x, y, z;\n\u00a0\u00a0int color;\n\u00a0\u00a0public:\n\u00a0\u00a0double get_x() const { return x; }\n\u00a0\u00a0void set_x(double x_in) { x = x_in; } // Same for y etc\n};\n```", "```cpp\nclass point_collection {\n\u00a0\u00a0point& operator[](size_t i);\n};\n```", "```cpp\nclass point {\n\u00a0\u00a0point_collection& coll_;\n\u00a0\u00a0size_t point_id_;\n\u00a0\u00a0public:\n\u00a0\u00a0double get_x() const { return coll_[point_id_]; }\n\u00a0\u00a0\u2026\n};\n```"]