["```cpp\nstd::vector<double> v;\n\u2026 add data to v \u2026 \nstd::for_each(v.begin(), v.end(),[](double& x){ ++x; });\n```", "```cpp\nstd::vector<double> v;\n\u2026 add data to v \u2026 \nstd::for_each(std::execution::par,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v.begin(), v.end(),[](double& x){ ++x; });\n```", "```cpp\ndouble much_computing(double x);\nstd::vector<double> v;\n\u2026 add data to v \u2026 \ndouble res = 0;\nstd::mutex res_lock;\nstd::for_each(std::execution::par, v.begin(), v.end(),\n\u00a0\u00a0[&](double& x){ \n\u00a0\u00a0\u00a0\u00a0double term = much_computing(x);\n\u00a0\u00a0\u00a0\u00a0std::lock_guard guard(res_lock);\n\u00a0\u00a0\u00a0\u00a0res += term;\n\u00a0\u00a0});\n```", "```cpp\nstd::vector<double> v(N);\nstd::for_each(std::execution::par,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v.begin(), v.end(),[](double& x){ work(x); });\n```", "```cpp\nstd::for_each(std::execution::par,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v.begin(), v.end(),[](double& x){ ++x; });\n```", "```cpp\nstd::vector<double> v(N);\nstd::sort(std::execution::par, v.begin(), v.end();\n```", "```cpp\nvoid f() {\n\u00a0\u00a0\u2026\n}\n```", "```cpp\nvoid g() {\n\u00a0\u00a0\u2026\n}\nvoid f() {\n\u00a0\u00a0\u2026\n\u00a0\u00a0g();\n\u00a0\u00a0\u2026\n}\n```", "```cpp\nvoid g() {\n\u00a0\u00a0\u2026\n}\nvoid coro() { // coroutine\n\u00a0\u00a0\u2026\n\u00a0\u00a0g();\n\u00a0\u00a0\u2026\n}\nvoid f() {\n\u00a0\u00a0\u2026\n\u00a0\u00a0std::coroutine_handle<???> H; // Not the real syntax\n\u00a0\u00a0coro();\n\u00a0\u00a0\u2026\n}\n```", "```cpp\nvoid h() {\n\u00a0\u00a0\u2026\n}\nvoid coro() {\u2026} // coroutine\nvoid f() {\n\u00a0\u00a0\u2026\n\u00a0\u00a0std::coroutine_handle<???> H; // Not the real syntax\n\u00a0\u00a0coro();\n\u00a0\u00a0h(); // Called after coro() is suspended\n\u00a0\u00a0\u2026\n}\n```", "```cpp\nvoid h(H) {\n\u00a0\u00a0H.resume(); // Not the real syntax\n}\nvoid coro() {\u2026} // coroutine\nvoid f() {\n\u00a0\u00a0\u2026\n\u00a0\u00a0std::coroutine_handle<???> H; // Not the real syntax\n\u00a0\u00a0coro();\n\u00a0\u00a0h(H); // Called after coro() is suspended\n\u00a0\u00a0\u2026\n}\n```", "```cpp\ngenerator<int> coro(){\n\u00a0\u00a0for (int i = 0;; ++i) {\n\u00a0\u00a0\u00a0\u00a0co_yield i;\n\u00a0\u00a0}\n}\nint main() {\n\u00a0\u00a0auto h = coro().h_;\n\u00a0\u00a0auto& promise = h.promise();\n\u00a0\u00a0for (int i = 0; i < 3; ++i) {\n\u00a0\u00a0\u00a0\u00a0std::cout << \"counter: \" << promise.value_ << \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::endl;\n\u00a0\u00a0\u00a0\u00a0h();\n\u00a0\u00a0}\n\u00a0\u00a0h.destroy();\n}\n```", "```cpp\ntemplate <typename T> struct generator {\n\u00a0\u00a0struct promise_type {\n\u00a0\u00a0\u00a0\u00a0T value_ = -1;\n\u00a0\u00a0\u00a0\u00a0generator get_return_object() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0using handle= std::coroutine_handle<promise_type>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return generator{handle::from_promise(*this)};\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::suspend_never initial_suspend() { return {}; }\n\u00a0\u00a0\u00a0\u00a0std::suspend_never final_suspend() noexcept { return \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{}; }\n\u00a0\u00a0\u00a0\u00a0void unhandled_exception() {}\n\u00a0\u00a0\u00a0\u00a0std::suspend_always yield_value(T value) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value_ = value;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return {};\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0};\n\u00a0\u00a0std::coroutine_handle<promise_type> h_;\n};\n```", "```cpp\ntemplate <typename T> struct generator {\n\u00a0\u00a0struct promise { \u2026 };\n\u00a0\u00a0using promise_type = promise;\n};\n```", "```cpp\ngenerator<int> coro(){\n\u00a0\u00a0for (int i = 0; i < 10; ++i) {\n\u00a0\u00a0\u00a0\u00a0co_yield i;\n\u00a0\u00a0}\n}\n```", "```cpp\ntask coro(std::jthread& t) {\n\u00a0\u00a0std::cout << \"Coroutine started on thread: \" <<\n\u00a0\u00a0\u00a0\u00a0std::this_thread::get_id() << '\\n';\n\u00a0\u00a0co_await awaitable{t};\n\u00a0\u00a0std::cout << \"Coroutine resumed on thread: \" <<\n\u00a0\u00a0\u00a0\u00a0std::this_thread::get_id() << '\\n';\n\u00a0\u00a0std::cout << \"Coroutine done on thread: \" <<\n\u00a0\u00a0\u00a0\u00a0std::this_thread::get_id() << '\\n';\n}\nint main() {\n\u00a0\u00a0std::cout << \"Main thread: \" <<\n\u00a0\u00a0\u00a0\u00a0std::this_thread::get_id() << '\\n';\n\u00a0\u00a0std::jthread t;\n\u00a0\u00a0coro(t);\n\u00a0\u00a0std::cout << \"Main thread done: \" << \n\u00a0\u00a0\u00a0\u00a0std::this_thread::get_id() << std::endl;\n}\n```", "```cpp\nstruct task{\n\u00a0\u00a0struct promise_type {\n\u00a0\u00a0\u00a0\u00a0task get_return_object() { return {}; }\n\u00a0\u00a0\u00a0\u00a0std::suspend_never initial_suspend() { return {}; }\n\u00a0\u00a0\u00a0\u00a0std::suspend_never final_suspend() noexcept { return \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{}; }\n\u00a0\u00a0\u00a0\u00a0void return_void() {}\n\u00a0\u00a0\u00a0\u00a0void unhandled_exception() {}\n\u00a0\u00a0};\n};\n```", "```cpp\nstruct awaitable {\n\u00a0\u00a0std::jthread& t;\n\u00a0\u00a0bool await_ready() { return false; }\n\u00a0\u00a0void await_suspend(std::coroutine_handle<> h) {\n\u00a0\u00a0\u00a0\u00a0std::jthread& out = t;\n\u00a0\u00a0\u00a0\u00a0out = std::jthread([h] { h.resume(); });\n\u00a0\u00a0}\n\u00a0\u00a0void await_resume() {}\n\u00a0\u00a0~awaitable() {}\n\u00a0\u00a0awaitable(std::jthread& t) : t(t) {}\n};\n```", "```cpp\nMain thread: 140003570591552\nCoroutine started on thread: 140003570591552\nMain thread done: 140003570591552\nCoroutine resumed on thread: 140003570587392\nCoroutine done on thread: 140003570587392\n```", "```cpp\nco_await promise.yield_value(x);\n```"]