["```cpp\ntemplate <class Word>\nvoid BM_read_seq(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0const size_t size = state.range(0);\n\u00a0\u00a0\u00a0\u00a0\u00a0void* memory = ::malloc(size);\n\u00a0\u00a0\u00a0\u00a0\u00a0void* const end = static_cast<char*>(memory) + size;\n\u00a0\u00a0\u00a0\u00a0\u00a0volatile Word* const p0 = static_cast<Word*>(memory);\n\u00a0\u00a0\u00a0\u00a0\u00a0Word* const p1 = static_cast<Word*>(end);\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (volatile Word* p = p0; p != p1; ) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0REPEAT(benchmark::DoNotOptimize(*p++);)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0::free(memory);\n\u00a0\u00a0\u00a0\u00a0\u00a0state.SetBytesProcessed(size*state.iterations());\n\u00a0\u00a0\u00a0\u00a0\u00a0state.SetItemsProcessed((p1 - p0)*state.iterations());\n}\n```", "```cpp\n#define ARGS ->RangeMultiplier(2)->Range(1<<10, 1<<30) \\\n\u00a0\u00a0\u00a0\u00a0\u00a0->Threads(1)->Threads(2)\nBENCHMARK_TEMPLATE1(BM_read_seq, unsigned long) ARGS;\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0\u00a0Word fill; ::memset(&fill, 0xab, sizeof(fill));\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (volatile Word* p = p0; p != p1; ) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0REPEAT(benchmark::DoNotOptimize(*p++ = \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fill);)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n```", "```cpp\nunsigned long x {0};\nvoid BM_incr(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(++x);\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n}\nBENCHMARK(BM_incr)->Threads(2);\n```", "```cpp\nunsigned long x {0};\nstd::mutex m;\n{ // Concurrent access happens here\n\u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard<std::mutex> guard(m);\n\u00a0\u00a0\u00a0\u00a0\u00a0++x;\n}\n```", "```cpp\nstd::atomic<unsigned long> x(0);\nvoid BM_shared(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(++x);\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nstd::atomic<unsigned long> a[1024];\nvoid BM_false_shared(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0std::atomic<unsigned long>& x = a[state.thread_index];\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(++x);\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nvoid BM_not_shared(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0std::atomic<unsigned long> x;\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(++x);\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\n// Global (shared) results\nstd::atomic<unsigned long> sum;\nunsigned long local_sum[\u2026];\n// Per-thread work is done here\nunsigned long& x = local_sum[thread_index];\nfor (size_t i = 0; i < N; ++i) ++x;\nsum += x;\n```", "```cpp\nsize_t N; \u00a0\u00a0\u00a0\u00a0// Count of initialized objects\nT* buffer; // Only [0]\u2026[N-1] are initialized\n```", "```cpp\nnew (buffer + N) T( \u2026 arguments \u2026 );\n```", "```cpp\n++N;\n```", "```cpp\nfor (size_t i = 0; keep_consuming(); ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0while (N <= i) {}; // Wait for the i-th element\n\u00a0\u00a0\u00a0\u00a0\u00a0consume(buffer[i]);\n}\n```", "```cpp\nsize_t N; \u00a0\u00a0\u00a0\u00a0// Count of initialized objects\nstd::mutex mN;\u00a0\u00a0\u00a0\u00a0// Mutex to guard N\n\u2026 Producer \u2026\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard l(mN);\n\u00a0\u00a0\u00a0\u00a0\u00a0++N;\n}\n\u2026 Consumer \u2026 \n{\n\u00a0\u00a0\u00a0\u00a0\u00a0size_t n;\n\u00a0\u00a0\u00a0\u00a0\u00a0do {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard l(mN);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n = N;\n\u00a0\u00a0\u00a0\u00a0\u00a0} while (n <= i);\n}\n```", "```cpp\nstd::lock_guard l(mN);\nwhile (N <= i) {};\n```", "```cpp\nstd::atomic<size_t> N; \u00a0\u00a0\u00a0\u00a0// Count of initialized objects\n\u2026 Producer \u2026\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0++N;\u00a0\u00a0\u00a0\u00a0// Atomic, no need for locks\n}\n\u2026 Consumer \u2026 \n{\n\u00a0\u00a0\u00a0\u00a0\u00a0while (N <= i) {};\n}\n```", "```cpp\nstd::atomic<size_t> N; \u00a0\u00a0\u00a0\u00a0// Count of initialized objects\nT* buffer; // Only [0]\u2026[N-1] are initialized\n\u2026 Producer \u2026\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0new (buffer + N) T( \u2026 arguments \u2026 );\n\u00a0\u00a0\u00a0\u00a0\u00a0++N;\u00a0\u00a0\u00a0\u00a0// Atomic, no need for locks\n}\n\u2026 Consumer \u2026 \nfor (size_t i = 0; keep_consuming(); ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0while (N <= i) {}; // Atomic read\n\u00a0\u00a0\u00a0\u00a0\u00a0consume(buffer[i]);\n}\n```", "```cpp\nwhile (N.load(std::memory_order_acquire) <= i);\n```", "```cpp\nN.fetch_add(1, std::memory_order_release);\n```", "```cpp\n\u2026 Producer \u2026\nnew (buffer + N) T( \u2026 arguments \u2026 );\n{ // Critical section start \u2013 acquire lock\n\u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard l(mN);\n\u00a0\u00a0\u00a0\u00a0\u00a0++N;\n} // Critical section end - Release lock\n\u2026 Consumer \u2026 \n{ // Critical section \u2013 acquire lock\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard l(mN);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n = N;\n} // Critical section \u2013 release lock\nconsume(buffer[N]);\n```", "```cpp\nstd::mutex mN;\nsize_t N = 0;\n\u2026\nnew (buffer + N) T( \u2026 arguments \u2026 );\n{ // Critical section start \u2013 acquire lock\n\u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard l(mN);\n\u00a0\u00a0\u00a0\u00a0\u00a0++N;\n} // Critical section end - release lock\n```", "```cpp\nstd::mutex mN;\nsize_t N = 0;\n\u2026\nnew (buffer + N) T( \u2026 arguments \u2026 );\u00a0\u00a0\u00a0\u00a0// N\nmN.lock();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// mN\n++N;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// N\nmN.unlock();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// mN\n```", "```cpp\nsize_t n, m;\n++m;\n++n;\n```", "```cpp\nmN.lock();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// mN\nmN.unlock();\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// mN\n++N;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// N\n```", "```cpp\nvoid BM_order(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x.store(1, memory_order);\n\u00a0\u00a0\u00a0\u00a0\u2026 unroll the loop 32 times for better accuracy \u2026\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x.store(1, memory_order);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0state.SetItemsProcessed(32*state.iterations());\n}\n```"]