["```cpp\nstd::vector<int> v = make_v(\u2026 some args \u2026);\ndo_work(v);\n```", "```cpp\nvoid do_work(std::vector<int>& vr) {\n\u00a0\u00a0\u2026 vr is a reference to v \u2026\n}\n```", "```cpp\nvoid do_work(std::vector<int> vc) {\n\u00a0\u00a0\u2026 vc is a copy of v \u2026\n}\n```", "```cpp\nvoid do_work(const std::vector<int>& v) {\n\u00a0\u00a0int sum = 0;\n\u00a0\u00a0for (int x: v) sum += x;\n\u00a0\u00a0\u2026 use sum \u2026 \n}\n```", "```cpp\nvoid do_work(std::vector<int> v) {\n\u00a0\u00a0for (int& x : v) x = std::min(x, 255);\n\u00a0\u00a0\u2026 do computations on the new values \u2026\n}\n```", "```cpp\nvoid do_work(std::vector<int>&& v) {\n\u00a0\u00a0\u2026 can alter v data \u2026 \n}\n```", "```cpp\nvoid do_work(std::vector<int> v) {\n\u00a0\u00a0\u2026 use v destructively \u2026 \n}\nstd::vector<int> v1(\u2026);\ndo_work(v1); \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Local copy is made\ndo_work(std::vector<int>(\u2026));\u00a0\u00a0\u00a0\u00a0// R-value\n```", "```cpp\nvoid print_sorted(std::vector<int> v) {\n\u00a0\u00a0std::sort(v.begin(), v.end());\n\u00a0\u00a0for (int x: v) std::cout << x << \u201c\\n\u201d;\n}\n```", "```cpp\ntemplate <typename T>\nvoid print_sorted(const std::vector<T>& v) {\n\u00a0\u00a0std::vector<const T*> vp; vp.reserve(v.size());\n\u00a0\u00a0for (const T& x: v) vp.push_back(&x);\n\u00a0\u00a0std::sort(vp.begin(), vp.end(), \n\u00a0\u00a0\u00a0\u00a0\u00a0[](const T* a, const T* b) { return *a < *b;});\n\u00a0\u00a0for (const T* x: vp) std::cout << *x << \u201c\\n\u201d;\n}\n```", "```cpp\nvoid BM_sort(benchmark::State& state) {\n\u00a0\u00a0\u00a0const size_t N = state.range(0);\n\u00a0\u00a0\u00a0std::vector<int> v0(N); for (int& x: v0) x = rand();\n\u00a0\u00a0\u00a0std::vector<int> v(N);\n\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v = v0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print_sorted(v);\n\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0state.SetItemsProcessed(state.iterations()*N);\n }\n```", "```cpp\nclass C {\n\u00a0\u00a0std::vector<int> v_;\n\u00a0\u00a0C(std::vector<int> ??? v) { \u2026 v_ is a copy of v \u2026 }\n};\n```", "```cpp\nclass C {\n\u00a0\u00a0std::vector<int> v_;\n\u00a0\u00a0C(const std::vector<int>& v) : v_(v) { \u2026 }\n};\n```", "```cpp\nclass C {\n\u00a0\u00a0std::vector<int> v_;\n\u00a0\u00a0C(std::vector<int>&& v) : v_(std::move(v)) { \u2026 }\n};\n```", "```cpp\nclass C {\n\u00a0\u00a0std::vector<int> v_;\n\u00a0\u00a0C(std::vector<int> v) : v_(std::move(v)) \n\u00a0\u00a0{ \u2026 do not use v here!!! \u2026 }\n};\n```", "```cpp\nstd::vector<int> v = make_v(\u2026 some args \u2026);\n```", "```cpp\nstd::vector<int> make_v(\u2026 some args \u2026) {\n\u00a0\u00a0std::vector<int> vtmp;\n\u00a0\u00a0\u2026 add data to vtmp \u2026\n\u00a0\u00a0return vtmp;\n}\n```", "```cpp\nclass C {\n\u00a0\u00a0int i_ = 0;\n\u00a0\u00a0public:\n\u00a0\u00a0explicit C(int i) : i_(i) { \n\u00a0\u00a0\u00a0std::cout << \u201cC() @\u201d << this << std::endl;\n\u00a0\u00a0}\n\u00a0\u00a0C(const C& c) : i_(c.i_) {\n\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \u201cC(const C&) @\u201d << this << std::endl;\n\u00a0\u00a0}\n\u00a0\u00a0C(C&& c) : i_(c.i_) {\n\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \u201cC(C&&) @\u201d << this << std::endl;\n\u00a0\u00a0}\n\u00a0\u00a0~C() { cout << \u201c~C() @\u201d << this << endl; }\n\u00a0\u00a0friend std::ostream& operator<<( std::ostream& out,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const C& c) {\n\u00a0\u00a0\u00a0\u00a0\u00a0out << c.i_; return out;\n\u00a0\u00a0}\n };\u00a0\u00a0\n C makeC(int i) { C ctmp(i); return ctmp; }\n int main() {\n\u00a0\u00a0\u00a0C c = makeC(42);\n\u00a0\u00a0\u00a0cout << c << endl;\n}\n```", "```cpp\nclass C {\n\u00a0\u00a0\u2026\n\u00a0\u00a0C(const C& c) = delete;\n\u00a0\u00a0C(C&& c) = delete;\n};\u00a0\u00a0\n```", "```cpp\nC makeC(int i) { return C(i); }\n```", "```cpp\nC makeC(int i) { C c(i); return std::move(c); }\n```", "```cpp\nC& makeC(int i) { C c(i); return c; } // Never do this!\n```", "```cpp\nstd::unique_ptr<C> makeC(int i) {\n\u00a0\u00a0return std::make_unique<C>(i);\n}\n```", "```cpp\nvoid do_work1(C* c);\nvoid do_work2(const C* c);\nstd::shared_ptr<C> p { new C(\u2026) };\ndo_work1(&*p);\ndo_work2(&*p);\n```", "```cpp\nfor ( \u2026 many iterations \u2026 ) {\n\u00a0\u00a0T* buffer = allocate(\u2026 size \u2026);\n\u00a0\u00a0do_work(buffer); // Computations use memory\n\u00a0\u00a0deallocate(buffer);\n}\n```", "```cpp\nvoid BM_make_str_new(benchmark::State & state) {\n\u00a0\u00a0\u00a0\u00a0const size_t NMax = state.range(0);\n\u00a0\u00a0\u00a0\u00a0for (auto _: state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const size_t N = (random_number() % NMax) + 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0char * buf = new char[N];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memset(buf, 0xab, N);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete[] buf;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0state.SetItemsProcessed(state.iterations());\n}\n```", "```cpp\n\u00a0\u00a0char * buf = new char[NMax];\n\u00a0\u00a0for (auto _: state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026}\n\u00a0\u00a0delete[] buf;\n```", "```cpp\nclass Buffer {\n\u00a0\u00a0size_t size_;\n\u00a0\u00a0std::unique_ptr<char[]> buf_;\n\u00a0\u00a0public:\n\u00a0\u00a0explicit Buffer(size_t N) : size_(N), buf_(\n\u00a0\u00a0\u00a0\u00a0new char[N]) {}\n\u00a0\u00a0void resize(size_t N) { \n\u00a0\u00a0\u00a0\u00a0\u00a0if (N <= size_) return;\n\u00a0\u00a0\u00a0\u00a0\u00a0char* new_buf = new char[N];\n\u00a0\u00a0\u00a0\u00a0\u00a0memcpy(new_buf, get(), size_);\n\u00a0\u00a0\u00a0\u00a0\u00a0buf_.reset(new_buf);\n\u00a0\u00a0\u00a0\u00a0\u00a0size_ = N;\n\u00a0\u00a0}\n\u00a0\u00a0char* get() { return &buf_[0]; }\n};\n```", "```cpp\nvoid BM_make_str_buf(benchmark::State& state) {\n\u00a0\u00a0const size_t NMax = state.range(0);\n\u00a0\u00a0Buffer buf(1);\n\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0const size_t N = (random_number() % NMax) + 1;\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0buf.resize(N);\n\u00a0\u00a0\u00a0\u00a0\u00a0memset(buf.get(), 0xab, N);\n\u00a0\u00a0}\n\u00a0\u00a0state.SetItemsProcessed(state.iterations());\n}\n```", "```cpp\nif (a[i] || b[i] || c[i]) { \u2026 do something \u2026 }\n```", "```cpp\nif (a[i] + b[i] + c[i]) { \u2026 do something \u2026 }\n```", "```cpp\nvoid f2(bool b, unsigned long x, unsigned long& s) {\n\u00a0\u00a0if (b) s += x;\n}\n```", "```cpp\nvoid f2(bool b, unsigned long x, unsigned long& s) {\n\u00a0\u00a0s += b*x;\n}\n```", "```cpp\nBM_conditional\u00a0\u00a0\u00a0176.304M items/s\nBM_branchless\u00a0\u00a0\u00a0\u00a0\u00a0498.89M items/s\n```", "```cpp\nint f(int x) { return (x > 0) ? x : 0; }\n```", "```cpp\nif (condition) f1(\u2026 args \u2026) else f2(\u2026 args \u2026);\n```", "```cpp\nusing func_ptr = int(*)(\u2026 params \u2026);\nstatic const func_ptr f[2] = { &f1, &f2 };\n(*f[condition])(\u2026 args \u2026);\n```"]