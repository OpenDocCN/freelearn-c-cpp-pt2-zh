["```cpp\nstd::atomic<unsigned long> count;\n\u00a0\u00a0\u2026\nfor ( \u2026 counting loop \u2026 ) { // On each thread\n\u00a0\u00a0\u2026 search \u2026 \n\u00a0\u00a0if (\u2026 found \u2026)\n\u00a0\u00a0\u00a0\u00a0count.fetch_add(1, std::memory_order_relaxed));\n}\n```", "```cpp\nunsigned long count;\nstd::mutex M; // Guards count\n\u00a0\u00a0\u2026\n// On each thread\nunsigned long local_count = 0;\nfor ( \u2026 counting loop \u2026 ) {\n\u00a0\u00a0\u2026 search \u2026 \n\u00a0\u00a0if (\u2026 found \u2026) ++local_count;\n}\nstd::lock_guard<std::mutex> L(M);\ncount += local_count;\n```", "```cpp\ntemplate <typename T> class mt_stack {\n\u00a0\u00a0std::stack<T> s_;\n\u00a0\u00a0std::mutex l_;\n\u00a0\u00a0public:\n\u00a0\u00a0mt_stack() = default;\n\u00a0\u00a0void push(const T& v) {\n\u00a0\u00a0\u00a0\u00a0std::lock_guard g(l_);\n\u00a0\u00a0\u00a0\u00a0s_.push(v);\n\u00a0\u00a0}\n\u00a0\u00a0\u2026\n};\n```", "```cpp\nmt_stack<int> s;\n\u00a0\u00a0\u2026 push some data on the stack \u2026 \nint x = 0;\nif (!s.empty()) {\n\u00a0\u00a0x = s.top();\n\u00a0\u00a0s.pop();\n}\n```", "```cpp\ntemplate <typename T> class mt_stack {\n\u00a0\u00a0std::stack<T> s_;\n\u00a0\u00a0std::mutex l_;\n\u00a0\u00a0public:\n\u00a0\u00a0std::optional<T> pop() {\n\u00a0\u00a0\u00a0\u00a0std::lock_guard g(l_);\n\u00a0\u00a0\u00a0\u00a0if (s_.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::optional<T>(std::nullopt);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::optional<T> res(std::move(s_.top()));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s_.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n};\n```", "```cpp\nmt_stack<int> s;\nvoid BM_stack(benchmark::State& state) {\n\u00a0\u00a0const size_t N = state.range(0);\n\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) s.push(i);\n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(s.pop());\n\u00a0\u00a0}\n\u00a0\u00a0state.SetItemsProcessed(state.iterations()*N);\n}\n```", "```cpp\ntemplate <typename T> class mt_stack {\n\u00a0\u00a0std::stack<T> s_;\n\u00a0\u00a0mutable std::mutex l_;\n\u00a0\u00a0public:\n\u00a0\u00a0std::optional<T> top() const {\n\u00a0\u00a0\u00a0\u00a0std::lock_guard g(l_);\n\u00a0\u00a0\u00a0\u00a0if (s_.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::optional<T>(std::nullopt);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::optional<T> res(s_.top());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n};\n```", "```cpp\ntemplate <typename T> class rw_stack {\n\u00a0\u00a0std::stack<T> s_;\n\u00a0\u00a0mutable std::shared_mutex l_;\n\u00a0\u00a0public:\n\u00a0\u00a0void push(const T& v) {\n\u00a0\u00a0\u00a0\u00a0std::unique_lock g(l_);\n\u00a0\u00a0\u00a0\u00a0s_.push(v);\n\u00a0\u00a0}\n\u00a0\u00a0std::optional<T> pop() {\n\u00a0\u00a0\u00a0\u00a0std::unique_lock g(l_);\n\u00a0\u00a0\u00a0\u00a0if (s_.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::optional<T>(std::nullopt);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::optional<T> res(std::move(s_.top()));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s_.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0std::optional<T> top() const {\n\u00a0\u00a0\u00a0\u00a0std::shared_lock g(l_);\n\u00a0\u00a0\u00a0\u00a0if (s_.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::optional<T>(std::nullopt);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::optional<T> res(s_.top());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n};\n```", "```cpp\nstd::atomic<size_t> top_;\n```", "```cpp\nconst size_t top = top_.fetch_add(1);\nnew (&data[top]) Element(\u2026 constructor arguments \u2026 );\n```", "```cpp\nconst size_t top = top_.fetch_sub(1);\nreturn std::move(data[top]);\n```", "```cpp\nstd::atomic<size_t> n;\nvoid BM_stack0_inc(benchmark::State& state) {\n\u00a0\u00a0st_stack<int> s0;\n\u00a0\u00a0const size_t N = state.range(0);\n\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n.fetch_add(1, std::memory_order_release);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s0.push(i);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n.fetch_sub(1, std::memory_order_acquire);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(s0.pop());\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0state.SetItemsProcessed(state.iterations()*N);\n}\n```", "```cpp\nstd::atomic<int> n_ = 0;\nint bounded_fetch_add(int dn, int maxn) {\n\u00a0\u00a0int n = n_.load(std::memory_order_relaxed);\n\u00a0\u00a0do {\n\u00a0\u00a0\u00a0\u00a0if (n + dn >= maxn || n + dn < 0) return -1;\n\u00a0\u00a0} while (!n_.compare_exchange_weak(n, n + dn,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::memory_order_release,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::memory_order_relaxed));\n\u00a0\u00a0return n;\n}\n```", "```cpp\n\u00a0\u00a0int i = 0;\n\u00a0\u00a0while ( \u2026 ) {\n\u00a0\u00a0\u00a0\u00a0if (++i == 8) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0static constexpr timespec ns = { 0, 1 };\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nanosleep(&ns, NULL);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n```", "```cpp\ntemplate <typename T> class mt_stack {\n\u00a0\u00a0std::deque<T> s_;\n\u00a0\u00a0int cap_ = 0;\n\u00a0\u00a0struct counts_t {\n\u00a0\u00a0\u00a0\u00a0int p_ = 0; // Producer index\n\u00a0\u00a0\u00a0\u00a0int c_ = 0; // Consumer index\n\u00a0\u00a0\u00a0\u00a0bool equal(std::atomic<counts_t>& n) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (p_ == c_) return true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*this = n.load(std::memory_order_relaxed);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0};\n\u00a0\u00a0mutable std::atomic<counts_t> n_;\n\u00a0\u00a0public:\n\u00a0\u00a0mt_stack(size_t n = 100000000) : s_(n), cap_(n) {}\n\u00a0\u00a0void push(const T& v);\n\u00a0\u00a0std::optional<T> pop();\n};\n```", "```cpp\nvoid push(const T& v) {\n\u00a0\u00a0counts_t n = n_.load(std::memory_order_relaxed);\n\u00a0\u00a0if (n.p_ == cap_) abort();\n\u00a0\u00a0while (!n.equal(n_) || \n\u00a0\u00a0\u00a0\u00a0!n_.compare_exchange_weak(n, {n.p_ + 1, n.c_},\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::memory_order_acquire,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::memory_order_relaxed)) {\n\u00a0\u00a0\u00a0\u00a0if (n.p_ == cap_) { \u2026 allocate more memory \u2026 }\n\u00a0\u00a0};\n\u00a0\u00a0++n.p_;\n\u00a0\u00a0new (&s_[n.p_]) T(v);\n\u00a0\u00a0assert(n_.compare_exchange_strong(n, {n.p_, n.c_ + 1},\n\u00a0\u00a0\u00a0\u00a0std::memory_order_release, std::memory_order_relaxed);\n}\n```", "```cpp\nstd::optional<T> pop() {\n\u00a0\u00a0counts_t n = n_.load(std::memory_order_relaxed);\n\u00a0\u00a0if (n.c_ == 0) return std::optional<T>(std::nullopt);\n\u00a0\u00a0while (!n.equal(n_) || \n\u00a0\u00a0\u00a0\u00a0!n_.compare_exchange_weak(n, {n.p_, n.c_ - 1},\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::memory_order_acquire,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::memory_order_relaxed)) {\n\u00a0\u00a0\u00a0\u00a0if (n.c_ == 0) return std::optional<T>(std::nullopt);\n\u00a0\u00a0};\n\u00a0\u00a0--n.cc_;\n\u00a0\u00a0std::optional<T> res(std::move(s_[n.p_]));\n\u00a0\u00a0s_[n.pc_].~T();\n\u00a0\u00a0assert(n_.compare_exchange_strong(n, {n.p_ - 1, n.c_},\n\u00a0\u00a0\u00a0\u00a0std::memory_order_release, std::memory_order_relaxed)); \n\u00a0\u00a0return res;\n}\n```", "```cpp\ntemplate <typename T> class mt_queue {\n\u00a0\u00a0std::queue<T> s_;\n\u00a0\u00a0mutable spinlock l_;\n\u00a0\u00a0public:\n\u00a0\u00a0void push(const T& v) {\n\u00a0\u00a0\u00a0\u00a0std::lock_guard g(l_);\n\u00a0\u00a0\u00a0\u00a0s_.push(v);\n\u00a0\u00a0}\n\u00a0\u00a0std::optional<T> pop() {\n\u00a0\u00a0\u00a0\u00a0std::lock_guard g(l_);\n\u00a0\u00a0\u00a0\u00a0if (s_.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::optional<T>(std::nullopt);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::optional<T> res(std::move(s_.front()));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s_.pop();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n};\n```", "```cpp\ntemplate <typename T> class pc_queue {\n\u00a0\u00a0public:\n\u00a0\u00a0explicit pc_queue(size_t capacity) : \n\u00a0\u00a0\u00a0\u00a0capacity_(capacity),\n\u00a0\u00a0\u00a0\u00a0data_(static_cast<T*>(::malloc(sizeof(T)*capacity_))) {}\n\u00a0\u00a0~pc_queue() { ::free(data_); }\n\u00a0\u00a0bool push(const T& v) {\n\u00a0\u00a0\u00a0\u00a0if (size_.load(std::memory_order_relaxed) >= capacity_)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n\u00a0\u00a0\u00a0\u00a0new (data_ + (back_ % capacity_)) T(v);\n\u00a0\u00a0\u00a0\u00a0++back_;\n\u00a0\u00a0\u00a0\u00a0size_.fetch_add(1, std::memory_order_release);\n\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0}\n\u00a0\u00a0std::optional<T> pop() {\n\u00a0\u00a0\u00a0\u00a0if (size_.load(std::memory_order_acquire) == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::optional<T>(std::nullopt);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::optional<T> res(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::move(data_[front_ % capacity_]));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data_[front_ % capacity_].~T();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++front_;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_.fetch_sub(1, std::memory_order_relaxed);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return res;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0private:\n\u00a0\u00a0const size_t capacity_;\n\u00a0\u00a0T* const data_;\n\u00a0\u00a0size_t front_ = 0;\n\u00a0\u00a0size_t back_ = 0;\n\u00a0\u00a0std::atomic<size_t> size_;\n};\n```", "```cpp\npc_queue<size_t> q(1UL<<20);\nvoid BM_queue_prod_cons(benchmark::State& state) {\n\u00a0\u00a0const bool producer = state.thread_index & 1;\n\u00a0\u00a0const size_t N = state.range(0);\n\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0if (producer) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) q.push(i);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(q.pop());\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0state.SetItemsProcessed(state.iterations()*N);\n}\nBENCHMARK(BM_queue_prod_cons)->Arg(1)->Threads(2)\n\u00a0\u00a0->UseRealTime();\nBENCHMARK_MAIN();\n```", "```cpp\nT pop() {\n\u00a0\u00a0T return_value;\n\u00a0\u00a0return_value = data[back];\n\u00a0\u00a0--back;\n\u00a0\u00a0return return_value;\n}\n```", "```cpp\nstd::atomic<int> wait; // 1 if managing memory\nif (wait == 1) {\n\u00a0\u00a0\u2026 wait for memory allocation to complete \u2026\n}\nif ( \u2026 out of memory \u2026 ) {\n\u00a0\u00a0wait = 1;\n\u00a0\u00a0\u2026 allocate more memory \u2026\n\u00a0\u00a0wait = 0;\n}\n\u2026 do the operation normally \u2026 \n```", "```cpp\nstd::atomic<int> wait;\u00a0\u00a0// 1 if managing memory\nstd::mutex lock;\nwhile (wait == 1) {};\u00a0\u00a0// Memory allocation in progress\nif ( \u2026 out of memory \u2026 ) {\n\u00a0\u00a0std::lock_guard g(lock);\n\u00a0\u00a0if (\u2026 out of memory \u2026) { // We got here first!\n\u00a0\u00a0\u00a0wait = 1;\n\u00a0\u00a0\u00a0\u00a0\u2026 allocate more memory \u2026\n\u00a0\u00a0\u00a0wait = 0;\n\u00a0\u00a0}\n}\n\u2026 do the operation normally \u2026 \n```"]