["```cpp\n 1 #include <boost/move/move.hpp>\n 2 #include <boost/swap.hpp>\n 3 #include <cstring>\n 4\n 5 class String\n 6 {\n 7 private:\n 8   BOOST_MOVABLE_BUT_NOT_COPYABLE(String)\n 9\n10 public:\n11   String(const char *s = nullptr) : str(nullptr), sz(0) {\n12     str = heapcpy(s, sz);\n13   }\n14\n15   ~String() {\n16     delete[] str;\n17     sz = 0;\n18   }\n19\n20   String(BOOST_RV_REF(String) that) : str(nullptr), sz(0) {\n21     swap(that);\n22   }\n23\n24   String& operator = (BOOST_RV_REF(String) rhs) {\n25     String tmp(boost::move(rhs));\n28\n29    return *this;\n30   }\n31\n32   void swap(String& rhs) {\n33     boost::swap(this->sz, rhs.sz);\n34     boost::swap(this->str, rhs.str);\n35   }\n36\n37   const char *get() const {\n38     return str;\n39   }\n40\n41 private:\n42   char *str;\n43   size_t sz;\n44\n45  static char *heapcpy(const char *str, size_t& sz) {\n46     char *ret = nullptr;\n47\n48     if (str) {\n49       sz = std::strlen(str) + 1;\n50       ret = new char[sz];\n51       std::strncpy(ret, str, sz);\n52     }\n53\n54     return ret;\n55   }\n56 };\n```", "```cpp\n 1 #include <boost/container/vector.hpp>\n 2 #include \"String.h\"  // for class String\n 3 #include <cassert>\n 4 \n 5 int main() {\n 6   boost::container::vector<String> strVec;\n 7   String world(\"world\");\n 8   // Move temporary (rvalue)\n 9   strVec.push_back(String(\"Hello\"));\n10   // Error, copy semantics needed\n11   //strVec.push_back(world);\n12   // Explicit move\n13   strVec.push_back(boost::move(world));\n14   // world nulled after move\n15   assert(world.get() == nullptr);\n16   // in-place construction\n17   strVec.emplace_back(\"Hujambo Dunia!\"); // Swahili\n18\n19   BOOST_FOREACH(String& str, strVec) {\n20     std::cout <<str.get() << '\\n';\n21   }\n22 }\n```", "```cpp\nHello\nworld\nHujambo Dunia!\n```", "```cpp\n 1 #include <iostream>\n 2 #include <string>\n 3 #include <boost/container/flat_map.hpp>\n 4 \n 5 int main()\n 6 {\n 7   boost::container::flat_map<std::string, std::string> \n 8           newCapitals;\n 9 \n10   newCapitals[\"Sri Lanka\"] = \"Sri Jayawardenepura Kotte\";\n11   newCapitals[\"Burma\"] = \"Naypyidaw\";\n12   newCapitals[\"Tanzania\"] = \"Dodoma\";\n13   newCapitals[\"Cote d'Ivoire\"] = \"Yamoussoukro\"; \n14   newCapitals[\"Nigeria\"] = \"Abuja\";\n15   newCapitals[\"Kazakhstan\"] = \"Astana\";\n16   newCapitals[\"Palau\"] = \"Ngerulmud\";\n17   newCapitals[\"Federated States of Micronesia\"] = \"Palikir\";\n18 \n19   for (const auto& entries : newCapitals) {\n20     std::cout<< entries.first << \": \" << entries.second\n21               << '\\n';\n22   }\n23 }\n```", "```cpp\n 1 #include <boost/container/flat_set.hpp>\n 2 #include <iostream>\n 3 #include <string>\n 4\n 5 template<typename C>\n 6 void printContainerInternals(const C& container) {\n 7   std::cout << \"Container layout\" << '\\n'\n 8             << \"-------------\\n\";\n 9 \n10   for (const auto& elem : container) {\n11     std::cout << \"[Addr=\" << &elem\n12               << \"] : [value=\" << elem << \"]\\n\";\n13   }\n14 }\n15 \n16 int main()\n17 {\n18   boost::container::flat_set<std::string> someStrings;\n19   someStrings.reserve(8);\n20 \n21   someStrings.insert(\"Guitar\");\n22   printContainerInternals(someStrings);\n23 \n24   someStrings.insert(\"Mandolin\");\n25   printContainerInternals(someStrings);\n26 \n27   someStrings.insert(\"Cello\");\n28   printContainerInternals(someStrings);\n29 \n30   someStrings.insert(\"Sitar\");\n31   printContainerInternals(someStrings);\n32 }\n```", "```cpp\n 1 #include <boost/container/slist.hpp>\n 2 #include <iostream>\n 3 #include <string>\n 4 \n 5 int main()\n 6 {\n 7   boost::container::slist<std::string> geologic_eras;\n 8 \n 9   geologic_eras.push_front(\"Neogene\");\n10   geologic_eras.push_front(\"Paleogene\");\n11   geologic_eras.push_front(\"Cretaceous\");\n12   geologic_eras.push_front(\"Jurassic\");\n13   geologic_eras.push_front(\"Triassic\");\n14   geologic_eras.push_front(\"Permian\");\n15   geologic_eras.push_front(\"Carboniferous\");\n16   geologic_eras.push_front(\"Devonian\");\n17   geologic_eras.push_front(\"Silurian\");\n18   geologic_eras.push_front(\"Ordovician\");\n19   geologic_eras.push_front(\"Cambrian\");\n20 \n21   for (const auto& str : geologic_eras) {\n22     std::cout << str << '\\n';\n23   }\n24 }\n```", "```cpp\n 1 #include <boost/container/slist.hpp>\n 2 #include <iostream>\n 3 #include <string>\n 4 #include <cassert>\n 5\n 6 int main()\n 7 {\n 8   boost::container::slist<std::string> eras;\n 9   boost::container::slist<std::string>::iterator last = \n10                                          eras.before_begin();\n11\n12   const char *era_names [] = {\"Cambrian\", \"Ordovician\", \n13                      \"Silurian\", \"Devonian\", \"Carboniferous\", \n14                      \"Permian\", \"Triassic\", \"Jurassic\", \n15                      \"Cretaceous\", \"Paleogene\", \"Neogene\"};\n16\n17   for (const char *period :era_names) {\n18     eras.emplace_after(last, period);\n19     ++last;\n20   }\n21\n22   int i = 0;\n23   for (const auto& str : eras) {\n24     assert(str == era_names[i++]);\n25   }\n26 }\n```", "```cpp\n 1 #include <boost/container/slist.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 \n 5 typedef boost::container::slist<std::string> list_type;\n 6 typedef list_type::iterator iter_type;\n 7 \n 8 int main()\n 9 {\n10   list_type dinos;\n11   iter_type last = dinos.before_begin();\n12 \n13   const char *dinoarray[] = {\"Elasmosaurus\", \"Fabrosaurus\",\n14                        \"Galimimus\", \"Hadrosaurus\", \"Iguanodon\",\n15                        \"Appatosaurus\", \"Brachiosaurus\",\n16                        \"Corythosaurus\", \"Dilophosaurus\"};\n17 \n18   // fill the slist\n19   for (const char *dino : dinoarray) {\n20     dinos.insert_after(last, dino);\n21     ++last;\n22   }\n23 \n24   // find the pivot\n25   last = dinos.begin();\n26   iter_type iter = last;\n27\n28   while (++iter != dinos.end()) {\n29     if (*last > *iter) {\n30       break;\n31     }\n32     ++last;\n33   }\n34 \n35   // find the end of the tail\n36   auto itend = last;\n37   while (iter != dinos.end()) {\n38     ++itend;\n39     ++iter;\n40   }\n41\n42   // splice after\n43   dinos.splice_after(dinos.before_begin(), dinos,\n44                   last, itend);\n45   for (const auto& str: dinos) {\n46    std::cout <<str<< '\\n';\n47   }\n48 }\n```", "```cpp\nvoid splice_after(const_iterator add_after, slist& source,\n          const_iterator start_after, const_iterator end);\n```", "```cpp\n35   // find the end of the tail\n36   size_t count = 0;\n37   auto itend = last;\n38\n39   while (iter != dinos.end()) {\n40     ++itend;\n41     ++iter;\n42     ++count;\n43   }\n44\n45   // splice after\n46   dinos.splice_after(dinos.before_begin(), dinos,\n47                   last, itend, count);\n\n```", "```cpp\nvoid splice_after(const_iterator pos, std::forward_list& list,const_iterator before_first, const_iterator after_last);\n```", "```cpp\n37   dinos.splice_after(dinos.before_begin(), dinos,\n38                      last, dinos.end());\n```", "```cpp\n 1 #include <vector>\n 2 #include <cassert>\n 3 \n 4 int main() {\n 5   std::vector<int>v{1, 2, 3, 5};\n 6   auto first = v.begin();\n 7   auto last = first + v.size() - 1;\n 8   assert(*last == 5);\n 9   v.insert(last, 4);\n10   // *last = 10;  // undefined behavior, invalid iterator\n11   for (int i = 0; i < 1000; ++i) {\n12     v.push_back(i);\n13   }\n14 \n15   // *first = 0; // likely invalidated\n16 }\n```", "```cpp\n 1 #include <boost/container/stable_vector.hpp>\n 2 #include <cassert>\n 3 #include <string>\n 4\n 5 int main()\n 6 {\n 7   const char *cloud_names[] = {\"cumulus\", \"cirrus\", \"stratus\",\n 8                 \"cumulonimbus\", \"cirrostratus\", \"cirrocumulus\",\n 9                 \"altocumulus\", \"altostratus\"};\n10\n11   boost::container::stable_vector<std::string> clouds;\n12   clouds.reserve(4);\n13   clouds.resize(4);   // To circumvent a bug in Boost 1.54\n14\n15   size_t name_count = sizeof(cloud_names)/sizeof(const char*);\n16   size_t capacity = clouds.capacity();\n17\n18   size_t i = 0;\n19   for (i = 0; i < name_count && i < capacity; ++i) {\n20     clouds[i] = cloud_names[i];\n21   }\n22\n23   auto first = clouds.begin();\n24\n25   for (; i < name_count; ++i) {\n26     clouds.push_back(cloud_names[i]);\n27   }\n28\n29   auto sixth = clouds.begin() + 5;\n30\n31   // 1 erase @4\n32   clouds.erase(clouds.begin() + 4);\n33   // 2 inserts @3\n34   clouds.insert(clouds.begin() + 3, \"stratocumulus\");\n35   clouds.insert(clouds.begin() + 3, \"nimbostratus\");\n36\n37   assert(*first == cloud_names[0]);\n38   assert(sixth == clouds.begin() + 6); // not +5\n39   assert(*sixth == cloud_names[5]);\n40 }\n```", "```cpp\n 1 #include <boost/current_function.hpp>\n 2 #include <boost/container/static_vector.hpp>\n 3 #include <iostream>\n 4\n 5 class ChattyInit\n 6 {\n 7 public:\n 8   ChattyInit() {\n 9     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n10   }\n11 };\n12\n13 int main()\n14 {\n15   boost::container::static_vector<ChattyInit, 10> myvector;\n16   std::cout << \"boost::container::static_vector initialized\"\n17             <<'\\n';\n18   while (myvector.size() < myvector.capacity()) {\n19     myvector.push_back(ChattyInit());\n20   }\n21\n22   // cisv.push_back(ChattyInit()); // runtime error\n23 }\n```", "```cpp\nboost::container::static_vector initialized\nChattyInit::ChattyInit()\nChattyInit::ChattyInit()\n\u2026 8 more lines \u2026\n```", "```cpp\nstd::vector<ChattyInit> myvector(10); // 10 elems value-inited\nassert(myvector.size() == 10);\n```", "```cpp\n 1 #include <string>\n 2 #include <tuple>\n 3 \n 4 struct Person  {\n 5   std::string name;\n 6   int age;\n 7   std::string profession;\n 8   std::string nationality;\n 9 };\n10\n11 bool operator < (const Person& p1, const Person& p2)\n12 {\n13   return std::tie(p1.nationality, p1.name, p1.age)\n14          < std::tie(p2.nationality, p2.name, p2.age);\n15 }\n```", "```cpp\n 1 #include <boost/unordered_set.hpp>\n 2 #include <boost/functional/hash.hpp>\n 3 #include <iostream>\n 4 #include <cassert>\n 5 #include \"Person.h\" // struct Person definition\n 6\n 7 bool operator==(const Person& left, const Person& right){\n 8   return (left.name == right.name\n 9          && left.age == right.age\n10          && left.profession == right.profession\n11          && left.nationality == right.nationality);\n12 }\n13\n14 namespace boost\n15 {\n16   template <>\n17   struct hash<Person>\n18   {\n19     size_t operator()(const Person& person) const{\n20       size_t hash = 0;\n21       boost::hash_combine(hash, \n22                          boost::hash_value(person.name)); \n23       boost::hash_combine(hash, \n24                        boost::hash_value(person.nationality)); \n25       return hash;\n26     }\n27   };\n28 }\n29\n30 int main() {\n31   boost::unordered_set<Person> persons;\n32\n33   Person p{\"Ned Land\", 40, \"Harpooner\",\"Canada\"};\n34   persons.insert(p); // succeeds\n35\n36   Person p1{\"Ned Land\", 32, \"C++ Programmer\",\"Canada\"};\n37   persons.insert(p1);  // succeeds\n38\n39   assert(persons.find(p) != persons.end());\n40   assert(persons.find(p1) != persons.end());\n41\n42   Person p2 = p;\n43   persons.insert(p2);   // fails\n44   assert(persons.size() == 2);\n45 }\n```", "```cpp\n1 #include <boost/ptr_container/ptr_vector.hpp>\n 2 #include <boost/noncopyable.hpp>\n 3 #include <iostream>\n 4 #include <boost/current_function.hpp>\n 5\n 6 class AbstractJob {\n 7 public:\n 8   virtual ~AbstractJob() {}\n 9\n10   void doJob() {\n11     doStep1();\n12     doStep2();\n13   }\n14\n15 private:\n16   virtual void doStep1() = 0;\n17   virtual void doStep2() = 0;\n18 };\n19\n20 class JobA : public AbstractJob\n21 {\n22   void doStep1() override {\n23     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n24   }\n25\n26   void doStep2() override {\n27     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n28   }\n29 };\n30\n31 class JobB : public AbstractJob\n32 {\n33   void doStep1() override {\n34     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n35   }\n36\n37   void doStep2() override {\n38     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n39   }\n40 };\n41\n42 int main()\n43 {\n44   boost::ptr_vector<AbstractJob> basePtrVec;\n45\n46   basePtrVec.push_back(new JobA);\n47   basePtrVec.push_back(new JobB);\n48\n49   AbstractJob& firstJob = basePtrVec.front();\n50   AbstractJob& lastJob = basePtrVec.back();\n51\n52   for (auto& job : basePtrVec) {\n53     job.doJob();\n54   }\n55 }\n```", "```cpp\n49   typedef boost::ptr_vector<AbstractJob>::iterator iter_t;\n50 \n51   for (iter_t it = basePtrVec.begin(); \n52        it != basePtrVec.end(); ++it) {\n53     AbstractJob& job = *it;\n54     job.do();\n55   }\n```", "```cpp\n 1 struct ConcreteBase\n 2 {\n 3   virtual void doWork() {}\n 4 };\n 5\n 6 struct Derived1 : public ConcreteBase\n 7 {\n 8   Derived1(int n) : data(n) {}\n 9   void doWork() override { std::cout <<data <<\"\\n\"; }\n10   int data;\n11 };\n12\n13 struct Derived2 : public ConcreteBase\n14 {\n15   Derived2(int n) : data(n) {}\n16   void doWork() override { std::cout <<data << \"\\n\"; }\n17   int data;\n18 };\n19\n20 int main()\n21 {\n22   boost::ptr_vector<ConcreteBase> vec;\n23   typedef boost::ptr_vector<ConcreteBase>::iterator iter_t;\n24                                                     \n25   vec.push_back(new Derived1(1));\n26   vec.push_back(new Derived2(2));\n27\n28   for (iter_t it = vec.begin(); it != vec.end(); ++it) {\n29     ConcreteBase obj = *it;\n30     obj.doWork();\n31   }\n32 }\n```", "```cpp\n 1 #include <boost/noncopyable.hpp>\n 2 \n 3 class ConcreteBase : public boost::noncopyable\n```", "```cpp\n 1 #include <boost/ptr_container/ptr_set.hpp>\n 2 #include <boost/noncopyable.hpp>\n 3 #include <string>\n 4 #include <iostream>\n 5 \n 6 class Animal : boost::noncopyable\n 7 {\n 8 public:\n 9   virtual ~Animal()\n10   {};\n11 \n12   virtual std::string name() const = 0;\n13 };\n14 \n15 class SnowLeopard : public Animal\n16 {\n17 public:\n18   SnowLeopard(const std::string& name) : name_(name) {}\n19 \n20   virtual ~SnowLeopard() { std::cout << \"~SnowLeopard\\n\"; }\n21 \n22   std::string name() const override\n23   {\n24     return name_ + \", the snow leopard\";\n25   }\n26 \n27 private:\n28   std::string name_;\n29 };\n30 \n31 class Puma : public Animal\n32 {\n33 public:\n34   Puma(const std::string& name) : name_(name) {}\n35   virtual ~Puma() { std::cout << \"~Puma\\n\"; }\n36 \n37   virtual std::string name() const\n38   {\n39     return name_ + \", the puma\";\n40   }\n41 \n42 private:\n43   std::string name_;\n44 };\n45 \n46 bool operator<(const Animal& left, const Animal& right)\n47 {\n48   return left.name() < right.name();\n49 }\n50 \n51 int main()\n52 {\n53   boost::ptr_set<Animal>animals;\n54   animals.insert(new Puma(\"Kaju\"));\n55   animals.insert(new SnowLeopard(\"Rongi\"));\n56   animals.insert(new Puma(\"Juki\"));\n57 \n58   for (auto&animal :animals) {\n59     std::cout <<animal.name() << '\\n';\n60   }\n61 }\n```", "```cpp\nJuki, the puma\nKaju, the puma\nRongi, the snow leopard\n~Puma\n~Puma\n~SnowLeopard\n```", "```cpp\n 1 #include <boost/ptr_container/ptr_map.hpp>\n 2 #include <iostream>\n 3 // include definitions of Animal, SnowLeopard, Puma\n 4 \n 5 int main() {\n 6   boost::ptr_multimap<std::string, Animal> animals;\n 7   std::string kj = \"Puma\";\n 8   std::string br = \"Snow Leopard\";\n 9 \n10   animals.insert(kj, new Puma(\"Kaju\"));\n11   animals.insert(br, new SnowLeopard(\"Rongi\"));\n12   animals.insert(kj, new Puma(\"Juki\"));\n13 \n14   for (const auto&entry : animals) {\n15     std::cout << \"[\" << entry.first << \"]->\" \n16               << entry.second->name() << '\\n';\n17   }\n18 }\n```", "```cpp\n[SnowLeopard]->Rongi, the snow leopard\n[Puma]->Kaju, the puma\n[Puma]->Juki, the puma\n```", "```cpp\n1 namespace X {\n2   // definition of T\n3   ...\n4 \n5   T* new_clone(const T& obj);\n6 }\n```", "```cpp\n1 #include <boost/ptr_container/ptr_vector.hpp>\n 2 #include <boost/noncopyable.hpp>\n 3 #include <string>\n 4 #include <iostream>\n 5 \n 6 namespace nature\n 7 {\n 8 \n 9 class Animal : boost::noncopyable\n10 {\n11 public:\n12   // ...\n13   virtual Animal *clone() const = 0;\n14 };\n15 \n16 class SnowLeopard : public Animal\n17 {\n18 public:\n19   // ...\n20   SnowLeopard *clone() const override\n21   {\n22     return new SnowLeopard(name_);\n23   }\n24 \n25 private:\n26   std::string name_;\n27 };\n28 \n29 class Puma : public Animal\n30 {\n31 public:\n32   // ...\n33   Puma *clone() const override\n34   {\n35     return new Puma(name_);\n36   }\n37 \n38 private:\n39   std::string name_;\n40 };\n41 \n42 Animal *new_clone(const Animal& animal)\n43 {\n44   return animal.clone();\n45 }\n46 \n47 } // end of namespace nature\n48 \n49 int main()\n50 {\n51   boost::ptr_vector<nature::Animal> animals, animals2;\n52 \n53   animals.push_back(new nature::Puma(\"Kaju\"));\n54   animals.push_back(new nature::SnowLeopard(\"Rongi\"));\n55   animals.push_back(new nature::Puma(\"Juki\"));\n56 \n57   animals2 = animals.clone();\n58 \n59   for (auto&animal : animals2) {\n60     std::cout <<animal.name() << '\\n';\n61   }\n62 }\n```", "```cpp\n57   animals2 = animals;\n```", "```cpp\n 1 #include <boost/ptr_container/ptr_vector.hpp>\n 2 #include <boost/ptr_container/ptr_list.hpp>\n 3 #include <cassert>\n 4 #include <iostream>\n 5 // definitions of Animal, SnowLeopard, Puma in namespace nature \n 6 \n 7 int main()\n 8 {\n 9   boost::ptr_vector<nature::Animal> mountA;\n10   boost::ptr_vector<nature::Animal> mountB;\n11   boost::ptr_list<nature::Animal> mountC;\n12 \n13   mountA.push_back(new nature::Puma(\"Kaju\"));\n14   mountA.push_back(new nature::SnowLeopard(\"Rongi\"));\n15   mountA.push_back(new nature::Puma(\"Juki\"));\n16   mountA.push_back(new nature::SnowLeopard(\"Turo\"));\n17 \n18   size_t num_animals = mountA.size();\n19 \n20   for (auto&animal : mountA) {\n21     std::cout << \"MountA: \" <<animal.name() << '\\n';\n22   }\n23 \n24   // Move all contents\n25   mountB = mountA.release();\n26   assert(mountA.size() == 0);\n27   assert(mountB.size() == num_animals);\n28 \n29   // move one element\n30   mountC.transfer(mountC.begin(), mountB.begin() + 1, mountB);\n31   assert(mountB.size() == num_animals - 1);\n32   assert(mountC.size() == 1);\n33 \n34   // move one element, second way\n35   auto popped = mountB.pop_back();\n36   mountC.push_back(popped.release());\n37 \n38   assert(mountB.size() + mountC.size() == num_animals);\n39   assert(mountC.size() == 2);\n40 \n41   // move a range of elements\n42   mountC.transfer(mountC.end(), mountB.begin(),\n43                   mountB.end(), mountB);\n44   assert(mountB.size() + mountC.size() == num_animals);\n45   assert(mountC.size() == num_animals);\n46 \n47   for (auto&animal : mountC) {\n48     std::cout << \"MountC: \" <<animal.name() << '\\n';\n49   }\n50 }\n```", "```cpp\n33   boost::ptr_vector<nature::Animal>::auto_type popped = \n34                                           mountB.pop_back();\n```", "```cpp\nboost::ptr_container<boost::nullable<Animal>> animals;\n```", "```cpp\nboost::ptr_container< Animal> animals;\n```", "```cpp\n 1 std::ptr_vector< boost::nullable<Animal>> animalsAndNulls;\n 2 ... // assign animals\n 3\n 4 for (auto it = animalsAndNulls.begin();\n 5 it != animalsAndNulls.end(); ++it)\n 6 {\n 7    if (!boost::is_null(it)) {\n 8      Animal& a = *it;\n 9      // do stuff ...\n10    }\n11 }\n```", "```cpp\n 1 #include <string>\n 2 #include <vector>\n 3 #include <boost/assign.hpp>\n 4 #include <cassert>\n 5\n 6 using namespace boost::assign;\n 7\n 8 int main()\n 9 {\n10   std::vector<std::string>greetings;\n11   greetings += \"Good morning\", \"Buenos dias\", \"Bongiorno\";\n12   greetings += \"Boker tov\", \"Guten Morgen\", \"Bonjour\";\n13\n14   assert(greetings.size() == 6);\n15 }\n```", "```cpp\n 1 #include <string>\n 2 #include <map>\n 3 #include <list>\n 4 #include <deque>\n 5 #include <boost/assign.hpp>\n 6 #include <iostream>\n 7 #include <boost/tuple/tuple.hpp>\n 8\n 9 using namespace boost::assign;\n10\n11 int main(){\n12   std::deque<std::string>greets;\n13   push_front(greets) = \"Good night\", \"Buenas noches\", \n14       \"Bounanotte\", \"Lyla tov\", \"Gute nacht\", \"Bonne nuit\";\n15\n16   std::map<std::string, std::string> rockCharacters;\n17   insert(rockCharacters)\n18         (\"John Barleycorn\", \"must die\")       // Traffic\n19         (\"Eleanor Rigby\", \"lives in a dream\") // Beatles\n20         (\"Arnold Layne\", \"had a strange hobby\")   // Floyd\n21         (\"Angie\", \"can't say we never tried\")    // Stones\n22         (\"Harry\", \"play the honkytonk\"); // Dire Straits\n23\n24   std::list<boost::tuple<std::string, std::string, \n25                         std::string>> trios;\n25   push_back(trios)(\"Athos\", \"Porthos\", \"Aramis\")\n26                   (\"Potter\", \"Weasley\", \"Granger\")\n27                   (\"Tintin\", \"Snowy\", \"Haddock\")\n28                   (\"Geller\", \"Bing\", \"Tribbiani\")\n29                   (\"Jones\", \"Crenshaw\", \"Andrews\");\n30\n31   std::cout << \"Night greets:\\n\";\n32   for (const auto& greet: greets) {\n33     std::cout << greet << '\\n';\n34   }\n35\n36   std::cout << \"\\nPeople:\\n\";\n37   for (const auto&character: rockCharacters) {\n38     std::cout << character.first << \": \"\n39               << character.second << '\\n';\n40   }\n41\n42   std::cout << \"Trios:\\n\";\n43   for (auto& trio: trios) {\n44     std::cout << boost::get<0>(trio) << \", \" \n45               << boost::get<1>(trio) << \", \" \n46               << boost::get<2>(trio) << '\\n';\n47   }\n48 }\n```", "```cpp\nNight greets:\nBonne nuit\nGute nacht\nLyla tov\nBounanotte\nBuenas noches\nGood night\nPeople:\nAngie: can't say we never tried\nArnold Layne: had a strange hobby\nEleanor Rigby: lives in a dream\nJohn Barleycorn: must die\nHarry: play the honkytonk\nPeople:\nAthos,Porthos, Aramis\nPotter,Weasley, Granger\nTintin,Snowy, Haddock\nJones,Crenshaw, Andrews\n```", "```cpp\n 1 #include <boost/assign.hpp>\n 2 #include <boost/rational.hpp>\n 3 #include <iterator>\n 4 \n 5 using namespace boost::assign;\n 6 \n 7 int main()\n 8 {\n 9   std::cout << \"Catalan numbers:\\n\";\n10   const std::vector<int> catalan = list_of(1)(1)(2)(5)\n11                        (14)(42) (132)(429)(1430)(4862);\n12\n13   std::ostream_iterator<int>os(std::cout, \" \");\n14   std::copy(catalan.begin(), catalan.end(), os);\n15\n16   std::cout << \"\\nBernoulli numbers:\\n\";\n17   const std::map<int, boost::rational<int>>bernoulli = \n18                       map_list_of(0, boost::rational<int>(1))\n19                             (1, boost::rational<int>(1, 2))\n20                             (2, boost::rational<int>(1, 6))\n21                             (3, boost::rational<int>(0))\n22                             (4, boost::rational<int>(-1, 30))\n23                             (5, boost::rational<int>(0))\n24                             (6, boost::rational<int>(1, 42))\n25                             (7, boost::rational<int>(0));\n26\n27   for (auto&b : bernoulli) {\n28     std::cout << 'B' << b.first << \": \" << b.second << \", \";\n29   }\n30   std::cout << '\\n';\n31 }\n```", "```cpp\nCatalan numbers:\n1 1 2 5 14 42 132 429 1430 4862\nBernoulli numbers:\nB0: 1/1, B1: 1/2, B2: 1/6, B3: 0/1, B4: -1/30, B5: 0/1, B6: 1/42, B7: 0/1,\n```", "```cpp\n1 #include <boost/assign.hpp>\n 2 #include <iostream>\n 3 \n 4 using namespace boost::assign;\n 5 \n 6 template<typename RangeType>\n 7 int inspect_range(RangeType&& rng)\n 8 {\n 9   size_t sz = boost::size(rng);\n10 \n11   if (sz > 0) {\n12     std::cout << \"First elem: \" << *boost::begin(rng) << '\\n';\n13     std::cout <<\"Last elem: \" << *(boost::end(rng) - 1) << '\\n';\n14   }\n15 \n16   return sz;\n17 }\n18 \n19 int main()\n20 {\n21   std::cout << inspect_range(\n22                  cref_list_of<10>(1)(2)(3)(4)(5)(6)(7)(8));\n23 \n24   typedef std::map<std::string, std::string> strmap_t;\n25   strmap_t helloWorlds =\n26          cref_list_of<3, strmap_t::value_type>\n27             (strmap_t::value_type(\"hello\", \"world\"))\n28             (strmap_t::value_type(\"hola\", \"el mundo\"))\n29             (strmap_t::value_type(\"hallo\", \"Welt\"));\n30 }\n```", "```cpp\n 1 std::vector<std::string>scholars{\"Ibn Sina\", \"Ibn Rushd\",\n 2                                   \"Al Khwarizmi\", \"Al Kindi\"};\n 3std::map<std::string, std::string> scholarsFrom\n 4={{scholars[0], \"Bukhara\"},\n 5      {scholars[1], \"Cordoba\"},\n 6{scholars[2], \"Khwarezm\"},\n 7                             {scholars[3], \"Basra\"}};\n```", "```cpp\n 1 #include <boost/ptr_container/ptr_vector.hpp>\n 2 #include <boost/ptr_container/ptr_map.hpp>\n 3 #include <boost/assign/ptr_list_inserter.hpp>\n 4 #include <boost/assign/ptr_map_inserter.hpp>\n 5 #include <boost/assign/ptr_list_of.hpp>\n 6 #include <string>\n 7 #include <iostream>\n 8 \n 9 using namespace boost::assign;\n10 \n11 struct WorkShift\n12 {\n13   WorkShift(double start = 9.30, double end = 17.30)\n14     : start_(start), end_(end)\n15   {}\n16 \n17   double start_, end_;\n18 };\n19 \n20 std::ostream& operator<<(std::ostream& os, const WorkShift& ws)\n21 {\n22   return os << \"[\" << ws.start_ <<\" till \" << ws.end_ << \"]\";\n23 }\n24 \n25 int main()\n26 {\n27   boost::ptr_vector<WorkShift> shifts = ptr_list_of<WorkShift>\n28                               (6.00, 14.00)();\n29   ptr_push_back(shifts)(14.00, 22.00)(22.00, 6.00);\n30 \n31   boost::ptr_map<std::string, WorkShift> shiftMap;\n32   ptr_map_insert(shiftMap)(\"morning\", 6.00, 14.00)(\"day\")\n33             (\"afternoon\", 14.00, 22.00)(\"night\", 22.00, 6.00);\n34 \n35   for (const auto& entry: shiftMap) {\n36     std::cout << entry.first <<\" \" <<shiftMap.at(entry.first)\n37               << '\\n';\n38   }\n39 }\n```", "```cpp\nafternoon [14 till 22]\ngeneral [9.3 till 17.3]\nmorning [6 till 14]\nnight [22 till 6]\n```", "```cpp\n 1 boost::ptr_vector<WorkShift> shifts;\n 2 boost::assign:push_back(shifts)(new WorkShift())\n 3                              (new WorkShift(6.00, 14.00));\n```", "```cpp\n 1 boost::ptr_vector<WorkShift> shifts;\n 2 WorkShift *w1 = new WorkShift(6.00, 14.00);\n 3 WorkShift *w2 = new WorkShift();\n 4 boost::assign::push_back(shifts)(w2)(w1);\n```", "```cpp\n1 boost::ptr_vector<WorkShift> shifts;\n2 boost::assign::ptr_push_back(shifts)()(6.00, 14.00);\n```", "```cpp\n 1 #include <boost/iterator/filter_iterator.hpp>\n 2 #include <boost/assign.hpp>\n 3 #include <vector>\n 4 #include <string>\n 5 #include <iostream>\n 6\n 7 struct Person\n 8 {\n 9   std::string name;\n10   int age;\n11   std::string bank_ac_no;\n12\n13   Person(const std::string& name, int years,\n14          const std::string& ac_no) : \n15          name(name), age(years), bank_ac_no(ac_no) {}\n16 };\n17\n17 void payout(double sum, const std::string& ac_no) {\n19   std::cout << \"Credited a sum of \"<< sum\n20             <<\" to bank account number \" << ac_no << '\\n';\n21 }\n22\n23 template<typename Itertype>\n24 void creditSum(Itertype first, Itertype last, double sum)\n25 {\n26   while (first != last) {\n27     payout(sum, first->bank_ac_no);\n28     first++;\n29   }\n30 }\n31\n32 bool seventyOrOlder(const Person& person)\n33 {\n34   return person.age >= 70;\n35 }\n36\n37 int main()\n38 {\n39   std::vector<Person> people{{\"A Smith\", 71, \"5702750\"},\n40                 {\"S Bates\", 56, \"3920774\"}, \n41                 {\"L Townshend\", 73, \"9513914\"}, \n42                 {\"L Milford\", 68, \"1108419\"}, \n43                 {\"F Cornthorpe\", 81, \"8143919\"}}; \n44                 \n45   auto first = boost::make_filter_iterator(seventyOrOlder,\n46                                people.begin(), people.end());\n47\n48   auto last = boost::make_filter_iterator(seventyOrOlder,\n49                                people.end(), people.end());\n50\n51   creditSum(first, last, 100);\n52 }\n```", "```cpp\n 1 #include <iostream>\n 2 #include <string>\n 3 #include <vector>\n 4 #include <map>\n 5 #include <algorithm>\n 6 #include <functional>\n 7 #include <boost/assign.hpp>\n 8 #include <boost/iterator/transform_iterator.hpp>\n 9 #include <numeric> // for std::accumulate\n10 using namespace boost::assign;\n11\n12 typedef std::map<std::string, int> scoremap;\n13\n14 struct GetScore : std::unary_function<\n15                         const scoremap::value_type&, int>\n16 {\n17   result_type operator()(argument_type entry) const\n18   {\n19     return entry.second;\n20   }\n21 };\n22\n23 int main()\n24 {\n25   scoremap subjectScores{{\"Physics\", 80}, {\"Chemistry\", 78},\n26                      {\"Statistics\", 88}, {\"Mathematics\", 92}};\n27\n28   boost::transform_iterator<GetScore,\n29                             scoremap::iterator>\n30                      first(subjectScores.begin(), GetScore()),\n31                      last(subjectScores.end(), GetScore());\n32\n33   std::cout << std::accumulate(first, last, 0) << '\\n';\n34 }\n```", "```cpp\n 1 #include <iostream>\n 2 #include <string>\n 3 #include <vector>\n 4 #include <algorithm>\n 5 #include <boost/assign.hpp>\n 6 #include <boost/function_output_iterator.hpp>\n 7\n 8 struct StringCat\n 9 {\n10   StringCat(std::string& str) : result_(str) {}\n11\n12   void operator()(const std::string& arg) {\n13     if (arg.find_first_of(\" \\t\") != std::string::npos) {\n14       result_ += \" \\\"\" + arg + \"\\\"\";\n15     } else {\n16       result_ += \" \" + arg;\n17     }\n18   }\n19\n20   std::string& result_;\n21 };\n22\n23 int main()\n24 {\n25   std::vector<std::string> dirs{\"photos\", \"videos\",\n26                             \"books\", \"personal docs\"};\n27 \n28   std::string dirString = \"\";\n29   std::copy(dirs.begin(), dirs.end(),\n30            boost::make_function_output_iterator(\n31   StringCat(dirString)));\n32   std::cout << dirString << '\\n';\n33 }\n```", "```cpp\nphotos videos books \"personal docs\"\n```", "```cpp\n  1 #include <iostream>\n  2 #include <algorithm>\n  3 #include <vector>\n  4 #include <boost/assign.hpp>\n 5 #include <boost/iterator.hpp>\n 6 #include <boost/iterator/iterator_facade.hpp>\n  7\n  8 template<typename T>\n  9 struct TreeNode\n 10 {\n 11   T data;\n 12   TreeNode<T> *left, *right;\n 13   TreeNode<T> *prev, *next;\n 14\n 15   TreeNode(const T& elem) : data(elem),\n 16          left(nullptr), right(nullptr),\n 17          prev(nullptr), next(nullptr)\n 18   {}\n 19\n 20   ~TreeNode()\n 21   {\n 22     delete left;\n 23     delete right;\n 24   }\n 25 };\n 26\n 27 template<typename T>\n 28 class BSTIterator :\n 29   public boost::iterator_facade <BSTIterator<T>, T,\n 30                   boost::bidirectional_traversal_tag>\n 31 {\n 32 public:\n 33   BSTIterator() : node_ptr(nullptr) {}\n 34   explicit BSTIterator(TreeNode<T> *node) :\n 35      node_ptr(node) {}\n 36   BSTIterator(const BSTIterator<T>& that) :\n 37      node_ptr(that.node_ptr) {}\n 38\n 39 private:\n 40   TreeNode<T> *node_ptr;\n 41\n 42   friend class boost::iterator_core_access;\n 43\n 44   void increment() { node_ptr = node_ptr->next; }\n 45   void decrement() { node_ptr = node_ptr->prev; }\n 46\n 47   bool equal(const BSTIterator<T>& that) const {\n 48     return node_ptr == that.node_ptr;\n 49   }\n 50\n 51   T& dereference() const { return node_ptr->data; }\n 52 };\n 53\n 54 template<typename T>\n 55 class BinarySearchTree\n 56 {\n 57 public:\n 58   BinarySearchTree() : root(nullptr), first(nullptr),\n 59                        last(nullptr) {}\n 60   ~BinarySearchTree() {\n 61     delete root;\n 62     delete last;\n 63   }\n 64\n 65   void insert(const T& elem) {\n 66     if (!root) {\n 67       root = new TreeNode<T>(elem);\n 68       first = root;\n 69       last = new TreeNode<T>(T());\n 70       first->next = last;\n 71       last->prev = first;\n 72     } else {\n 73       insert(elem, root);\n 74     }\n 75   }\n 76\n 77   BSTIterator<T>begin() { return BSTIterator<T>(first); }\n 78   BSTIterator<T>end() { return BSTIterator<T>(last); }\n 79\n 80   BSTIterator<T>begin() const {\n 81     return BSTIterator<const T>(first);\n 82   }\n 83   BSTIterator<T>end() const {\n 84     return BSTIterator<const T>(last);\n 85   }\n 86\n 87 private:\n 88   TreeNode<T> *root;\n 89   TreeNode<T> *first;\n 90   TreeNode<T> *last;\n 91\n 92   void insert(const T& elem, TreeNode<T> *node) {\n 93     if (elem < node->data) {\n 94       if (node->left) {\n 95         insert(elem, node->left);\n 96       } else {\n 97         node->left = new TreeNode<T>(elem);\n 98         node->left->prev = node->prev;\n 99         node->prev = node->left;\n100         node->left->next = node;\n101\n102         if (!node->left->prev) {\n103           first = node->left;\n104         } else {\n105           node->left->prev->next = node->left;\n106         }\n107       }\n108     } else if (node->data < elem) {\n109       if (node->right) {\n110         insert(elem, node->right);\n111       } else {\n112         node->right = new TreeNode<T>(elem);\n113         node->right->next = node->next;\n114         node->next = node->right;\n115         node->right->prev = node;\n116\n117         if (node->right->next) {\n118           node->right->next->prev = node->right;\n119         }\n120       }\n121     }\n122   }\n123 };\n```", "```cpp\n125 int main() \n126 {\n127   BinarySearchTree<std::string> bst;\n128   bst.insert(\"abc\");\n129   bst.insert(\"def\");\n130   bst.insert(\"xyz\");\n131\n132   for(auto& x: bst) {\n133     std::cout << x << '\\n';\n134   }\n135 }\n```", "```cpp\nif (it == container.end())\n```"]