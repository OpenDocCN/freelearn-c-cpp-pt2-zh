["```cpp\n 1 struct Book\n 2 {\n 3   Book(const std::string& id,\n 4        const std::string& name,\n 5        const std::string& auth)\n 6         : isbn(id), title(name), author(auth)\n 7   {}\n 8\n 9   std::string isbn;\n10   std::string title;\n11   std::string author;\n12 };\n13\n14 bool operator< (const Book& lhs, const Book& rhs)\n12 {  return lhs.isbn < rhs.isbn;  }\n```", "```cpp\n 1 #include <vector>\n 2 #include <string>\n 3 #include <algorithm>\n 4 #include <iostream>\n 5\n 6 // include the definition of struct Book\n 7 \n 8 int main()\n 9 {\n10   std::vector<Book> books;\n11   books.emplace_back(\"908..511..123\", \"Little Prince\",\n12                      \"Antoine St. Exupery\");\n13   books.emplace_back(\"392..301..109\", \"Nineteen Eighty Four\",\n14                      \"George Orwell\");\n15   books.emplace_back(\"872..610..176\", \"To Kill a Mocking Bird\",\n16                      \"Harper Lee\");\n17   books.emplace_back(\"392..301..109\", \"Animal Farm\",\n18                      \"George Orwell\");\n19\n20   std::sort(books.begin(), books.end());\n21 }\n```", "```cpp\n 1 bool byDescendingISBN(const Book& lhs, const Book& rhs)\n 2 {  return lhs.isbn > rhs.isbn; }\n 3 \n 4 ...\n 5 std::vector<Book> books;\n 6 ...\n 7 std::sort(books.begin(), books.end(), byDescendingISBN);\n```", "```cpp\n 1 ...\n 2 struct CompareBooks\n 3 {\n 4   bool operator()(const Book& b1, const Book& b2) const {\n 5     return (b1.author < b2.author)\n 6            || (b1.author == b2.author \n 7                && b1.title < b2.title);\n 8   }\n 9 };\n10\n11 ...\n12 std::vector<Book> books;\n13 ...\n14 std::sort(books.begin(), books.end(), CompareBooks());\n```", "```cpp\n 1 #include <vector>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <algorithm>\n 5\n 6 struct ConcatIfStartsWith {\n 7   ConcatIfStartsWith(char c) : startCh(c) {}\n 8\n 9   void operator()(const std::string& name) {\n10     if (name.size() > 0 && name.at(0) == startCh) {\n11       csNames += name + \", \";\n12     }\n13   }\n14\n15   std::string getConcat() const {\n16     return csNames;\n17   }\n18\n19   void reset() { csNames = \"\"; }\n20\n21 private:\n22   char startCh;\n23   std::string csNames;\n24 };\n25\n26 int main() {\n27   std::vector<std::string> names{\"Meredith\", \"Guinnevere\", \n28       \"Mabel\", \"Myrtle\", \"Germaine\", \"Gwynneth\", \"Mirabelle\"};\n29\n30   const auto& fe = std::for_each(names.begin(), names.end(), \n31                            ConcatIfStartsWith('G'));\n32   std::cout << fe.getConcat() << '\\n';\n33 }\n```", "```cpp\nGuinnevere, Germaine, Gwynneth, \n```", "```cpp\n   const auto& fe = std::for_each(names.begin(), names.end(), \n                                  ConcatIfStartsWith('G'));\n```", "```cpp\n 1 #include <vector>\n 2 #include <algorithm>\n 3 #include <cassert>\n 4 \n 5 int main() {\n 6   std::vector<int> vec{2, 4, 6, 8, 9, 1};\n 7 \n 8   auto it = std::find_if(vec.begin(), vec.end(),\n 9                         [](const int& num) -> bool \n10                         {  return num % 2 != 0; }\n11                         );\n12 \n13   assert(it != vec.end() && *it == 9);\n14 }\n```", "```cpp\n[](const int& num) -> bool\n```", "```cpp\n{  return num % 2 != 0;  }\n```", "```cpp\n[](const int& num) { return num % 2 != 0; }\n```", "```cpp\n 1 #include <vector>\n 2 #include <string>\n 3 #include <algorithm>\n 4 #include <iterator>\n 5 typedef std::vector<std::string> NameVec;\n 6\n 7 NameVec getNamesShorterThan(const NameVec& names,\n 8                             size_t maxSize) {\n 9   NameVec shortNames;\n10   std::copy_if(names.begin(), names.end(),\n11                std::back_inserter(shortNames),\n12                [maxSize](const std::string& name) {\n13                   return name.size() <= maxSize;\n14                }\n15                );\n16   return shortNames;\n17 }\n```", "```cpp\n[=](const std::string& name) {\n   return name.size() <= maxSize;\n}\n```", "```cpp\n[=](const std::string& name) mutable -> bool {\n maxSize *= 2;\n   return name.size() <= maxSize;\n}\n```", "```cpp\n 1 #include <vector>\n 2 #include <string>\n 3 #include <algorithm>\n 4 #include <iostream>\n 5\n 6 int main() {\n 7   std::string concat;\n 8   char startCh = 'M';\n 9   std::vector<std::string> names{\"Meredith\", \"Guinnevere\", \"Mabel\"\n10                  , \"Myrtle\", \"Germaine\", \"Gwynneth\", \"Mirabelle\"};\n11 \n12   std::for_each(names.begin(), names.end(), \n13                [&concat, startCh](const std::string& name) {\n14                  if (name.size() > 0 && name[0] == startCh) {\n15                    concat += name + \", \";\n16                  }\n17                });\n18   std::cout << concat << '\\n';\n19 }\n```", "```cpp\nMeredith, Mabel, Myrtle, Mirabelle\n```", "```cpp\n  std::for_each(names.begin(), names.end(), \n               [&concat, startCh](const auto& name) {\n                 if (name.size() > 0 && name[0] == startCh) {\n                   concat += name + \", \";\n                 }\n               });\n```", "```cpp\nclass Queue\n{\npublic:\n  ...\n template <typename CallbackType>\n int listen(MsgType msgtype, CallbackType cb);\n  ...\n};\n```", "```cpp\nvoid msgRead(Message msg);\n```", "```cpp\nreturn-type(param1-type, param2-type, ..., paramN-type)\n```", "```cpp\nreturn-type (*)(param1-type, param2-type, ..., paramN-type)\n```", "```cpp\nint(double, const char*);\n```", "```cpp\nint (*)(double, const char*);\n```", "```cpp\n#include <boost/function.hpp>\n\nclass Queue\n{\npublic:\n  ...\n int listen(MsgType msgtype, boost::function<void(Message)> cb);\n  ...\n};\n```", "```cpp\nclass MessageHandler\n{\npublic:\n  ...\n  void handleMessage(Message msg);\n};\n```", "```cpp\nvoid(MessageHandler*, Message);\n```", "```cpp\n 1 MessageHandler *handler = new MessageHandler(...);\n 2 Queue q(...);\n 3 ...\n 4 q.listen(msgType, [handler](Message msg)\n 5                   {  handler->handleMessage(msg);  }\n 6                   );\n```", "```cpp\n 1 class MessageHandler\n 2 {\n 3 public:\n 4   ...\n 5   void listenOnQueue(Queue& q, MessageType msgType) {\n 6     q.listen(msgType, [this](Message msg) \n 7                       { handleMsg(msg); } );\n 8   }\n 9 \n10   void handleMsg(Message msg) { ... }\n11 };\n```", "```cpp\ndouble pow(double base, double power);\n```", "```cpp\n#include <cmath>\n\nstruct RaiseTo {\n  RaiseTo(double power) : power_(power) {}\n\n  double operator()(double base) const {\n    return pow(base, power_);\n  }\n\n  double power_;\n};\n```", "```cpp\nstd::vector<double> nums, raisedToThree;\n...\nstd::transform(nums.begin(), nums.end(), \n               std::back_inserter(raisedToThree),\n               RaiseTo(3));\n```", "```cpp\nstd::transform(nums.begin(), nums.end(), \n               std::back_inserter(raisedToThree),\n               pow(_, 3));\n```", "```cpp\nboost::bind(pow, _1, 3)\n```", "```cpp\n 1 #include <boost/bind.hpp>\n 2 \n 3 std::vector<double> nums, raisedToThree;\n 4 std::transform(nums.begin(), nums.end(),\n 5                std::back_inserter(raisedToThree),\n 6                boost::bind(pow, _1, 3));\n```", "```cpp\nusing std::placeholders::_1;\nusing std::placeholders::_2;\n// etc. OR\nusing namespace std::placeholders;\n```", "```cpp\nboost::bind(std::less<int>(), _2, _1)\n```", "```cpp\nboost::bind(std::less<int>(), _2, _1)(1, 10)\n```", "```cpp\nassert( std::less<int>()(1, 10) );\nassert( !boost::bind(std::less<int>(), _2, _1)(1, 10) );\n```", "```cpp\n 1 class MessageHandler\n 2 {\n 3 public:\n 4   ...\n 5   void listenOnQueue(Queue& q, MessageType msgType) {\n 6     q.listen(msgType, boost::bind(&MessageHandler::handleMsg,\n 7                                   this, _1));\n 8   }\n 9 \n10   void handleMsg(Message msg) { ... }\n11 };\n```", "```cpp\n 1 #include <functional>\n 2 ...\n 3 std::vector<std::string> names{\"Groucho\", \"Chico\", \"Harpo\"};\n 4 std::vector<std::string::size_type> lengths;\n 5 using namespace std::placeholders;\n 67 std::transform(names.begin(), names.end(), \n 8                std::back_inserter(lengths),\n 9                std::bind(&std::string::size, _1));\n```", "```cpp\n 1 #include <boost/mem_fn.hpp> // <functional> for std\n 2\n...\n 7 std::transform(names.begin(), names.end(), \n 8                std::back_inserter(lengths),\n 9                boost::mem_fn(&std::string::size));\n```", "```cpp\n1 std::string str;\n2 auto f = boost::bind(&std::string::size, 5); // binds to literal 5\n3 auto g = boost::bind(&std::string::size, _1, 20); // binds two args\n```", "```cpp\n4 f(); // error: operand has type int, expected std::string\n5 g(str); // error: std::string::size does not take two arguments\n```", "```cpp\nstd::string strPi = \"3.141595259\";\ndouble pi = boost::lexical_cast<double>(strPi);\n```", "```cpp\ntemplate <typename Target, typename Source>Target lexical_cast(const Source&);\n```", "```cpp\n 1 namespace boost {\n 2 template <>\n 3 double lexical_cast<double, std::string>(\n 4                          const std::string& str)\n 5 {\n 6   const char *numstr = str.c_str();\n 7   char *end = nullptr;\n 8   double ret = strtod(numstr, &end);\n 9   \n10   if (end && *end != '\\0') {\n11     throw boost::bad_lexical_cast();\n12   }\n13\n14   return ret;\n15 }\n16 } // boost\n```", "```cpp\nstd::string strPi = \"3.14159259\";\ndouble pi = boost::lexical_cast<double>(strPi);\n```", "```cpp\ntemplate<typename T> void foo(T);     // 1\ntemplate<typename T> void foo(T*);    // 2\ntemplate<typename T> T foo(T, T);     // 3\nvoid foo(int);                        // 4\ntemplate<> void foo<double>(double);  // 5\n\nint x;\nfoo(&x);   // calls 2\nfoo(4, 5); // calls 3\nfoo(10);   // calls 4\nfoo(10.0); // calls 5\n```", "```cpp\ntemplate <typename T, typename U>\nclass Bar { /* default implementation */ };\n\ntemplate <typename T>\nclass Bar<T*, T> { /* implementation for pointers */ };\n```", "```cpp\n 1 #include <iostream>\n 2\n 3 template <unsigned int N>\n 4 struct Factorial\n 5 {\n 6   enum {value = N * Factorial<N-1>::value};\n 7 };\n 8\n 9 template <>\n10 struct Factorial<0>\n11 {\n12   enum {value = 1};  // 0! == 1\n13 };\n14\n15 int main()\n16 {\n17   std::cout << Factorial<8>::value << '\\n';  // prints 40320\n18 }\n```", "```cpp\nint arr[Factorial<8>::value];  // an array of 40320 ints\n```", "```cpp\n 1 #include <iostream>\n 2\n 3 template <typename T>\n 4 struct IsPointer {\n 5   enum { value = 0 };\n 6 };\n 7\n 8 template <typename T>\n 9 struct IsPointer <T*> {\n10   enum { value = 1 };\n11 };\n12\n13 int main() {\n14   std::cout << IsPointer<int>::value << '\\n';\n15   std::cout << IsPointer<int*>::value << '\\n';\n16 }\n```", "```cpp\n 1 #include <boost/type_traits/is_pointer.hpp>\n 2 #include <boost/type_traits/is_array.hpp>\n 3 #include <boost/type_traits/rank.hpp>\n 4 #include <boost/type_traits/extent.hpp>\n 5 #include <boost/type_traits/is_pod.hpp>\n 6 #include <string>\n 7 #include <iostream>\n 8 #include <cassert>\n 8\n 9 struct MyStruct {\n10   int n;\n11   float f;\n12   const char *s;\n13 };\n14\n15 int main()\n16 {\n17 // check pointers\n18   typedef int* intptr;\n19   std::cout << \"intptr is \"\n20             << (boost::is_pointer<intptr>::value ?\"\" :\"not \") \n21             << \"pointer type\\n\";\n22 // introspect arrays\n23   int arr[10], arr2[10][15];\n24   if (boost::is_array<decltype(arr)>::value) {\n25     assert(boost::rank<decltype(arr)>::value == 1);\n26     assert(boost::rank<decltype(arr2)>::value == 2);\n27     assert(boost::extent<decltype(arr)>::value == 10);\n28     assert(boost::extent<decltype(arr2)>::value == 10);\n29     assert((boost::extent<decltype(arr2), 1>::value) == 15);\n30     std::cout << \"arr is an array\\n\";\n31   }\n32\n33 // POD vs non-POD types\n34   std::cout << \"MyStruct is \" \n35             << (boost::is_pod<MyStruct>::value ?\"\" : \"not \")\n36             << \"pod type.\" << '\\n';\n37   std::cout << \"std::string is \" \n38             << (boost::is_pod<std::string>::value ?\"\" : \"not \")\n40             << \"pod type.\" << '\\n';\n41 }\n```", "```cpp\n 1 #include <boost/type_traits/is_pod.hpp>\n 2 #include <cstring>\n 3 #include <iostream>\n 4 #include <string>\n 5 \n 6 struct MyStruct {\n 7   int n; float f;\n 8   const char *s;\n 9 };\n10\n11 template <typename T, size_t N>\n12 T* fastCopy(T(&arr)[N], boost::true_type podType)\n13 {\n14   std::cerr << \"fastCopy for POD\\n\";\n15   T *cpyarr = new T[N];\n16   memcpy(cpyarr, arr, N*sizeof(T));\n17\n18   return cpyarr;\n19 }\n20\n21 template <typename T, size_t N>\n22 T* fastCopy(T(&arr)[N], boost::false_type nonPodType)\n23 {\n24   std::cerr << \"fastCopy for non-POD\\n\";\n25   T *cpyarr = new T[N];\n26   std::copy(&arr[0], &arr[N], &cpyarr[0]);\n27\n28   return cpyarr;\n29 }\n30\n31 template <typename T, size_t N>\n32 T* fastCopy(T(&arr)[N])\n33 {\n34   return fastCopy(arr, typename boost::is_pod<T>::type());\n35 }\n36\n37 int main()\n38 {\n39   MyStruct podarr[10] = {};\n40   std::string strarr[10];\n41\n42   auto* cpyarr = fastCopy(podarr);\n43   auto* cpyarr2 = fastCopy(strarr);\n44   delete []cpyarr;\n45   delete []cpyarr2;\n46 }\n```", "```cpp\ntemplate <typename T, size_t N>\nvoid copy(T (&lhs)[N], T (&rhs)[N]);\n```", "```cpp\n 1 template <typename T, size_t N>\n 2 void copy(T (&lhs)[N], T (&rhs)[N])\n 3 {\n 4   for (size_t i = 0; i < N; ++i) {\n 5     lhs[i] = rhs[i];\n 6   }\n 7 }\n```", "```cpp\n 1 // optimized for POD-type\n 2 template <typename T, size_t N>\n 3 void copy(T (&lhs)[N], T (&rhs)[N])\n 4 {\n 5   memcpy(lhs, rhs, N*sizeof(T));\n 6 }\n```", "```cpp\n#include <boost/utility/enable_if.hpp>\n#include <boost/type_traits/is_pod.hpp>\n\n// optimized for POD-type\ntemplate <typename T, size_t N>\ntypename boost::enable_if<boost::is_pod<T>>::type\ncopy(T (&lhs)[N], T (&rhs)[N])\n{\n  memcpy(lhs, rhs, N*sizeof(T));\n}\n```", "```cpp\nstd::string s[10], s1[10];\ncopy(s1, s);  // invokes the generic template\n```", "```cpp\ndouble d[10], d1[10];\ncopy(d1, d);\n```", "```cpp\n 1 template <typename T, size_t N>\n 2 typename boost::disable_if<boost::is_pod<T>>::type\n 3 copy(T (&lhs)[N], T (&rhs)[N])\n 4 {\n 5   for (size_t i = 0; i < N; ++i) {\n 6     lhs[i] = rhs[i];\n 7   }\n 8 }\n```", "```cpp\ntypename boost::disable_if_c<boost::is_pod<T>::value>::type\n```", "```cpp\ntemplate <typename T>\nstruct add_pointer;\n```", "```cpp\n 1 #include <boost/mpl/or.hpp>\n 2 #include <boost/type_traits.hpp>\n 34 if (boost::mpl::or_<\n 5                     boost::is_pointer<int*>,\n 6                     boost::is_array<int*>\n 7                    >::value) {\n 8   std::cout << \"int* is a pointer or array type\\n\";\n 9 }\n10\n11 if (boost::mpl::or_<\n12                     boost::is_pointer<int[]>,\n13                     boost::is_array<int[]>\n14                    >::value) {\n15   std::cout << \"int* is a pointer or array type\\n\";\n16 }\n```", "```cpp\n 1 #include <boost/mpl/or.hpp>\n 2 #include <boost/type_traits.hpp>\n 3\n 4 template <typename T>\n 5 struct is_pointer_or_array\n 6       : boost::mpl::or_<boost::is_pointer<T>, \n 7                         boost::is_array<T>>\n 8 {};\n```", "```cpp\ntemplate <typename T, typename U> struct is_smaller;\n```", "```cpp\n 1 #include <boost/mpl/and.hpp>\n 2 #include <boost/mpl/int.hpp>\n 3 #include <boost/mpl/integral_c.hpp>\n 4 #include <boost/mpl/less.hpp>\n 5 #include <iostream>\n 6 namespace mpl = boost::mpl;\n 7\n 8 template <typename L, typename R>\n 9 struct is_smaller : mpl::less<\n10                     mpl::integral_c<size_t, sizeof(L)>\n11                    , mpl::integral_c<size_t, sizeof(R)>>\n12 {};\n13\n14 int main()\n15 {\n16   if (is_smaller<short, int>::value) {\n17     std::cout << \"short is smaller than int\\n\";\n18   } else { ... }\n19 }\n```", "```cpp\ntemplate <typename T, size_t M,\n          typename S, size_t N>\nvoid arrayAssign(T(&lhs)[M], S(&rhs)[N]);\n```", "```cpp\n 1 #include <boost/type_traits.hpp>\n 2 #include <type_traits>\n 3 #include <boost/mpl/and.hpp>\n 4 #include <boost/mpl/or.hpp>\n 5 #include <boost/mpl/not.hpp>\n 6 #include <boost/mpl/greater.hpp>\n 7 #include <boost/mpl/greater_equal.hpp>\n 8 #include <boost/mpl/equal.hpp>\n 9 #include <boost/mpl/if.hpp>\n10 #include <boost/mpl/integral_c.hpp>\n11 #include <boost/utility/enable_if.hpp>\n12 #include <iostream>\n13\n14 namespace mpl = boost::mpl;\n15\n16 template <typename T, typename S>\n17 struct is_larger\n18    : mpl::greater<mpl::integral_c<size_t, sizeof(T)>\n19                 , mpl::integral_c<size_t, sizeof(S)>>\n20 {};\n21 template <typename T, typename S>\n22 struct is_smaller_equal\n23   : mpl::not_<is_larger<T, S>>\n24 {};\n25\n26 template <typename T, typename S>\n27 struct is_floating_assignable\n28    : mpl::and_<\n29        boost::is_floating_point<T>\n30      , boost::is_arithmetic<S>\n31      , is_smaller_equal<S, T>\n32      >\n33 {};\n34\n35 template <typename T, typename S>\n36 struct is_integer_assignable\n37    : mpl::and_<\n38        boost::is_integral<T>\n39      , boost::is_integral<S>\n40      , is_smaller_equal<S, T>\n41      , mpl::if_<boost::is_signed<S>\n42               , boost::is_signed<T>\n43               , mpl::or_<boost::is_unsigned<T>\n44                        , mpl::and_<boost::is_signed<T>\n45                                  , is_larger<T, S>>\n46                         >\n47               >\n48      >\n49 {};\n50\n51 template <typename T, typename S>\n52 struct is_non_pod_assignable\n53    : mpl::and_<\n54                mpl::not_<mpl::and_<boost::is_pod<T>\n55                                  , boost::is_pod<S>>\n56                         >\n57              , std::is_assignable<T, S>\n58               >\n59 {};\n60\n61 template <typename T, typename U>\n62 struct is_array_assignable\n63    : boost::false_type\n64 {};\n65\n66 template <typename T, size_t M, typename S, size_t N>\n67 struct is_array_assignable<T (&)[M], S (&)[N]>\n68    : mpl::and_<\n69           mpl::or_<\n70               boost::is_same<T, S>\n71             , is_floating_assignable<T, S>\n72             , is_integer_assignable<T, S>\n73             , is_non_pod_assignable<T, S>\n74              >\n75         , mpl::greater_equal<mpl::integral_c<size_t, M>\n76                            , mpl::integral_c<size_t, N>>\n77         >\n78 {};\n79\n80\n81 template <typename T, size_t M, typename S, size_t N>\n82 typename boost::enable_if<is_array_assignable<T(&)[M], \n83                                               S(&)[N]>>::type\n84 assignArray(T (&target)[M], S (&source)[N])\n85 { /* actual copying implementation */ }\n```", "```cpp\nz = x + y();\n```", "```cpp\ndouble integrate(std::function<double(double)> func,\n                 double low, double high);\n```", "```cpp\ndouble result = integrate(x + 1/x, 1, 10);\n```", "```cpp\nresult = integrate([](double) { return x + 1/x; }, 1, 10);\n```", "```cpp\n 1 #include <iostream>2\n 3 struct Constant {\n 4   Constant(double val = 0.0) : val_(val) {}\n 5   double operator()(double) const { return val_; }\n 67   const double val_;\n 8 };\n 9\n10 Constant c5(5);\n11 std::cout << c5(1.0) << '\\n';  // prints 5\n```", "```cpp\n 1 struct Variable {\n 2   double operator()(double x) { return x; }\n 3 };\n 4\n 5 Variable x;\n 6 std::cout << x(8) << '\\n';  // prints 8\n 7 std::cout << x(10) << '\\n'; // prints 10\n```", "```cpp\nstruct Expr {\n  ...\n  double operator()(double x) {\n    return (value computed using x);\n  }\n};\n```", "```cpp\n 1 template <typename E1, typename E2, typename OpType>\n 2 struct ComplexExpression {\n 3   ComplexExpression(E1 left, E2 right) : left_(left), \n 4             right_(right) \n 5   {}\n 6\n 7   double operator()(double x) { \n 8     return OpType()(left_(x), right_(x));\n 9   }\n10\n11   E1 left_; E2 right_;\n12 };\n```", "```cpp\n 1 template <typename E, typename Enable = void>\n 2 struct Expr {\n 3   Expr(E e) : expr_(e) {}\n 4  \n 5   double operator()(double x) { return expr_(x); }\n 6 \n 7 private: \n 8   E expr_;\n 9 };\n10\n11 template <typename E1, typename E2, typename Op>\n12 struct ComplexExpression\n13 {\n14   ComplexExpression(Expr<E1> left, Expr<E2> right) : \n15                    left_(left), right_(right) {}\n16\n17   double operator()(double d) {\n18     return Op()(left_(d), right_(d));\n19   }\n20\n21 private:\n22   Expr<E1> left_;\n23   Expr<E2> right_;\n24 };\n```", "```cpp\n 1 #include <functional>\n 2 \n 3 template <typename E1, typename E2>\n 4 Expr<ComplexExpression<E1, E2, std::plus<double>>> \n 5           operator+ (E1 left, E2 right)\n 6 {\n 7   typedef ComplexExpression <E1, E2,\n 8                                 std::plus<double>> ExprType;\n 9   return ExprType(Expr<E1>(left), Expr<E2>(right));\n10 }\n```", "```cpp\nVariable x;\nConstant c1(1);\nintegrate(x + c1/x, 1, 10);\n```", "```cpp\n 1 #include <boost/utility/enable_if.hpp>\n 2 #include <boost/type_traits/is_arithmetic.hpp>\n 34 template <typename E>\n 5 struct Expr<E, typename boost::enable_if< \n 6                               boost::is_arithmetic<E>>::type> \n 7 {\n 8   Expr(E& e) : expr_(Constant(e)) {}\n 9\n10   double operator()(double x) { return expr_(x); }\n11\n12   Constant expr_;\n13 };\n```", "```cpp\nVariable x;\nstd::cout << (x + 1/x)(10) << '\\n'; \nstd::cout << ((x*x - x + 4)/(2*x))(10) << '\\n';\n```", "```cpp\n 1 #include <boost/phoenix/core.hpp>\n 2 #include <boost/phoenix/operator.hpp>\n 3 #include <iostream>\n 4\n 5 int main() {\n 6   namespace phx = boost::phoenix;\n 7   double eX;\n 8   auto x = phx::ref(eX);\n 9\n10   eX = 10.0;\n11   std::cout << (x + 1/x)() << '\\n';              // prints 10.1\n12   std::cout << ((x*x -x + 4) / (2*x))() << '\\n'; // prints 4.7\n13 }\n```", "```cpp\n 1 #include <boost/phoenix/core.hpp>\n 2 #include <boost/phoenix/operator.hpp>\n 3 #include <vector>\n 4 #include <string>\n 5 #include <iostream>\n 6 #include <algorithm>\n 7\n 8 int main() {\n 9   using boost::phoenix::arg_names::arg1;\n10   std::vector<std::string> vec{\"Lambda\", \"Iota\", \n11                                \"Sigma\", \"Alpha\"};\n12   std::for_each(vec.begin(), vec.end(), \n13                 std::cout << arg1 << '\\n');\n14 }\n```", "```cpp\n 1 #include <boost/phoenix/core.hpp>\n 2 #include <boost/phoenix/statement/if.hpp>\n 3 #include <boost/phoenix/operator.hpp>\n 4 #include <algorithm>\n 5 #include <vector>\n 6 #include <iostream>\n 7 \n 8 int main() {\n 9   namespace phx = boost::phoenix;\n10   using namespace phx;\n11   using phx::arg_names::arg1;\n12\n13   std::vector<std::string> names{\"Daltrey\", \"Townshend\", \n14                                  \"Entwistle\", \"Moon\"};\n15   std::for_each(names.begin(), names.end(),   \n16             if_(arg1 == \"Daltrey\") [\n17               std::cout << arg1 << \", vocalist\" << '\\n'\n18             ].else_[\n19               std::cout << arg1 << \", instrumentalist\" << '\\n'\n20             ]\n21             );\n22 }\n```", "```cpp\nDaltrey, vocalist\nTownshend, instrumentalist\nEntwistle, instrumentalist\nMoon, instrumentalist\n```", "```cpp\n 1 #include <vector>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <boost/phoenix/core.hpp>\n 5 #include <boost/phoenix/stl/algorithm.hpp>\n 6 #include <boost/phoenix/stl/container.hpp>\n 7 #include <cassert>\n 8\n 9 int main() {\n10   namespace phx = boost::phoenix;\n11   using phx::arg_names::arg1;\n12   std::vector<std::string> greets{ \"Hello\", \"Hola\", \"Hujambo\", \n13                                    \"Hallo\" };\n14   auto finder = phx::find(greets, arg1);\n15   auto it = finder(\"Hujambo\");\n16\n17   assert (phx::end(greets)() != it);\n18   std::cout << *it << '\\n';\n19   assert (++it != greets.end());\n20   std::cout << *it << '\\n';\n21 }\n```", "```cpp\nHujambo\nHallo\n```", "```cpp\n 1 #include <vector>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <algorithm>\n 5 #include <boost/phoenix/core.hpp>\n 6 #include <boost/phoenix/function.hpp>\n 7 #include <boost/phoenix/operator.hpp>\n 8 #include <boost/phoenix/stl/container.hpp>\n 9 #include <boost/phoenix/stl/algorithm.hpp>\n10\n11 struct substr_impl {\n12   template<typename C, typename F1, typename F2>\n13   struct result  {\n14     typedef C type;\n15   };\n16\n17   template<typename C, typename F1, typename F2>\n18   C operator()(const C& c, const F1& offset, \n19               const F2& length) const\n20   {  return c.substr(offset, length); }\n21 };\n22\n23 int main() {\n24   namespace phx = boost::phoenix;\n25   using phx::arg_names::arg1;\n26\n27   std::vector<std::string> names{\"Pete Townshend\", \n28             \"Roger Daltrey\", \"Keith Moon\", \"John Entwistle\"};\n29   phx::function<substr_impl> const substr = substr_impl();\n30\n31   std::for_each(names.begin(), names.end(), std::cout <<\n32                substr(arg1, 0, phx::find(arg1, ' ')\n33                                - phx::begin(arg1))\n34                 << '\\n');\n35 }\n```", "```cpp\n 1 #include <boost/spirit/include/qi.hpp>\n 2 #include <cassert>\n 3 namespace qi = boost::spirit::qi;\n 4\n 5 int main()\n 6 {\n 7   std::string str = \"Hello, world!\";\n 8\n 9   auto iter = str.begin();\n10   bool success = qi::parse(iter, str.end(), qi::alpha);\n11                            \n12   assert(!success);\n13   assert(iter - str.begin() == 1);\n14 }\n```", "```cpp\n 1 #include <boost/spirit/include/qi.hpp>\n 2 #include <cassert>\n 3 namespace qi = boost::spirit::qi;\n 4\n 5 int main()\n 6 {\n 7   std::string str = \"Hello, world!\";\n 8\n 9   auto iter = str.begin();\n10   bool success = qi::parse(iter, str.end(),\n11                   qi::string(\"Hello\") >> qi::string(\"world\"));\n12\n13   assert(!success);\n14\n15   iter = str.begin();\n16   success = qi::phrase_parse(iter, str.end(),\n17                   qi::string(\"Hello\") >> qi::string(\"world\"),\n18                   +(qi::space|qi::punct));\n19\n20   assert(success);\n21   assert(iter - str.begin() == str.size());\n22 }\n```", "```cpp\n1   std::string str = \"Hello, WORLD!\";\n2   iter = str.begin();\n3   success = qi::phrase_parse(iter, str.end(),\n4                   qi::string(\"Hello\") >> \n5                     qi::no_case[qi::string(\"world\")],\n6                   +(qi::space|qi::punct));\n7   assert(success);\n```", "```cpp\n 1   std::string str = \"Hello world\";\n 2   auto iter = str.begin();\n 3   bool success = qi::parse(iter, str.end(),\n 4                   qi::skip(qi::space)[qi::string(\"Hello\") >> \n 5                                        qi::string(\"world\")]);\n 6   assert( success); \n```", "```cpp\n 1 #include <boost/spirit/include/qi.hpp>\n 2 #include <iostream>\n 3 namespace qi = boost::spirit::qi;\n 4\n 5 void print(unsigned int n) {\n 6   std::cout << n << '\\n';\n 7 }\n 8\n 9 int main() {\n10   std::string str = \"10 20 30 40 50 60\";\n11\n12   auto iter = str.begin();\n13   bool success = qi::phrase_parse(iter, str.end(),\n14                                   +qi::uint_[print],\n15                                   qi::space);\n16   assert(success);\n17   assert(iter == str.end());\n18 }\n```", "```cpp\n 1 #include <vector>\n 2\n 3 void printv(std::vector<unsigned int> vn) \n 4 {\n 5   for (const int& n: vn) {\n 6     std::cout << n << '\\n';\n 7   }\n 8 }\n 9\n10 int main() {\n11   std::string str = \"10 20 30 40 50 60\";\n12\n13   auto iter = str.begin();\n14   bool success = qi::phrase_parse(iter, str.end(),\n15                                  (+qi::uint_)[printv],\n16                                  qi::space);\n17 }\n```", "```cpp\n 1 #include <boost/spirit/include/qi.hpp>\n 2 #include <boost/spirit/include/phoenix_core.hpp>\n 3 #include <boost/spirit/include/phoenix_operator.hpp>\n 4 #include <boost/spirit/include/phoenix_stl.hpp> \n 5 \n 6 int main() {\n 7   using boost::phoenix::push_back;\n 8 \n 9   std::string str = \"10 20 30 40 50 60\";\n10   std::vector<unsigned int> vec;\n11   auto iter = str.begin();\n12   bool status = qi::phrase_parse(iter, str.end(),\n13                 +qi::uint_[push_back(boost::phoenix::ref(vec), \n14                                         qi::_1)],\n15                  qi::space);\n16 }\n```", "```cpp\nstd::vector<unsigned int> result;\nbool success = qi::phrase_parse(iter, str.end(),\n +qi::uint_, result,\n                                qi::space);\nfor (int n: result) {std::cout << n << '\\n';\n}\n```", "```cpp\nqi::rule<std::string::iterator> space_rule = qi::space; \n```", "```cpp\nqi::rule<std::string::iterator, double()> double_rule = \n                                                  qi::double_;\n```", "```cpp\nqi::rule<std::string::iterator, std::vector<double>(), \n                qi::space_type> doubles_p = +qi::double_;\n```", "```cpp\nqi::rule<std::string::iterator, std::vector<double>(), \n                                 qi::space_type> doubles_p;\ndoubles_p %= +qi::double_;\n```", "```cpp\nstd::string nums = \"0.207879576 0.577215 2.7182818 3.14159259\";\nstd::vector<double> result;\nqi::phrase_parse(iter1, iter2,\n doubles_p[boost::phoenix::ref(result) == qi::_1],\n                qi::space);\n```", "```cpp\n#include <boost/spirit/include/qi.hpp>\n\nnamespace qi = boost::spirit::qi;\n\nqi::int_parser<unsigned short, 10, 4, 4> year_p;\nqi::int_parser<unsigned short, 10, 2, 2> month_p, day_p, hour_p, \n                                          min_p, sec_p;\nqi::rule<std::string::iterator> date_p = \n   year_p >> qi::char_('-') >> month_p >> qi::char_('-') >> day_p;\n\nqi::rule<std::string::iterator> seconds_p = \n            sec_p >> -(qi::char_('.') >> qi::ushort_);\n\nqi::rule<std::string::iterator> time_p = \n   hour_p >> qi::char_(':') >> min_p \n             >> -(qi::char_(':') >> seconds_p);\n\nqi::rule<std::string::iterator> timestamp_p = date_p >> -\n                                        (qi::space >> time_p);\n```", "```cpp\n1 #include <boost/spirit/include/qi.hpp>\n 2 #include <boost/bind.hpp>\n 3 #include <cassert>\n 4 namespace qi = boost::spirit::qi;\n 5\n 6 struct timestamp_t\n 7 {\n 8   void setYear(short val) { year = val; }\n 9   unsigned short getYear() { return year; }\n10   // Other getters / setters\n11\n12 private:\n13   unsigned short year, month, day,\n14            hours, minutes, seconds, fractions;\n15 };\n16\n17 timestamp_t parseTimeStamp(std::string input)\n18 {\n19   timestamp_t ts;\n20\n21   qi::int_parser<unsigned short, 10, 4, 4> year_p;\n22   qi::int_parser<unsigned short, 10, 2, 2> month_p, day_p, \n23                                       hour_p, min_p, sec_p;\n24   qi::rule<std::string::iterator> date_p =\n25    year_p [boost::bind(&timestamp_t::setYear, &ts, ::_1)]\n26    >> qi::char_('-')\n27    >> month_p [boost::bind(&timestamp_t::setMonth, &ts, ::_1)]\n28    >> qi::char_('-')\n29    >> day_p [boost::bind(&timestamp_t::setDay, &ts, ::_1)];\n30\n31   qi::rule<std::string::iterator> seconds_p =\n32       sec_p [boost::bind(&timestamp_t::setSeconds, &ts, ::_1)]\n33         >> -(qi::char_('.')\n34         >> qi::ushort_\n35         [boost::bind(&timestamp_t::setFractions, &ts, ::_1)]);\n36\n37   qi::rule<std::string::iterator> time_p =\n38    hour_p  [boost::bind(&timestamp_t::setHours, &ts, ::_1)]\n39    >> qi::char_(':')\n40    >> min_p [boost::bind(&timestamp_t::setMinutes, &ts, ::_1)]\n41     >> -(qi::char_(':') >> seconds_p);\n42\n43   qi::rule<std::string::iterator> timestamp_p = date_p >> -\n44                                        (qi::space >> time_p);\n45   auto iterator = input.begin();\n46   bool success = qi::phrase_parse(iterator, input.end(),\n47                                   timestamp_p, qi::space);\n48   assert(success);\n49\n50   return ts;\n51 }\n```"]