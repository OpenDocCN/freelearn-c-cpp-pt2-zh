["```cpp\n 1 #include <iostream>\n 2 #include <string>\n 3 #include <vector>\n 4\n 5 int main()\n 6 {\n 7   typedef std::vector<std::string> strvec;\n 8\n 9   strvec angloSaxon{\"Guten Morgen!\", \"Godmorgen!\", \n10                    \"Good morning!\", \"goedemorgen\"};\n11\n12   strvec romance{\"Buenos dias!\", \"Bonjour!\", \n13                  \"Bom dia!\", \"Buongiorno!\"};\n14\n15   size_t max1 = angloSaxon.size(), max2 = romance.size();\n16   size_t i = 0, j = 0;\n17\n18   while (i < max1 || j < max2) {\n19     if (i < max1)\n20       std::cout << angloSaxon[i++] << '\\n';\n21\n22     if (j < max2)\n23       std::cout << romance[j++] << '\\n';\n24   }\n25 }\n```", "```cpp\nBuenos dias!\nGuten Morgen!\nBonjour!\nGodmorgen!\nBom dia!\nGood morning!\nBuongiorno!\ngoedemorgen\n```", "```cpp\n 1 #include <boost/thread.hpp>\n 2 #include <string>\n 3 #include <vector>\n 4 #include <iostream>\n 5\n 6 typedef std::vector<std::string> strvec;\n 7 \n 8 void printGreets(const strvec& greets)\n 9 {\n10   for (const auto& greet : greets) {\n11     std::cout << greet << '\\n';\n12   }\n13 }\n14\n15 int main()\n16 {\n17   strvec angloSaxon{\"Guten Morgen!\", \"Godmorgen!\", \n18                    \"Good morning!\", \"goedemorgen\"};\n19\n20   strvec romance{\"Buenos dias!\", \"Bonjour!\", \n21                  \"Bom dia!\", \"Buongiorno!\"};\n15\n16   boost::thread t1(printGreets, romance);\n17   printGreets(angloSaxon);\n18   t1.join();\n19 }\n```", "```cpp\nGuten Morgen!\nBuenos dias!\nGodmorgen!\nBonjour!\nBom dia!\nGood morning!\nBuongiorno!\ngoedemorgen\n```", "```cpp\nGuten Morgen!\nBuenos dGodmorgeias!\nn!\nBonjour!\nBom dia! Good morning!\nBuongiorno!\ngoedemorgen\n```", "```cpp\n$ g++ Listing9_2.cpp -o Listing9_2 -lboost_thread -lboost_system \u2013lboost_chrono \u2013pthread \n```", "```cpp\n 1 void threadFunc() { ... }\n 2\n 3 boost::thread makeThread(void (*thrFunc)()) {\n 4   assert(thrFunc);\n 5   boost::thread thr(thrFunc);\n 6   // do some work\n 7   return thr;\n 8 }\n 9\n10 int main() {\n11   auto thr1 = makeThread(threadFunc);\n12   // ...\n13   thr1.join();\n14 }\n```", "```cpp\n 1 int main() {\n 2   boost::thread thr(thrFunc, arg1, ...);\n 3   thr.detach();\n 4   // ...\n 5 }\n```", "```cpp\nBOOST_THREAD_TRHOW_IF_PRECONDITION_NOT_SATISFIED BOOST_THREAD_PROVIDES_THREAD_DESTRUCTOR_CALLS_TERMINATE_IF_JOINABLE\n```", "```cpp\n 1 #include <boost/thread.hpp>\n 2 #include <boost/chrono/duration.hpp>\n 3 #include <vector>\n 4 #include <map>\n 5 #include <iostream>\n 6 #include <sstream>\n 7 #include <boost/move/move.hpp>\n 8\n 9 void doStuff(const std::string& name) {\n10   std::stringstream sout;\n11   sout << \"[name=\" << name << \"]\"\n12     << \"[id=\" << boost::this_thread::get_id() << \"]\"\n13     << \" doing work\\n\";\n14   std::cout << sout.str();\n15   boost::this_thread::sleep_for(boost::chrono::seconds(2));\n16 }\n17\n18 int main() {\n19   typedef std::map<boost::thread::id, boost::thread> threadmap;\n20   threadmap tmap;\n21\n22   std::vector<std::string> tnames{ \"thread1\", \"thread2\",\n23                             \"thread3\", \"thread4\", \"thread5\" };\n24   for (auto name : tnames) {\n25     boost::thread thr(doStuff, name);\n26     tmap[thr.get_id()] = boost::move(thr);\n27   }\n28\n29   for (auto& thrdEntry : tmap) {\n30     thrdEntry.second.join();\n31     std::cout << thrdEntry.first << \" returned\\n\";\n32   }\n33 }\n```", "```cpp\n 1 #include <vector>\n 2 #include <string>\n 3 #include <fstream>\n 4 #include <boost/filesystem.hpp>\n 5\n 6 std::vector<char> readFromFile(const std::string& filepath)\n 7 {\n 8   std::ifstream ifs(filepath);\n 9   size_t length = boost::filesystem::file_size(filepath);\n10   std::vector<char> content(length);\n11   ifs.read(content.data(), length);\n12\n13   return content;\n14 }\n15\n16 std::vector<char> diffContent(const std::vector<char>& c1,\n17                               const std::vector<char>& c2) {\n18   // stub - returns an empty vector\n19   return std::vector<char>();\n20 }\n```", "```cpp\n 1 #define BOOST_THREAD_PROVIDES_FUTURE\n 2 #include <boost/thread.hpp>\n 3 #include <boost/thread/future.hpp>\n 4 // other includes\n 5\n 6 std::vector<char> diffFiles(const std::string& file1, \n 7                             const std::string& file2) {\n 8   // set up the promise-future pair\n 9   boost::promise<std::vector<char>> promised_value;\n10   boost::future<std::vector<char>> future_result\n11                                = promised_value.get_future();\n12   // spawn a reader thread for file2\n13   boost::thread reader(\n14                     [&promised_value, &file2]() {\n15                       std::cout << \"Reading \" << file2 << '\\n';\n16                       auto content = readFromFile(file2);\n17                       promised_value.set_value(content);\n18                       std::cout << \"Read of \" << file2\n19                                 << \" completed.\\n\";\n20                     });\n21\n22   std::cout << \"Reading \" << file1 << '\\n';\n23   auto content1 = readFromFile(file1);\n24   std::cout << \"Read of \" << file1 << \" completed.\\n\";\n25\n26   auto content2 = future_result.get(); // this blocks\n27   auto diff = diffContent(content1, content2);\n28   reader.join();\n29   return diff; \n30 }\n```", "```cpp\n 1 #define BOOST_THREAD_PROVIDES_FUTURE\n 2 #include <boost/thread.hpp>\n 3 #include <boost/thread/future.hpp>\n 4 #include <boost/chrono.hpp>\n 5 #include <ctime>\n 6 #include <cassert>\n 7 #include <cstdlib>\n 8 #include <iostream>\n 9 \n10 int main() {\n11   boost::promise<void> promise;\n12   boost::future<void> future = promise.get_future();\n13\n14   std::cout << \"Main thread id=\" \n15                       << boost::this_thread::get_id() << '\\n';\n16   boost::thread thr([&promise]() {\n17          srand(time(0));\n18          int secs = 10 + rand() % 10;\n19          std::cout << \"Thread \" << boost::this_thread::get_id()\n20                   << \" sleeping for \"\n21                   << secs << \" seconds\\n\";\n22          boost::this_thread::sleep_for(\n23               boost::chrono::seconds(secs));\n24          promise.set_value();\n25        });\n26\n27   size_t timeout_count = 0;\n28   size_t secs = 2;\n29\n30   while (future.wait_for(boost::chrono::seconds(secs)) \n31           == boost::future_status::timeout) {\n32     std::cout << \"Main thread timed out\\n\";\n33     ++timeout_count;\n34   }\n35   assert(future.is_ready());\n36   assert(future.get_state() == boost::future_state::ready);\n37\n38   std::cout << \"Timed out for \" << timeout_count * secs \n39             << \" seconds \\n\";\n40   thr.join();\n41 }\n```", "```cpp\n 1 #define BOOST_THREAD_PROVIDES_FUTURE\n 2 #include <boost/thread.hpp>\n 3 #include <boost/thread/future.hpp>\n 4 // other includes\n 5\n 6 std::vector<char> readFromFile(const std::string& filepath)\n 7 {\n 8   std::ifstream ifs(filepath, std::ios::ate);\n 9   if (!ifs) {\n10     throw std::runtime_error(filepath + \" unreadable\");\n11   }\n12   ... // rest of the code \u2013 check Listing 10.4a\n13 }\n14\n15 std::vector<char> diffFiles(const std::string& file1,\n16                             const std::string& file2) {\n17   // set up the promise-future pair\n18   boost::promise<std::vector<char> > promised_value;\n19   boost::future<std::vector<char> > future_result\n20                                = promised_value.get_future();\n21   // spawn a reader thread for file2\n22   boost::thread reader(\n23                        [&promised_value, &file2]() {\n24                          try {\n25                            auto content = readFromFile(file2);\n26                            promised_value.set_value(content);\n27                          } catch (std::exception& e) {\n28                            promised_value.set_exception(\n29                               boost::copy_exception(e));\n30                          }\n31                        });\n32   ...\n33   std::vector<char> diff;\n34   try {\n35     auto content2 = future_result.get(); // this blocks\n36     diff = diffContent(content1, content2);\n37   } catch (std::exception& e) {\n38     std::cerr << \"Exception caught: \" << e.what() << '\\n';\n39   }\n40   reader.join();\n41   return diff; \n42 }\n```", "```cpp\n 1 #include <string>\n 2 #include <vector>\n 3 #include <iostream>\n 4 #define BOOST_THREAD_PROVIDES_FUTURE\n 5 #include <boost/lexical_cast.hpp>\n 6 #include <boost/thread.hpp>\n 7 #include <boost/thread/future.hpp>\n 8 #include <boost/chrono.hpp>\n 9\n10 int main() {\n11   boost::promise<std::string> prom;\n12   boost::future<std::string> fut(prom.get_future());\n13   boost::shared_future<std::string> shfut(std::move(fut));\n14   boost::thread publisher([&prom]() {\n15               std::string id =\n16                 boost::lexical_cast<std::string>(\n17                                boost::this_thread::get_id());\n18               std::cout << \"Publisher thread \" << id \n19                         << \" starting.\\n\";\n20               boost::this_thread::sleep_for(\n21                                   boost::chrono::seconds(15));\n22               prom.set_value(id);\n23            });\n24   auto thrFunc = [](boost::shared_future<std::string> sf, \n25                     int waitFor) {\n26     while (sf.wait_for(boost::chrono::seconds(waitFor))\n27         == boost::future_status::timeout) {\n28       std::cout << \"Subscriber thread \" \n29                 << boost::this_thread::get_id()\n30                 << \" waiting ...\\n\";\n31     }\n32\n33     std::cout << \"\\nSubscriber thread \" \n34               << boost::this_thread::get_id()\n35               << \" got \" << sf.get() << \".\\n\";\n36   };\n37\n38   boost::thread subscriber1(thrFunc, shfut, 2);\n39   boost::thread subscriber2(thrFunc, shfut, 4);\n40   boost::thread subscriber3(thrFunc, shfut, 6);\n41\n42   publisher.join();\n43   subscriber1.join();\n44   subscriber2.join();\n45   subscriber3.join();\n46 }\n```", "```cpp\n 1 // include other headers\n 2 #include <exception>\n... // other code\n22   boost::thread reader(\n23                        [&promised_value, &file2]() {\n24                          try {\n25                            auto content = readFromFile(file2);\n26                            promised_value.set_value(content);\n27                          } catch (std::exception& e) {\n28                            promised_value.set_exception(\n29                                     std::current_exception());\n30                          }\n31                        });\n```", "```cpp\n22   boost::thread reader(\n23                        [&promised_value, &file2]() {\n24                          try {\n25                            auto content = readFromFile(file2);\n26                            promised_value.set_value(content);\n27                          } catch (std::exception& e) {\n28                            promised_value.set_exception(\n29                                  std::make_exception_ptr(e));\n30                          }\n31                        });\nThe exception stored in a std::exception_ptr can be thrown using std::rethrow_exception, as shown here:\n01 void throwAgain(std::exception_ptr eptr) {\n02   // do stuff\n03   std::rethrow_exception(eptr);\n04 }\n```", "```cpp\n 1 #include <future>\n 2 #include <thread>\n 3 #include <vector>\n 4 // other includes\n 5\n 6 std::vector<char> readFromFile(const std::string& filepath)\n 7 {\n 8   std::ifstream ifs(filepath, std::ios::ate);\n 9   if (!ifs) {\n10     throw std::runtime_error(filepath + \" unreadable\");\n11   }\n12   ... // rest of the code \u2013 check Listing 10.4a\n13 }\n14\n15 std::vector<char> diffFiles(const std::string& file1,\n16                             const std::string file2)\n17 {\n18   typedef std::vector<char> buffer_t;\n19   std::packaged_task<buffer_t(const std::string&)>\n20             readerTask(readFromFile);\n21   auto future = readerTask.get_future();\n22\n23   try {\n24     std::thread thread2(std::move(readerTask), file2);\n25     auto content1 = readFromFile(file1);\n26     std::cout << \"Read from file \" << file1 << \" completed.\\n\";\n27\n28     auto content2 = future.get();\n29     thread2.detach();\n30     return diffContent(content1, content2);\n31   } catch (std::exception& e) {\n32     std::cout << \"Exception caught: \" << e.what() << '\\n';\n33   }\n34\n35   return std::vector<char>(); \n36 }\n```", "```cpp\n 1 #include <iostream>\n 2 #include <thread>\n 3 #include <future>\n 4 #include <chrono>\n 5 #include <ctime>\n 6 #include <cstdlib>\n 7\n 8 int main()\n 9 {\n10   int duration = 10 + rand() % 10;\n11   srand(time(0));\n12   std::cout << \"Main thread id=\"\n13             << std::this_thread::get_id() << '\\n';\n14 \n15   std::future<int> future =\n16     std::async(std::launch::async,\n17        [](int secs) -> int {               \n18            std::cout << \"Thread \" << std::this_thread::get_id()\n19                     << \" sleeping for \"\n20                     << secs << \" seconds\\n\";\n21            std::this_thread::sleep_for(\n22                     std::chrono::seconds(secs));\n23            return secs;\n24        }, duration);\n25   \n26   size_t timeout_count = 0, secs = 2;\n27 \n28   while (future.wait_for(std::chrono::seconds(secs))\n29           == std::future_status::timeout) {\n30     std::cout << \"Main thread timed out\\n\";\n31     ++timeout_count;\n32   }\n33   std::cout << \"Launched task slept for \" \n34             << future.get() << '\\n';\n35   std::cout << \"Timed out for \" << timeout_count * secs \n36             << \" seconds \\n\";\n37 }\n```", "```cpp\nauto future = std::async([]() {...}, arg1, arg2);\n```", "```cpp\nauto future = std::async(std::launch::async|std::launch::deferred,\n                          []() {...}, arg1, arg2);\n```", "```cpp\nint main() {\n  int x = 0;\n  const int max = 1000000;\n\n  auto thrFunc = [&x]() {\n                          for (int i = 0; i < max; ++i) {\n                            ++x;\n                          }\n                        };\n\n  boost::thread t1(thrFunc);\n  boost::thread t2(thrFunc);\n  t1.join();\n  t2.join();\n\n  std::cout << \"Value of x: \" << x << '\\n';\n}\n```", "```cpp\n 1 #include <boost/thread/thread.hpp>\n 2 #include <boost/thread/mutex.hpp>\n 3 #include <iostream>\n 4\n 5 int main()\n 6 {\n 7   int x = 0;\n 8   static const int max = 1000000;\n 9   boost::mutex mtx;\n10\n11   auto thrFunc = [&x, &mtx]() {\n12     for (int i = 0; i < max; ++i) {\n13       mtx.lock();\n14       ++x;\n15       mtx.unlock();\n16     }\n17   };\n18\n19   boost::thread t1(thrFunc);\n20   boost::thread t2(thrFunc);\n21\n22   t1.join();\n23   t2.join();\n24\n25   std::cout << \"Value of x: \" << x << '\\n';\n26 }\n```", "```cpp\n2000000\n```", "```cpp\n12     mtx.lock();\n13     for (int i = 0; i < max; ++i) {\n14       ++x;\n15     }\n16     mtx.unlock();\n```", "```cpp\nboost::mutex mtx;\nif (mtx.try_lock()) {\n  std::cout << \"Acquired lock\\n\";\n} else {\n  std::cout << \"Failed to acquire lock\\n\";\n}\n```", "```cpp\nboost::mutex mtx;\nif (mtx.try_lock_for(boost::chrono::seconds(5))) { \n  std::cout << \"Acquired lock\\n\";\n} else {\n  std::cout << \"Failed to acquire lock\\n\";\n}\n```", "```cpp\n 1 #include <boost/thread/thread.hpp>\n 2 #include <boost/thread/mutex.hpp>\n 3 #include <iostream>\n 4\n 5 int main()\n 6 {\n 7   int x = 0;\n 8   static const int max = 1000000;\n 9   boost::mutex mtx;\n10\n11   auto thrFunc = [&x, &mtx]() {\n12     for (int i = 0; i < max; ++i) {\n13       boost::lock_guard<boost::mutex> lg(mtx);\n14       ++x;\n16     }\n17   };\n18\n19   boost::thread t1(thrFunc);\n20   boost::thread t2(thrFunc);\n21\n22   t1.join();\n23   t2.join();\n24\n25   std::cout << \"Value of x: \" << x << '\\n';\n26 }\n```", "```cpp\n 1 boost::mutex mtx;\n 2 ...\n 3 mtx.lock();  // mutex locked\n 4 ...\n 5 {\n 6   boost::lock_guard<boost::mutex> lk(mtx, boost::adopt_lock);\n 7   ...\n 8 } // end of scope\n```", "```cpp\n 7   int x = 0;\n 8   static const int max = 1000000;\n 9   boost::mutex mtx;\n10\n11   auto thrFunc = [&x, &mtx]() {\n12     boost::unique_lock<boost::mutex> ul(mtx, boost::defer_lock);\n13     assert(!ul.owns_lock());\n14\n15     for (int i = 0; i < max; ++i) {\n16       ul.lock();\n17       ++x;\n18       assert(ul.owns_lock());\n19       assert(ul.mutex() == &mtx);\n20\n21       ul.unlock();\n22     }\n23   };\n```", "```cpp\n 1 #include <iostream>\n 2 #include <cstdlib>\n 3 #include <ctime>\n 4 #include <set>\n 5 #include <boost/thread.hpp>\n 6\n 7 struct player {\n 8   int id;\n 9   // other fields\n10   bool operator < (const player& that) const {\n11     return id < that.id;\n12   }\n13 };\n14\n15 std::set<player> armed, unarmed; // A, U\n16 boost::mutex amtx, umtx;\n17\n18 auto a2u = [&](int playerId) {\n19         boost::lock_guard<boost::mutex> lka(amtx);\n20         auto it = armed.find(player{playerId}); \n21         if (it != armed.end()) {\n22           auto plyr = *it;\n23           boost::unique_lock<boost::mutex> lku(umtx);\n24           unarmed.insert(plyr);\n25           lku.unlock();\n26           armed.erase(it);\n27         }\n28       };\n29\n30 auto u2a = [&](int playerId) {\n31         boost::lock_guard<boost::mutex> lku(umtx);\n32         auto it = unarmed.find(player{playerId});\n33         if (it != unarmed.end()) {\n34           auto plyr = *it;\n35           boost::unique_lock<boost::mutex> lka(amtx);\n36           armed.insert(plyr);\n37           lka.unlock();\n38           unarmed.erase(it);\n39         }\n40       };\n41\n42 void onAmmoExhausted(int playerId) { // event callback\n43   boost::thread exhausted(a2u, playerId);\n44   exhausted.detach();\n45 }\n46\n47 void onAmmoReplenished(int playerId) { // event callback\n48   boost::thread replenished(a2u, playerId);\n49   replenished.detach();\n50 }\n```", "```cpp\n30 auto u2a = [&](int playerId) {\n31     boost::unique_lock<boost::mutex> \n32       lka(amtx, boost::defer_lock),\n33       lku(umtx, boost::defer_lock);\n34                                              \n35     boost::lock(lka, lku);  // ordered locking\n36     auto it = unarmed.find(player{playerId});\n37     if (it != unarmed.end()) {\n38       auto plyr = *it;\n39       armed.insert(plyr);\n40       lka.unlock();\n41       unarmed.erase(it);\n42     }\n43   };\n```", "```cpp\n 1 #include <boost/thread/thread.hpp>\n 2 #include <boost/thread/mutex.hpp>\n 3 #include <boost/thread/condition_variable.hpp>\n 4 #include <boost/array.hpp>\n 5\n 6 template <typename T, size_t maxsize>\n 7 struct CircularQueue\n 8 {\n 9   CircularQueue () : head_(0), tail_(0) {}\n10\n11   void pop() {\n12     boost::unique_lock<boost::mutex> lock(qlock);\n13     if (size() == 0) {\n14       canRead.wait(lock, [this] { return size() > 0; });\n15     }\n16     ++head_;\n17     lock.unlock();\n18     canWrite.notify_one();\n19   }\n20\n21   T top() {\n22     boost::unique_lock<boost::mutex> lock(qlock);\n23    if (size() == 0) {\n24       canRead.wait(lock, [this] { return size() > 0; });\n25     }\n26     T ret = data[head_ % maxsize];\n27     lock.unlock();\n28\n29     return ret;\n30   }\n31\n32   void push(T&& obj) {\n33     boost::unique_lock<boost::mutex> lock(qlock);\n34     if (size() == capacity()) {\n35       canWrite.wait(lock, [this] \n36                         { return size() < capacity(); });\n37     }\n38     data[tail_++ % maxsize] = std::move(obj);\n39     lock.unlock();\n40     canRead.notify_one();\n41   }\n42\n43   size_t head() const { return head_; }\n44   size_t tail() const { return tail_; }\n45\n46   size_t count() const {\n47     boost::unique_lock<boost::mutex> lock(qlock);\n48     return (tail_ - head_); \n49   }\n50\n51 private:\n52   boost::array<T, maxsize> data;\n53   size_t head_, tail_;\n54 \n55   size_t capacity() const { return maxsize; }\n56   size_t size() const { return (tail_ - head_); };\n57\n58   mutable boost::mutex qlock;\n59   mutable boost::condition_variable canRead;\n60   mutable boost::condition_variable canWrite;\n61 };\n62\n63 int main()\n64 {\n65   CircularQueue<int, 200> ds;\n66\n67   boost::thread producer([&ds] {\n68             for (int i = 0; i < 10000; ++i) {\n69               ds.push(std::move(i));\n70               std::cout << i << \"-->\"\n71                   << \" [\" << ds.count() << \"]\\n\";\n72             }\n73          });\n74\n75   auto func = [&ds] {\n76     for (int i = 0; i < 2500; ++i) {\n77       std::cout << \"\\t\\t<--\" << ds.top() << \"\\n\";\n78       ds.pop();\n79     }\n80   };\n81\n82   boost::thread_group consumers;\n83   for (int i = 0; i < 4; ++i) {\n84     consumers.create_thread(func);\n85   }\n86 \n87   producer.join();\n88   consumers.join_all();\n89 }\n```", "```cpp\n 1 struct book_t\n 2 {\n 3   std::string title;\n 4   std::string author;\n 5   int edition;\n 6 };\n 7\n 8 class LibraryCatalog\n 9 {\n10 public:\n11   typedef boost::unordered_map<std::string, book_t> map_type;\n12   typedef std::vector<book_t> booklist_t;\n13\n14   boost::optional<book_t> find_book(const std::string& title) \n15                                                       const;\n16   booklist_t find_books(const std::vector<std::string>& \n17                                            titles) const;\n18   bool add_book(const book_t& book);\n19   bool remove_book(const std::string& title);\n20 };\n```", "```cpp\n 1 #include <vector>\n 2 #include <string>\n 3 #include <boost/thread.hpp>\n 4 #include <boost/optional.hpp>\n 5 #include <boost/unordered/unordered_map.hpp>\n 6\n 7 struct book_t { /* definitions */ };\n 8\n 9\n10 class LibraryCatalog {\n11 public:\n12   typedef boost::unordered_map<std::string, book_t> map_type;\n13   typedef std::vector<book_t> booklist_t;\n14\n15   boost::optional<book_t> find_book(const std::string& title)\n16                                                       const {\n17     boost::shared_lock<boost::shared_mutex> rdlock(mtx);\n18     auto it = catalog.find(title);\n19\n20     if (it != catalog.end()) {\n21       return it->second;\n22     }\n23     rdlock.unlock();\n24\n25     return boost::none;\n26   }\n27\n28   booklist_t find_books(const std::vector<std::string>& titles)\n29                                                         const {\n30     booklist_t result;\n31     for (auto title : titles) {\n32       auto book = find_book(title);\n33\n34       if (book) {\n35         result.push_back(book.get());\n36       }\n37     }\n38\n39     return result;\n40   }\n41\n42   bool add_book(const book_t& book) {\n43     boost::unique_lock<boost::shared_mutex> wrlock(mtx);\n44     auto it = catalog.find(book.title);\n45\n46     if (it == catalog.end()) {\n47       catalog[book.title] = book;\n48       return true;\n49     }\n50     else if (it->second.edition < book.edition) {\n51       it->second = book;\n52       return true;\n53     }\n54\n55     return false;\n56   }\n57\n58   bool remove_book(const std::string& title) {\n59     boost::unique_lock<boost::shared_mutex> wrlock(mtx);\n60     return catalog.erase(title);\n61   }\n62\n63 private:\n64   map_type catalog;\n65   mutable boost::shared_mutex mtx;\n66 };\n```", "```cpp\n 1 bool LibraryCatalog::add_book(const book_t& book) {\n 2   boost::upgrade_lock<boost::shared_mutex> upglock(mtx);\n 3   auto it = catalog.find(book.title);\n 4\n 5   if (it == catalog.end()) {\n 6     boost::upgrade_to_unique_lock<boost::shared_mutex> \n 7                                             ulock(upglock);\n 8     catalog[book.title] = book;\n 9     return true;\n10   } else if (it->second.edition > book.edition) {\n11     boost::upgrade_to_unique_lock<boost::shared_mutex> \n12                                             ulock(upglock);\n13     it->second = book;\n14     return true;\n15   }\n16\n17   return false;\n18 }\n```", "```cpp\n 1 #include <iostream>\n 2 #include <boost/coroutine/all.hpp>\n 3 #include <boost/bind.hpp>\n 4 #include <vector>\n 5 #include <string>\n 6\n 7 template <typename T>\n 8 using pull_type = typename\n 9   boost::coroutines::asymmetric_coroutine<T>::pull_type;\n10\n11 template <typename T>\n12 using push_type = typename\n13   boost::coroutines::asymmetric_coroutine<T>::push_type;\n14\n15 template <typename T>\n16 void getNextElem(push_type<T>& sink, \n17                  const std::vector<T>& vec)\n18 {\n19   for (const auto& elem: vec) {\n20     sink(elem);\n21   }\n22 }\n23\n24 int main()\n25 {\n26   std::vector<std::string> vec{\"hello\", \"hi\", \"hola\", \n27                                \"servus\"};\n28   pull_type<std::string> greet_func(\n29       boost::bind(getNextElem<std::string>, ::_1, \n30       boost::cref(vec)));\n31\n32   while (greet_func) {\n33     std::cout << greet_func.get() << '\\n';\n34     greet_func();\n35   }\n36 }\n```", "```cpp\nvoid (push_type&, const std::vector<T>&)\n```"]