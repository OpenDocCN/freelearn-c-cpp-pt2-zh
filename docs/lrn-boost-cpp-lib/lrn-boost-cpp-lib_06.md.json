["```cpp\n 1 struct PersonEntry\n 2 {\n 3   std::string name;\n 4   std::string phoneNumber;\n 5   std::string city;\n 6 };\n```", "```cpp\n 1 bool operator<(const PersonEntry& left, \n 2                const PersonEntry& right) {\n 3   return left.name< right.name;\n 4 }\n```", "```cpp\n 1 #include <set>\n 2 #include <iostream>\n 3 #include <string>\n 4\n 5 struct PersonEntry {\n 6   std::string name;\n 7   std::string phoneNumber;\n 8   std::string city;\n 9 };\n10\n11 int main() {\n12   std::multiset<PersonEntry> directory;\n13   PersonEntry p1{\"Arindam Mukherjee\", \"550 888 9999\", \"Pune\"};\n14   PersonEntry p2{\"Arindam Mukherjee\", \"990 770 2458\", \n15                  \"Calcutta\"};\n16   directory.insert(p1);\n17   directory.insert(p2);\n18   auto it1 = directory.lower_bound(\n19                 PersonEntry{ \"Arindam Mukherjee\", \"\", \"\" });\n20   auto it2 = directory.upper_bound(\n21                 PersonEntry{ \"Arindam Mukherjee\", \"\", \"\" });\n22\n23   while (it1 != it2) {\n24     std::cout << \"Found: [\" <<it1->name << \", \"\n25               <<it1->phoneNumber << \", \" <<it1->city << \"]\\n\";\n26     ++it1;\n27   }\n28 }\n```", "```cpp\n 1 #include <boost/multi_index_container.hpp>\n 2 #include <boost/multi_index/indexed_by.hpp>\n 3 #include <boost/multi_index/ordered_index.hpp>\n 4 #include <boost/multi_index/identity.hpp>\n 5\n 6 using namespace boost::multi_index;\n 7\n 8 typedef ordered_non_unique<identity<PersonEntry>> by_person;\n 9 typedef multi_index_container<PersonEntry,\n10                       indexed_by<by_person>> directory_t;\n\n```", "```cpp\n 1 #include <boost/multi_index_container.hpp>\n 2 #include <boost/multi_index/indexed_by.hpp>\n 3 #include <boost/multi_index/ordered_index.hpp>\n 4 #include <boost/multi_index/identity.hpp>\n 5 #include <boost/multi_index/member.hpp>\n 6 #include \"PersonEntry.h\"  // contains PersonEntry definition\n 7 using namespace boost::multi_index;\n 8\n 9 typedef ordered_non_unique<member<PersonEntry, std::string,\n10                           &PersonEntry::name>> by_name;\n11 typedef ordered_unique<member<PersonEntry, std::string,\n12                        &PersonEntry::phoneNumber>>by_phone;\n13\n14 typedef multi_index_container<PersonEntry,\n15                             indexed_by<by_name,\n16                                        by_phone>> directory_t;\n\n```", "```cpp\n 1 int main()\n 2 {\n 3   directory_t phonedir;\n 4   PersonEntry p1{\"Arindam Mukherjee\", \"550 888 9999\", \"Pune\"};\n 5   PersonEntry p2{\"Arindam Mukherjee\", \"990 770 2458\", \n 6                  \"Calcutta\"};\n 7   PersonEntry p3{\"Ace Ventura\", \"457 330 1288\", \"Tampa\"};\n 8\n 9   phonedir.insert(p1);\n10   phonedir.insert(p2);\n11   phonedir.insert(p3);\n12 \n13   auto iter = phonedir.find(\"Ace Ventura\");\n14   assert(iter != phonedir.end() && iter->city == \"Tampa\");\n15\n16   auto& ph_indx = phonedir.get<1>();\n17   auto iter2 = ph_indx.find(\"990 770 2458\");\n18   assert(iter2 != ph_indx.end());\n19   assert(iter2->city == \"Calcutta\");\n20\n21   for (auto& elem: ph_indx) {\n22     std::cout << elem.name <<\" lives in \" << elem.city\n23         << \" and can be reached at \"<< elem.phoneNumber\n24         << '\\n';\n25   }\n26 }\n```", "```cpp\n 1 struct phone_tag {};\n 2 typedef ordered_unique< <tag<phone_tag>, member<PersonEntry, \n 3          std::string, &PersonEntry::phoneNumber>> by_phone;\n 4\n 5 auto& ph_indx = phonedir.get<phone_tag>(); \n\n```", "```cpp\n 1 #include <boost/multi_index/sequenced_index.hpp>\n 2 typedef multi_index_container<PersonEntry,\n 3                             indexed_by<by_name,\n 4                                        by_phone,\n 5                             sequenced<>>> directory_t;\n\n```", "```cpp\n 1 #include <boost/multi_index/random_access_index.hpp>\n 2 typedef multi_index_container<PersonEntry,\n 3                      indexed_by<by_name,\n 4                           by_phone,\n 5                           random_access<>>> directory_t;\n\n```", "```cpp\n 1 // the necessary includes for Boost Multi-index\n 2\n 3 typedef multi_index_container<PersonEntry,\n 4 indexed_by<by_name,by_phone, \n 5                               random_access<>>> directory_t;\n 6\n 7 int main()\n 8 {\n 9   directory_t phonedir;  // directory_t defined in listing 6.3\n10\n11   phonedir.insert(PersonEntry{\"Dr. Dolittle\", \"639 420 7624\", \n12                               \"Atlanta\"});\n13   phonedir.insert(PersonEntry{\"Arindam Mukherjee\", \n14                               \"990 770 2458\", \"Calcutta\"});\n15   phonedir.insert(PersonEntry{\"Ace Ventura\", \"457 330 1288\",\n16                               \"Tampa\"});\n17   phonedir.insert(PersonEntry{\"Arindam Mukherjee\", \n18                               \"550 888 9999\", \"Pune\"});\n19\n20   auto& name_index = phonedir.get<0>();\n21   auto it = name_index.find(\"Ace Ventura\");\n22   auto& random_index = phonedir.get<2>();\n23   if (it != name_index.end()) {\n24     auto rit = phonedir.project<2>(it);\n25     std::cout << \"Element found: \" << it->name \n26       << \", position = \" <<rit - random_index.begin() << '\\n';\n27   }\n28 }\n```", "```cpp\n 1 // include required Boost Multi-index headers\n 2 #include <boost/lambda/lambda.hpp>\n 3\n 4 namespace bl = boost::lambda;  // lambda placeholder\n 5\n 6 int main()\n 7 {\n 8   directory_t phonedir;  // directory_t defined in listing 6.3\n 9\n10    phonedir.insert(PersonEntry{\"Dr. Dolittle\", \"639 420 7624\",\n11                                \"Atlanta\"});\n12    phonedir.insert(PersonEntry{\"Arindam Mukherjee\", \n13                                \"990 770 2458\", \"Calcutta\"});\n14    phonedir.insert(PersonEntry{\"Ace Ventura\", \"457 330 1288\",\n15                               \"Tampa\"});\n16    phonedir.insert(PersonEntry{\"Arindam Mukherjee\", \n17                                \"550 888 9999\", \"Pune\"});\n18\n19   auto& name_index = phonedir.get<0>();\n20   auto range = name_index.range(\"Ar\" <= bl::_1, \"D\" > bl::_1);\n21 \n22   for (auto start = range.first; start != range.second; \n23        ++start) {\n24     std::cout << start->name << \", \" << start->phoneNumber \n25               << \", \" << start->city << \"\\n\";\n26   }\n27 }\n```", "```cpp\nArindam Mukherjee, 550 888 9999, Pune\nArindam Mukherjee, 990 770 2458, Calcutta\n```", "```cpp\n 1 // include required Boost Multi-Index headers\n 2 #include <boost/lambda/lambda.hpp>\n 3\n 4 // by_name, by_phone defined Listing 6.3\n 5 using namespace boost::multi_index;\n 6\n 7 typedef ordered_non_unique<member<PersonEntry, std::string, \n 8                             &PersonEntry::name>> by_name;\n 9 typedef ordered_unique<member<PersonEntry, std::string, \n10                        &PersonEntry::phoneNumber>> by_phone;\n11 typedef multi_index_container<PersonEntry,\n12                              indexed_by<random_access<>,\n13                                 by_name, by_phone>> phdir_t;\n14\n15 int main()\n16 {\n17   phdir_t phonedir;\n18\n19   phonedir.push_back(PersonEntry{\"Dr. Dolittle\",\n20            \"639 420 7624\", \"Atlanta\"}); // insert won't work\n21   auto& phindx = phonedir.get<2>();\n22   phindx.insert(PersonEntry{\"Arindam Mukherjee\",\n23                             \"550 888 9999\", \"Pune\"});\n24   auto& nameindx = phonedir.get<1>();\n25   nameindx.insert(PersonEntry{\"Arindam Mukherjee\",\n26                               \"990 770 2458\", \"Calcutta\"});\n27   phonedir.push_front(PersonEntry{\"Ace Ventura\", \n28                               \"457 330 1288\", \"Tampa\"});\n29\n30   nameindx.erase(\"Arindam Mukherjee\");  // erases 2 matching\n31   phonedir.erase(phonedir.begin());     // erases Ace Ventura\n32   assert(phonedir.size() == 1);\n33   std::cout <<\"The lonesome \"<< phonedir.begin()->name << '\\n';\n34\n35   phonedir.push_back(PersonEntry{\"Tarzan\", \"639 420 7624\", \n36                                  \"Okavango\"});\n37   assert(phonedir.size() == 1);\n38   std::cout <<\"Still alone \"<< phonedir.begin()->name << '\\n'; \n39 \n40   phonedir.push_back(PersonEntry{\"Tarzan\", \"9441500252\",\n41                                  \"Okavango\"});\n42   assert(phonedir.size() == 2);\n43\n44   PersonEntry tarzan = *(phonedir.begin() + 1);\n45   tarzan.phoneNumber = \"639 420 7624\";\n46   assert(!phonedir.replace(phonedir.begin() + 1, tarzan));\n47 }\n```", "```cpp\nThe lonesome Dr. Dolittle\n```", "```cpp\n 1 #include <boost/bimap.hpp>\n 2 #include <boost/assign.hpp>\n 3 #include <string>\n 4 #include <iostream>\n 5 #include <cassert>\n 6 using namespace boost::assign;\n 7\n 8 typedef boost::bimap<std::string, std::string> string_bimap_t;\n 9\n10 int main()\n11 {\n12   string_bimap_t countryCapitals;\n13\n14   insert(countryCapitals)(\"Slovenia\", \"Ljubljana\")\n15                          (\"New Zealand\", \"Wellington\")\n16                          (\"Tajikistan\", \"Bishkek\")\n17                          (\"Chile\", \"Santiago\")\n18                          (\"Jamaica\", \"Kingston\");\n19\n20   string_bimap_t::left_map& countries = countryCapitals.left;\n21   string_bimap_t::left_map::const_iterator it\n22        = countries.find(\"Slovenia\");\n23   if (it != countries.end()) {\n24     std::cout << \"Capital of \"<< it->first << \" is \"\n25               << it->second << \"\\n\";\n26   }\n27\n28   string_bimap_t::right_map& cities = countryCapitals.right;\n29   string_bimap_t::right_map::const_iterator it2\n30        = cities.find(\"Santiago\");\n31   if (it2 != cities.end()) {\n32      std::cout << it2->first <<\" is the capital of \"\n33                << it2->second << \"\\n\";\n34   }\n35\n36   size_t size = countryCapitals.size();\n37   countryCapitals.insert(\n38        string_bimap_t::value_type(\"Chile\", \"Valparaiso\"));\n39   assert(countries.at(\"Chile\") == \"Santiago\");\n40   assert(size == countryCapitals.size());\n41\n42   countryCapitals.insert(\n43     string_bimap_t::value_type(\"Norfolk Island\", \"Kingston\"));\n44   assert(cities.at(\"Kingston\") == \"Jamaica\");\n45   assert(size == countryCapitals.size());\n46 }\n```", "```cpp\n 1 #include <boost/bimap.hpp>\n 2 #include <boost/bimap/multiset_of.hpp>\n 3 #include <boost/assign.hpp>\n 4 #include <string>\n 5 #include <iostream>\n 6 #include <cassert>\n 7 using namespace boost::assign;\n 8 namespace boostbi = boost::bimaps;\n 9\n10 typedef boost::bimap<boostbi::multiset_of<std::string>,\n11             boostbi::multiset_of<std::string>> string_bimap_t;\n12\n13 int main()\n14 {\n15   string_bimap_t namesShortNames;\n16\n17   insert(namesShortNames)(\"Robert\", \"Bob\")\n18                          (\"Robert\", \"Rob\")\n19                          (\"William\", \"Will\")\n20                          (\"Christopher\", \"Chris\")\n21                          (\"Theodore\", \"Ted\")\n22                          (\"Edward\", \"Ted\");\n23\n24   size_t size = namesShortNames.size();\n25   namesShortNames.insert(\n26           string_bimap_t::value_type(\"William\", \"Bill\"));\n27   assert(size + 1 == namesShortNames.size());\n28\n29   namesShortNames.insert(\n30           string_bimap_t::value_type(\"Christian\", \"Chris\"));\n31   assert(size + 2 == namesShortNames.size());\n32\n33   string_bimap_t::left_map& names = namesShortNames.left;\n34   string_bimap_t::left_map::const_iterator it1\n35        = names.lower_bound(\"William\");\n36   string_bimap_t::left_map::const_iterator it2\n37        = names.upper_bound(\"William\");\n38\n39   while (it1 != it2) {\n40     std::cout << it1->second <<\" is a nickname for \"\n41               << it1->first << '\\n';\n42     ++it1;\n43   }\n44\n45   string_bimap_t::right_map& shortNames = \n46                                   namesShortNames.right;\n46   \n47   auto iter_pair = shortNames.equal_range(\"Chris\");\n48   for (auto it3 = iter_pair.first; it3 != iter_pair.second;\n49        ++it3) {\n50     std::cout << it3->first <<\" is a nickname for \"\n51               << it3->second << '\\n';\n52   } \n53 }\n```", "```cpp\n 1 struct name {};\n 2 struct nickname {};\n 3\n 4 typedef boost::bimap<\n 5             boostbi::multiset_of<\n 6                boostbi::tagged<std::string, name>>,\n 7             boostbi::multiset_of<\n 8                boostbi::tagged<std::string, nickname>>>\n 9         string_bimap_t;\n10\n11 string_bimap_t namesShortNames;\n12\n13 auto& names = namesShortNames.by<name>();\n14 auto& nicknames = namesShortNames.by<nickname>();\n\n```", "```cpp\n 1 #include <boost/bimap/support/lambda.hpp>\n 2\n 3 \u2026\n 4 string_bimap_t namesShortNames;\n 5 \u2026\n 6 using boost::bimaps::_key;\n 7 const auto& range = namesShortNames.right.range(\"Ch\" <= _key,\n 8                                                 _key < \"W\");\n 9 \n10 for (auto i1 = range.first; i1 != range.second; ++i1) {\n11   std::cout << i1->first << \":\" << i1->second << '\\n';\n12 }\n```", "```cpp\n 1 auto i1 = names.find(\"Edward\");\n 2 auto i2 = namesShortNames.project<nickname>(i1);\n 3\n 4 const auto& range = shortNames.range(_key == i2->first, \n 5                                      _key == i2->first);\n 6\n 7 for (auto i3 = range.first; i3 != range.second; ++i3) {\n 8   std::cout << i3->first << \":\" << i3->second << '\\n';\n 9 }\n```"]