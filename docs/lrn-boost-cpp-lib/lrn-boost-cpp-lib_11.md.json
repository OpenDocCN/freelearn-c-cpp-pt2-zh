["```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 namespace asio = boost::asio;\n 4\n 5 int main() {\n 6   asio::io_service service;\n 7\n 8   service.post(\n 9     [] {\n10       std::cout << \"Hello, world!\" << '\\n';\n11     });\n12\n13   std::cout << \"Greetings: \\n\";\n14   service.run();\n15 }\n```", "```cpp\n$ g++ -g listing11_1.cpp -o listing11_1 -lboost_system -std=c++11\n\n```", "```cpp\n$ g++ -g listing11_25.cpp -o listing11_25 -lboost_system -lboost_coroutine -lboost_date_time -std=c++11\n\n```", "```cpp\nGreetings: Hello, World!\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 namespace asio = boost::asio;\n 4\n 5 int main() {\n 6   asio::io_service service;\n 7   // Hello Handler \u2013 dispatch behaves like post\n 8   service.dispatch([]() { std::cout << \"Hello\\n\"; });\n 9\n10   service.post(\n11     [&service] { // English Handler\n12       std::cout << \"Hello, world!\\n\";\n13       service.dispatch([] {  // Spanish Handler, immediate\n14                          std::cout << \"Hola, mundo!\\n\";\n15                        });\n16     });\n17   // German Handler\n18   service.post([&service] {std::cout << \"Hallo, Welt!\\n\"; });\n19   service.run();\n20 }\n```", "```cpp\nHello\nHello, world!\nHola, mundo!\nHallo, Welt!\n```", "```cpp\nHello Handler\nEnglish Handler\nGerman Handler\n```", "```cpp\nHello\nHello, world!\nHallo, Welt!\nHola, mundo!\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/thread.hpp>\n 3 #include <boost/date_time.hpp>\n 4 #include <iostream>\n 5 namespace asio = boost::asio;\n 6\n 7 #define PRINT_ARGS(msg) do {\\\n 8   boost::lock_guard<boost::mutex> lg(mtx); \\\n 9   std::cout << '[' << boost::this_thread::get_id() \\\n10             << \"] \" << msg << std::endl; \\\n11 } while (0)\n12\n13 int main() {\n14   asio::io_service service;\n15   boost::mutex mtx;\n16\n17   for (int i = 0; i < 20; ++i) {\n18     service.post([i, &mtx]() { \n19                          PRINT_ARGS(\"Handler[\" << i << \"]\");\n20                          boost::this_thread::sleep(\n21                               boost::posix_time::seconds(1));\n22                        });\n23   }\n24\n25   boost::thread_group pool;\n26   for (int i = 0; i < 4; ++i) {\n27     pool.create_thread([&service]() { service.run(); });\n28   }\n29\n30   pool.join_all();\n31 }\n```", "```cpp\n$ g++ -g listing9_3.cpp -o listing9_3 -lboost_system -lboost_thread -lboost_date_time -pthread -std=c++11\n\n```", "```cpp\n[b5c15b40] Handler[0]\n[b6416b40] Handler[1]\n[b6c17b40] Handler[2]\n[b7418b40] Handler[3]\n[b5c15b40] Handler[4]\n[b6416b40] Handler[5]\n\u2026\n[b6c17b40] Handler[13]\n[b7418b40] Handler[14]\n[b6416b40] Handler[15]\n[b5c15b40] Handler[16]\n[b6c17b40] Handler[17]\n[b7418b40] Handler[18]\n[b6416b40] Handler[19]\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <memory>\n 3 #include <boost/thread.hpp>\n 4 #include <iostream>\n 5 namespace asio = boost::asio;\n 6\n 7 typedef std::unique_ptr<asio::io_service::work> work_ptr;\n 8\n 9 #define PRINT_ARGS(msg) do {\\ \u2026 \n...\n14\n15 int main() {\n16   asio::io_service service;\n17   // keep the workers occupied\n18   work_ptr work(new asio::io_service::work(service));\n19   boost::mutex mtx;\n20\n21   // set up the worker threads in a thread group\n22   boost::thread_group workers;\n23   for (int i = 0; i < 3; ++i) {\n24     workers.create_thread([&service, &mtx]() {\n25                          PRINT_ARGS(\"Starting worker thread \");\n26                          service.run();\n27                          PRINT_ARGS(\"Worker thread done\");\n28                        });\n29   }\n30\n31   // Post work\n32   for (int i = 0; i < 20; ++i) {\n33     service.post(\n34       [&service, &mtx]() {\n35         PRINT_ARGS(\"Hello, world!\");\n36         service.post([&mtx]() {\n37                            PRINT_ARGS(\"Hola, mundo!\");\n38                          });\n39       });\n40   }\n41\n42   work.reset(); // destroy work object: signals end of work\n43   workers.join_all(); // wait for all worker threads to finish\n44 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/thread.hpp>\n 3 #include <boost/date_time.hpp>\n 4 #include <cstdlib>\n 5 #include <iostream>\n 6 #include <ctime>\n 7 namespace asio = boost::asio;\n 8 #define PRINT_ARGS(msg) do {\\\n...\n13\n14 int main() {\n15   std::srand(std::time(0));\n16   asio::io_service service;\n17   asio::io_service::strand strand(service);\n18   boost::mutex mtx;\n19   size_t regular = 0, on_strand = 0;\n20 \n21  auto workFuncStrand = [&mtx, &on_strand] {\n22           ++on_strand;\n23           PRINT_ARGS(on_strand << \". Hello, from strand!\");\n24           boost::this_thread::sleep(\n25                       boost::posix_time::seconds(2));\n26         };\n27\n28   auto workFunc = [&mtx, &regular] {\n29                   PRINT_ARGS(++regular << \". Hello, world!\");\n30                   boost::this_thread::sleep(\n31                         boost::posix_time::seconds(2));\n32                 };\n33   // Post work\n34   for (int i = 0; i < 15; ++i) {\n35     if (rand() % 2 == 0) {\n36       service.post(strand.wrap(workFuncStrand));\n37     } else {\n38       service.post(workFunc);\n39     }\n40   }\n41\n42   // set up the worker threads in a thread group\n43   boost::thread_group workers;\n44   for (int i = 0; i < 3; ++i) {\n45     workers.create_thread([&service, &mtx]() {\n46                        PRINT_ARGS(\"Starting worker thread \");\n47                       service.run();\n48                        PRINT_ARGS(\"Worker thread done\");\n49                     });\n50   }\n51\n52   workers.join_all(); // wait for all worker threads to finish\n53 }\n```", "```cpp\n33   for (int i = 0; i < 15; ++i) {\n34     if (rand() % 2 == 0) {\n35       strand.post(workFuncStrand);\n37     } else {\n...\n```", "```cpp\n[b73b6b40] Starting worker thread \n[b73b6b40] 0\\. Hello, world from strand!\n[b6bb5b40] Starting worker thread \n[b6bb5b40] 1\\. Hello, world!\n[b63b4b40] Starting worker thread \n[b63b4b40] 2\\. Hello, world!\n[b73b6b40] 3\\. Hello, world from strand!\n[b6bb5b40] 5\\. Hello, world!\n[b63b4b40] 6\\. Hello, world!\n\u2026\n[b6bb5b40] 14\\. Hello, world!\n[b63b4b40] 4\\. Hello, world from strand!\n[b63b4b40] 8\\. Hello, world from strand!\n[b63b4b40] 10\\. Hello, world from strand!\n[b63b4b40] 13\\. Hello, world from strand!\n[b6bb5b40] Worker thread done\n[b73b6b40] Worker thread done\n[b63b4b40] Worker thread done\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 #include <cassert>\n 4 #include <vector>\n 5 namespace asio = boost::asio;\n 6 namespace sys = boost::system;\n 7 using namespace asio::ip;\n 8\n 9 void printAddrProperties(const address& addr) {\n10   std::cout << \"\\n\\n\" << addr << \": \";\n11\n12   if (addr.is_v4()) {\n13     std::cout << \"netmask=\" << address_v4::netmask(addr.to_v4());\n14   } else if (addr.is_v6()) { /* ... */ }\n15\n16   if (addr.is_unspecified()) { std::cout << \"is unspecified, \"; }\n17   if (addr.is_loopback()) { std::cout << \"is loopback, \"; }\n18   if (addr.is_multicast()) { std::cout << \"is multicast, \"; }\n19 }\n20\n21 int main() {\n22   sys::error_code ec;\n23   std::vector<address> addresses;\n24   std::vector<const char*> addr_strings{\"127.0.0.1\", \n25            \"10.28.25.62\", \"137.2.33.19\", \"223.21.201.30\",\n26            \"232.28.25.62\", \"140.28.25.62/22\"};\n27\n28   addresses.push_back(address_v4());       // default: 0.0.0.0\n29   addresses.push_back(address_v4::any());  // INADDR_ANY\n30\n31   for (const auto& v4str : addr_strings) {\n32     address_v4 addr = address_v4::from_string(v4str, ec);\n33     if (!ec) {\n34       addresses.push_back(addr);\n35     }\n36   }\n37\n38   for (const address& addr1: addresses) {\n39     printAddrProperties(addr1);\n40   }\n41 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 #include <vector>\n 4 namespace asio = boost::asio;\n 5 namespace sys = boost::system;\n 6 using namespace asio::ip;\n 7\n 8 void printAddr6Properties(const address_v6& addr) {\n 9   if (addr.is_v4_mapped()) { std::cout << \"is v4-mapped, \"; }\n10   else {  \n11     if (addr.is_link_local()) { std::cout << \"is link local\";}\n12   }  \n13 }\n14\n15 void printAddrProperties(const address& addr) { ... }\n16\n17 int main() {\n18   sys::error_code ec;\n19   std::vector<address> addresses;\n20   std::vector<const char*> addr_strings{\"::1\", \"::\",\n21     \"fe80::20\", \"::ffff:223.18.221.9\", \"2001::1e0:0:0:1a:2a\"};\n22\n23   for (const auto& v6str: addr_strings) {\n24     address addr = address_v6::from_string(v6str, ec);\n25     if (!ec) { addresses.push_back(addr); }\n26   }\n27\n28   for (const auto& addr : addresses) {\n29     printAddrProperties(addr);\n30   }\n31 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 namespace asio = boost::asio;\n 4\n 5 int main(int argc, char *argv[]) {\n 6   if (argc < 2) {\n 7     std::cout << \"Usage: \" << argv[0] << \" host [service]\\n\";\n 8     exit(1);\n 9   }\n10   const char *host = argv[1];\n11   const char *svc = (argc > 2) ? argv[2] : \"\";\n12\n13   try {\n14     asio::io_service service;\n15     asio::ip::tcp::resolver resolver(service);\n16     asio::ip::tcp::resolver::query query(host, svc);\n17     asio::ip::tcp::resolver::iterator end,\n18                             iter = resolver.resolve(query);\n19     while (iter != end) {\n20       asio::ip::tcp::endpoint endpoint = iter->endpoint();\n21       std::cout << \"Address: \" << endpoint.address()\n22                 << \", Port: \" << endpoint.port() << '\\n';\n23       ++iter;\n24     }\n25   } catch (std::exception& e) {\n26     std::cout << e.what() << '\\n';\n27   }\n28 }\n```", "```cpp\nasio::ip::tcp::resolver::query query(asio::ip::tcp::v6(), \n host, svc);\n\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 namespace asio = boost::asio;\n 4\n 5 int main(int argc, char *argv[]) {\n 6   if (argc < 2) {\n 7     std::cout << \"Usage: \" << argv[0] << \" ip [port]\\n\";\n 8     exit(1);\n 9   }\n10\n11   const char *addr = argv[1];\n12   unsigned short port = (argc > 2) ? atoi(argv[2]) : 0;\n13\n14   try {\n15     asio::io_service service;\n16     asio::ip::tcp::endpoint ep(\n17               asio::ip::address::from_string(addr), port);\n18     asio::ip::tcp::resolver resolver(service);\n19     asio::ip::tcp::resolver::iterator iter = \n20                              resolver.resolve(ep), end;\n21     while (iter != end) {\n22       std::cout << iter->host_name() << \" \"\n23                 << iter->service_name() << '\\n';\n24       iter++;\n25     }\n26   } catch (std::exception& ex) {\n27     std::cerr << ex.what() << '\\n';\n28   }\n29 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 #include <cassert>\n 4 namespace asio = boost::asio;\n 5\n 6 int main() {\n 7   char buf[10];\n 8   asio::mutable_buffer mbuf(buf, sizeof(buf));\n 9   asio::const_buffer cbuf(buf, 5);\n10\n11   std::cout << buffer_size(mbuf) << '\\n';\n12   std::cout << buffer_size(cbuf) << '\\n';\n13\n14   char *mptr = asio::buffer_cast<char*>(mbuf);\n15   const char *cptr = asio::buffer_cast<const char*>(cbuf);\n16   assert(mptr == cptr && cptr == buf);\n17   \n18   size_t offset = 5;\n19   asio::mutable_buffer mbuf2 = mbuf + offset;\n20   assert(asio::buffer_cast<char*>(mbuf2)\n21         - asio::buffer_cast<char*>(mbuf) == offset);\n22   assert(buffer_size(mbuf2) == buffer_size(mbuf) - offset);\n23 }\n```", "```cpp\nasio::const_buffer cbuf(addr, length);\nchar *buf = asio::buffer_cast<char*>(cbuf); // fails to compile\n\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <vector>\n 3 #include <string>\n 4 #include <iostream>\n 5 #include <cstdlib>\n 6 #include <ctime>\n 7 namespace asio = boost::asio;\n 8\n 9 int main() {\n10   std::srand(std::time(nullptr));\n11\n12   std::vector<char> v1(10);\n13   char a2[10];\n14   std::vector<asio::mutable_buffer> bufseq(2);\n15\n16   bufseq.push_back(asio::mutable_buffer(v1.data(), \n17                                         v1.capacity()));\n18   bufseq.push_back(asio::mutable_buffer(a2, sizeof(a2)));\n19\n20   for (auto cur = asio::buffers_begin(bufseq),\n21        end = asio::buffers_end(bufseq); cur != end; cur++) {\n22     *cur = 'a' + rand() % 26;\n23   }\n24\n25   std::cout << \"Size: \" << asio::buffer_size(bufseq) << '\\n';\n26\n27   std::string s1(v1.begin(), v1.end());\n28   std::string s2(a2, a2 + sizeof(a2));\n29\n30   std::cout << s1 << '\\n' << s2 << '\\n';\n31 }\n```", "```cpp\ntypedef basic_deadline_timer<boost::posix_time::ptime> \n                                             deadline_timer;\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/date_time.hpp>\n 3 #include <iostream>\n 4\n 5 int main() {\n 6   boost::asio::io_service service;\n 7   boost::asio::deadline_timer timer(service);\n 8\n 9   long secs = 5;\n10   std::cout << \"Waiting for \" << secs << \" seconds ...\" \n11             << std::flush;\n12   timer.expires_from_now(boost::posix_time::seconds(secs));\n13\n14   timer.wait();\n15 \n16   std::cout << \" done\\n\";\n17 }\n```", "```cpp\nusing namespace boost::gregorian;\nusing namespace boost::posix_time;\n\ntimer.expires_at(day_clock::local_day(), \n                 hours(16) + minutes(12) + seconds(58));\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/date_time.hpp>\n 3 #include <iostream>\n 4\n 5 void on_timer_expiry(const boost::system::error_code& ec)\n 6 {\n 7   if (ec) {\n 8     std::cout << \"Error occurred while waiting\\n\";\n 9   } else {\n10     std::cout << \"Timer expired\\n\";\n11   }\n12 }\n13\n14 int main()\n15 {\n16   boost::asio::io_service service;\n17   boost::asio::deadline_timer timer(service);\n18\n19\n20   long secs = 5;\n21   timer.expires_from_now(boost::posix_time::seconds(secs));\n22\n23   std::cout << \"Before calling deadline_timer::async_wait\\n\";\n24   timer.async_wait(on_timer_expiry);\n25   std::cout << \"After calling deadline_timer::async_wait\\n\";\n26\n27   service.run();\n28 }\n```", "```cpp\nBefore calling deadline_timer::async_wait\nAfter calling deadline_timer::async_wait\nTimer expired\n```", "```cpp\nboost::asio::deadline_timer timer;\ntimer.expires_from_now(boost::posix_time::seconds(5));\ntimer.wait();\nstd::cout << \"Hello, \";\ntimer.expires_from_now(boost::posix_time::seconds(10));\ntimer.wait();\nstd::cout << \"world!\\n\";\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/bind.hpp>\n 3 #include <boost/date_time.hpp>\n 4 #include <iostream>\n 5\n 6 void print_world(const boost::system::error_code& ec) {\n 7   std::cout << \"world!\\n\";\n 8 }\n 9\n10 void print_hello(boost::asio::deadline_timer& timer,\n11                  const boost::system::error_code& ec) {\n12   std::cout << \"Hello, \" << std::flush;\n13\n14   timer.expires_from_now(boost::posix_time::seconds(10));\n15   timer.async_wait(print_world);\n16 }\n17\n18 int main()\n19 {\n20   boost::asio::io_service service;\n21   boost::asio::deadline_timer timer(service);\n22   timer.expires_from_now(boost::posix_time::seconds(5));\n23\n24   timer.async_wait(boost::bind(print_hello, boost::ref(timer),\n25                                            ::_1));\n26\n27   service.run();\n28 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/asio/spawn.hpp>\n 3 #include <boost/bind.hpp>\n 4 #include <boost/date_time.hpp>\n 5 #include <iostream>\n 6\n 7 void wait_and_print(boost::asio::yield_context yield,\n 8                     boost::asio::io_service& service)\n 9 {\n10   boost::asio::deadline_timer timer(service);\n11\n12   timer.expires_from_now(boost::posix_time::seconds(5));\n13   timer.async_wait(yield);\n14   std::cout << \"Hello, \" << std::flush;\n15 \n16   timer.expires_from_now(boost::posix_time::seconds(10));\n17   timer.async_wait(yield);\n18   std::cout << \"world!\\n\";\n19 }\n20\n21 int main()\n22 {\n23   boost::asio::io_service service;\n24   boost::asio::spawn(service,\n25           boost::bind(wait_and_print, ::_1, \n26                                       boost::ref(service)));\n27   service.run();\n28 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 #include <exception>\n 4 namespace asio = boost::asio;\n 5\n 6 int main(int argc, char *argv[]) {\n 7   if (argc < 3) {\n 8     std::cerr << \"Usage: \" << argv[0] << \" host port\\n\";\n 9     return 1;\n10   }\n11\n12   asio::io_service service;\n13   try {\n14     asio::ip::udp::resolver::query query(asio::ip::udp::v4(),\n15                                        argv[1], argv[2]);\n16     asio::ip::udp::resolver resolver(service);\n17     auto iter = resolver.resolve(query);\n18     asio::ip::udp::endpoint endpoint = iter->endpoint();\n19   \n20     asio::ip::udp::socket socket(service, \n21                                  asio::ip::udp::v4());\n22     const char *msg = \"Hello from client\";\n23     socket.send_to(asio::buffer(msg, strlen(msg)), endpoint);\n24     char buffer[256];\n25     size_t recvd = socket.receive_from(asio::buffer(buffer,\n26                                  sizeof(buffer)), endpoint);\n27     buffer[recvd] = 0;\n28     std::cout << \"Received \" << buffer << \" from \" \n29        << endpoint.address() << ':' << endpoint.port() << '\\n';\n30   } catch (std::exception& e) {\n31     std::cerr << e.what() << '\\n';\n32   }\n33 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <exception>\n 4 #include <iostream>\n 5 namespace asio = boost::asio;\n 6\n 8 int main() \n 9 {\n10   const unsigned short port = 55000;\n11   const std::string greet(\"Hello, world!\");\n12\n13   asio::io_service service;\n14   asio::ip::udp::endpoint endpoint(asio::ip::udp::v4(), port);\n15   asio::ip::udp::socket socket(service, endpoint);\n16   asio::ip::udp::endpoint ep;\n17\n18   while (true) try {\t\n19     char msg[256];\n20     auto recvd = socket.receive_from(asio::buffer(msg, \n21                                             sizeof(msg)), ep);\n22     msg[recvd] = 0;\n23     std::cout << \"Received: [\" << msg << \"] from [\" \n24               << ep << \"]\\n\";\n25\n26     socket.send_to(asio::buffer(greet.c_str(), greet.size()),\n27                    ep);\n27     socket.send_to(asio::buffer(msg, strlen(msg)), ep);\n28   } catch (std::exception& e) {\n29     std::cout << e.what() << '\\n';\n30   }\n31 }\n```", "```cpp\ntemplate <typename MutableBufSeq, typename ReadHandler>\ndeduced async_receive_from(\n    const MutableBufSeq& buffers,\n    endpoint_type& sender_ep,\n ReadHandler handler);\n\ntemplate <typename ConstBufSeq, typename WriteHandler>\ndeduced async_send_to(\n    const ConstBufSeq& buffers,\n    endpoint_type& sender_ep,\n WriteHandler handler);\n\n```", "```cpp\nvoid(const boost::system::error_code&, size_t)\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 namespace asio = boost::asio;\n 4 namespace sys = boost::system;\n 5\n 6 const size_t MAXBUF = 256;\n 7\n 8 class UDPAsyncServer {\n 9 public:\n10   UDPAsyncServer(asio::io_service& service, \n11                  unsigned short port) \n12      : socket(service, \n13           asio::ip::udp::endpoint(asio::ip::udp::v4(), port))\n14   {  waitForReceive();  }\n15\n16   void waitForReceive() {\n17     socket.async_receive_from(asio::buffer(buffer, MAXBUF),\n18           remote_peer,\n19           [this] (const sys::error_code& ec,\n20                   size_t sz) {\n21             const char *msg = \"hello from server\";\n22             std::cout << \"Received: [\" << buffer << \"] \"\n23                       << remote_peer << '\\n';\n24             waitForReceive();\n25\n26             socket.async_send_to(\n27                 asio::buffer(msg, strlen(msg)),\n28                 remote_peer,\n29                 [this](const sys::error_code& ec,\n30                        size_t sz) {});\n31           });\n32   }\n33\n34 private:\n35   asio::ip::udp::socket socket;\n36   asio::ip::udp::endpoint remote_peer;\n37   char buffer[MAXBUF];\n38 };\n39\n40 int main() {\n41   asio::io_service service;\n42   UDPAsyncServer server(service, 55000);\n43   service.run();\n44 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/asio/spawn.hpp>\n 3 #include <boost/bind.hpp>\n 4 #include <boost/shared_ptr.hpp>\n 5 #include <boost/make_shared.hpp>\n 6 #include <iostream>\n 7 namespace asio = boost::asio;\n 8 namespace sys = boost::system;\n 9\n10 const size_t MAXBUF = 256;\n11 typedef boost::shared_ptr<asio::ip::udp::socket>\n12                                   shared_udp_socket;\n13\n14 void udp_send_to(boost::asio::yield_context yield,\n15                  shared_udp_socket socket,\n16                  asio::ip::udp::endpoint peer)\n17 {\n18     const char *msg = \"hello from server\";\n19     socket->async_send_to(asio::buffer(msg, std::strlen(msg)),\n20                          peer, yield);\n21 }\n22\n23 void udp_server(boost::asio::yield_context yield,\n24                 asio::io_service& service,\n25                 unsigned short port)\n26 {\n27   shared_udp_socket socket =\n28       boost::make_shared<asio::ip::udp::socket>(service,\n29           asio::ip::udp::endpoint(asio::ip::udp::v4(), port));\n30\n31   char buffer[MAXBUF];\n32   asio::ip::udp::endpoint remote_peer;\n33   boost::system::error_code ec;\n34\n35   while (true) {\n36     socket->async_receive_from(asio::buffer(buffer, MAXBUF),\n37                 remote_peer, yield[ec]);\n38\n39     if (!ec) {\n40       spawn(socket->get_io_service(), \n41         boost::bind(udp_send_to, ::_1, socket,\n42                                  remote_peer));\n43     }\n44   }\n45 }\n46\n47 int main() {\n48   asio::io_service service;\n49   spawn(service, boost::bind(udp_server, ::_1,\n50                      boost::ref(service), 55000));\n51   service.run();                               \n52 }\n```", "```cpp\n18     socket.async_receive_from(asio::buffer(buffer, MAXBUF),\n19           remote_peer,\n20           [this] (const sys::error_code& ec,\n21                   size_t sz) {\n...            ...\n26             socket.async_send_to(\n27                 asio::buffer(msg, strlen(msg)),\n28                 remote_peer,\n29                 [this](const sys::error_code& ec,\n30                        size_t sz) {\n31                   waitForReceive();\n32                 });\n33           });\n```", "```cpp\n  17 void waitForReceive() {\n 18   boost::shared_array<char> recvbuf(new char[MAXBUF]);\n 19   auto epPtr(boost::make_shared<asio::ip::udp::endpoint>());\n 20   socket.async_receive_from(\n 21         asio::buffer(recvbuf.get(), MAXBUF),\n  22         *epPtr,\n 23         [this, recvbuf, epPtr] (const sys::error_code& ec,\n  24                 size_t sz) {\n 25           waitForReceive();\n  26\n  27           recvbuf[sz] = 0;\n  28           std::ostringstream sout;\n  29           sout << '[' << boost::this_thread::get_id()\n  30                << \"] Received: \" << recvbuf.get()\n  31                << \" from client: \" << *epPtr << '\\n';\n  32           std::cout << sout.str() << '\\n';\n  33           socket.async_send_to(\n 34               asio::buffer(recvbuf.get(), sz),\n  35               *epPtr,\n 36               [this, recvbuf, epPtr](\n 37                      const sys::error_code& ec, size_t sz) {\n  38               });\n  39        });\n  40 }\n```", "```cpp\n 1 #include <boost/shared_array.hpp>\n...\n14 void udp_send_to(boost::asio::yield_context yield,\n15               shared_udp_socket socket,\n16               asio::ip::udp::endpoint peer,\n17               boost::shared_array<char> buffer, size_t size)\n18 {\n19     const char *msg = \"hello from server\";\n20     socket->async_send_to(asio::buffer(msg, std::strlen(msg)),\n21                          peer, yield);\n22     socket->async_send_to(asio::buffer(buffer.get(), size),\n23                           peer, yield);\n24 }\n25\n26 void udp_server(boost::asio::yield_context yield,\n27                 asio::io_service& service,\n28                 unsigned short port)\n29 {\n30   shared_udp_socket socket =\n31       boost::make_shared<asio::ip::udp::socket>(service,\n32           asio::ip::udp::endpoint(asio::ip::udp::v4(), port));\n33\n34   asio::ip::udp::endpoint remote_peer;\n35   boost::system::error_code ec;\n36\n38   while (true) {\n39     boost::shared_array<char> buffer(new char[MAXBUF]);\n40     size_t size = socket->async_receive_from(\n41                       asio::buffer(buffer.get(), MAXBUF),\n42                       remote_peer, yield[ec]);\n43\n44     if (!ec) {\n45       spawn(socket->get_io_service(), \n46         boost::bind(udp_send_to, ::_1, socket, remote_peer,\n47                                  buffer, size));\n43     }\n44   }\n45 }\n```", "```cpp\n46 int main() {\n47   asio::io_service service;\n48   UDPAsyncServer server(service, 55000);\n49\n50   boost::thread_group pool;\n51   pool.create_thread([&service] { service.run(); });\n52   pool.create_thread([&service] { service.run(); });\n53   pool.create_thread([&service] { service.run(); });\n54   pool.create_thread([&service] { service.run(); });\n55   pool.join_all();\n56 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <iostream>\n 3 namespace asio = boost::asio;\n 4\n 5 int main(int argc, char* argv[]) {\n 6   if (argc < 3) {\n 7     std::cerr << \"Usage: \" << argv[0] << \" host port\\n\";\n 8     exit(1);\n 9   }\n10\n11   const char *host = argv[1], *port = argv[2];\n12\n13   asio::io_service service;\n14   asio::ip::tcp::resolver resolver(service);\n15   try {\n16     asio::ip::tcp::resolver::query query(asio::ip::tcp::v4(),\n17                                        host, port);\n18     asio::ip::tcp::resolver::iterator end, \n19                        iter = resolver.resolve(query);\n20\n21     asio::ip::tcp::endpoint server(iter->endpoint());\n22     std::cout << \"Connecting to \" << server << '\\n';\n23     asio::ip::tcp::socket socket(service, \n24                                  asio::ip::tcp::v4());\n25     socket.connect(server);\n26     std::string message = \"Hello from client\";\n27     asio::write(socket, asio::buffer(message.c_str(),\n28                                    message.size()));\n29     socket.shutdown(asio::ip::tcp::socket::shutdown_send);\n30 \n31     char msg[BUFSIZ];\n32     boost::system::error_code ec;\n33     size_t sz = asio::read(socket, \n34                          asio::buffer(msg, BUFSIZ), ec);\n35     if (!ec || ec == asio::error::eof) {\n36       msg[sz] = 0;\n37       std::cout << \"Received: \" << msg << '\\n';\n38     } else {\n39       std::cerr << \"Error reading response from server: \"\n40                 << ec.message() << '\\n';\n41     }\n34   } catch (std::exception& e) {\n35     std::cerr << e.what() << '\\n';\n36   }\n37 }\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/thread.hpp>\n 3 #include <boost/shared_ptr.hpp>\n 4 #include <boost/array.hpp>\n 5 #include <iostream>\n 6 namespace asio = boost::asio;\n 7\n 8 typedef boost::shared_ptr<asio::ip::tcp::socket> socket_ptr;\n 9\n10 int main() {\n11   const unsigned short port = 56000;\n12   asio::io_service service;\n13   asio::ip::tcp::endpoint endpoint(asio::ip::tcp::v4(), port);\n14   asio::ip::tcp::acceptor acceptor(service, endpoint);\n15\n16   while (true) {\n17     socket_ptr socket(new asio::ip::tcp::socket(service));\n18     acceptor.accept(*socket);\n19     boost::thread([socket]() {\n20       std::cout << \"Service request from \"\n21                 << socket->remote_endpoint() << '\\n';\n22       boost::array<asio::const_buffer, 2> bufseq;\n23       const char *msg = \"Hello, world!\";\n24       const char *msg2 = \"What's up?\";\n25       bufseq[0] = asio::const_buffer(msg, strlen(msg));\n26       bufseq[1] = asio::const_buffer(msg2, strlen(msg2));\n27 \n28       try {\n29         boost::system::error_code ec;\n30         char recvbuf[BUFSIZ];\n31         auto sz = read(*socket, asio::buffer(recvbuf,\n32                                             BUFSIZ), ec);\n33         if (!ec || ec == asio::error::eof) {\n34           recvbuf[sz] = 0;\n35           std::cout << \"Received: \" << recvbuf << \" from \"\n36                     << socket->remote_endpoint() << '\\n';\n37           write(*socket, bufseq);\n38           socket->close();\n39         }\n40       } catch (std::exception& e) {\n41         std::cout << \"Error encountered: \" << e.what() << '\\n';\n42       }\n43     });\n44   }\n45 }\n```", "```cpp\n12 asio::io_service service;\n13 boost::unique_ptr<asio::io_service::work> workptr(\n14                                    new dummyWork(service));\n15 auto threadFunc = [&service] { service.run(); };\n16 \n17 boost::thread_group workers;\n18 for (int i = 0; i < max_threads; ++i) { //max_threads\n19   workers.create_thread(threadFunc);\n20 }\n21\n22 asio::ip::tcp::endpoint ep(asio::ip::tcp::v4(), port);\n23 asio::ip::tcp::acceptor acceptor(service, ep);24 while (true) {\n25   socket_ptr socket(new asio::ip::tcp::socket(service));\n26   acceptor.accept(*socket);\n27\n28   service.post([socket] { /* do I/O on the connection */ });\n29 }\n30\n31 workers.join_all();\n32 workptr.reset(); // we don't reach here\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/asio/spawn.hpp>\n 3 #include <boost/thread.hpp>\n 4 #include <boost/shared_ptr.hpp>\n 5 #include <boost/make_shared.hpp>\n 6 #include <boost/bind.hpp>\n 7 #include <boost/array.hpp>\n 8 #include <iostream>\n 9 #include <cstring>\n10\n11 namespace asio = boost::asio;\n12 typedef boost::shared_ptr<asio::ip::tcp::socket> socketptr;\n13\n14 void handle_connection(asio::yield_context yield,\n15                        socketptr socket)\n16 {\n17   asio::io_service& service = socket->get_io_service();\n18   char msg[BUFSIZ];\n19   msg[0] = '\\0';\n20   boost::system::error_code ec;\n21   const char *resp = \"Hello from server\";\n22\n23   size_t size = asio::async_read(*socket, \n24                      asio::buffer(msg, BUFSIZ), yield[ec]);\n25\n26   if (!ec || ec == asio::error::eof) {\n27     msg[size] = '\\0';\n28     boost::array<asio::const_buffer, 2> bufseq;\n29     bufseq[0] = asio::const_buffer(resp, ::strlen(resp));\n30     bufseq[1] = asio::const_buffer(msg, size);\n31\n32     asio::async_write(*socket, bufseq, yield[ec]);\n33     if (ec) {\n34       std::cerr << \"Error sending response to client: \"\n35                 << ec.message() << '\\n';\n36     }\n37   } else {\n38     std::cout << ec.message() << '\\n';\n39   }\n40 }\n41\n42 void accept_connections(asio::yield_context yield,\n43                         asio::io_service& service,\n44                         unsigned short port)\n45 {\n46   asio::ip::tcp::endpoint server_endpoint(asio::ip::tcp::v4(),\n47                                           port);\n48   asio::ip::tcp::acceptor acceptor(service, server_endpoint);\n49\n50   while (true) {\n51     auto socket = \n52         boost::make_shared<asio::ip::tcp::socket>(service);\n53     acceptor.async_accept(*socket, yield);\n54\n55     std::cout << \"Handling request from client\\n\";\n56     spawn(service, boost::bind(handle_connection, ::_1, \n57                                socket));\n58   }\n59 }\n60\n61 int main() {\n62   asio::io_service service;\n63   spawn(service, boost::bind(accept_connections, ::_1,\n64                              boost::ref(service), 56000));\n65   service.run();\n66 }\n```", "```cpp\n 1 #ifndef ASYNCSVR_HPP\n 2 #define ASYNCSVR_HPP\n 3 #include <boost/asio.hpp>\n 4 #include <boost/shared_ptr.hpp>\n 5 #include <boost/make_shared.hpp>\n 6 #include <iostream>\n 7 #include \"asynconn.hpp\"\n 8\n 9 namespace asio = boost::asio;\n10 namespace sys = boost::system;\n11 typedef boost::shared_ptr<TCPAsyncConnection>\n12               TCPAsyncConnectionPtr;\n13\n14 class TCPAsyncServer {\n15 public:\n16   TCPAsyncServer(asio::io_service& service, unsigned short p)\n17           : acceptor(service,\n18                     asio::ip::tcp::endpoint(\n19                           asio::ip::tcp::v4(), p)) {\n20     waitForConnection();\n21   }\n22\n23   void waitForConnection() {\n24     TCPAsyncConnectionPtr connectionPtr = boost::make_shared\n25           <TCPAsyncConnection>(acceptor.get_io_service());\n26     acceptor.async_accept(connectionPtr->getSocket(),\n27           [this, connectionPtr](const sys::error_code& ec) {\n28             if (ec) {\n29               std::cerr << \"Failed to accept connection: \"\n30                         << ec.message() << \"\\n\";\n31             } else {\n32               connectionPtr->waitForReceive();\n33               waitForConnection();\n34             }\n35           });\n36   }\n37\n38 private:\n39   asio::ip::tcp::acceptor acceptor;\n40 };\n41\n42 #endif /* ASYNCSVR_HPP */\n```", "```cpp\n 1 #include <boost/asio.hpp>\n 2 #include <boost/thread.hpp>\n 3 #include <boost/shared_ptr.hpp>\n 4 #include <iostream>\n 5 #include \"asyncsvr.hpp\"\n 6 #define MAXBUF 1024\n 7 namespace asio = boost::asio;\n 8\n 9 int main() {\n10   try {\n11     asio::io_service service;\n12     TCPAsyncServer server(service, 56000);\n13     service.run();\n14   } catch (std::exception& e) {\n15     std::cout << e.what() << '\\n';\n16   }\n17 }\n```", "```cpp\n 1 #ifndef ASYNCONN_HPP\n 2 #define ASYNCONN_HPP\n 3\n 4 #include <boost/asio.hpp>\n 5 #include <boost/thread.hpp>\n 6 #include <boost/shared_ptr.hpp>\n 7 #include <iostream>\n 8 #define MAXBUF 1024\n 9\n10 namespace asio = boost::asio;\n11 namespace sys = boost::system;\n12\n13 class TCPAsyncConnection\n14   : public boost::enable_shared_from_this<TCPAsyncConnection> {\n15 public:\n16   TCPAsyncConnection(asio::io_service& service) :\n17       socket(service) {}\n18\n19   asio::ip::tcp::socket& getSocket() {\n20     return socket;\n21   }\n22\n23   void waitForReceive() {\n24     auto thisPtr = shared_from_this();\n25     async_read(socket, asio::buffer(buf, sizeof(buf)),\n26         [thisPtr](const sys::error_code& ec, size_t sz) {\n27           if (!ec || ec == asio::error::eof) {\n28             thisPtr->startSend();\n29             thisPtr->buf[sz] = '\\0'; \n30             std::cout << thisPtr->buf << '\\n';\n31             \n32             if (!ec) { thisPtr->waitForReceive(); }\n33           } else {\n34             std::cerr << \"Error receiving data from \"\n35                     \"client: \" << ec.message() << \"\\n\";\n36           }\n37         });\n38   }\n39\n40   void startSend() {\n41     const char *msg = \"Hello from server\";\n42     auto thisPtr = shared_from_this();\n43     async_write(socket, asio::buffer(msg, strlen(msg)),\n44         [thisPtr](const sys::error_code& ec, size_t sz) {\n45           if (ec) {\n46             if (ec == asio::error::eof) {\n47                thisPtr->socket.close();\n48             }\n49             std::cerr << \"Failed to send response to \"\n50                     \"client: \" << ec.message() << '\\n';\n51           }\n52         });\n53   }\n54\n55 private:\n56   asio::ip::tcp::socket socket;\n57   char buf[MAXBUF];\n58 };\n59\n60 #endif /* ASYNCONN_HPP */\n```"]