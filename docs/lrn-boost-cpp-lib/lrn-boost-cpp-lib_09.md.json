["```cpp\n 1 #include <boost/filesystem.hpp>\n 2 #include <iostream>\n 3\n 4 namespace fs = boost::filesystem;\n 5\n 6 int main() {\n 7   // Get the current working directory\n 8   fs::path cwd = fs::current_path();\n 9\n10   // Print the path to stdout\n11   std::cout << \"generic: \" << cwd.generic_string() << '\\n';\n12   std::cout << \"native: \" << cwd.string() << '\\n';\n13   std::cout << \"quoted: \" << cwd << '\\n';\n14 \n15   std::cout << \"Components: \\n\";\n16   for (const auto& dir : cwd) {\n17     std::cout <<'[' <<dir.string() << ']'; // each part\n18   }\n19   std::cout << '\\n';\n20 }\n```", "```cpp\ngeneric: E:/DATA/Packt/Boost/Draft/Book/Chapter07/examples\nnative:E:\\DATA\\Packt\\Boost\\Draft\\Book\\Chapter07\\examples\nquoted: \"E:\\DATA\\Packt\\Boost\\Draft\\Book\\Chapter07\\examples\"\nComponents:\n[E:][/][DATA][Packt] [Boost][Draft][Book][Chapter07][examples]\n```", "```cpp\ngeneric: /home/amukher1/devel/c++/book/ch07\nnative: /home/amukher1/devel/c++/book/ch07\nquoted: \"/home/amukher1/devel/c++/book/ch07\"\nComponents:\n[/][home][amukher1] [devel][c++][book][ch07]\n```", "```cpp\n$ g++ <source>.c -o <executable> -lboost_filesystem -lboost_system\n\n```", "```cpp\n$ g++ <source>.cpp -c -I/opt/boost/include\n$ g++ <source>.o -o <executable> -L/opt/boost/lib -lboost_filesystem-mt -lboost_system-mt -Wl,-rpath,/opt/boost/lib\n\n```", "```cpp\n 1 #define BOOST_FILESYSTEM_NO_DEPRECATED\n 2 #include <boost/filesystem.hpp>\n 3 #include <iostream>\n 4 #include <cassert>\n 5 namespace fs = boost::filesystem;\n 6 \n 7 int main() {\n 8   fs::path p1; // empty path\n 9   assert(p1.empty());  // does not fire\n10   p1 = \"/opt/boost\";   // assign an absolute path\n11   assert(!p1.empty());\n12   p1.clear();\n13   assert(p1.empty());\n14 }\n```", "```cpp\n15 void make_relative_paths() {\n16   fs::path p2(\"..\"); // relative path\n17   p2 /= \"..\";\n18   std::cout << \"Relative path: \" << p2.string() << '\\n';\n19\n20   std::cout << \"Absolute path: \"\n21      << fs::absolute(p2, \"E:\\\\DATA\\\\photos\").string() << '\\n';\n22   std::cout << \"Absolute path wrt CWD: \"\n23             << fs::absolute(p2).string() << '\\n';\n24\n25   std::cout << fs::canonical(p2).string() << '\\n';\n26 }\n27\n```", "```cpp\nRelative path: ..\\..\nAbsolute path: E:\\DATA\\photos\\..\\..\nAbsolute path wrt CWD: E:\\DATA\\Packt\\Boost\\Draft\\Book\\Chapter07\\examples\\..\\..\nCanonical: E:/DATA\\Packt\\Boost\\Draft\\Book\n```", "```cpp\n28 void handle_canonical_errors() {\n29   fs::path p3 = \"E:\\\\DATA\"; // absolute path\n30   auto p4 = p3 / \"boost\" / \"boost_1_56\";  // append elements\n31   std::cout << p4.string() << '\\n';\n32   std::cout.put('\\n');\n33\n34   boost::system::error_code ec;\n35   auto p5 = p4 / \"..\" / \"boost_1_100\";  // append elements\n36   auto p6 = canonical(p5, ec);\n37\n38   if (ec.value() == 0) {\n39     std::cout << \"Normalized: \" << p6.string() << '\\n';\n40   } else {\n41     std::cout << \"Error (file=\" << p5.string()\n42           << \") (code=\" << ec.value() << \"): \"\n43           << ec.message() << '\\n';\n44   }\n45 }\n```", "```cpp\n 1 #include <boost/filesystem.hpp>\n 2 #include <iostream>\n 3 #include <cassert>\n 4 namespace fs = boost::filesystem;\n 5\n 6 void printPathParts(const fs::path& p1)\n 7 {\n 8 std::cout << \"For path: \" << p1.string() << '\\n';\n 9\n10   if (p1.is_relative()) {\n11     std::cout << \"\\tPath is relative\\n\";\n12   } else {\n13     assert(p1.is_absolute());\n14     std::cout << \"\\tPath is absolute\\n\";\n15   }\n16\n17   if (p1.has_root_name())\n18     std::cout << \"Root name: \"\n19               << p1.root_name().string() << '\\n';\n20\n21   if (p1.has_root_directory())\n22     std::cout << \"Root directory: \"\n23               << p1.root_directory().string() << '\\n';\n24\n25   if (p1.has_root_path())\n26     std::cout << \"Root path: \"\n27               << p1.root_path().string() << '\\n';\n28\n29   if (p1.has_parent_path())\n30     std::cout << \"Parent path: \"\n31               << p1.parent_path().string() << '\\n';\n32\n33   if (p1.has_relative_path())\n34     std::cout << \"Relative path: \"\n35               << p1.relative_path().string() << '\\n';\n36\n37   if (p1.has_filename())\n38     std::cout << \"File name: \"\n39               << p1.filename().string() << '\\n';\n40\n41   if (p1.has_extension())\n42     std::cout << \"Extension: \"\n43               << p1.extension().string() << '\\n';\n44\n45   if (p1.has_stem())\n46     std::cout << \"Stem: \" << p1.stem().string() << '\\n';\n47\n48   std::cout << '\\n';\n49 }\n50\n51 int main()\n52 {\n53   printPathParts (\"\");                    // no components\n54   printPathParts (\"E:\\\\DATA\\\\books.txt\"); // all components\n55   printPathParts (\"/root/favs.txt\");      // no root name\n56   printPathParts (\"\\\\DATA\\\\books.txt\");   // Windows, relative\n57   printPathParts (\"boost\");              // no rootdir, no extn\n58   printPathParts (\".boost\");              // no stem, only extn\n59   printPathParts (\"..\");                  // no extension\n60   printPathParts (\".\");                   // no extension\n61   printPathParts (\"/opt/boost/\");         // file name == .\n62 }\n```", "```cpp\nboost::filesystem::path p1(\"/opt/boost\"), p2(\"/opt/cmake\");\nif (boost::filesystem::equivalent(p1, p2 / \"..\" / \"boost\") {\n  std::cout << \"The two paths are equivalent\\n\";\n}\n```", "```cpp\nboost::filesystem::path p1(\"/opt/boost/include/boost/thread.hpp\");\nfor (const auto& pathElem: p1) {\n  std::cout <<pathElem.string() <<\"  \";\n}\n```", "```cpp\nsize_t count = std::distance(p1.begin(), p1.end());\n\n```", "```cpp\n 1 #include <boost/filesystem.hpp>\n 2 #include <iostream>\n 3 namespace fs = boost::filesystem;\n 4\n 5 fs::path commonPrefix(const fs::path& first,\n 6                       const fs::path& second) {\n 7   auto prefix =\n 8     [](const fs::path& p1, const fs::path& p2) {\n 9       auto result =\n10         std::mismatch(p1.begin(), p1.end(), p2.begin());\n11       fs::path ret;\n12       std::for_each(p2.begin(), result.second,\n13               [&ret](const fs::path& p) {\n14               ret /= p;\n15               });\n16       return ret;\n17     };\n18\n19   size_t n1 = std::distance(first.begin(), first.end());\n20   size_t n2 = std::distance(second.begin(), second.end());\n21 \n22   return (n1 < n2) ? prefix(first, second)\n23                    : prefix(second, first);\n24 }\n```", "```cpp\n 1 #include <boost/filesystem.hpp>\n 2 #include <iostream>\n 3 #include <algorithm>\n 4 namespace fs = boost::filesystem;\n 5\n 6 void traverse(const fs::path& dirpath) {\n 7   if (!exists(dirpath) || !is_directory(dirpath)) {\n 8     return;\n 9   }\n10\n11   fs::directory_iterator dirit(dirpath), end;\n12\n13   std::for_each(dirit, end, [](const fs::directory_entry& entry) {\n14           std::cout <<entry.path().string() << '\\n';\n15         });\n16 }\n17\n18 int main(int argc, char *argv[1]) {\n19   if (argc > 1) {\n20     traverse(argv[1]);\n21   }\n22 }\n```", "```cpp\n 1 void traverseRecursive(const fs::path& path)\n 2 {\n 3   if (!exists(path) || !is_directory(path)) {\n 4     return;\n 5   }\n 6\n 7   try {\n 8     fs::recursive_directory_iterator it(path), end;\n 9\n10     while (it != end) {\n11       printFileProperties(*it, it.level());\n12\n13       if (!is_symlink(it->path())\n14           && is_directory(it->path())\n15           && it->path().filename() == \"foo\") {\n16           it.no_push();\n17       }\n18       boost::system::error_code ec;\n19       it.increment(ec);\n21       if (ec) {\n22         std::cerr << \"Skipping entry: \"\n23                   << ec.message() << '\\n';\n24       }\n25     }\n26   } catch (std::exception& e) {\n27     std::cout << \"Exception caught: \" << e.what() << '\\n';\n28   }\n29 }\n```", "```cpp\n 1 #include <boost/filesystem.hpp>\n 2 #include <iostream>\n 3 #include <boost/date_time.hpp>\n 4 namespace fs = boost::filesystem;\n 5 namespace pxtm = boost::posix_time;\n 6\n 7 void printFileProperties(const fs::directory_entry& entry,\n 8                          int indent = 0) {\n 9   const fs::path& path= entry.path();\n10   fs::file_status stat = entry.symlink_status();\n11   std::cout << std::string(2*indent, '');\n12\n13   try {\n14     if (is_symlink(path)) {\n15       auto origin = read_symlink(path);\n16       std::cout <<\" L \" << \" -  - \"\n17                 << path.filename().string() << \" -> \"\n18                 << origin.string();\n19     } else if (is_regular_file(path)) {\n20       std::cout << \" F \" << \" \"\n21          << file_size(path) << \" \" << \" \"\n22          << pxtm::from_time_t(last_write_time(path))\n23          << \" \" << path.filename().string();\n24     } else if (is_directory(path)) {\n25       std::cout << \" D \" << \" \u2013 \" << \" \"\n26 << pxtm::from_time_t(last_write_time(path))\n27 << \" \" << path.filename().string();\n28     } else {\n29       switch (stat.type()) {\n30       case fs::character_file:\n31         std::cout << \" C \";\n32         break;\n33       case fs::block_file:\n34         std::cout << \" B \";\n35         break;\n36       case fs::fifo_file:\n37         std::cout << \" P \";\n38         break;\n39       case fs::socket_file:\n40         std::cout << \" S \";\n41         break;\n42       default:\n43         std::cout << \" - \";\n44         break;\n45       }\n46       std::cout << pxtm::from_time_t(last_write_time(path))\n47                 << \" \";\n48       std::cout << path.filename().string();\n49     }\n50     std::cout << '\\n';\n51   } catch (std::exception& e) {\n52     std::cerr << \"Exception caught: \" <<e.what() << '\\n';\n53   }\n54 }\n```", "```cpp\nfile_type  sizetime  name -> target\n```", "```cpp\n$ g++ listing8_7.cpp -o listing8_7 -std=c++11 -lboost_filesystem -lboost_date_time\n\n```", "```cpp\n 1 #include <boost/filesystem.hpp>\n 2 #include <iostream>\n 3 #include <cassert>\t\n 4 namespace fs = boost::filesystem;\n 5\n 6 int main() {\n 7   fs::path p1 = \"notpresent/dirtest\";\n 8   boost::system::error_code ec;\n 9   if (!is_directory(p1.parent_path()) || exists(p1)) {\n10     assert( !create_directory(p1, ec) );\n11\n12     if (is_directory(p1)) assert(!ec.value());\n13     else assert(ec.value());\n14   }\n15\n16   try {\n17     if (create_directories(p1)) {\n18       assert( !create_directory(p1) );\n19     }\n20   } catch (std::exception& e) {\n21     std::cout << \"Exception caught: \" << e.what() << '\\n';\n22   }\n23 }\n```", "```cpp\n 1 #include <boost/filesystem.hpp>\n 2 namespace fs = boost::filesystem;\n 3\n 4 void makeSymLink(const fs::path& target, const fs::path& link) {\n 5   boost::system::error_code ec;\n 6 \n 7   if (is_directory(target)) {\n 8     create_directory_symlink(target, link);\n 9   } else {\n10     create_symlink(target, link);\n11   }\n12 }\n```", "```cpp\n 1 void copyDirectory(const fs::path& src, const fs::path& target) {\n 2   if (!is_directory(src)\n 3     || (exists(target) && !is_directory(target))\n 4     || !is_directory(absolute(target).parent_path())\n 5     || commonPrefix(src, target) == src) {\n 6     throw std::runtime_error(\"Preconditions not satisfied\");\n 7   }\n 8\n 9   boost::system::error_code ec;\n10   fs::path effectiveTarget = target;\n11   if (exists(target)) {\n12     effectiveTarget /= src.filename();\n13   }\n14   create_directory(effectiveTarget);\n15\n16   fs::directory_iterator iter(src), end;\n17   while (iter != end) {\n18     auto status = iter->symlink_status();\n19     auto currentTarget = effectiveTarget/\n20                               iter->path().filename();\n21\n22     if (status.type() == fs::regular_file) {\n23       copy_file(*iter, currentTarget,\n24                     fs::copy_option::overwrite_if_exists);\n25     } else if (status.type() == fs::symlink_file) {\n26       copy_symlink(*iter, currentTarget);\n27     } else if (status.type() == fs::directory_file) {\n28       copyDirectory(*iter, effectiveTarget);\n29     } // else do nothing\n30     ++iter;\n31   }\n32 }\n```", "```cpp\nvoid rename(const path& old_path, const path& new_path);\nvoid rename(const path& old_path, const path& new_path,\n            error_code& ec);\n```", "```cpp\nbool remove(const path& p);\nbool remove(const path& p, error_code& ec);\nuintmax_t remove_all(const path& p);\nuintmax_t remove_all(const path& p, error_code& ec);\n```", "```cpp\n 1 #include <boost/iostreams/stream.hpp>\n 2 #include <boost/iostreams/device/file_descriptor.hpp>\n 3 #include <iostream>\n 4 #include <string>\n 5 #include <cassert>\n 6 #include <sys/types.h>\n 7 #include <fcntl.h>\n 8 namespace io = boost::iostreams;\n 9\n10 int main(int argc, char *argv[]) {\n11   if (argc < 2) {\n12     return 0;\n13   }\n14\n15   int fdr = open(argv[1], O_RDONLY);\n16   if (fdr >= 0) {\n17     io::file_descriptor_source fdDevice(fdr,\n18                    io::file_descriptor_flags::close_handle);\n19     io::stream<io::file_descriptor_source> in(fdDevice);\n20     assert(fdDevice.is_open());\n21\n22     std::string line;\n23     while (std::getline(in, line))\n24     std::cout << line << '\\n';\n25   }\n26 }\n```", "```cpp\n$ g++ listing8_11.cpp -o listing8_11 -std=c++11 -lboost_iostreams\n\n```", "```cpp\n$ g++listing8_11.cpp -o listing8_11-I /opt/boost/include -std=c++11 -L /opt/boost/lib -lboost_iostreams-mt -Wl,-rpath,/opt/boost/lib\n\n```", "```cpp\n 1 #include <boost/iostreams/device/array.hpp>\n 2 #include <boost/iostreams/stream.hpp>\n 3 #include <boost/iostreams/copy.hpp>\n 4 #include <iostream>\n 5 #include <vector>\n 6 namespace io = boost::iostreams;\n 7\n 8 int main() {\n 9   char out_array[256];\n10   io::array_sink sink(out_array, out_array + sizeof(out_array));\n11   io::stream<io::array_sink> out(sink);\n12   out << \"Size of out_array is \" << sizeof(out_array)\n13       << '\\n' << std::ends << std::flush;\n14\n15   std::vector<char> vchars(out_array,\n16                           out_array + strlen(out_array));\n17   io::array_source src(vchars.data(),vchars.size());\n18   io::stream<io::array_source> in(src);\n19\n20   io::copy(in, std::cout);\n21 }\n```", "```cpp\nThe size of out_array is 256\n```", "```cpp\n 1 #include <boost/iostreams/device/array.hpp>\n 2 #include <boost/iostreams/device/back_inserter.hpp>\n 3 #include <boost/iostreams/stream.hpp>\n 4 #include <boost/iostreams/copy.hpp>\n 5 #include <iostream>\n 6 #include <vector>\n 7 namespace io = boost::iostreams;\n 8\n 9 int main() {\n10   typedef std::vector<char> charvec;\n11   charvec output;\n12   io::back_insert_device<charvec> sink(output);\n13   io::stream<io::back_insert_device<charvec>> out(sink);\n14   out << \"Size of outputis \"<< output.size() << std::flush;\n15\n16   std::vector<char> vchars(output.begin(),\n17                            output.begin() + output.size());\n18   io::array_source src(vchars.data(),vchars.size());\n19   io::stream<io::array_source> in(src);\n20\n21   io::copy(in, std::cout);\n22 }\n```", "```cpp\n 1 #include <boost/iostreams/device/file.hpp>\n 2 #include <boost/iostreams/filtering_stream.hpp>\n 3 #include <boost/iostreams/filter/counter.hpp>\n 4 #include <boost/iostreams/copy.hpp>\n 5 #include <iostream>\n 6 #include <vector>\n 7 namespace io = boost::iostreams;\n 8\n 9 int main(int argc, char *argv[]) {\n10   if (argc <= 1) {\n11     return 0;\n12   }\n13\n14   io::file_source infile(argv[1]);\n15   io::counter counter;\n16   io::filtering_istream fis;\n17   fis.push(counter);\n18   assert(!fis.is_complete());\n19   fis.push(infile);\n20   assert(fis.is_complete());\n21\n22   io::copy(fis, std::cout);\n23\n24   io::counter *ctr = fis.component<io::counter>(0);\n25   std::cout << \"Chars: \" << ctr->characters() << '\\n'\n26             << \"Lines: \" << ctr->lines() << '\\n';\n27 }\n```", "```cpp\n 1 #include <boost/iostreams/device/file.hpp>\n 2 #include <boost/iostreams/filtering_stream.hpp>\n 3 #include <boost/iostreams/filter/grep.hpp>\n 4 #include <boost/iostreams/copy.hpp>\n 5 #include <boost/regex.hpp>\n 6 #include <iostream>\n 7 namespace io = boost::iostreams;\n 8\n 9 int main(int argc, char *argv[]) {\n10   if (argc <= 1) {\n11     return 0;\n12   }\n13\n14   io::file_source infile(argv[1]);\n15   io::filtering_istream fis;\n16   io::grep_filter grep(boost::regex(\"^\\\\s*$\"),\n17       boost::regex_constants::match_default, io::grep::invert);\n18   fis.push(grep);\n19   fis.push(infile);\n20\n21   io::copy(fis, std::cout);\n22 }\n```", "```cpp\n$ g++ listing8_15.cpp -o listing8_15 -std=c++11 -lboost_iostreams-lboost_regex\n\n```", "```cpp\n$ g++ listing8_15.cpp -o listing8_15-I /opt/boost/include -std=c++11 -L /opt/boost/lib -lboost_iostreams-mt-lboost_regex-mt -Wl,-rpath,/opt/boost/lib\n\n```", "```cpp\n 1 #include <boost/iostreams/device/file.hpp>\n 2 #include <boost/iostreams/filtering_stream.hpp>\n 3 #include <boost/iostreams/stream.hpp>\n 4 #include <boost/iostreams/filter/gzip.hpp>\n 5 #include <boost/iostreams/copy.hpp>\n 6 #include <iostream>\n 7 namespace io = boost::iostreams;\n 8\n 9 int main(int argc, char *argv[]) {\n10   if (argc <= 1) {\n11     return 0;\n12   }\n13   // compress\n14   io::file_source infile(argv[1]);\n15   io::filtering_istream fis;\n16   io::gzip_compressor gzip;\n17   fis.push(gzip);\n18   fis.push(infile);\n19\n20   io::file_sink outfile(argv[1] + std::string(\".gz\"));\n21   io::stream<io::file_sink> os(outfile);\n22   io::copy(fis, os);\n23\n24   // decompress\n25   io::file_source infile2(argv[1] + std::string(\".gz\"));\n26   fis.reset();\n27   io::gzip_decompressor gunzip;\n28   fis.push(gunzip);\n29   fis.push(infile2);\n30   io::copy(fis, std::cout);\n31 }\n```", "```cpp\nfiltering_ostream fos;\nfos.push(grep);\nfos.push(gzip);\nfos.push(sink);\n```", "```cpp\nfiltering_istream fis;\nfis.push(counter);\nfis.push(gunzip);\nfis.push(source);\n```", "```cpp\nfiltering_ostream fos;\nfos.push(grep | gzip | sink);\n\nfiltering_istream fis;\nfis.push(counter | gunzip | source);\n```", "```cpp\n 1 #include <boost/iostreams/device/file.hpp>\n 2 #include <boost/iostreams/filtering_stream.hpp>\n 3 #include <boost/iostreams/stream.hpp>\n 4 #include <boost/iostreams/filter/bzip2.hpp>\n 5 #include <boost/iostreams/filter/grep.hpp>\n 6 #include <boost/iostreams/copy.hpp>\n 7 #include <boost/regex.hpp>\n 8 #include <iostream>\n 9 namespace io = boost::iostreams;\n10\n11 int main(int argc, char *argv[]) {\n12   if (argc <= 1) { return 0; }\n13\n14   io::file_source infile(argv[1]);\n15   io::bzip2_compressor bzip2;\n16   io::grep_filter grep(boost::regex(\"^\\\\s*$\"),\n17         boost::regex_constants::match_default,\n18         io::grep::invert);\n19   io::filtering_istream fis;\n20   fis.push(bzip2 | grep | infile);\n21   io::file_sink outfile(argv[1] + std::string(\".bz2\"));\n22   io::stream<io::file_sink> os(outfile);\n23\n24   io::copy(fis, os);\n25 }\n```", "```cpp\n 1 #include <boost/iostreams/device/file.hpp>\n 2 #include <boost/iostreams/filtering_stream.hpp>\n 3 #include <boost/iostreams/stream.hpp>\n 4 #include <boost/iostreams/filter/gzip.hpp>\n 5 #include <boost/iostreams/filter/bzip2.hpp>\n 6 #include <boost/iostreams/filter/zlib.hpp>\n 7 #include <boost/iostreams/copy.hpp>\n 8 #include <boost/iostreams/tee.hpp>\n 9 namespace io = boost::iostreams;\n10\n11 int main(int argc, char *argv[]) {\n12   if (argc <= 1) { return 0; }\n13\n14   io::file_source infile(argv[1]);  // input\n15   io::stream<io::file_source> ins(infile);\n16\n17   io::gzip_compressor gzip;\n18   io::file_sink gzfile(argv[1] + std::string(\".gz\"));\n19   io::filtering_ostream gzout;     // gz output\n20   gzout.push(gzip | gzfile);\n21   auto gztee = tee(gzout);\n22\n23   io::bzip2_compressor bzip2;\n24   io::file_sink bz2file(argv[1] + std::string(\".bz2\"));\n25   io::filtering_ostream bz2out;     // bz2 output\n26   bz2out.push(bzip2 | bz2file);\n27   auto bz2tee = tee(bz2out);\n28\n29   io::zlib_compressor zlib;\n30   io::file_sink zlibfile(argv[1] + std::string(\".zlib\"));\n31\n32   io::filtering_ostream zlibout;\n33   zlibout.push(gztee | bz2tee | zlib | zlibfile);\n34\n35   io::copy(ins, zlibout);\n36 }\n```", "```cpp\n    if (is_regular_file(path)) { /* \u2026 */ }\n    else if (is_directory(path)) { /* \u2026 */ }\n    else if (is_symlink(path)) { /* \u2026 */ }\n    ```", "```cpp\n    boost::filesystem::path p1(\"/opt/boost/include/boost/thread.hpp\");\n    size_t n = std::distance(p1.begin(), p1.end());\n    ```"]