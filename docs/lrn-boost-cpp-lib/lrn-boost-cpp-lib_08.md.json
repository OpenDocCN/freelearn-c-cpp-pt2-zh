["```cpp\n 1 #include <boost/date_time.hpp>\n 2 #include <iostream>\n 3 #include <cassert>\n 4 namespace greg = boost::gregorian;\n 5\n 6 int main() {\n 7   greg::date d0;  // default constructed, is not a date\n 8   assert(d0.is_not_a_date());\n 9   // Construct dates from parts\n10   greg::date d1(1948, greg::Jan, 30);\n11   greg::date d2(1968, greg::Apr, 4);\n12\n13   // Construct dates from string representations\n14   greg::date dw1 = greg::from_uk_string(\"15/10/1948\");\n15   greg::date dw2 = greg::from_simple_string(\"1956-10-29\");\n16   greg::date dw3 = greg::from_undelimited_string(\"19670605\");\n17   greg::date dw4 = greg::from_us_string(\"10-06-1973\");\n18\n19   // Current date\n20   greg::date today = greg::day_clock::local_day();\n21   greg::date londonToday = greg::day_clock::universal_day();\n22\n23   // Take dates apart\n24   std::cout << today.day_of_week() << \" \" << today.day() << \", \"\n25             << today.month() << \", \" << today.year() << '\\n';\n26 }\n```", "```cpp\n$ g++ example.cpp -o example -lboost_date_time\n```", "```cpp\n 1 #include <boost/date_time.hpp>\n 2 #include <iostream>\n 3 namespace greg = boost::gregorian;\n 4\n 5 int main() {\n 6   greg::date d1(1948, greg::Jan, 30);\n 7   greg::date d2(1968, greg::Apr, 4);\n 8\n 9   greg::date_duration day_diff = d2 - d1;\n10   std::cout << day_diff.days() \n11             << \" days between the two dates\\n\";\n12\n13   greg::date six_weeks_post_d1 = d1 + greg::weeks(6);\n14   std::cout << six_weeks_post_d1 << '\\n';\n15\n16   greg::date day_before_d2 = d2 - greg::days(1);\n17   std::cout << day_before_d2 << '\\n';\n18 }\n```", "```cpp\n 1 #include <boost/date_time.hpp>\n 2 #include <iostream>\n 3 namespace greg = boost::gregorian;\n 4 namespace dt = boost::date_time;\n 5\n 6 int main() {\n 7   greg::date startCal(2015, greg::Jan, 1);\n 8   greg::date endCal(2015, greg::Dec, 31);\n 9\n10   greg::date startFiscal(2014, greg::Oct, 1);\n11   greg::date endFiscal(2015, greg::Sep, 30);\n12\n13   greg::date_period cal(startCal, endCal);\n14   greg::date_period fisc(startFiscal, endFiscal);\n15\n16   std::cout << \"Fiscal year begins \" << fisc.begin()\n17     << \" and ends \" << fisc.end() << '\\n';\n18\n19   if (cal.intersects(fisc)) {\n20     auto overlap = cal.intersection(fisc);\n21     greg::month_iterator miter(overlap.begin());\n22\n23     while (*miter < overlap.end()) {\n24       greg::last_day_of_the_week_in_month \n25                    last_weekday(greg::Friday, miter->month());\n26       std::cout << last_weekday.get_date(miter->year())\n27                 << '\\n';\n28       ++miter;\n29     }\n30   }\n31 }\n```", "```cpp\n 1 #include <boost/date_time.hpp>\n 2 #include <iostream>\n 3 #include <cassert>\n 4 #include <ctime>\n 5 namespace greg = boost::gregorian;\n 6 namespace pt = boost::posix_time;\n 7\n 8 int main() {\n 9   pt::ptime pt; // default constructed, is not a time\n10   assert(pt.is_not_a_date_time());\n11\n12   // Get current time\n13   pt::ptime now1 = pt::second_clock::universal_time();\n14   pt::ptime now2 = pt::from_time_t(std::time(0));\n15\n16   // Construct from strings\n17   // Create time points using durations\n18   pt::ptime pt1(greg::day_clock::universal_day(),\n19           pt::hours(10) + pt::minutes(42)\n20           + pt::seconds(20) + pt::microseconds(30));\n21   std::cout << pt1 << '\\n';\n22\n23   // Compute durations\n24   pt::time_duration dur = now1 - pt1;\n25   std::cout << dur << '\\n';\n26   std::cout << dur.total_microseconds() << '\\n';\n27\n28   pt::ptime pt2(greg::day_clock::universal_day()),\n29        pt3 = pt::time_from_string(\"2015-01-28 10:00:31.83\"),\n30        pt4 = pt::from_iso_string(\"20150128T151200\");\n31\n32   std::cout << pt2 << '\\n' << to_iso_string(pt3) << '\\n'\n33             << to_simple_string(pt4) << '\\n';\n34 }\n```", "```cpp\n 1 #include <boost/date_time.hpp>\n 2 #include <iostream>\n 3 namespace pt = boost::posix_time;\n 4 namespace dt = boost::date_time;\n 5 \n 6 int main() {\n 7   switch (pt::time_duration::resolution()) {\n 8   case dt::time_resolutions::sec:\n 9     std::cout << \" second\\n\";\n10     break;\n11   case dt::time_resolutions::tenth:\n12     std::cout << \" tenth\\n\";\n13     break;\n14   case dt::time_resolutions::hundredth:\n15     std::cout << \" hundredth\\n\";\n16     break;\n17   case dt::time_resolutions::milli:\n18     std::cout << \" milli\\n\";\n19     break;\n20   case dt::time_resolutions::ten_thousandth:\n21     std::cout << \" ten_thousandth\\n\";\n22     break;\n23   case dt::time_resolutions::micro:\n24     std::cout << \" micro\\n\";\n25     break;\n26   case dt::time_resolutions::nano:\n27     std::cout << \" nano\\n\";\n28     break;\n29   default:\n30     std::cout << \" unknown\\n\";\n31     break;\n32   }\n33   std::cout << pt::time_duration::num_fractional_digits()\n34             << '\\n';\n35   std::cout << pt::time_duration::ticks_per_second() \n36             << '\\n';\n37 }\n```", "```cpp\n 1 #include <boost/date_time.hpp>\n 2 #include <iostream>\n 3 #include <cassert>\n 4 namespace greg = boost::gregorian;\n 5 namespace pt = boost::posix_time;\n 6\n 7 int main()\n 8 {\n 9   // Get current time\n10   pt::ptime now1 = pt::second_clock::local_time();\n11   pt::time_period starts_now(now1, pt::hours(2));\n12\n13   assert(starts_now.length() == pt::hours(2));\n14\n15   auto later1 = now1 + pt::hours(1);\n16   pt::time_period starts_in_1(later1, pt::hours(3));\n17\n18   assert(starts_in_1.length() == pt::hours(3));\n19\n20   auto later2 = now1 + pt::hours(3);\n21   pt::time_period starts_in_3(later2, pt::hours(1));\n22\n23   assert(starts_in_3.length() == pt::hours(1));\n24\n26   std::cout << \"starts_in_1 starts at \" << starts_in_1.begin()\n27             << \" and ends at \" << starts_in_1.last() << '\\n';\n28\n29   // comparing time periods\n30   // non-overlapping\n31   assert(starts_now < starts_in_3);\n32   assert(!starts_now.intersects(starts_in_3));\n33\n34   // overlapping\n35   assert(starts_now.intersects(starts_in_1));\n36\n37   assert(starts_in_1.contains(starts_in_3));\n38 }\n```", "```cpp\n 1 #include <boost/date_time.hpp>\n 2 #include <iostream>\n 3\n 4 namespace greg = boost::gregorian;\n 5 namespace pt = boost::posix_time;\n 6\n 7 int main()\n 8 {\n 9   pt::ptime now = pt::second_clock::local_time();\n10   pt::ptime start_of_day(greg::day_clock::local_day());\n11\n12   for (pt::time_iterator iter(start_of_day, \n13          pt::hours(1)); iter < now; ++iter)\n14   {\n15     std::cout << *iter << '\\n';\n16   }\n17 }\n```", "```cpp\ntemplate <typename Representation, typename Period>\nclass duration;\n```", "```cpp\ntypedef boost::chrono::duration<int64_t, boost::ratio<1, 100>> \n                                                    centiseconds;\ncentiseconds cs(1000);  // represents 10 seconds\n```", "```cpp\n 1 #include <boost/chrono/chrono.hpp>\n 2 #include <boost/chrono/chrono_io.hpp>\n 3 #include <iostream>\n 4 #include <cstdint>\n 5 namespace chrono = boost::chrono;\n 6\n 7 int main()\n 8 {\n 9   chrono::duration<int64_t, boost::ratio<1, 100>> csec(10);\n10   std::cout << csec.count() << '\\n';\n11   std::cout << csec << '\\n';\n12\n13   chrono::seconds sec(10);\n14   chrono::milliseconds sum = sec + chrono::milliseconds(20);\n15   // chrono::seconds sum1 = sec + chrono::milliseconds(20);\n16\n17   chrono::milliseconds msec = sec;\n18\n19   // chrono::seconds sec2 = sum;\n20   chrono::seconds sec2 = \n21                  chrono::duration_cast<chrono::seconds>(sum);\n22 }\n```", "```cpp\n10 centiseconds\n```", "```cpp\n$ g++ example.cpp -o example -lboost_system -lboost_chrono\n```", "```cpp\nboost::chrono::milliseconds millies(20);\nboost::chrono::duration<double> sec(10);\n\nboost::chrono::duration<double> sec2 = sec + millies;\nstd::cout << sec2 << '\\n';\n```", "```cpp\n#include <boost/ratio.hpp>\ntypedef boost::ratio<1000> kilo;\ntypedef boost::ratio<1, 1000> milli;\ntypedef boost::ratio<22, 7> not_quite_pi;\nstd::cout << not_quite_pi::num << \"/\" \n          << not_quite_pi::den << '\\n';\nstd::cout << boost::ratio_string<kilo, char>::prefix() \n          << '\\n';\nstd::cout << boost::ratio_string<milli, char>::prefix() \n          << '\\n';\n```", "```cpp\n22/7\nkilo\nmilli\n```", "```cpp\n 1 #include <iostream>\n 2 #include <boost/chrono.hpp>\n 3\n 4 namespace chrono = boost::chrono;\n 5\n 6 int main()\n 7 {\n 8   typedef chrono::system_clock::period tick_period;\n 9   std::cout\n10      << boost::ratio_string<tick_period, char>::prefix() \n11      << \" seconds\\n\";\n12   chrono::system_clock::time_point epoch;\n13   chrono::system_clock::time_point now = \n14                             chrono::system_clock::now();\n15\n16   std::cout << epoch << '\\n';\n17   std::cout << chrono::time_point_cast<chrono::hours>(now) \n18             << '\\n';\n19 }\n```", "```cpp\nnanoseconds\n0 nanoseconds since Jan 1, 1970\n395219 hours since Jan 1, 1970\n```", "```cpp\n 1 #include <fstream>\n 2 #include <memory>\n 3 #include <boost/timer/timer.hpp>\n 4 #include <string>\n 5 #include <boost/filesystem.hpp>\n 6 using std::ios;\n 7\n 8 std::unique_ptr<char[]> readFile(const std::string& file_name,\n 9                                  std::streampos& size)\n10 {\n11   std::unique_ptr<char[]> buffer;\n12   std::ifstream file(file_name, ios::binary);\n13\n14   if (file) {\n15     size = boost::filesystem::file_size(file_name);\n16\n17     if (size > 0) {\n18       buffer.reset(new char[size]);\n19\n20       boost::timer::cpu_timer timer;\n21       file.read(buffer.get(), size);\n22       timer.stop();\n23\n24       std::cerr << \"file size = \" << size\n25                 << \": time = \" << timer.format();\n26     }\n27   }\n28\n29   return buffer;\n30 }\n```", "```cpp\nfile size = 1697199:  0.111945s wall, 0.000000s user + 0.060000s system = 0.060000s CPU (53.6%)\n```", "```cpp\n$ g++ source.cpp -o executable -std=c++11 -lboost_system -lboost_timer\n```", "```cpp\n12   boost::timer::cpu_timer timer;\n13   file.open(file_name, ios::in|ios::binary|ios::ate);\n14\n15   if (file) {\n16     size = file.tellg();\n17\n18     if (size > 0) {\n19       timer.stop();\n20       buffer.reset(new char[size]);\n21\n22       timer.resume();\n23       file.seekg(0, ios::beg);\n24       file.read(buffer.get(), size);\n25     }\n26\n27     file.close();\n28   }\n29\n30   timer.stop();\n31 \n```", "```cpp\n20       file.seekg(0, ios::beg);\n21       boost::timer::cpu_timer timer;\n22       file.read(buffer.get(), size);\n23       timer.stop();\n24\n25       boost::timer::cpu_times times = timer.elapsed();\n26       std::cout << std::fixed << std::setprecision(8)\n27                 << times.wall / 1.0e9 << \"s wall, \"\n28                 << times.user / 1.0e9 << \"s user + \"\n29                 << times.system / 1.0e9 << \"s system. \"\n30                 << (double)100*(timer.user + timer.system) \n31                       / timer.wall << \"% CPU\\n\";\n```", "```cpp\n17     if (size > 0) {\n18       buffer.reset(new char[size]);\n19\n20       file.seekg(0, ios::beg);\n21\n22       boost::timer::auto_cpu_timer timer;\n23       file.read(buffer.get(), size);\n24     }\n```", "```cpp\n0.102563s wall, 0.000000s user + 0.040000s system = 0.040000s CPU (39.0%)\n```", "```cpp\n17     if (size > 0) {\n18       buffer.reset(new char[size]);\n19\n20       file.seekg(0, ios::beg);\n21\n22       {\n23         boost::timer::auto_cpu_timer timer(std::cerr);\n24         file.read(buffer.get(), size);\n25       }\n26       // remaining statements in scope\n27     }\n```"]