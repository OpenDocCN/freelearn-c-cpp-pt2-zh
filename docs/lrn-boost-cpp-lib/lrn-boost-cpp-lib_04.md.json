["```cpp\ntemplate <typename charT,\n          typename Traits = std::char_traits<chart>,\n          typename Allocator = std::allocator<chart>>\nstd::basic_string;\n```", "```cpp\n 1 #include <string>\n 2 #include <algorithm>\n 3 #include <cassert>\n 4 #include <cctype>\n 5 \n 6 int main() {\n 7   std::string song = \"Green-tinted sixties mind\";\n 8   std::transform(song.begin(), song.end(), song.begin(),\n 9                  ::toupper);\n10 \n11   assert(song == \"GREEN-TINTED SIXTIES MIND\");\n12 }\n```", "```cpp\n 1 #include <string>\n 2 #include <boost/algorithm/string.hpp>\n 3 #include <cassert>\n 4\n 5 int main()\n 6 {\n 7   std::string song = \"Green-tinted sixties mind\";\n 8   boost::to_upper(song);\n 9   assert(song == \"GREEN-TINTED SIXTIES MIND\");\n10 }\n```", "```cpp\n 1 #include <string>\n 2 #include <boost/algorithm/string.hpp>\n 3 #include <cassert>\n 4\n 5 int main()\n 6 {\n 7   char song[17] = \"Book of Taliesyn\";\n 8   boost::to_upper(song);\n 9   assert(std::string(song) == \"BOOK OF TALIESYN\");\n10 }\n```", "```cpp\n 1 #include <string>\n 2 #include <boost/algorithm/string.hpp>\n 3 #include <cassert>\n 4\n 5 int main()\n 6 {\n 7   std::string song = \"Green-tinted sixties mind\";\n 8   typedef boost::iterator_range<std::string::iterator>\n 9                                                RangeType; \n10   RangeType range = boost::make_iterator_range(\n11                        song.begin() + 13, song.begin() + 20);\n12   boost::to_upper(range);\n13   assert(song == \"Green-tinted SIXTIES mind\");\n14 }\n```", "```cpp\n 8 auto range = boost::make_iterator_range(song.begin() + 13,\n 9                                       song.begin() + 20);\n\n```", "```cpp\n 1 #include <string>\n 2 #include <boost/algorithm/string.hpp>\n 3 #include <cassert>\n 4\n 5 int main()\n 6 {\n 7   char song[17] = \"Book of Taliesyn\";\n 8 \n 9   typedef boost::iterator_range<char*> RangeType; \n10   RangeType rng = boost::make_iterator_range(song + 8,\n11                                              song + 16);\n12   boost::to_upper(rng);\n13   assert(std::string(song) == \"Book of TALIESYN\");\n14 }\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <cassert>\n 4 \n 5 int main() {\n 6   std::string input = \"linearize\";\n 7   std::string test = \"near\";\n 8   assert(boost::contains(input, test));\n 9 }\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <cassert>\n 4 \n 5 int main() {\n 6   std::string str1 = \"Find the Cost of Freedom\";\n 7   std::string str2 = boost::to_lower_copy(str1);\n 8   assert(str1 != str2);\n 9   boost::to_lower(str1);\n10   assert(str1 == str2);\n11   assert(str1 == \"find the cost of freedom\");\n12 }\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 \n 5 int main()\n 6 {\n 7   const char *haystack = \"Mary had a little lamb\";\n 8   const char *needles[] = {\"little\", \"Little\", 0};\n 9 \n10   for (int i = 0; needles[i] != 0; ++i) {\n11     auto ret = boost::find_first(haystack, needles[i]);\n12   \n13     if (ret.begin() == ret.end()) {\n14       std::cout << \"String [\" << needles[i] << \"] not found in\"\n15                 << \" string [\" << haystack << \"\\n\";\n16     } else {\n17       std::cout << \"String [\" << needles[i] << \"] found at \" \n18                 << \"offset \" << ret.begin() - haystack\n19                 << \" in string [\" << haystack << \"\\n\";\n20     }\n21 \n22     std::cout << \"'\" << ret << \"'\" << '\\n';\n23   }\n24 }\n```", "```cpp\n               << \"offset \" << ret.begin() \u2013 haystack.begin()\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <vector>\n 5\n 6 int main()\n 7 {\n 8   typedef boost::iterator_range<std::string::const_iterator>\n 9                                                 string_range;\n10   std::vector<string_range> matches;\n11   std::string str = \"He deserted the unit while they trudged \"\n12                     \"through the desert one night.\";\n13 \n14   boost::find_all(matches, str, \"desert\");\n15   for (auto match : matches) {\n16     std::cout << \"Found [\" << \"desert\" << \"] at offset \"\n17           << match.begin() - str.begin() << \".\\n\";\n18   }\n19 }\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 \n 5 int main()\n 6 {\n 7   std::string str = \"The application tried to read from an \"\n 8                     \"invalid address at 0xbeeffed\";\n 9 \n10   auto token = boost::find_token(str, boost::is_xdigit(), \n11                                boost::token_compress_on);\n12   while (token.begin() != token.end()) {\n13     if (boost::size(token) > 3) {\n14       std::cout << token << '\\n';\n15     }\n16 \n17     auto remnant = boost::make_iterator_range(token.end(), \n18                                             str.end());\n19     token = boost::find_token(remnant, boost::is_xdigit(),\n20                             boost::token_compress_on);\n21   }\n22 }\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <vector>\n 5 #include <iterator>\n 6 #include <algorithm>\n 7\n 8 struct MinLen\n 9 {\n10   bool operator()(const std::string& s) const \n11   { return s.size() > 3; }\n12 };\n13 \n14 int main() {\n15   std::string str = \"The application tried to read from an \"\n16                     \"invalid address at 0xbeeffed\";\n17 \n18   std::vector<std::string> v;\n19   auto ret = boost::iter_find(v, str, \n20                      boost::token_finder(boost::is_xdigit(), \n21                                   boost::token_compress_on));\n22 \n23   std::ostream_iterator<std::string> osit(std::cout, \", \");\n24   std::copy_if(v.begin(), v.end(), osit, MinLen());\n25 }\n```", "```cpp\n  1 std::string haystack = \"How little is too little\";\n  2 std::string needle = \"Little\";\n  3 \n 4 auto ret = boost::find(haystack,\n 5                       boost::last_finder(needle,\n 6                                   boost::is_iequal()));\n\n```", "```cpp\n 1 struct EqualsShift {\n 2   EqualsShift(unsigned int n) : shift(n) {}\n 3 \n 4   bool operator()(char input, char search) const\n 5   {\n 6     int disp = tolower(input) - 'a' - shift;\n 7     return tolower(search) == (disp >= 0)?'a':'z' + disp;\n 8   }\n 9 \n10 private:\n11   unsigned long shift;\n12 };\n13\n14 // encoded ... How little is too little\n15 std::string encoded = \"Lsa pmxxpi mw xss pmxxpi\";\n16 std::string realWord = \"little\";\n17 auto ret = boost::find(encoded,\n18                        boost::first_finder(realWord,\n19                                           EqualsShift(4)));\n\n```", "```cpp\n1 std::string run = \"Run Forrest run\";\n2 assert( boost::find_head(run, 3) == \"Run\");\n3 assert( boost::find_head(run, -3) == \"Run Forrest \");\n4 assert( boost::find_tail(run, 3) == \"run\");\n5 assert( boost::find_ tail(run, -3) == \" Forrest run\");\n\n```", "```cpp\n 1 #include <boost/range.hpp>\n 2 #include <boost/range/adaptors.hpp>\n 3 #include <string>\n 4 #include <iostream>\n 5 #include <boost/algorithm/string.hpp>\n 6 #include <cassert>\n 7\n 8 int main()\n 9 {\n10   std::string str = \"funny text\";\n11   auto range = str | boost::adaptors::strided(2);\n12   boost::to_upper(range);\n13   assert(str == \"FuNnY TeXt\");\n14 }\n```", "```cpp\nauto range = boost::adaptors::stride(str, 2);\n```", "```cpp\nauto range = str | boost::adaptors::sliced(1, str.size() \u2013 1)| boost::adaptors::strided(2);\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <cassert>\n 5 \n 6 bool isNewline(char c) {\n 7   return c == '\\n';\n 8 }\n 9 \n10 int main()\n11 {\n12   std::string input = \"  Hello  \";\n13   std::string input2 = \"Hello   \\n\";\n14   \n15   boost::trim(input);\n16   boost::trim_right_if(input2, isNewline);\n17 \n18   assert(*(input.end() - 1) != ' ');\n19   assert(*(input2.end() - 1) != '\\n' && \n20          *(input2.end() - 1) == ' ');\n21 }\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <cassert>\n 5 \n 6 int main()\n 7 {\n 8   std::string input = \"Hello, World! Hello folks!\";\n 9   boost::replace_first(input, \"Hello\", \"Hola\");\n10   assert(input == \"Hola, World! Hello folks!\");\n11   boost::erase_first(input, \"Hello\");\n12   assert(input == \"Hola, World!  folks!\");\n13 }\n```", "```cpp\nstd::string input = \"Hello, World! Hello folks!\";\nauto output = boost::ireplace_last_copy(input, \"hello\", \"Hola\");\nassert(input == \"Hello, World! Hello folks!\"); // input unchanged\nassert(output == \"Hello, World! Hola folks!\"); // copy changed\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <vector>\n 5 #include <cassert>\n 6\n 7 int main()\n 8 {\n 9   std::string dogtypes = \"mongrel, puppy, whelp, hound\";\n10   std::vector<std::string> dogs;\n11   boost::split(dogs, dogtypes, boost::is_any_of(\" ,\"),\n12                boost::token_compress_on);\n13   \n14   assert(dogs.size() == 4);\n15   assert(dogs[0] == \"mongrel\" && dogs[1] == \"puppy\" &&\n16          dogs[2] == \"whelp\" && dogs[3] == \"hound\");\n17 }\n```", "```cpp\n 1 #include <boost/algorithm/string.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 #include <vector>\n 5\n 6 int main()\n 7 {\n 8   std::string dogtypes = \n 9                \"mongrel and puppy and whelp and hound\";\n10   std::vector<std::string> dogs;\n11   boost::iter_split(dogs, dogtypes, \n12                     boost::first_finder(\" and \"));\n13   assert(dogs.size() == 4);\n14   assert(dogs[0] == \"mongrel\" && dogs[1] == \"puppy\" &&\n15          dogs[2] == \"whelp\" && dogs[3] == \"hound\");\n16 }\n```", "```cpp\nstd::vector<std::string> vec{\"mongrel\", \"puppy\", \"whelp\", \"hound\"};\nstd::string joined = boost::join(vec, \", \");\nassert(joined == \"mongrel, puppy, whelp, hound\");\n```", "```cpp\nbool fiveOrLessChars(const std::string& s) { return s.size() <= 5; }\n\nstd::vector<std::string> vec{\"mongrel\", \"puppy\", \"whelp\", \"hound\"};\nstd::string joined = boost::join_if(vec, \", \", fiveOrLessChars);\nassert(joined == \"puppy, whelp, hound\");\n```", "```cpp\n 1 #include <iostream>\n 2 #include <boost/tokenizer.hpp>\n 3 #include <string>\n 4 \n 5 int main()\n 6 {\n 7   std::string input = \n 8         \"God knows, I've never been a spiritual man!\";\n 9 \n10   boost::tokenizer<> tokenizer(input);\n11\n12   for (boost::tokenizer<>::iterator token = tokenizer.begin();\n13         token != tokenizer.end(); ++token) {\n14     std::cout << *token << '\\n';\n15   }\n16 }\n```", "```cpp\nGod\nknows\nI\nve\nnever\nbeen\na\nspiritual\nman\n```", "```cpp\n 1 #include <boost/tokenizer.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4\n 5 int main()\n 6 {\n 7   std::string input = \n 8                \"God knows, I've never been a spiritual man!\";\n 9\n10   boost::char_separator<char> sep(\" \\t,.!?;./\\\"(){}[]<>\");\n11   typedef boost::tokenizer<boost::char_separator<char> > \n12                                                  tokenizer;\n13   tokenizer mytokenizer(input, sep);\n14   for (auto& token: mytokenizer) \n16   {\n17     std::cout << token << '\\n';\n18   }\n19 }\n```", "```cpp\nJoe Reed,45,Bristol UK\nOphir Leibovitch,28,Netanya Israel\nRaghav Moorthy,31,Mysore India\n```", "```cpp\nJoe Reed,45,\"33 Victoria St., Bristol UK\"\nOphir Leibovitch,28,\"19 Smilanski Street, Netanya, Israel\"\nRaghav Moorthy,31,\"156A Railway Gate Road, Mysore India\"\n```", "```cpp\nAmit Gupta,70,\"\\\"Nandanvan\\\", Ghole Road, Pune, India\"\n```", "```cpp\n 1 #include <iostream>\n 2 #include <boost/tokenizer.hpp>\n 3 #include <string>\n 4\n 5 int main()\n 6 {\n 7   std::string input = \"Amit Gupta,70,\\\"\\\\\\\"Nandanvan\\\\\\\", \"\n 8                       \"Ghole Road, Pune, India\\\"\";\n 9\n10   typedef boost::tokenizer<boost::escaped_list_separator<char> > \n11                                           tokenizer;\n12   tokenizer mytokenizer(input);\n13  \n14   for (auto& tok: mytokenizer) \n15   {\n16     std::cout << tok << '\\n';\n17   }\n18 }\n```", "```cpp\n/Alon Ben-Ari/-35-11~/5 Zamenhoff St., Tel Aviv\n```", "```cpp\n 1 #include <iostream>\n 2 #include <boost/tokenizer.hpp>\n 3 #include <string>\n 4\n 5 int main()\n 6 {\n 7   std::string input = \n 8        \"/Alon Ben-Ari/-35-11~/5 Zamenhoff St., Tel Aviv\";\n 9\n10   typedef boost::tokenizer<boost::escaped_list_separator<char> > \n11                                               tokenizer;\n12   boost::escaped_list_separator<char> sep('~', '-', '/');\n13   tokenizer mytokenizer(input, sep);\n14  \n15   for (auto& tok: mytokenizer) {\n16     std::cout << tok << '\\n';\n17   }\n18 }\n```", "```cpp\nAlon Ben-Ari\n35\n11/5 Zamenhoff Str., Tel Aviv\n```", "```cpp\n201408091403290000001881303614419ABNANL2AWSSDEUTDEMM720000000412000EUR\u2026\n```", "```cpp\nOffset 0, length 8: date of record in YYYYMMDD format.\nOffset 8, length 9: time of record in HHMMSSmmm format where mmm represents milliseconds.\nOffset 17, length 16: the transaction identifier for the transaction, numeric format.\nOffset 33, length 11: the Swift Bank Identifier Code for the bank from which money is transferred.\nOffset 44, length 11: the Swift Bank Identifier Code for the bank to which money is transferred.\nOffset 55, length 12: the transaction amount.\nOffset 67, length 3: the ISO code for the currency of transaction.\n```", "```cpp\n 1 #include <boost/tokenizer.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 \n 5 int main()\n 6 {\n 7   std::string input =  \n 8      \"201408091403290000001881303614419ABNANL2AWSSDEUTDEMM72\"\n 9      \"0000000412000EUR\";\n10   int lengths[] = {8, 9, 16, 11, 11, 12, 13};\n11 \n12   boost::offset_separator ofs(lengths, lengths + 7);\n13   typedef boost::tokenizer<boost::offset_separator> tokenizer;\n14   tokenizer mytokenizer(input, ofs);\n15   \n16   for (auto& token: mytokenizer) {\n17     std::cout << token << '\\n';\n18   }\n19 }\n```", "```cpp\n20140809\n140329000\n0001881303614419\nABNANL2AWSS\nDEUTDEMM720\n000000412000\nEUR\n```", "```cpp\nboost::offset_separator ofs(lengths, lengths + nfields, \n false);\n\n```", "```cpp\nboost::offset_separator ofs(lengths, lengths + nfields, restart,\n false);\n\n```", "```cpp\n    template <typename InputIterator, typename StringType>bool operator()(InputIterator& next,InputIterator end,StringType& token)\n    ```", "```cpp\n 1 class qstring_token_generator\n 2 {\n 3 public:\n 4   typedef std::string::const_iterator iterator;\n 5\n 6   qstring_token_generator(char open_q = '\"',\n 7              char close_q = '\"', char esc_c = '\\\\',\n 8              bool skip_empty = true);\n 9 \n10   bool operator() (iterator& next, iterator end,\n11                    std::string& token);\n12 \n13   void reset();\n14\n15 private:\n16   // helper functions to be defined\n17\n18   char start_marker;\n19   char end_marker;\n20   char escape_char;\n21   bool skip_empty_tokens;\n22   bool in_token;\n23   bool in_escape;\n24 };\n```", "```cpp\n 1   qstring_token_generator::qstring_token_generator\n 2             (char open_q, char close_q, char esc_c,\n 3              bool skip_empty) : \n 4      start_marker(open_q), end_marker(close_q), \n 5      escape_char(esc_c), skip_empty_tokens(skip_empty),\n 6      in_token(false), in_escape(false)\n 7   {}\n```", "```cpp\n 1   void qstring_token_generator::reset()\n 2   {\n 3     in_token = false;\n 4     in_escape = false;\n 5   }\n```", "```cpp\n 1 iterator qstring_token_generator::start_token(iterator& next)\n 2 {\n 3   in_token = true;\n 4   return ++next;\n 5 }\n 6\n 7 std::string qstring_token_generator::end_token(iterator& next,\n 8                                         iterator token_start) \n 9 {\n10   in_token = false;\n11   auto token_end = next++;\n12   return std::string(token_start, token_end);\n13 }\n```", "```cpp\n 1 bool operator() (iterator& next, iterator end,\n 2                  std::string& token)\n 3 {\n 4   iterator token_start;\n 5\n 6   while (next != end) {\n 7     if (in_escape) {\n 8       // unset in_escape after reading the next char\n 9       in_escape = false;\n10     } else if (*next == start_marker) { // found start marker\n11       if (!in_token) { // potential new token\n12         token_start = start_token(next);\n13         continue;\n14       } else { // already in a quoted string\n15         if (start_marker == end_marker) {\n16           // Found end_marker, is equal to start_marker\n17           token = end_token(next, token_start);\n18           if (!token.empty() || !skip_empty_tokens) {\n19             return true;\n20           }\n21         } else {\n22           // Multiple start markers without end marker.\n23           // Discard previous start markers, consider\n24           //  inner-most token only.\n25           token_start = start_token(next);\n26           continue;\n27         }\n28       }\n29     } else if (*next == end_marker) {\n30       // Found end_marker, is not equal to start_marker\n31       if (in_token) {\n32         token = end_token(next, token_start);\n33         if (!token.empty() || !skip_empty_tokens) {\n34           return true;\n35         }\n36       }\n37     } else if (*next == escape_char) {\n38       in_escape = !in_escape;  // toggle\n39     }\n40     ++next;\n41   }\n42\n43   return false;\n44 }\n```", "```cpp\n 1  std::string input = \"I'm taking a train from Frankfurt \"\n 2                    \"(am Main) to Frankfurt (an der Oder)\";\n 3  bool skipEmpty = true;\n 4  qstring_token_generator qsep('(', ')', '\\\\', skipEmpty);\n 5  typedef boost::tokenizer<qstring_token_generator> qtokenizer;\n 6  qtokenizer tokenizer(input, qsep);\n 7\n 8  unsigned int n = 0;\n 9  for (auto& token: tokenizer) {\n10    std::cout << ++n << ':' << token << '\\n';\n11 }\n```", "```cpp\n([1-9][0-9]*)(\\s+\\w+)*\n```", "```cpp\n$ g++ source.cpp -o progname -lboost_regex\n\n```", "```cpp\n$ g++ source.cpp -o progname -I/opt/boost/include -L/opt/boost/lib -lboost_regex-mt -Wl,-rpath,/opt/boost/lib\n\n```", "```cpp\n1 #include <boost/regex.hpp>\n2 #include <string>\n3 #include <cassert>\n4 int main()\n5 {\n6   std::string str1 = \"Alaska area\";\n7   boost::regex r1(\"a.*a\");\n8   assert(!boost::regex_match(str1, r1));\n9 }\n```", "```cpp\n7   boost::regex r1(\"a.*a\", boost::regex::icase);\n8   assert(boost::regex_match(str1.begin(), str1.end(), r1));\n```", "```cpp\n 1 #include <boost/regex.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 \n 5 int main() {\n 6   std::string str2 = \"An array of papers from the academia \"\n 7                      \"on Alaska area's fauna\";\n 8   boost::regex r2(\"a\\\\w*a\");\n 9   boost::smatch matches;\n10   std::string::const_iterator start = str2.begin(),\n11                               end = str2.end();\n12\n13   while (boost::regex_search(start, end, matches, r2)) { \n14     std::cout << \"Matched substring \" << matches.str()\n15            << \" at offset \" << matches[0].first - str2.begin()\n16            << \" of length \" << matches[0].length() << '\\n';\n17     start = matches[0].second;\n18   }\n19 }\n```", "```cpp\nMatched substring arra at offset 3 of length 4.\nMatched substring academia at offset 28 of length 8.\nMatched substring aska at offset 42 of length 4.\nMatched substring area at offset 47 of length 4.\nMatched substring auna at offset 58 of length 4.\n```", "```cpp\n 1 #include <boost/regex.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4 int main()\n 5 {\n 6   std::string str2 = \"An array of papers from the academia \"\n 7                      \"on Alaska area's fauna\";\n 8  boost::regex r2(\"a(\\\\w*)a\");\n 9  boost::smatch matches;\n10   std::string::const_iterator start = str2.begin(),\n11                               end = str2.end();\n12\n13   while (boost::regex_search(start, end, matches, r2)) {\n14     std::cout << \"Matched substring '\" << matches.str()\n15          << \"' following '\" << matches.prefix().str()\n16          << \" preceding '\" << matches.suffix().str() << \"'\\n\";\n17     start = matches[0].second;\n18     for (size_t s = 1; s < matches.size(); ++s) {\n19       if (matches[s].matched) {\n20         std::cout << \"Matched substring \" << matches[s].str()\n21            << \" at offset \" << matches[s].first \u2013 str2.begin()\n22            << \" of length \" << matches[s].length() << '\\n';\n23       }\n24     }\n25   }\n26 }\n```", "```cpp\n 1 #include <boost/regex.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4\n 5 int main()\n 6 {\n 7   std::string str2 = \"An array of papers from the academia \"\n 8                      \"on Alaska area's fauna\";\n 9   boost::regex r1(\"\\\\ba\\\\w*a\\\\b\", boost::regex::icase);\n10   boost::sregex_iterator rit(str2.begin(), str2.end(), r1), rend;\n11 \n12   while (rit != rend) {\n13     std::cout << *rit++ << '\\n';\n14   }\n15 }\n```", "```cpp\nacademia\nAlaska\narea\n```", "```cpp\n 1 #include <boost/regex.hpp>\n 2 #include <string>\n 3 #include <iostream>\n 4\n 5 int main()\n 6 {\n 7   std::string str3 = \"animal=Llama lives_in=Chile \"\n 8                      \"and is related_to=vicuna\";\n 9   boost::regex r3(\"(\\\\w+)=(\\\\w+)\");\n10   int subindx[] = {2, 1};\n11   boost::sregex_token_iterator tokit(str3.begin(), str3.end(),\n12                                      r3, subindx), tokend;\n13   while (tokit != tokend) {\n14     std::cout << *tokit++ << '\\n';\n15   }\n16   std::cout << '\\n';\n17 }\n```", "```cpp\nLlama\nanimal\nChile\nlives_in\nvicuna\nrelated_to\n```", "```cpp\n 1 #include <boost/algorithm/string_regex.hpp>\n 2 #include <boost/regex.hpp>\n 3 #include <string>\n 4 #include <iostream>\n 5 #include <vector>\n 6\n 7 int main()\n 8 {\n 9   std::string line = \"All that you touch\";\n10   std::vector<std::string> words;\n11   boost::find_all_regex(words, line, boost::regex(\"\\\\w+\"));\n12\n13   std::string record = \"Pigs on the Wing|Dogs| Pigs| Sheep\";\n14   std::vector<std::string> fields;\n15   boost::split_regex(fields, record, boost::regex(\"[\\\\|]\"));\n16\n17   for (auto word: words) { std::cout << word << \",\"; }\n18   std::cout << '\\n';\n19   for (auto field: fields) { std::cout << field << \",\"; }\n20 }\n```", "```cpp\nAll,ll,l,that,hat,at,t,you,ou,u,touch,ouch,ch,h,\nPigs on the Wing,Dogs, Pigs, Sheep,\n```", "```cpp\n 1 #include <boost/regex.hpp>\n 2 #include <cassert>\n 3\n 4 int main()\n 5 {\n 6   std::string str4 = \"England's Queen, India's President, \"\n 7                      \"people's choice\";\n 8   boost::regex r4(\"(\\\\w+)'s\\\\s+(\\\\w+)\");\n10   std::string rep = boost::regex_replace(str4, r4, \"\\\\2 of \\\\1\");\n11   \n12   assert(rep == \"Queen of England, President of India, \"\n13                   \"choice of people\");\n14 }\n```"]