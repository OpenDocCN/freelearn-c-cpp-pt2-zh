["```cpp\n 1 #include <istream>\n 2 #include <fstream>\n 3 typedef unsigned char byte;\n 4 \n 5 byte *rotateImage(std::string imgFile, double angle, \n 6                   size_t& sz) {\n 7   // open the file for reading\n 8   std::ifstream imgStrm(imgFile.c_str(), std::ios::binary);\n 9 \n10   if (imgStrm) {\n11     // determine file size\n12     imgStrm.seekg(0, std::ios::end);\n13     sz = imgStrm.tellg();\n14     imsStrm.seekg(0);        // seek back to start of stream\n15\n16     byte *img = new byte[sz]; // allocate buffer and read\n17     // read the image contents\n18     imgStrm.read(reinterpret_cast<char*>(img), sz);\n19     // process it\n20     byte *rotated = img_rotate(img, sz, angle);\n21     // deallocate buffer\n22     delete [] img;\n23 \n24     return rotated;\n25   }\n26 \n27   sz = 0;\n28   return 0;\n29 }\n```", "```cpp\n 1 struct ScopeGuard\n 2 {\n 3   ScopeGuard(byte *buffer) : data_(buffer) {}\n 4   ~ScopeGuard() { delete [] data_; }\n 5\n 6   byte *get() { return data_; }\n 7 private:\n 8   byte *data_;\n 9 };\n10 \n11 byte *rotateImage(std::string imgFile, double angle, size_t& sz)\n12 {\n13   // open the file for reading\n14   std::ifstream imgStrm(imgFile.c_str(), std::ios::binary);\n15 \n16   if (imgStrm) {\n17     // determine file size\n18     imgStrm.seekg(0, std::ios::end);\n19     sz = imgStrm.tellg();\n20     imgStrm.seekg(0);\n21\n22     // allocate buffer and read\n23     ScopeGuard img(new byte[sz]);\n24     // read the image contents\n25     imgStrm.read(reinterpret_cast<char*>(img.get()), sz);\n26     // process it\n27     return img_rotate(img.get(), sz, angle);\n28   } // ScopeGuard destructor\n29 \n30   sz = 0;\n31   return 0;\n32 }\n```", "```cpp\n 1 class Widget;\n 2 \n 3 // \u2026\n 4 \n 5 void useWidget()\n 6 {\n 7   Widget *wgt = new Widget;\n 8   wgt->setTitle(...);\n 9   wgt->setSize(...);\n10   wgt->display(...);\n11   delete wgt;\n12 }\n```", "```cpp\n 1 #include <boost/scoped_ptr.hpp>\n 2 #include \"Widget.h\"  // contains the definition of Widget\n 3 \n 4 // \u2026\n 5 \n 6 void useWidget()\n 7 {\n 8   boost::scoped_ptr<Widget> wgt(new Widget);\n 9   wgt->setTitle(...);\n10   wgt->setSize(...);\n11   wgt->display(...);\n12 }\n```", "```cpp\n 1 #include <boost/scoped_ptr.hpp>\n 2 #include <cassert>\n 3 #include \"Widget.h\" // Widget definition\n 4 // \u2026\n 5 \n 6 void useTwoWidgets()\n 7 {\n 8   // default constructed scoped_ptr \n 9   boost::scoped_ptr<Widget> wgt;\n10   assert(!wgt);          // null test - Boolean context\n11 \n12   wgt.reset(new Widget); // create first widget\n13   assert(wgt);          // non-null test \u2013 Boolean context\n14   wgt->display();        // display first widget\n15   wgt.reset(new Widget); // destroy first, create second widget\n16   wgt->display();        // display second widget\n17   \n18   Widget *w1 = wgt.get();  // get the raw pointer\n19   Widget& rw1 = *wgt;      // 'dereference' the smart pointer\n20   assert(w1 == &rw1);      // same object, so same address\n21\n22   boost::scoped_ptr<Widget> wgt2(new Widget);\n23   Widget *w2 = wgt2.get();\n24   wgt.swap(wgt2);\n25   assert(wgt.get() == w2);  // effect of swap\n26   assert(wgt2.get() == w1); // effect of swap\n27 }\n```", "```cpp\n 1 class Widget { ... };\n 2\n 3 Widget *makeWidget() // Legacy function\n 4 {\n 5   return new Widget;\n 6 }\n 7 \n 8 void useWidget()\n 9 {\n10   boost::scoped_ptr<Widget> wgt(makeWidget());\n11   wgt->display();              // widget displayed\n12 }   // Widget destroyed on scope exit\n```", "```cpp\n 1 class Widget { ... };\n 2\n 3 void makeNewWidget(boost::scoped_ptr<Widget>& result)\n 4 {\n 5   result.reset(new Widget);\n 6   result->setProperties(...);\n 7 }\n 8 \n 9 void makeAndUseWidget()\n10 {\n11   boost::scoped_ptr<Widget> wgt; // null wgt\n12   makeNewWidget(wgt);         // wgt set to some Widget object.\n13   wgt->display();              // widget #1 displayed\n14 \n15   makeNewWidget(wgt);        // wgt reset to some other Widget.\n16                              // Older wgt released.\n17   wgt->display();            // widget #2 displayed\n18 }\n```", "```cpp\n// DatabaseHandler.h\n 1 #ifndef DATABASEHANDLER_H\n 2 #define DATABASEHANDLER_H\n 3\n 4 class FileLogger;\n 5 class DBConnection;\n 6\n 7 class DatabaseHandler\n 8 {\n 9 public:\n10   DatabaseHandler();\n11   ~DatabaseHandler();\n12   // other methods here\n13\n14 private:\n15   FileLogger *logger_;\n16   DBConnection *dbconn_;\n17 };\n18\n19 #endif /* DATABASEHANDLER_H */\n```", "```cpp\n// DatabaseHandler.cpp\n 1 #include \"DatabaseHandler.h\"\n 2 \n 3 // Dummy concrete implementations\n 4 class FileLogger\n 5 {\n 6 public:\n 7   FileLogger(const std::string& logfile) {...}\n 8 private:\n 9   ...\n10 };\n11\n12 class DBConnection\n13 {\n14 public:\n15   DBConnection(const std::string& dbhost,\n16                const std::string& username,\n17                const std::string& passwd) {...}\n18 private:\n19   ...\n20 };\n21\n22 // class methods implementation\n23 DatabaseHandler::DatabaseHandler(const std::string& logFile,\n24           const std::string& dbHost,\n25           const std::string& user, const std::string& passwd)\n26         : logger_(new FileLogger(logFile)), \n27           dbconn_(new DBConnection(dbHost, user, passwd))\n28 {}\n29\n30 ~DatabaseHandler()\n31 {\n32   delete logger_;\n33   delete dbconn_;\n34 }\n35 \n36 // Other methods\n```", "```cpp\n// DatabaseHandler.h\n 1 #ifndef DATABASEHANDLER_H\n 2 #define DATABASEHANDLER_H\n 3\n 4 #include <boost/scoped_ptr.hpp>\n 5\n 6 class FileLogger;\n 7 class DBConnection;\n 8\n 9 class DatabaseHandler\n10 {\n11 public:\n12   DatabaseHandler(const std::string& logFile,\n13        const std::string& dbHost, const std::string& user,\n14        const std::string& passwd);\n15   ~DatabaseHandler();\n16   // other methods here\n17\n18 private:\n19   boost::scoped_ptr<FileLogger> logger_;\n20   boost::scoped_ptr<DBConnection> dbconn_;\n21 \n22   DatabaseHandler(const DatabaseHandler&);\n23   DatabaseHandler& operator=(const DatabaseHandler&);\n24 };\n25 #endif /* DATABASEHANDLER_H */\n```", "```cpp\n// DatabaseHandler.cpp\n 1 #include \"DatabaseHandler.h\"\n 2 \n 3 // Dummy concrete implementations\n 4 class FileLogger\n 5 {\n 6 public:\n 7   FileLogger(const std::string& logfile) {...}\n 8 private:\n 9   ...\n10 };\n11\n12 class DBConnection\n13 {\n14 public:\n15   DBConnection(const std::string& dbhost,\n16                const std::string& username,\n17                const std::string& passwd) {...}\n18 private:\n19   ...\n20 };\n21\n22 // class methods implementation\n23 DatabaseHandler::DatabaseHandler(const std::string& logFile,\n24             const std::string& dbHost, const std::string& user,\n25             const std::string& passwd)\n26         : logger_(new FileLogger(logFileName)),\n27           dbconn_(new DBConnection(dbsys, user, passwd))\n28 {}\n29\n30 ~DatabaseHandler()\n31 {}\n32 \n33 // Other methods\n```", "```cpp\n 1 #include <boost/scoped_array.hpp>\n 2\n 3 typedef unsigned char byte;\n 4\n 5 byte *rotateImage(const std::string &imgFile, double angle, \n 6                   size_t& sz) {\n 7   // open the file for reading\n 8   std::ifstream imgStrm(imgFile, std::ios::binary);\n 9 \n10   if (imgStrm) {\n11     imgStrm.seekg(0, std::ios::end);\n12     sz = imgStrm.tellg();            // determine file size\n13     imgStrm.seekg(0);\n14 \n15     // allocate buffer and read\n16     boost::scoped_array<byte> img(new byte[sz]);\n17     // read the image contents\n18     imgStrm.read(reinterpret_cast<char*>(img.get()), sz);\n19 \n20     byte first = img[0];  // indexed access\n21     return img_rotate(img.get(), sz, angle);\n22   }\n23 \n24   sz = 0;\n25   return 0;\n26 }\n```", "```cpp\n// Logger.h\n 1 #include <memory>\n 2\n 3 class Logger\n 4 {\n 5 public:\n 6   Logger(const std::string& filename) { ... }\n 7   ~Logger() {...}\n 8   void log(const std::string& message, ...) { ... }\n 9   // other methods\n10 };\n11\n12 std::unique_ptr<Logger> make_logger(\n13                       const std::string& filename) {\n14   std::unique_ptr<Logger> logger(new Logger(filename));\n15   return logger;\n16 }\n```", "```cpp\n 1 #include \"Logger.h\"\n 2 \n 3 void doLogging(const std::string& msg, ...)\n 4 {\n 5   std::string logfile = \"/var/MyApp/log/app.log\";\n 6   std::unique_ptr<Logger> logger = make_logger(logfile);\n 7   logger->log(msg, ...);\n 8 }\n```", "```cpp\n 1 #include <memory>\n 2\n 3 typedef unsigned char byte;\n 4\n 5 byte *rotateImage(std::string imgFile, double angle, size_t& sz)\n 6 {\n 7   // open the file for reading\n 8   std::ifstream imgStrm(imgFile, std::ios::binary);\n 9 \n10   if (imgStrm) {\n11     imgStrm.seekg(0, std::ios::end);\n12     sz = imgStrm.tellg();      // determine file size\n13     imgStrm.seekg(0);\n14     \n15     // allocate buffer and read\n16     std::unique_ptr<byte[]> img(new byte[sz]);\n17     // read the image contents\n18     imgStrm.read(reinterpret_cast<char*>(img.get()),sz);\n19     // process it\n20     byte first = img[0];  // access first byte\n21     return img_rotate(img.get(), sz, angle);\n22   }\n23 \n24   sz = 0;\n25   return 0;\n26 }\n```", "```cpp\n 1 #include \"Logger.h\"  // Listing 3.6a\n 2 \n 3 void doLogging(const std::string& msg, ...)\n 4 {\n 5   std::string filename = \"/var/MyApp/log/app.log\";\n 6   std::unique_ptr<Logger> logger = \n 7                 std::make_unique<Logger>(filename);\n 8   logger->log(msg, ...);\n 9 }\n```", "```cpp\n// two argument constructor\nLogger::Logger(const std::string& filename, loglevel_t level) {\n  ...\n}\n\nstd::unique_ptr<Logger> logger =\n std::make_unique<Logger>(filename, DEBUG);\n\n```", "```cpp\n 1 #include <boost/shared_ptr.hpp>\n 2 #include <iostream>\n 3 #include <cassert>\n 4 \n 5 class Foo {\n 6 public:\n 7   Foo() {}\n 8   ~Foo() { std::cout << \"~Foo() destructor invoked.\" << '\\n';}\n 9 };\n10 \n11 typedef boost::shared_ptr<Foo> SPFoo;\n12   \n13 int main()\n14 {\n15   SPFoo f1(new Foo);\n16   // SPFoo f1 = new Foo; // Won't work, explicit ctor\n17   assert(f1.use_count() == 1);\n18\n19   // copy construction\n20   SPFoo f2(f1);\n21   assert(f1.use_count() == f2.use_count() && \n22          f1.get() == f2.get() && f1.use_count() == 2);\n23   std::cout << \"f1 use_count: \" << f1.use_count() << '\\n';\n24          \n25   SPFoo f3(new Foo);\n26   SPFoo f4(f3);\n27   assert(f3.use_count() == 2 && f3.get() == f4.get());\n28   std::cout << \"f3 use_count: \" << f3.use_count() << '\\n';\n29  \n30   // copy assignment\n31   f4 = f1;\n32   assert(f4.use_count() == f1.use_count() && \n33         f1.use_count() == 3 && f1.get() == f4.get());\n34   assert(f3.use_count() == 1);\n35   std::cout << \"f1 use_count: \" << f1.use_count() << '\\n';\n36   std::cout << \"f3 use_count: \" << f3.use_count() << '\\n';\n37 }\n```", "```cpp\nf1 use_count: 2\nf3 use_count: 2\nf1 use_count: 3\nf3 use_count: 1\n~Foo() destructor invoked.\n~Foo() destructor invoked.\n```", "```cpp\n 1 class AppComponent\n 2 {\n 3 public:\n 4  AppComponent() : spconn_(new DatabaseConnection(...))\n 5  {}\n 6 \n 7  AppComponent( \n 8         const boost::shared_ptr<DatabaseConnection>& spc)\n 9      : spconn_(spc) {}\n11 \n12  // Other public member\n13  ...\n14\n15  boost::shared_ptr<DatabaseConnection> getConnection() {\n16    return spconn_;\n17  }\n18 \n19 private:\n20  boost::shared_ptr<DatabaseConnection> spconn_;\n21  // other data members\n22 };\n```", "```cpp\n 1 AppComponent c1;\n 2 AppComponent c2(a.getConnection());\n```", "```cpp\n 1 class Person;\n 2 typedef boost::shared_ptr<Person> PersonPtr;\n 3 std::vector<PersonPtr> personList;\n 4 std::multimap<std::string, PersonPtr> personNameMap;\n 5 ...\n 6 \n 7 for (auto it = personList.begin(); \n 8      it != personList.end(); ++it) {\n 9   personNameMap.insert(std::make_pair((*it)->name(), *it));\n10 }\n```", "```cpp\n 1 typedef boost::shared_ptr<DatabaseConnection> DBConnectionPtr;\n 2\n 3 struct DBConnectionFactory\n 4 {\n 5   typedef std::map<DBCredentials, DBConnectionPtr> \n 6                                             ConnectionMap;\n 7\n 8   static DBConnectionPtr connect(const DBCredentials& creds)\n 9   {\n10     auto iter = conn_map_.find(creds);\n11\n12     if (iter != conn_map_.end()) {\n13       return iter->second;\n14     } else {\n15       DBConnectionPtr dbconn(new DatabaseConnection(creds));\n16       conn_map_[creds] = dbconn;\n17       return dbconn;\n18     }\n19   }\n20 \n21   static ConnectionMap conn_map_;\n22 };\n23 \n24 DBConnectionFactory::ConnectionMap \n25                                DBConnectionFactory::conn_map_;\n26 int main()\n27 {\n28   DBCredentials creds(...);\n29   DBConnectionPtr dbconn = DBConnectionFactory::connect(creds);\n30   DBConnectionPtr dbconn2 =DBConnectionFactory::connect(creds);\n31   assert(dbconn.get() == dbconn2.get() \n32          && dbconn.use_count() == 3);\n33 }\n```", "```cpp\n 1 typedef boost::shared_ptr<DatabaseConnection> DBConnectionPtr;\n 2 typedef boost::weak_ptr<DatabaseConnection> DBConnectionWkPtr;\n 3\n 4 struct DBConnectionFactory\n 5 {\n 6   typedef std::map<DBCredentials, DBConnectionWkPtr> \n 7                                             ConnectionMap;\n 8\n 9   static DBConnectionPtr connect(const DBCredentials& creds) {\n10      ConnectionIter it = conn_map_.find(creds);\n11      DBConnectionPtr connptr;\n12\n13     if (it != conn_map_.end() &&\n14         (connptr = it->second.lock())) {\n15       return connptr;\n16     } else {\n17       DBConnectionPtr dbconn(new DatabaseConnection(creds));\n18       conn_map_[creds] = dbconn;  // weak_ptr = shared_ptr;\n19       return dbconn;\n20     }\n21   }\n22 \n23   static ConnectionMap conn_map_;\n24 };\n25 \n26 DBConnectionFactory::ConnectionMap \n27                                DBConnectionFactory::conn_map_;\n28 int main()\n29 {\n30   DBCredentials creds(...);\n31   DBConnectionPtr dbconn = DBConnectionFactory::connect(creds);\n32   DBConnectionPtr dbconn2 =DBConnectionFactory::connect(creds);\n33   assert(dbconn.get() == dbconn2.get() \n34          && dbconn.use_count() == 2);\n35 }\n```", "```cpp\n 1 #include <boost/make_shared.hpp>\n 2\n 3 struct Foo {\n 4   Foo(const std::string& name, int num);\n 5   ...\n 6 };\n 7\n 8 boost::shared_ptr<Foo> spfoo = \n 9             boost::make_shared<Foo>(\"Foo\", 10);\n10\n```", "```cpp\n 1 #include <boost/smart_ptr.hpp>\n 2 #include <boost/current_function.hpp>\n 3 #include <iostream>\n 4 #include <cassert>\n 5\n 6 class CanBeShared\n 7        : public boost::enable_shared_from_this<CanBeShared> {\n 8 public:\n 9   ~CanBeShared() {\n10     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n11   }\n12   \n13   boost::shared_ptr<CanBeShared> share()\n14   {\n15     return shared_from_this();\n16   }\n17 };\n18 \n19 typedef boost::shared_ptr<CanBeShared> CanBeSharedPtr;\n20 \n21 void doWork(CanBeShared& obj)\n22 {\n23   CanBeSharedPtr sp = obj.share();\n24   std::cout << \"Usage count in doWork \"<<sp.use_count() <<'\\n';\n25   assert(sp.use_count() == 2);\n26   assert(&obj == sp.get());\n27 }\n28 \n29 int main()\n30 {\n31   CanBeSharedPtr cbs = boost::make_shared<CanBeShared>();\n32   doWork(*cbs.get());\n33   std::cout << cbs.use_count() << '\\n';\n34   assert(cbs.use_count() == 1);\n35 }\n```", "```cpp\n 1 #include <boost/shared_ptr.hpp>\n 2 \n 3 int main()\n 4 {\n 5   boost::shared_ptr<Foo> f1 = boost::make_shared<Foo>();\n 6   boost::shared_ptr<Foo> f2(f1.get());  // don't try this\n 7\n 8   assert(f1.use_count() == 1 && f2.use_count() == 1);\n 9   assert(f1.get() == f2.get());\n10 } // boom!\n```", "```cpp\n 1 #include <boost/intrusive_ptr.hpp>\n 2 #include <iostream>\n 3 \n 4 namespace NS {\n 5 class Bar {\n 6 public:\n 7   Bar() : refcount_(0) {}\n 8  ~Bar() { std::cout << \"~Bar invoked\" << '\\n'; }\n 9 \n10   friend void intrusive_ptr_add_ref(Bar*);\n11   friend void intrusive_ptr_release(Bar*);\n12 \n13 private:\n14   unsigned long refcount_;\n15 };\n16 \n17 void intrusive_ptr_add_ref(Bar* b) {\n18   b->refcount_++;\n19 }\n20 \n21 void intrusive_ptr_release(Bar* b) {\n22   if (--b->refcount_ == 0) {\n23     delete b;\n24   }\n25 }    \n26 } // end NS\n27 \n28 \n29 int main()\n30 {\n31   boost::intrusive_ptr<NS::Bar> pi(new NS::Bar, true);\n32   boost::intrusive_ptr<NS::Bar> pi2(pi);\n33   assert(pi.get() == pi2.get());\n34   std::cout << \"pi: \" << pi.get() << '\\n'\n35             << \"pi2: \" << pi2.get() << '\\n';\n36 }\n```", "```cpp\n 1 #include <boost/intrusive_ptr.hpp>\n 2 #include <boost/smart_ptr/intrusive_ref_counter.hpp>\n 3 #include <iostream>\n 4 #include <cassert>\n 5\n 6 namespace NS {\n 7 class Bar : public boost::intrusive_ref_counter<Bar> {\n 8 public:\n 9   Bar() {}\n10   ~Bar() { std::cout << \"~Bar invoked\" << '\\n'; }\n11 };\n12 } // end NS\n13\n14 int main() {\n15   boost::intrusive_ptr<NS::Bar> pi(new NS::Bar);\n16   boost::intrusive_ptr<NS::Bar> pi2(pi);\n17   assert(pi.get() == pi2.get());\n18   std::cout << \"pi: \" << pi.get() << '\\n'\n19             << \"pi2: \" << pi2.get() << '\\n';\n20   \n21   assert(pi->use_count() == pi2->use_count()\n22          && pi2->use_count() == 2);\n23   std::cout << \"pi->use_count() : \" << pi->use_count() << '\\n'\n24          << \"pi2->use_count() : \" << pi2->use_count() << '\\n';\n25 }\n```", "```cpp\n 7 class Bar : public boost::intrusive_ref_counter<Bar, \n 8                               boost::thread_safe_counter>\n```", "```cpp\n 1 #include <boost/shared_ptr.hpp>\n 2 #include <stdio.h>\n 3 #include <time.h>\n 4 \n 5 struct FILEDeleter\n 6 {\n 7   void operator () (FILE *fp) const {\n 8     fprintf(stderr, \"Deleter invoked\\n\");\n 9     if (fp) {\n10       ::fclose(fp);\n11     }\n12   }\n13 };\n14 \n15 int main()\n16 {\n18   boost::shared_ptr<FILE> spfile(::fopen(\"tmp.txt\", \"a+\"), \n19                                  FILEDeleter());\n20   time_t t;\n21   time(&t);\n22 \n23   if (spfile) {\n24     fprintf(spfile.get(), \"tstamp: %s\\n\", ctime(&t));\n25   }\n26 }\n```", "```cpp\n 1 #include <memory>\n...\n18   std::unique_ptr<FILE, FILEDeleter> spfile(::fopen(\"tmp.txt\", \n19                                             \"a+\"), FILEDeleter());\n```"]