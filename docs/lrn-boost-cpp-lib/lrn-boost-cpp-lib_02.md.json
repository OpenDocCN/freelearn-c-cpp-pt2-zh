["```cpp\nstd::string find_latest_album_of(const std::string& artisteName);\n```", "```cpp\n 1 #include <string>\n 2 #include <map>\n 3\n 4 typedef std::map<std::string, std::string> artiste_album_map;\n 5\n 6 extern artiste_album_map latest_albums;\n 7\n 8 std::string find_latest_album_of(\n 9                     const std::string& artiste_name) {\n10   auto iter = latest_albums.find(artiste_name);\n11\n12   if (iter != latest_albums.end()) {\n13     return iter->second;\n14   } else {\n15     return \"\";\n16   }\n17 }\n```", "```cpp\n 1 #include <string>\n 2 #include <map>\n 3 #include <boost/optional.hpp>\n 4\n 5 typedef std::map<std::string, std::string> artiste_album_map;\n 6\n 7 extern artiste_album_map latest_albums;\n 8 \n 9 boost::optional<std::string> find_latest_album_of(\n10                             const std::string& artiste_name) {\n11   auto iter = latest_albums.find(artiste_name);\n12\n13   if (iter != latest_albums.end()) {\n14     return iter->second;\n15   } else {\n16     return boost::none;\n17   }\n18 }\n```", "```cpp\n 1 #include <boost/optional.hpp>\n 2\n 3 template <typename C>\n 4 boost::optional<typename C::mapped_type>\n 5 lookup(const C& dict, const typename C::key_type& key)\n 6 {\n 7   typename C::const_iterator it = dict.find(key);\n 8   if (it != dict.end()) {\n 9     return it->second;\n10   } else {\n11     return boost::none;\n12   }\n13 }\n```", "```cpp\n 1 std::string artiste(\"Korn\");\n 2 boost::optional<std::string> album = \n 3                             find_latest_album_of(artiste);\n 4 if (album) {\n 5   std::cout << \"The last album from \" << artiste;\n 6\n 7   if (album->empty()) {\n 8     std::cout << \" is untitled\\n\";\n 9   } else {\n10     std::cout << \" is named \" << *album << '\\n';\n11   }\n12 } else {\n13   std::cout << \"No information on albums from \" \n14             << artiste << '\\n';\n15 }\n```", "```cpp\n 1 void printFavoriteCity(const std::string& name,\n 2                        const std::string& city)\n 3 {\n 4   std::cout << name \"'s favorite city is \" << city << '\\n';\n 5 }\n 6\n 7 boost::optional<std::string> getFavoriteCity(\n 8                           const std::string& resident_id);\n 9 ...\n10 std::string resident = \"Serge\";\n11 boost::optional<std::string> fav_city = \n12                                     getFavoriteCity(resident);\n13\n14 printFavoriteCity(fav_city.get_value_or(\"Paris\"));\n```", "```cpp\n 1 #include <boost/tuple/tuple.hpp>\n 2 #include <vector>\n 3\n 4 boost::tuple<size_t, size_t, double>\n 5      getBestTransactDays(std::vector<double> prices)\n 6 {\n 7   double min = std::numeric_limits<double>::max();\n 8   double gain = 0.0, max_gain = 0.0;\n 9   size_t min_day, max_day;\n10   size_t buy_day;\n11   for (size_t i = 0, days = prices.size(); i < days; ++i) {\n12     if (prices[i] < min) {\n13       min = prices[i];\n14       min_day = i;\n15     } else if ((gain = prices[i] - min) > max_gain) {\n16       max_gain = gain;\n17       buy_day = min_day;\n18       max_day = i;\n19     }\n20   }\n21\n22   return boost::make_tuple(buy_day, max_day, max_gain);\n23 }\n```", "```cpp\n22 boost::tuple<size_t, size_t, double> best_buy(buy_day, max_day, \n23                                         max_gain);\n24 return best_buy;\n```", "```cpp\n 1 std::vector<double> stockPrices;\n 2 ...\n 3 boost::tuple<size_t, size_t, double> best_buy = \n 4                              getBestTransactDays(stockPrices);\n 5 \n 6 size_t buyDay = boost::get<0>(best_buy);  // Access 0th element\n 7 size_t sellDay = boost::get<1>(best_buy); // Access 1st element\n 8 double profit = boost::get<2>(best_buy); // Access 2nd element\n```", "```cpp\n 1 size_t buyDay, sellDay;\n 2 double profit;\n 3 boost::tie(buyDay, sellDay, profit) =  \n 4                 getBestTransactDays(stockPrices);\n```", "```cpp\n 1 size_t buyDay, sellDay;\n 2 boost::tie(buyDay, sellDay, boost::tuples::ignore) =\n 3                              getBestTransactDays(stockPrices);\n```", "```cpp\n 1 boost::tuple<int, int, std::string> t1 = \n 2                          boost::make_tuple(1, 2, \"Hello\");\n 3 boost::tuple<double, double, const char*> t2 = \n 4                         boost::make_tuple(1, 2, \"Hi\");\n 5 assert(t1 < t2);   // because Hello < Hi\n```", "```cpp\n 1 boost::tuple<int, int, std::string> t1 = \n 2                          boost::make_tuple(1, 20, \"Hello\");\n 3 boost::tuple<double, double, const char*> t2 = \n 4                        boost::make_tuple(1, 2, \"Hi\");\n 5 assert(t1 > t2);    // because 20 > 2\n```", "```cpp\n 1 struct my_type {\n 2   int a;\n 3   double b;\n 4   char c;\n 5 };\n 6\n 7 bool operator<(const my_type& left, const my_type& right) {\n 8   return boost::make_tuple(left.a, left.b, left.c) <\n 9                 boost::make_tuple(right.a, right.b, right.c);\n10 }\n```", "```cpp\n 1 template <typename T>\n 2 size_t tuple_length(const T&) {\n 3   return boost::tuples::length<T>::value;\n 4 }\n```", "```cpp\n 1 #include <boost/variant.hpp>\n 2 #include <string>\n 3\n 4 struct Foo {\n 5   Foo(int n = 0) : id_(n) {} // int convertible to Foo\n 6 private:\n 7   int id_;\n 8 };\n 9 \n10 struct Bar {\n11   Bar(int n = 0) : id_(n) {} // int convertible to Bar\n12 private:\n13   int id_;\n14 };  \n15 \n16 int main()\n17 {\n18   boost::variant<Foo, int, std::string> value; // error if Foo \n19                                 // not be default constructible\n20   boost::variant<std::string, Foo, Bar> value2;\n21 \n22   value = 1;                 // sets int, not Foo\n23   int *pi = boost::get<int>(&value);\n24   assert(pi != 0);\n25   value = \"foo\";             // sets std::string\n26   value = Foo(42);           // sets Foo\n27\n28   // value2 = 1;             // ERROR: ambiguous - Foo or Bar?\n29   // std::cout << value << ' ' << value2 << '\\n'; // ERROR:\n30                   // Foo, Bar cannot be streamed to ostream\n31 }\n```", "```cpp\n 1 #include <boost/variant.hpp>\n 2 #include <string>\n 3 #include <cassert>\n 4 \n 5 int main() {\n 6   boost::variant<std::string, int> v1;\n 7   v1 = \"19937\";                    // sets string\n 8   int i1;\n 9 \n10   try {    \n11     i1 = boost::get<int>(v1);      // will fail, throw\n12   } catch (std::exception& e) {\n13     std::cerr << e.what() << '\\n';\n14   }\n15 \n16   int *pi = boost::get<int>(&v1);  // will return null\n17   assert(pi == 0);\n18 \n19   size_t index = v1.which();        // returns 0\n20 }\n```", "```cpp\n 1 #include <boost/variant.hpp>\n 2 \n 3 struct SimpleVariantVisitor :public boost::static_visitor<void>\n 4 {\n 5   void operator() (const std::string& s) const\n 6   { std::cout << \"String: \" << s << '\\n'; }\n 7 \n 8   void operator() (long n) const\n 9   { std::cout << \"long: \" << n << '\\n'; }\n10 };\n11 \n12 int main()\n13 {\n14   boost::variant<std::string, long, double> v1;\n15   v1 = 993.3773;\n16 \n17   boost::apply_visitor(SimpleVariantVisitor(), v1);\n18 }\n```", "```cpp\n 1 #include <boost/variant.hpp>\n 2\n 3 struct PrintVisitor : boost::static_visitor<>\n 4 {\n 5    template <typename T>\n 6    void operator() (const T& t) const {\n 7      std::cout << t << '\\n';\n 8    }\n 9 };\n10\n11 boost::variant<std::string, double, long, Foo> v1;\n12 boost::apply_visitor(PrintVisitor(), v1);\n```", "```cpp\n 1 #include <boost/variant.hpp>\n 2\n 3 std::vector<boost::variant<std::string, double, long> > vvec;\n 4 \u2026\n 5 std::for_each(vvec.begin(), vvec.end(),\n 6                  boost::apply_visitor(SimpleVariantVisitor()));\n```", "```cpp\n    {\n        \"Name\": \"Lucas\",\n        \"Age\": 38,\n        \"PhoneNumbers\" : [\"1123654798\", \"3121548967\"],\n        \"Address\" : { \"Street\": \"27 Riverdale\", \"City\": \"Newtown\", \n                             \"PostCode\": \"902739\"}\n    }\n```", "```cpp\n[\n    {\n        \"Name\": \"Lucas\",\n        \"Age\": 38,\n        \"PhoneNumbers\" : [\"1123654798\", \"3121548967\"],\n        \"Address\" : { \"Street\": \"27 Riverdale\", \"City\": \"Newtown\", \n                             \"PostCode\": \"902739\"}\n    },\n    {\n        \"Name\": \"Damien\",\n        \"Age\": 52,\n        \"PhoneNumbers\" : [\"6427851391\", \"3927151648\"],\n        \"Address\": {\"Street\": \"11 North Ave.\", \"City\" : \"Rockport\", \n                        \"PostCode\": \"389203\"}\n    },\n    \u2026 \n]\n```", "```cpp\n 1 struct JSONNullType {};\n 2 boost::variant<std::string, double, bool, JSONNullType> jsonToken;\n```", "```cpp\n 1 #define BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT\n 2 #include <boost/variant.hpp>\n 3\n 4 struct JSONNullType {};\n 5\n 6 typedef boost::make_recursive_variant<\n 7                      std::string,\n 8                      double,\n 9                      bool,\n10                      JSONNullType,\n11                      std::map<std::string,\n12                               boost::recursive_variant_>\n13                     >::type JSONValue;\n```", "```cpp\n 1 #define BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT\n 2 #include <boost/variant.hpp>\n 3\n 4 struct JSONNullType {};\n 5\n 6 typedef boost::make_recursive_variant<\n 7                      std::string,\n 8                      double,\n 9                      bool,\n10                      JSONNullType,\n11                      std::map<std::string,\n12                               boost::recursive_variant_>,\n13                      std::vector<boost::recursive_variant_>\n14                     >::type JSONValue;\n15\n16 typedef std::vector<JSONValue> JSONArray;\n17 typedef std::map<std::string, JSONValue> JSONObject;\n```", "```cpp\n 1 void printArrElem(const JSONValue& val);\n 2 void printObjAttr(const JSONObject::value_type& val); \n 3\n 4 struct JSONPrintVisitor : public boost::static_visitor<void>\n 5 {\n 6   void operator() (const std::string& str) const\n 7   {\n 8     std::cout << '\"' << escapeStr(str) << '\"';\n 9   }\n10\n11   void operator() (const JSONNullType&) const\n12   {\n13     std::cout << \"null\";\n14   }\n15\n16   template <typename T>\n17   void operator()(const T& value) const\n18   {\n19     std::cout << std::boolalpha << value;\n20   }\n21\n22   void operator()(const JSONArray& arr) const\n23   {\n24     std::cout << '[';\n25\n26     if (!arr.empty()) {\n27       boost::apply_visitor(*this, arr[0]);\n28       std::for_each(arr.begin() + 1, arr.end(), printArrElem);\n29     }\n30 \n31     std::cout << \"\\n\";\n32   }\n33\n34   void operator()(const JSONObject& object) const\n35   {\n36     std::cout << '{';\n37 \n38     if (!object.empty()) {\n39       const auto& kv_pair = *(object.begin());\n40       std::cout << '\"' << escapeStr(kv_pair.first) << '\"';\n41       std::cout << ':';\n42       boost::apply_visitor(*this, kv_pair.second);\n43\n44       auto it = object.begin();\n45       std::for_each(++it, object.end(), printObjAttr);\n46     }\n47     std::cout << '}';\n48   }\n49\n50 };\n51\n52 void printArrElem(const JSONValue& val) {\n53   std::cout << ',';\n54   boost::apply_visitor(JSONPrintVisitor(), val);\n55 }\n56\n57 void printObjAttr(const JSONObject::value_type& val) {\n58   std::cout << ',';\n59   std::cout << '\"' << escapeStr(val.first) << '\"';\n60   std::cout << ':';\n61   boost::apply_visitor(JSONPrintVisitor(), val.second);\n62 }\n```", "```cpp\n 1 #include <boost/any.hpp>\n 2 #include <vector>\n 3 #include <iostream>\n 4 #include <string>\n 5 #include <cassert>\n 6 using boost::any_cast;\n 7\n 8 struct MyValue {\n 9   MyValue(int n) : value(n) {}\n10\n11   int get() const { return value; }\n12\n13   int value;\n14 };\n15\n16 int main() {\n17   boost::any v1, v2, v3, v4;\n18\n19   assert(v1.empty());\n20   const char *hello = \"Hello\";\n21   v1 = hello;\n22   v2 = 42;\n23   v3 = std::string(\"Hola\");\n24   MyValue m1(10);\n25   v4 = m1;\n26\n27   try {\n28     std::cout << any_cast<const char*>(v1) << '\\n';\n29     std::cout << any_cast<int>(v2) << '\\n';\n30     std::cout << any_cast<std::string>(v3) << '\\n';\n31     auto x = any_cast<MyValue>(v4);\n32     std::cout << x.get() << '\\n';\n33   } catch (std::exception& e) {\n34     std::cout << e.what() << '\\n';\n35   }\n36 }\n```", "```cpp\n 1 boost::any v1 = 42;2 boost::any v2 = std::string(\"Hello\");\n 3 std::string *str = boost::any_cast<std::string>(&v1);\n 4 assert(str == nullptr);\n 5 int *num = boost::any_cast<int>(&v2);\n 6 assert(num == nullptr);\n 7\n 8 num = boost::any_cast<int>(&v1);\n 9 str = boost::any_cast<std::string>(&v2);\n10 assert(num != nullptr);\n11 assert(str != nullptr);\n```", "```cpp\ntemplate <typename T>\nbool is_type(boost::any& any) {\n  return ( !any.empty() && boost::any_cast<T>(&any) );\n}\n```", "```cpp\nboost::any v1 = std::string(\"Hello\");\nassert( is_type<std::string>(v1) );\n```", "```cpp\n 1 boost::any v1 = 19937;\n 2 boost::any v2 = std::string(\"Hello\");\n 3\n 4 assert(boost::any_cast<int>(&v1) != nullptr);\n 5 assert(boost::any_cast<std::string>(&v2) != nullptr);\n 6\n 7 v1 = 22.36;\n 8 v1.swap(v2);\n 9 assert(boost::any_cast<std::string>(&v1) != nullptr);\n10 assert(boost::any_cast<double>(&v2) != nullptr);\n```", "```cpp\nboost::any value;\nvalue = 20;\nif (value.type().hash_code() == typeid(int).hash_code()) {\n  std::cout << boost::any_cast<int>(value) << '\\n';\n}\n```", "```cpp\n#include <boost/lexical_cast.hpp>\nnamespace boost {\ntemplate <typename T, typename S>\nT lexical_cast (const S& source);\n}\n```", "```cpp\n 1 std::string str = \"1234\";\n 2\n 3 try {\n 4   int n = boost::lexical_cast<int>(str);\n 5   assert(n == 1234);\n 6 } catch (std::exception& e) {\n 7   std::cout << e.what() << '\\n';\n 8 }\n```", "```cpp\n#include <boost/lexical_cast.hpp>\nnamespace boost {\ntemplate <typename T >\nT lexical_cast (const char* str, size_t size);\n}\n```", "```cpp\n 1 std::string str = \"abc1234\";\n 2\n 3 try {\n 4   int n = boost::lexical_cast<int>(str.c_str() + 3, 4);\n 5   assert(n == 1234);\n 6 } catch (std::exception& e) {\n 7   std::cout << e.what() << '\\n';\n 8 }\n```", "```cpp\n1 int main(int argc, char *argv[])\n2 {\n3   std::cout << \"Program name: \" << argv[0] << '\\n';\n4\n5   for (int i = 1; i < argc; ++i) {\n6     std::cout << \"argv[\" << i << \"]: \" << argv[i] << '\\n';\n7   }\n8 }\n```", "```cpp\n$ diff file1 file2\n\n```", "```cpp\n$ diff -U 5 file1 file2\n$ diff --unified=5 file1 file2\n\n```", "```cpp\n$ diff --unified file1 file2\n\n```", "```cpp\n$ diff -pN \u2013unified=5 old_source_dir new_source_dir\n\n```", "```cpp\n 1 #include <boost/program_options.hpp>\n 2\n 3 namespace po = boost::program_options;\n 4 namespace postyle = boost::program_options::command_line_style;\n 5 \n 6 int main(int argc, char *argv[])\n 7 {\n 8   po::options_description desc(\"Options\");\n 9   desc.add_options()\n10      (\"unified,U\", po::value<unsigned int>()->default_value(3),\n11             \"Print in unified form with specified number of \"\n12             \"lines from the surrounding context\")\n13      (\",p\", \"Print names of C functions \"\n14             \" containing the difference\")\n15      (\",N\", \"When comparing two directories, if a file exists in\"\n16             \" only one directory, assume it to be present but \"\n17             \" blank in the other directory\")\n18      (\"help,h\", \"Print this help message\");\n```", "```cpp\n19   int unix_style    = postyle::unix_style\n20                      |postyle::short_allow_next;\n21\n22   int windows_style = postyle::allow_long\n23                      |postyle::allow_short\n24                      |postyle::allow_slash_for_short\n25                      |postyle::allow_slash_for_long\n26                      |postyle::case_insensitive\n27                      |postyle::short_allow_next\n28                      |postyle::long_allow_next;\n```", "```cpp\n29   po::variables_map vm;\n30   try {\n31     po::store(\n32       po::command_line_parser(argc, argv)\n33          .options(desc)\n34          .style(unix_style)  // or windows_style\n35          .run(), vm);\n36\n37     po::notify(vm); \n38\n39     if (argc == 1 || vm.count(\"help\")) {\n40       std::cout << \"USAGE: \" << argv[0] << '\\n'\n41                 << desc << '\\n';\n42       return 0;\n43     }\n44   } catch (po::error& poe) {\n45     std::cerr << poe.what() << '\\n'\n46               << \"USAGE: \" << argv[0] << '\\n' << desc << '\\n';\n47     return EXIT_FAILURE;\n48   }\n```", "```cpp\n49   unsigned int context = 0;\n50   if (vm.count(\"unified\")) {\n51     context = vm[\"unified\"].as<unsigned int>();\n52   }\n53\n54   bool print_cfunc = (vm.count(\"p\") > 0);\n```", "```cpp\n$ diff -pN --unified=5 old_source_dir new_source_dir\n\n```", "```cpp\n 1 std::string file1, file2;\n 2 po::options_description posparams(\"Positional params\");\n 3 posparams.add_options()\n 4         (\"file1\", po::value<std::string>(&file1)->required(), \"\")\n 5         (\"file2\", po::value<std::string>(&file2)->required(), \"\");\n 6 desc.add(posparams);\n 7\n 8\n 9 po::positional_options_description posOpts;\n10 posOpts.add(\"file1\", 1);  // second param == 1 indicates that\n11 posOpts.add(\"file2\", 1);  //  we expect only one arg each\n12\n13 po::store(po::command_line_parser(argc, argv)14                 .options(desc)\n15                 .positional(posOpts)\n16                 .style(windows_style)\n17                 .run(), vm);\n```", "```cpp\n 1 po::options_description desc(\"Options\");\n 2 desc.add_option()\n 3      (\"include,I\", po::value<std::vector<std::string> >(),\n 4       \"Include files.\")\n 5      (\u2026);\n```", "```cpp\n$ c++ source.cpp \u2013o target -I path1 -I path2 -I path3\n\n```", "```cpp\n$ discover_assets --servers svr1 svr2 svr3 --uid user\n\n```", "```cpp\n 1 po::options_description desc(\"Options\");\n 2 desc.add_option()\n 3      (\"servers,S\", \n 4       po::value<std::vector<std::string> >()->multitoken(),\n 5       \"List of hosts or IPs.\")\n 6      (\"uid,U\", po::value<std::string>, \"User name\");\n```", "```cpp\n1 std::vector<std::string> servers = vm[\"servers\"];\n```", "```cpp\n1 std::vector<std::string> servers;\n2 desc.add_option()\n3      (\"servers,S\",\n4       po::value<std::vector<std::string> >(&servers\n5          ->multitoken(),\n6       \"List of hosts or IPs.\")\u2026;\n```", "```cpp\n 1 #include <boost/current_function.hpp>\n 2 #include <iostream>\n 3\n 4 namespace FoFum {\n 5 class Foo\n 6 {\n 7 public:\n 8   void bar() {\n 9     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n10     bar_private(5);\n11   }\n12\n13   static void bar_static() {\n14     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n15   }\n16\n17 private:\n18   float bar_private(int x) const {\n19     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n20   return 0.0;\n21   }\n22 };\n23 } // end namespace FoFum\n24\n25 namespace {\n26 template <typename T>\n27 void baz(const T& x)\n28 {\n29   std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n30 }\n32 } // end unnamed namespace\n33\n34 int main()\n35 {\n36   std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n37   FoFum::Foo f;\n38   f.bar();\n39   FoFum::Foo::bar_static();\n40   baz(f);\n41 }\n```", "```cpp\nint main()\nvoid FoFum::Foo::bar()\nfloat FoFum::Foo::bar1(int) const\nstatic void FoFum::Foo::bar_static()\nvoid {anonymous}::baz(const T&) [with T = FoFum::Foo]\n```", "```cpp\nint __cdecl main(void)\nvoid __thiscall FoFum::Foo::bar(void)\nfloat __thiscall FoFum::Foo::bar1(int) const\nvoid __cdecl FoFum::Foo::bar_static(void)\nvoid __cdecl 'anonymous-namespace'::baz<class FoFum::Foo>(const class FoFum::Foo &)\n```", "```cpp\n#include <boost/core/swap.hpp>\nnamespace boost {\n  template<typename T1, typename T2>\n  void swap(T1& left, T2& right);}\n```", "```cpp\n 1 template <typename T>\n 2 void process_values(T& arg1, T& arg2, \u2026)\n 3 {\n 4   \u2026\n 5   std::swap(arg1, arg2);\n```", "```cpp\n 1 namespace X {\n 2   struct Foo {};\n 3\n 4   void swap(Foo& left, Foo& right) { \n 5     std::cout << BOOST_CURRENT_FUNCTION << '\\n';\n 6   }\n 7 }\n```", "```cpp\n 1 X::Foo f1, f2;\n 2 process_values(f1, f2, \u2026); // calls process_values<X::Foo>\n```", "```cpp\n 1 #include <boost/core/swap.hpp>\n 2\n 3 template <typename T>\n 4 void process_values(T& arg1, T& arg2, \u2026)\n 5 {\n 6   \u2026\n 7   boost::swap(arg1, arg2);\n```", "```cpp\n 1 template <typename T>\n 2 void process_values(T& arg1, T& arg2, \u2026)\n 3 {\n 4   \u2026\n 5   using std::swap;\n 6   swap(arg1, arg2);\n```", "```cpp\n 1 #include <cassert>\n 2\n 3 double power(double base, double exponent)\n 4 {\n 5   // no negative powers of zero\n 6   assert(base != 0 || exponent > 0);\n 7   \u2026\n 8 }\n```", "```cpp\n 1 #include <boost/static_assert.hpp>\n 2\n 3 template <typename T>\n 4 class SmallObjectAllocator\n 5 {\n 6   BOOST_STATIC_ASSERT(sizeof(T) <= 16);\n 7\n 8 public:\n 9   SmallObjectAllocator() {}\n10 };\n```", "```cpp\n11 struct Foo\n12 {\n13   char data[32];\n14 };\n15\n16 int main()\n17 {\n18   SmallObjectAllocator<int> intAlloc;\n19   SmallObjectAllocator<Foo> fooAlloc; // ERROR: sizeof(Foo) > 16\n20 }\n```", "```cpp\nStaticAssertTest.cpp: In instantiation of 'class SmallObjectAllocator<Foo>':\nStaticAssertTest.cpp:19:29:   required from here\nStaticAssertTest.cpp:6:3: error: invalid application of 'sizeof' to incomplete type 'boost::STATIC_ASSERTION_FAILURE<false>'\n```", "```cpp\nStaticAssertTest.cpp: In instantiation of 'class SmallObjectAllocator<Foo>':\nStaticAssertTest.cpp:19:29:   required from here\nStaticAssertTest.cpp:6:3: error: static assertion failed: sizeof(T) <= 16\n```", "```cpp\n 1 BOOST_STATIC_ASSERT_MSG(sizeof(T) <= 16, \"Objects of size more\" \n 2                         \" than 16 bytes not supported.\");\n```", "```cpp\n 1 #include <boost/static_assert.hpp>\n 2 #include <boost/type_traits.hpp>\n 3\n 4 template <typename T, typename U>\n 5 T bitwise_or (const T& left, const U& right)\n 6 {\n 7   BOOST_STATIC_ASSERT(boost::is_pod<T>::value && \n 8                       boost::is_pod<U>::value);\n 9   BOOST_STATIC_ASSERT(sizeof(T) >= sizeof(U));\n10\n11   T result = left;\n12   unsigned char *right_array =\n13           reinterpret_cast<unsigned char*>(&right);\n14   unsigned char *left_array =\n15           reinterpret_cast<unsigned char*>(&result);\n16   for (size_t i = 0; i < sizeof(U); ++i) {\n17     left_array[i] |= right_array[i];\n18   }\n19\n20   return result;\n21 }\n```", "```cpp\n 1 #include <boost/predef.h>\n 2 #include <iostream>\n 3\n 4 void checkOs()\n 5 {\n 6   // identify OS\n 7 #if defined(BOOST_OS_WINDOWS)\n 8   std::cout << \"Windows\" << '\\n';\n 9 #elif defined(BOOST_OS_LINUX)\n10   std::cout << \"Linux\" << '\\n';\n11 #elif defined(BOOST_OS_MACOS)\n12   std::cout << \"MacOS\" << '\\n';\n13 #elif defined(BOOST_OS_UNIX)\n14   std::cout << Another UNIX\" << '\\n'; // *_AIX, *_HPUX, etc. \n15 #endif\n16 }\n```", "```cpp\n 1 #include <boost/predef.h>\n 2 #include <iostream>\n 34 void checkArch()\n 5 {\n 6   // identify architecture\n 7 #if defined(BOOST_ARCH_X86)\n 8  #if defined(BOOST_ARCH_X86_64)\n 9   std::cout << \"x86-64 bit\" << '\\n';\n10  #else\n11   std::cout << \"x86-32 bit\" << '\\n';\n12  #endif\n13 #elif defined(BOOST_ARCH_ARM)\n14   std::cout << \"ARM\" << '\\n';\n15 #else\n16   std::cout << \"Other architecture\" << '\\n';\n17 #endif\n18 }\n```", "```cpp\n 1 #include <boost/predef.h>\n 2 #include <iostream>\n 3\n 4 void checkCompiler()\n 5 {\n 6   // identify compiler\n 7 #if defined(BOOST_COMP_GNUC)\n 8   std::cout << \"GCC, Version: \" << BOOST_COMP_GNUC << '\\n';\n 9 #elif defined(BOOST_COMP_MSVC)\n10   std::cout << \"MSVC, Version: \" << BOOST_COMP_MSVC << '\\n';\n11 #else\n12   std::cout << \"Other compiler\" << '\\n';\n13 #endif\n14 }\n```", "```cpp\n 1 #include <boost/predef.h>\n 2 #include <iostream>\n 3\n 4 void checkCpp11()\n 5 {\n 6   // Do version checks\n 7 #if defined(BOOST_COMP_GNUC)\n 8  #if BOOST_COMP_GNUC < BOOST_VERSION_NUMBER(4, 8, 1)\n 9    std::cout << \"Incomplete C++ 11 support\" << '\\n';\n10  #else\n11    std::cout << \"Most C++ 11 features supported\" << '\\n';\n12  #endif\n13 #elif defined(BOOST_COMP_MSVC)\n14  #if BOOST_COMP_MSVC < BOOST_VERSION_NUMBER(12, 0, 0)\n15    std::cout << \"Incomplete C++ 11 support\" << '\\n';\n16  #else\n17    std::cout << \"Most C++ 11 features supported\" << '\\n';\n18  #endif\n19 #endif\n20 }\n```", "```cpp\n 1 #include <boost/config.hpp>\n 2 #include <boost/version.hpp>\n 3 #include <iostream>\n 4 \n 5 void buildEnvInfo() {\n 6   std::cout << \"Compiler: \" << BOOST_COMPILER << '\\n'\n 7             << \"Platform: \" << BOOST_PLATFORM << '\\n'\n 8             << \"Library: \" << BOOST_STDLIB << '\\n';\n 9\n10   std::cout << \"Boost version: \" << BOOST_LIB_VERSION << '['\n11                             << BOOST_VERSION << ']' << '\\n';\n12 }\n```"]