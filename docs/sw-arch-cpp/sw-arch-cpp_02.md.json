["```cpp\nstruct Duration {\n  int millis_;\n};\n\nvoid example() {\n  auto d = Duration{};\n  d.millis_ = 100;\n\n  auto timeout = 1; // second\n  d.millis_ = timeout; // ouch, we meant 1000 millis but assigned just 1\n}\n```", "```cpp\n#include <chrono>\n\nusing namespace std::literals::chrono_literals;\n\nstruct Duration {\n  std::chrono::milliseconds millis_;\n};\n\nvoid example() {\n  auto d = Duration{};\n  // d.millis_ = 100; // compilation error, as 100 could mean anything\n  d.millis_ = 100ms; // okay\n\n```", "```cpp\n  auto timeout = 1s; // or std::chrono::seconds(1);\n  d.millis_ =\n      timeout; // okay, converted automatically to milliseconds\n}\n\n```", "```cpp\n// Approach #1\nint count_dots(const char *str, std::size_t len) {\n  int count = 0;\n  for (std::size_t i = 0; i < len; ++i) {\n    if (str[i] == '.') count++;\n  }\n  return count;\n}\n\n// Approach #2\nint count_dots(std::string_view str) {\n  return std::count(std::begin(str), std::end(str), '.');\n}\n```", "```cpp\nstd::ostream &operator<<(std::ostream &stream, const MyPair<int, int> \n    &mp) {\n  stream << mp.firstMember() << \", \";\n  stream << mp.secondMember();\n  return stream;\n}\n```", "```cpp\nclass MyPair {\n// ...\n  friend std::ostream &operator<<(std::ostream &stream, \n    const MyPair &mp);\n};\nstd::ostream &operator<<(std::ostream &stream, const MyPair &mp) {\n  stream << mp.first_ << \", \";\n  stream << mp.second_ << \", \";\n  stream << mp.secretThirdMember_;\n  return stream;\n}\n```", "```cpp\nclass Rectangle {\n public:\n  virtual ~Rectangle() = default;\n  virtual double area() { return width_ * height_; }\n  virtual void setWidth(double width) { width_ = width; }\n  virtual void setHeight(double height) { height_ = height; }\n private:\n  double width_;\n  double height_;\n};\n\nclass Square : public Rectangle {\n public:\n  double area() override;\n  void setWidth(double width) override;\n  void setHeight(double height) override;\n};\n```", "```cpp\nclass IFoodProcessor {\n public:\n  virtual ~IFoodProcessor() = default;\n  virtual void blend() = 0;\n};\n```", "```cpp\nclass Blender : public IFoodProcessor {\n public:\n  void blend() override;\n};\n```", "```cpp\nclass IFoodProcessor {\n public:\n  virtual ~IFoodProcessor() = default;\n  virtual void blend() = 0;\n  virtual void slice() = 0;\n  virtual void dice() = 0;\n};\n\nclass AnotherFoodProcessor : public IFoodProcessor {\n public:\n  void blend() override;\n  void slice() override;\n  void dice() override;\n};\n```", "```cpp\nclass IBlender {\n public:\n  virtual ~IBlender() = default;\n  virtual void blend() = 0;\n};\n\nclass ICutter {\n public:\n  virtual ~ICutter() = default;\n  virtual void slice() = 0;\n  virtual void dice() = 0;\n};\n```", "```cpp\nclass FrontEndDeveloper {\n public:\n  void developFrontEnd();\n};\n\nclass BackEndDeveloper {\n public:\n  void developBackEnd();\n};\n\nclass Project {\n public:\n  void deliver() {\n    fed_.developFrontEnd();\n    bed_.developBackEnd();\n  }\n private:\n  FrontEndDeveloper fed_;\n  BackEndDeveloper bed_;\n};\n```", "```cpp\nclass Developer {\n public:\n  virtual ~Developer() = default;\n  virtual void develop() = 0;\n};\n\nclass FrontEndDeveloper : public Developer {\n public:\n  void develop() override { developFrontEnd(); }\n private:\n  void developFrontEnd();\n};\n\nclass BackEndDeveloper : public Developer {\n public:\n  void develop() override { developBackEnd(); }\n private:\n  void developBackEnd();\n};\n```", "```cpp\nclass Project {\n public:\n  using Developers = std::vector<std::unique_ptr<Developer>>;\n  explicit Project(Developers developers)\n      : developers_{std::move(developers)} {}\n\n  void deliver() {\n    for (auto &developer : developers_) {\n      developer->develop();\n    }\n  }\n\n private:\n  Developers developers_;\n};\n```", "```cpp\nclass FrontEndDeveloper {\n public:\n  void develop() { developFrontEnd(); }\n private:\n  void developFrontEnd();\n};\n\nclass BackEndDeveloper {\n public:\n  void develop() { developBackEnd(); }\n private:\n  void developBackEnd();\n};\n```", "```cpp\ntemplate <typename... Devs>\nclass Project {\n public:\n  using Developers = std::vector<std::variant<Devs...>>;\n\n  explicit Project(Developers developers)\n      : developers_{std::move(developers)} {}\n\n  void deliver() {\n    for (auto &developer : developers_) {\n      std::visit([](auto &dev) { dev.develop(); }, developer);\n    }\n  }\n\n private:\n  Developers developers_;\n};\n```", "```cpp\nusing MyProject = Project<FrontEndDeveloper, BackEndDeveloper>;\nauto alice = FrontEndDeveloper{};\nauto bob = BackEndDeveloper{};\nauto new_project = MyProject{{alice, bob}};\nnew_project.deliver();\n```", "```cpp\nclass MiddlewareDeveloper {\n public:\n  void developMiddleware() {}\n};\n\nclass Project {\n public:\n  void deliver() {\n    fed_.developFrontEnd();\n    med_.developMiddleware();\n    bed_.developBackEnd();\n  }\n\n private:\n  FrontEndDeveloper fed_;\n  MiddlewareDeveloper med_;\n  BackEndDeveloper bed_;\n};\n```", "```cpp\nclass MiddlewareDeveloper {\n public:\n  void develop() { developMiddleware(); }\n\n private:\n  void developMiddleware();\n};\n```", "```cpp\nusing MyProject = Project<FrontEndDeveloper, MiddlewareDeveloper, BackEndDeveloper>;\nauto alice = FrontEndDeveloper{};\nauto bob = BackEndDeveloper{};\nauto charlie = MiddlewareDeveloper{};\nauto new_project = MyProject{{alice, charlie, bob}};\nnew_project.deliver();\n```", "```cpp\nclass CachingProcessor {\n public:\n  Result process(WorkItem work);\n  Results processBatch(WorkBatch batch);\n  void addListener(const Listener &listener);\n  void removeListener(const Listener &listener);\n\n private:\n  void addToCache(const WorkItem &work, const Result &result);\n  void findInCache(const WorkItem &work);\n  void limitCacheSize(std::size_t size);\n  void notifyListeners(const Result &result);\n  // ...\n};\n```", "```cpp\nclass WorkResultsCache {\n public:\n  void addToCache(const WorkItem &work, const Result &result);\n  void findInCache(const WorkItem &work);\n  void limitCacheSize(std::size_t size);\n private:\n  // ...\n};\n\nclass ResultNotifier {\n public:\n  void addListener(const Listener &listener);\n  void removeListener(const Listener &listener);\n  void notify(const Result &result);\n private:\n  // ...\n};\n\nclass CachingProcessor {\n public:\n  explicit CachingProcessor(ResultNotifier &notifier);\n  Result process(WorkItem work);\n  Results processBatch(WorkBatch batch);\n private:\n  WorkResultsCache cache_;\n  ResultNotifier notifier_;\n  // ...\n};\n```"]