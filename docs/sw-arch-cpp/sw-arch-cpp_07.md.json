["```cpp\nstruct Resource;\n\n// C API\nResource* acquireResource();\nvoid releaseResource(Resource *resource);\n\n// C++ API\nusing ResourceRaii = std::unique_ptr<Resource, decltype(&releaseResource)>;\nResourceRaii acquireResourceRaii();\n```", "```cpp\ntemplate <class T, size_t N>\nstruct array {\n // types:\n typedef T& reference;\n typedef const T& const_reference;\n typedef /*implementation-defined*/ iterator;\n typedef /*implementation-defined*/ const_iterator;\n typedef size_t size_type;\n typedef ptrdiff_t difference_type;\n typedef T value_type;\n typedef T* pointer;\n typedef const T* const_pointer;\n typedef reverse_iterator<iterator> reverse_iterator;\n typedef reverse_iterator<const_iterator> const_reverse_iterator;\n```", "```cpp\n // no explicit construct/copy/destroy for aggregate type\n```", "```cpp\n constexpr void fill(const T& u);\n constexpr void swap(array<T, N>&) noexcept(is_nothrow_swappable_v<T&>);\n```", "```cpp\n // iterators:\n constexpr iterator begin() noexcept;\n constexpr const_iterator begin() const noexcept;\n constexpr iterator end() noexcept;\n constexpr const_iterator end() const noexcept;\n\n constexpr reverse_iterator rbegin() noexcept;\n constexpr const_reverse_iterator rbegin() const noexcept;\n constexpr reverse_iterator rend() noexcept;\n constexpr const_reverse_iterator rend() const noexcept;\n\n constexpr const_iterator cbegin() const noexcept;\n constexpr const_iterator cend() const noexcept;\n constexpr const_reverse_iterator crbegin() const noexcept;\n constexpr const_reverse_iterator crend() const noexcept;\n```", "```cpp\n // capacity:\n constexpr size_type size() const noexcept;\n constexpr size_type max_size() const noexcept;\n constexpr bool empty() const noexcept;\n\n // element access:\n constexpr reference operator[](size_type n);\n constexpr const_reference operator[](size_type n) const;\n constexpr const_reference at(size_type n) const;\n constexpr reference at(size_type n);\n constexpr reference front();\n constexpr const_reference front() const;\n constexpr reference back();\n constexpr const_reference back() const;\n\n constexpr T * data() noexcept;\n constexpr const T * data() const noexcept;\nprivate:\n // the actual storage, like T elements[N];\n};\n```", "```cpp\ntemplate<class T, class... U>\n  array(T, U...) -> array<T, 1 + sizeof...(U)>;\n```", "```cpp\nauto ints = std::array{1, 2, 3};\n```", "```cpp\nauto legCount = std::unordered_map{ std::pair{\"cat\", 4}, {\"human\", 2}, {\"mushroom\", 1} };\n```", "```cpp\nvoid A(Resource*); \nvoid B(Resource&); \nvoid C(std::unique_ptr<Resource>); \nvoid D(std::unique_ptr<Resource>&);\nvoid E(std::shared_ptr<Resource>); \nvoid F(std::shared_ptr<Resource>&);\n```", "```cpp\ntemplate<typename T>\nT& Queue::push(T&& val) {\n gsl::Expects(!this->full());\n // push the element\n gsl::Ensures(!this->empty());\n}\n```", "```cpp\n#ifdef NDEBUG\n\ninline namespace release {\n\n#else \n\ninline namespace debug {\n\n#endif\n\n\nstruct EasilyDebuggable {\n\n// ...\n\n#ifndef NDEBUG\n\n// fields helping with debugging\n\n#endif\n\n};\n\n\n} // end namespace\n```", "```cpp\nvoid calculate(int param); // If param equals -1 it means \"no value\"\n\n\nvoid calculate(int param = -1);\n```", "```cpp\nvoid calculate(std::optional<int> param);\n```", "```cpp\nint try_parse(std::string_view maybe_number);\nbool try_parse(std::string_view maybe_number, int &parsed_number);\nint *try_parse(std::string_view maybe_number);\nstd::optional<int> try_parse(std::string_view maybe_number);\n```", "```cpp\nstruct UserProfile {\n  std::string nickname;\n  std::optional <std::string> full_name;\n  std::optional <std::string> address;\n  std::optional <PhoneNumber> phone;\n};\n```", "```cpp\nauto temperatures = std::vector<double>{ -3., 2., 0., 8., -10., -7\\. };\n\n// ...\n\nfor (std::size_t i = 0; i < temperatures.size() - 1; ++i) {\n\n    for (std::size_t j = i + 1; j < temperatures.size(); ++j) {\n\n        if (std::abs(temperatures[i] - temperatures[j]) > 5) \n            return std::optional{i};\n\n    }\n\n}\n\nreturn std::nullopt;\n```", "```cpp\nauto it = std::ranges::adjacent_find(temperatures, \n                                     [](double first, double second) {\n    return std::abs(first - second) > 5);\n});\nif (it != std::end(temperatures)) \n    return std::optional{std::distance(std::begin(temperatures), it)};\n\nreturn std::nullopt);\n```", "```cpp\nusing namespace std::ranges;\n\nauto is_even = [](auto x) { return x % 2 == 0; };\n\nauto to_string = [](auto x) { return std::to_string(x); };\n\nauto my_range = views::iota(1)\n\n    | views::filter(is_even)\n\n    | views::take(2)\n```", "```cpp\n    | views::reverse\n\n    | views::transform(to_string);\n\nstd::cout << std::accumulate(begin(my_range), end(my_range), \"\"s) << '\\n';\n```", "```cpp\nusing CustomerId = int;\n\n\nCustomerId get_current_customer_id() { return 42; }\n```", "```cpp\nstruct Merchant {\n\n  int id;\n\n};\n```", "```cpp\nstruct Item {\n\n  std::string name;\n\n  std::optional<std::string> photo_url;\n\n  std::string description;\n\n  std::optional<float> price;\n\n  time_point<system_clock> date_added{};\n\n  bool featured{};\n\n};\n```", "```cpp\nstd::ostream &operator<<(std::ostream &os, const Item &item) {\n\n  auto stringify_optional = [](const auto &optional) {\n\n    using optional_value_type =\n\n        typename std::remove_cvref_t<decltype(optional)>::value_type;\n\n    if constexpr (std::is_same_v<optional_value_type, std::string>) {\n\n      return optional ? *optional : \"missing\";\n\n    } else {\n\n      return optional ? std::to_string(*optional) : \"missing\";\n\n    }\n\n  };\n\n\n  auto time_added = system_clock::to_time_t(item.date_added);\n\n\n  os << \"name: \" << item.name\n\n     << \", photo_url: \" << stringify_optional(item.photo_url)\n\n     << \", description: \" << item.description\n\n     << \", price: \" << std::setprecision(2) \n     << stringify_optional(item.price)\n\n     << \", date_added: \" \n     << std::put_time(std::localtime(&time_added), \"%c %Z\")\n\n     << \", featured: \" << item.featured;\n\n  return os;\n\n}\n```", "```cpp\nenum class Category {\n\n  Food,\n\n  Antiques,\n\n  Books,\n\n  Music,\n\n  Photography,\n\n  Handicraft,\n\n  Artist,\n\n};\n```", "```cpp\nstruct Store {\n\n  gsl::not_null<const Merchant *> owner;\n\n  std::vector<Item> items;\n\n  std::vector<Category> categories;\n\n};\n```", "```cpp\nusing Stores = std::vector<gsl::not_null<const Store *>>;\n\n\nStores get_favorite_stores_for(const CustomerId &customer_id) {\n```", "```cpp\n  static const auto merchants = std::vector<Merchant>{{17}, {29}};\n```", "```cpp\n  static const auto stores = std::vector<Store>{\n\n      {.owner = &merchants[0],\n\n       .items =\n\n           {\n\n               {.name = \"Honey\",\n\n                .photo_url = {},\n\n                .description = \"Straight outta Compton's apiary\",\n\n                .price = 9.99f,\n\n                .date_added = system_clock::now(),\n\n                .featured = false},\n\n               {.name = \"Oscypek\",\n\n                .photo_url = {},\n\n                .description = \"Tasty smoked cheese from the Tatra \n                                mountains\",\n\n                .price = 1.23f,\n\n                .date_added = system_clock::now() - 1h,\n\n                .featured = true},\n\n           },\n\n       .categories = {Category::Food}},\n\n      // more stores can be found in the complete code on GitHub\n\n  };\n```", "```cpp\n  static auto favorite_stores_by_customer =\n\n      std::unordered_map<CustomerId, Stores>{{42, {&stores[0], &stores[1]}}};\n\n  return favorite_stores_by_customer[customer_id];\n\n}\n```", "```cpp\nusing Items = std::vector<gsl::not_null<const Item *>>;\n\n\nItems get_featured_items_for_store(const Store &store) {\n\n  auto featured = Items{};\n\n  const auto &items = store.items;\n\n  for (const auto &item : items) {\n\n    if (item.featured) {\n\n      featured.emplace_back(&item);\n\n    }\n\n  }\n\n  return featured;\n\n}\n```", "```cpp\nItems get_all_featured_items(const Stores &stores) {\n\n  auto all_featured = Items{};\n\n  for (const auto &store : stores) {\n\n    const auto featured_in_store = get_featured_items_for_store(*store);\n\n    all_featured.reserve(all_featured.size() + featured_in_store.size());\n\n    std::copy(std::begin(featured_in_store), std::end(featured_in_store),\n\n              std::back_inserter(all_featured));\n\n  }\n\n  return all_featured;\n\n}\n```", "```cpp\nvoid order_items_by_date_added(Items &items) {\n\n  auto date_comparator = [](const auto &left, const auto &right) {\n\n    return left->date_added > right->date_added;\n\n  };\n\n  std::sort(std::begin(items), std::end(items), date_comparator);\n\n}\n```", "```cpp\nvoid order_items_by_date_added(Items &items) {\n\n  auto date_comparator = []<typename T>(const T &left, const T &right) {\n\n    return left->date_added > right->date_added;\n\n  };\n\n  std::sort(std::begin(items), std::end(items), date_comparator);\n\n}\n```", "```cpp\nvoid render_item_gallery(const Items &items) {\n\n  std::copy(\n\n      std::begin(items), std::end(items),\n\n      std::ostream_iterator<gsl::not_null<const Item *>>(std::cout, \"\\n\"));\n\n}\n```", "```cpp\nint main() {\n\n  auto fav_stores = get_favorite_stores_for(get_current_customer_id());\n\n\n  auto selected_items = get_all_featured_items(fav_stores);\n\n\n  order_items_by_date_added(selected_items);\n\n\n  render_item_gallery(selected_items);\n\n}\n```", "```cpp\nname: Handmade painted ceramic bowls, photo_url: http://example.com/beautiful_bowl.png, description: Hand-crafted and hand-decorated bowls made of fired clay, price: missing, date_added: Sun Jan  3 12:54:38 2021 CET, featured: 1\n\nname: Oscypek, photo_url: missing, description: Tasty smoked cheese from the Tatra mountains, price: 1.230000, date_added: Sun Jan  3 12:06:38 2021 CET, featured: 1\n```", "```cpp\n#include <ranges>\n\n\nusing namespace std::ranges;\n```", "```cpp\nItems get_featured_items_for_store(const Store &store) {\n\n  auto items = store.items | views::filter(&Item::featured) |\n\n               views::transform([](const auto &item) {\n\n                 return gsl::not_null<const Item *>(&item);\n\n               });\n\n  return Items(std::begin(items), std::end(items));\n\n}\n```", "```cpp\nItems get_all_featured_items(const Stores &stores) {\n\n  auto all_featured = stores | views::transform([](auto elem) {\n\n                        return get_featured_items_for_store(*elem);\n\n                      });\n\n\n  auto ret = Items{};\n\n  for_each(all_featured, [&](auto elem) {\n\n    ret.reserve(ret.size() + elem.size());\n\n    copy(elem, std::back_inserter(ret));\n\n  });\n\n  return ret;\n\n}\n```", "```cpp\nvoid order_items_by_date_added(Items &items) {\n\n  sort(items, greater{}, &Item::date_added);\n\n}\n```", "```cpp\nvoid render_item_gallery([[maybe_unused]] const Items &items) {\n\n  copy(items,\n\n       std::ostream_iterator<gsl::not_null<const Item *>>(std::cout, \"\\n\"));\n\n}\n```", "```cpp\nauto get_featured_items_for_store(const Store &store) {\n\n  return store.items | views::filter(&Item::featured) |\n\n         views::transform(\n\n             [](const auto &item) { return gsl::not_null(&item); });\n\n}\n```", "```cpp\nItems get_all_featured_items(const Stores &stores) {\n\n  auto all_featured = stores | views::transform([](auto elem) {\n\n                        return get_featured_items_for_store(*elem);\n\n                      }) |\n\n                      views::join;\n\n  auto as_items = Items{};\n\n  as_items.reserve(distance(all_featured));\n\n  copy(all_featured, std::back_inserter(as_items));\n\n  return as_items;\n\n}\n```", "```cpp\n#include <algorithm>\n\n#include <array>\n\n\nstruct Merchant { int id; };\n\n\nbool has_merchant(const Merchant &selected) {\n\n  auto merchants = std::array{Merchant{1}, Merchant{2}, Merchant{3},\n\n                              Merchant{4}, Merchant{5}};\n\n  return std::binary_search(merchants.begin(), merchants.end(), selected,\n\n                            [](auto a, auto b) { return a.id < b.id; });\n\n}\n```", "```cpp\nint main() { return has_merchant({4}); }\n```", "```cpp\nconstexpr bool has_merchant(const Merchant &selected) \n```", "```cpp\nmain:\n\n        mov     eax, 1\n\n        ret\n```", "```cpp\ntemplate<typename T>\n\nvoid foo(T& t) {...}\n```", "```cpp\nvoid foo(std::swappable auto& t) {...}\n```", "```cpp\ntemplate <class T>\nconcept movable = std::is_object_v<T> && std::move_constructible<T> && std::assignable_from<T&, T> && std::swappable<T>;\n```", "```cpp\ntemplate<class T>\nconcept swappable = requires(T& a, T& b) { ranges::swap(a, b); };\n```", "```cpp\nvoid sink(std::movable auto& resource);\n```", "```cpp\nrange auto get_all_featured_items(const Stores &stores);\n```", "```cpp\ntemplate <typename Range, typename Comp, typename Proj>\n\nconcept sortable_range =\n\n    random_access_range<Range> &&std::sortable<iterator_t<Range>, Comp, Proj>;\n```", "```cpp\ntemplate <typename Range, typename Comp>\n\nconcept sortable_indirectly_dated_range =\n\n    random_access_range<Range> &&std::sortable<iterator_t<Range>, Comp> && requires(range_value_t<Range> v) { { v->date_added }; };\n```", "```cpp\nrequires(I i) {\n\n  { i++ } -> std::same_as<I>;\n\n}\n```", "```cpp\nvoid order_items_by_date_added(\n\n    sortable_range<greater, decltype(&Item::date_added)> auto &items) {\n\n  sort(items, greater{}, &Item::date_added);\n\n}\n```", "```cpp\nvoid order_items_by_date_added(\n\n    sortable_indirectly_dated_range<greater> auto &items) {\n\n  sort(items, greater{}, &Item::date_added);\n\n}\n```", "```cpp\ntemplate <input_range Container>\n\nrequires std::is_same_v<typename Container::value_type,\n\n                        gsl::not_null<const Item *>> void\n\nrender_item_gallery(const Container &items) {\n\n  copy(items,\n\n       std::ostream_iterator<typename Container::value_type>(std::cout, \"\\n\"));\n\n}\n```", "```cpp\nimport my_module;\n```", "```cpp\nmodule;\n```", "```cpp\nexport module customer;\n```", "```cpp\nexport using CustomerId = int;\n\n\nexport CustomerId get_current_customer_id() { return 42; }\n```", "```cpp\nmodule;\n\n\nexport module merchant;\n\n\nexport struct Merchant {\n\n  int id;\n\n};\n```", "```cpp\n#define MY_MACRO\n\nimport my_module;\n```", "```cpp\nmodule;\n\n\n#include <chrono>\n\n#include <iomanip>\n\n#include <optional>\n\n#include <string>\n\n#include <vector>\n```", "```cpp\nexport module store;\n\n\nexport import merchant;\n```", "```cpp\nexport module my_module:foo;\n\n\nexport template<typename T> foo() {}\n```", "```cpp\nexport module my_module;\n\n\nexport import :foo;\n```"]