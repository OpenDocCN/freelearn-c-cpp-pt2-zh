["```cpp\nusing namespace std::chrono;\n\n\nvoid self_measuring_function() {\n\n  auto timestamp_begin = high_resolution_clock::now();\n\n\n  auto cleanup = gsl::finally([timestamp_begin] {\n\n    auto timestamp_end = high_resolution_clock::now();\n\n    std::cout << \"Execution took: \" << duration_cast<microseconds>(timestamp_end - timestamp_begin).count() << \" us\";\n\n  });\n```", "```cpp\n  // perform work\n\n  // throw std::runtime_error{\"Unexpected fault\"};\n\n}\n```", "```cpp\nstruct Noncopyable {\n\n  Noncopyable() = default;\n\n  Noncopyable(const Noncopyable&) = delete;\n\n  Noncopyable& operator=(const Noncopyable&) = delete;\n\n};\n\n\nclass MyType : NonCopyable {};\n```", "```cpp\nstruct MyTypeV2 {\n\n  MyTypeV2() = default;\n\n  MyTypeV2(const MyTypeV2 &) = delete;\n\n  MyTypeV2 & operator=(const MyTypeV2 &) = delete;\n\n  MyTypeV2(MyTypeV2 &&) = delete;\n\n  MyTypeV2 & operator=(MyTypeV2 &&) = delete;\n\n};\n```", "```cpp\nclass PotentiallyMisleading {\n\npublic:\n\n  PotentiallyMisleading() = default;\n\n  PotentiallyMisleading(const PotentiallyMisleading &) = default;\n\n  PotentiallyMisleading &operator=(const PotentiallyMisleading &) = default;\n\n  PotentiallyMisleading(PotentiallyMisleading &&) = default;\n\n  PotentiallyMisleading &operator=(PotentiallyMisleading &&) = default;\n\n  ~PotentiallyMisleading() = default;\n\n\nprivate:\n\n  std::unique_ptr<int> int_;\n\n};\n```", "```cpp\nclass RuleOfZero {\n\n  std::unique_ptr<int> int_;\n\n};\n```", "```cpp\ntemplate <typename T> class Array {\n\npublic:\n\n  Array(T *array, int size) : array_{array}, size_{size} {}\n\n\n  ~Array() { delete[] array_; }\n\n\n  T &operator[](int index) { return array_[index]; }\n\n  int size() const { return size_; }\n\n  friend void swap(Array &left, Array &right) noexcept {\n    using std::swap;\n    swap(left.array_, right.array_);\n    swap(left.size_, right.size_);\n  }\n\n\nprivate:\n\n  T *array_;\n\n  int size_;\n\n};\n```", "```cpp\n  Array &operator=(Array other) noexcept {\n\n    swap(*this, other);\n\n    return *this;\n\n  }\n```", "```cpp\n  Array(const Array &other) : array_{new T[other.size_]}, size_{other.size_} {\n\n    std::copy_n(other.array_, size_, array_);\n\n  }\n```", "```cpp\n  Array(Array &&other) noexcept\n\n      : array_{std::exchange(other.array_, nullptr)}, size_{std::exchange(other.size_, 0)} {}\n```", "```cpp\nnamespace detail {\n\nstruct contains_fn final {\n\n  template <std::input_iterator It, std::sentinel_for<It> Sent, typename T,\n\n            typename Proj = std::identity>\n\n  requires std::indirect_binary_predicate<\n\n      std::ranges::equal_to, std::projected<It, Proj>, const T *> constexpr bool\n\n  operator()(It first, Sent last, const T &value, Proj projection = {}) const {\n```", "```cpp\n    while (first != last && std::invoke(projection, *first) != value)\n\n      ++first;\n\n    return first != last;\n\n  }\n```", "```cpp\n  template <std::ranges::input_range Range, typename T,\n\n            typename Proj = std::identity>\n\n  requires std::indirect_binary_predicate<\n\n      std::ranges::equal_to,\n\n      std::projected<std::ranges::iterator_t<Range>, Proj>,\n\n      const T *> constexpr bool\n\n  operator()(Range &&range, const T &value, Proj projection = {}) const {\n```", "```cpp\n    return (*this)(std::ranges::begin(range), std::ranges::end(range), value,\n\n                   std::move(projection));\n\n  }\n\n};\n\n}  // namespace detail\n```", "```cpp\ninline constexpr detail::contains_fn contains{};\n```", "```cpp\nint main() {\n\n  auto ints = std::ranges::views::iota(0) | std::ranges::views::take(5);\n\n\n  return contains(ints, 42);\n\n}\n```", "```cpp\ntemplate <typename T, typename DebugPrintingPolicy = NullPrintingPolicy>\n\nclass Array {\n```", "```cpp\nstruct NullPrintingPolicy {\n\n  template <typename... Args> void operator()(Args...) {}\n\n};\n```", "```cpp\nstruct CoutPrintingPolicy {\n\n  void operator()(std::string_view text) { std::cout << text << std::endl; }\n\n};\n```", "```cpp\n  Array(T *array, int size) : array_{array}, size_{size} {\n\n    DebugPrintingPolicy{}(\"constructor\");\n\n  }\n\n\n  Array(const Array &other) : array_{new T[other.size_]}, size_{other.size_} {\n\n    DebugPrintingPolicy{}(\"copy constructor\");\n\n    std::copy_n(other.array_, size_, array_);\n\n  }\n\n\n  // ... other members ... \n```", "```cpp\nArray<T, CoutPrintingPolicy>(new T[size], size);\n```", "```cpp\ntemplate <typename ConcreteItem> class GlamorousItem {\n\npublic:\n\n  void appear_in_full_glory() {\n\n    static_cast<ConcreteItem *>(this)->appear_in_full_glory();\n\n  }\n\n};\n```", "```cpp\nclass PinkHeels : public GlamorousItem<PinkHeels> {\n\npublic:\n\n  void appear_in_full_glory() {\n\n    std::cout << \"Pink high heels suddenly appeared in all their beauty\\n\";\n\n  }\n\n};\n\n\nclass GoldenWatch : public GlamorousItem<GoldenWatch> {\n\npublic:\n\n  void appear_in_full_glory() {\n\n    std::cout << \"Everyone wanted to watch this watch\\n\";\n\n  }\n\n};\n```", "```cpp\ntemplate <typename... Args>\n\nusing PreciousItems = std::tuple<GlamorousItem<Args>...>;\n\n\nauto glamorous_items = PreciousItems<PinkHeels, GoldenWatch>{};\n```", "```cpp\n  std::apply(\n\n      []<typename... T>(GlamorousItem<T>... items) {    \n          (items.appear_in_full_glory(), ...); },\n\n      glamorous_items);\n```", "```cpp\n  using GlamorousVariant = std::variant<PinkHeels, GoldenWatch>;\n\n  auto glamorous_items = std::array{GlamorousVariant{PinkHeels{}}, GlamorousVariant{GoldenWatch{}}};\n\n  for (auto& elem : glamorous_items) {\n\n    std::visit([]<typename T>(GlamorousItem<T> item){ item.appear_in_full_glory(); }, elem);\n\n  }\n```", "```cpp\nclass CommonGlamorousItem {\n\npublic:\n\n  template <typename T> requires std::is_base_of_v<GlamorousItem<T>, T>\n\n  explicit CommonGlamorousItem(T &&item)\n\n      : item_{std::forward<T>(item)} {}\n\nprivate:\n\n  GlamorousVariant item_;\n\n};\n```", "```cpp\n  void appear_in_full_glory() {\n\n    std::visit(\n\n        []<typename T>(GlamorousItem<T> item) { \n            item.appear_in_full_glory(); },\n\n        item_);\n\n  }\n```", "```cpp\nauto glamorous_items = std::array{CommonGlamorousItem{PinkHeels{}},\n\n                                  CommonGlamorousItem{GoldenWatch{}}};\n\n    for (auto& elem : glamorous_items) {\n\n      elem.appear_in_full_glory();\n\n    }\n```", "```cpp\nclass GlamorousItem {\n\npublic:\n\n  template <typename T>\n\n  explicit GlamorousItem(T t)\n\n      : item_{std::make_unique<TypeErasedItem<T>>(std::move(t))} {}\n\n\n  void appear_in_full_glory() { item_->appear_in_full_glory_impl(); }\n\n\nprivate:\n\n  std::unique_ptr<TypeErasedItemBase> item_;\n\n};  \n```", "```cpp\n  struct TypeErasedItemBase {\n\n    virtual ~TypeErasedItemBase() = default;\n\n    virtual void appear_in_full_glory_impl() = 0;\n\n  };\n```", "```cpp\n  template <typename T> class TypeErasedItem final : public TypeErasedItemBase {\n\n  public:\n\n    explicit TypeErasedItem(T t) : t_{std::move(t)} {}\n\n    void appear_in_full_glory_impl() override { t_.appear_in_full_glory(); }\n\n\n  private:\n\n    T t_;\n\n  };\n```", "```cpp\nclass PinkHeels {\n\npublic:\n\n  void appear_in_full_glory() {\n\n    std::cout << \"Pink high heels suddenly appeared in all their beauty\\n\";\n\n  }\n\n};\n\n\nclass GoldenWatch {\n\npublic:\n\n  void appear_in_full_glory() {\n\n    std::cout << \"Everyone wanted to watch this watch\\n\";\n\n  }\n\n};\n```", "```cpp\n  auto glamorous_items =\n\n      std::array{GlamorousItem{PinkHeels{}}, GlamorousItem{GoldenWatch{}}};\n\n  for (auto &item : glamorous_items) {\n\n    item.appear_in_full_glory();\n\n  }\n```", "```cpp\nclass Pixel {\n\npublic:\n\n  static Pixel fromRgba(char r, char b, char g, char a) {\n\n    return Pixel{r, g, b, a};\n\n  }\n\n  static Pixel fromBgra(char b, char g, char r, char a) {\n\n    return Pixel{r, g, b, a};\n\n  }\n\n\n  // other members\n\n\nprivate:\n\n  Pixel(char r, char g, char b, char a) : r_(r), g_(g), b_(b), a_(a) {}\n\n  char r_, g_, b_, a_;\n\n}\n```", "```cpp\nstruct Pixel {\n\n  char r, g, b, a;\n\n};\n\n\nPixel makePixelFromRgba(char r, char b, char g, char a) {\n\n  return Pixel{r, g, b, a};\n\n}\n\n\nPixel makePixelFromBgra(char b, char g, char r, char a) {\n\n  return Pixel{r, g, b, a};\n\n}\n```", "```cpp\nstruct Pixel {\n\n  char r, g, b, a;\n\n\nprivate:\n\n  Pixel(char r, char g, char b, char a) : r(r), g(g), b(b), a(a) {}\n\n  friend Pixel makePixelFromRgba(char r, char g, char b, char a);\n\n  friend Pixel makePixelFromBgra(char b, char g, char r, char a);\n\n};\n```", "```cpp\nstd::unique_ptr<IDocument> open(std::string_view path) {\n\n    if (path.ends_with(\".pdf\")) return std::make_unique<PdfDocument>();\n\n    if (name == \".html\") return std::make_unique<HtmlDocument>();\n\n\n    return nullptr;\n\n}\n```", "```cpp\nclass DocumentOpener {\n\npublic:\n\n  using DocumentType = std::unique_ptr<IDocument>;\n\n  using ConcreteOpener = DocumentType (*)(std::string_view);\n\n\nprivate:\n\n  std::unordered_map<std::string_view, ConcreteOpener> openerByExtension;\n\n};\n```", "```cpp\n  void Register(std::string_view extension, ConcreteOpener opener) {\n\n    openerByExtension.emplace(extension, opener);\n\n  }\n```", "```cpp\n  DocumentType open(std::string_view path) {\n\n    if (auto last_dot = path.find_last_of('.');\n\n        last_dot != std::string_view::npos) {\n\n      auto extension = path.substr(last_dot + 1);\n\n      return openerByExtension.at(extension)(path);\n\n    } else {\n\n      throw std::invalid_argument{\"Trying to open a file with no extension\"};\n\n    }\n\n  }\n```", "```cpp\nauto document_opener = DocumentOpener{};\n\n\ndocument_opener.Register(\n\n    \"odt\", [](auto path) -> DocumentOpener::DocumentType {\n\n      return std::make_unique<OdtDocument>(path);\n\n    });\n```", "```cpp\n  auto document = document_opener.open(\"file.odt\");\n\n  std::cout << document->extract_text().front();\n```", "```cpp\nstruct Item {\n\n  std::string name;\n\n  std::optional<std::string> photo_url;\n\n  std::string description;\n\n  std::optional<float> price;\n\n  time_point<system_clock> date_added{};\n\n  bool featured{};\n\n};\n```", "```cpp\n  template <typename ConcreteBuilder> friend class GenericItemBuilder;\n```", "```cpp\ntemplate <typename ConcreteBuilder> class GenericItemBuilder {\n\npublic:\n\n  explicit GenericItemBuilder(std::string name)\n\n      : item_{.name = std::move(name)} {}\n\nprotected:\n\n  Item item_;\n```", "```cpp\n  Item build() && {\n\n    item_.date_added = system_clock::now();\n\n    return std::move(item_);\n\n  }\n```", "```cpp\n  ConcreteBuilder &&with_description(std::string description) {\n\n    item_.description = std::move(description);\n\n    return static_cast<ConcreteBuilder &&>(*this);\n\n  }\n\n\n  ConcreteBuilder &&marked_as_featured() {\n\n    item_.featured = true;\n\n    return static_cast<ConcreteBuilder &&>(*this);\n\n  }\n```", "```cpp\nclass ItemBuilder final : public GenericItemBuilder<ItemBuilder> {\n\n  using GenericItemBuilder<ItemBuilder>::GenericItemBuilder;\n\n};\n```", "```cpp\n  auto directly_loaded_item = ItemBuilder{\"Pot\"}\n\n                                  .with_description(\"A decent one\")\n\n                                  .with_price(100)\n\n                                  .build();\n```", "```cpp\nclass FetchingItemBuilder final\n\n    : public GenericItemBuilder<FetchingItemBuilder> {\n\npublic:\n\n  explicit FetchingItemBuilder(std::string name)\n\n      : GenericItemBuilder(std::move(name)) {}\n\n\n  FetchingItemBuilder&& using_data_from(std::string_view url) && {\n\n    item_ = fetch_item(url);\n\n    return std::move(*this);\n\n  }\n\n};\n```", "```cpp\n  auto fetched_item =\n\n      FetchingItemBuilder{\"Linen blouse\"}\n\n          .using_data_from(\"https://example.com/items/linen_blouse\")\n\n          .marked_as_featured()\n\n          .build();\n```", "```cpp\nclass Map {\n\npublic:\n\n    virtual std::unique_ptr<Map> clone() const;\n\n    // ... other members ...\n\n};\n\n\nclass MapWithPointsOfInterests {\n\npublic:\n\n    std::unique_ptr<Map> clone() override const;\n\n    // ... other members ...\n\nprivate:\n\n    std::vector<PointOfInterest> pois_;\n\n};\n```", "```cpp\nnamespace state {\n\n\nstruct Depleted {};\n\n\nstruct Available {\n\n  int count;\n\n};\n\n\nstruct Discontinued {};\n\n} // namespace state\n```", "```cpp\nusing State = std::variant<state::Depleted, state::Available, state::Discontinued>;\n```", "```cpp\nnamespace event {\n\n\nstruct DeliveryArrived {\n\n  int count;\n\n};\n\n\nstruct Purchased {\n\n  int count;\n\n};\n\n\nstruct Discontinued {};\n\n\n} // namespace event\n```", "```cpp\nState on_event(state::Available available, event::DeliveryArrived delivered) {\n\n  available.count += delivered.count;\n\n  return available;\n\n}\n\n\nState on_event(state::Available available, event::Purchased purchased) {\n\n  available.count -= purchased.count;\n\n  if (available.count > 0)\n\n    return available;\n\n  return state::Depleted{};\n\n}\n```", "```cpp\ntemplate <typename S> State on_event(S, event::Discontinued) {\n\n  return state::Discontinued{};\n\n}\n```", "```cpp\nState on_event(state::Depleted depleted, event::DeliveryArrived delivered) {\n\n  return state::Available{delivered.count};\n\n}\n```", "```cpp\ntemplate<class... Ts> struct overload : Ts... { using Ts::operator()...; };\n\ntemplate<class... Ts> overload(Ts...) -> overload<Ts...>;\n```", "```cpp\nclass ItemStateMachine {\n\npublic:\n\n  template <typename Event> void process_event(Event &&event) {\n\n    state_ = std::visit(overload{\n\n        [&](const auto &state) requires std::is_same_v<\n\n            decltype(on_event(state, std::forward<Event>(event))), State> {\n\n          return on_event(state, std::forward<Event>(event));\n\n        },\n\n        [](const auto &unsupported_state) -> State {\n\n          throw std::logic_error{\"Unsupported state transition\"};\n\n        }\n\n      },\n\n      state_);\n\n  }\n\n\nprivate:\n\n  State state_;\n\n};\n```", "```cpp\n      std::string report_current_state() {\n\n        return std::visit(\n\n            overload{[](const state::Available &state) -> std::string {\n\n                       return std::to_string(state.count) + \n                       \" items available\";\n\n                     },\n\n                     [](const state::Depleted) -> std::string {\n\n                       return \"Item is temporarily out of stock\";\n\n                     },\n\n                     [](const state::Discontinued) -> std::string {\n\n                       return \"Item has been discontinued\";\n\n                     }},\n\n            state_);\n\n      }\n```", "```cpp\n        auto fsm = ItemStateMachine{};\n\n        std::cout << fsm.report_current_state() << '\\n';\n\n        fsm.process_event(event::DeliveryArrived{3});\n\n        std::cout << fsm.report_current_state() << '\\n';\n\n        fsm.process_event(event::Purchased{2});\n\n        std::cout << fsm.report_current_state() << '\\n';\n\n        fsm.process_event(event::DeliveryArrived{2});\n\n        std::cout << fsm.report_current_state() << '\\n';\n\n        fsm.process_event(event::Purchased{3});\n\n        std::cout << fsm.report_current_state() << '\\n';\n\n        fsm.process_event(event::Discontinued{});\n\n        std::cout << fsm.report_current_state() << '\\n';\n\n        // fsm.process_event(event::DeliveryArrived{1});\n```", "```cpp\nItem is temporarily out of stock\n\n3 items available\n\n1 items available\n\n3 items available\n\nItem is temporarily out of stock\n\nItem has been discontinued\n```", "```cpp\n  auto single_threaded_pool = std::pmr::unsynchronized_pool_resource();\n\n  std::pmr::set_default_resource(&single_threaded_pool);\n```", "```cpp\n  auto ints = std::vector<int, std::pmr::polymorphic_allocator<int>>(std::pmr::get_default_resource());\n\n  auto also_ints = std::pmr::vector<int>{};\n```", "```cpp\n  auto buffer = std::array<std::byte, 1 * 1024 * 1024>{};\n\n  auto monotonic_resource =\n\n      std::pmr::monotonic_buffer_resource{buffer.data(), buffer.size()};\n\n  auto pool_options = std::pmr::pool_options{.max_blocks_per_chunk = 0,\n\n      .largest_required_pool_block = 512};\n\n  auto arena =\n\n      std::pmr::unsynchronized_pool_resource{pool_options, &monotonic_resource};\n```", "```cpp\nclass verbose_resource : public std::pmr::memory_resource {\n\n  std::pmr::memory_resource *upstream_resource_;\n\npublic:\n\n  explicit verbose_resource(std::pmr::memory_resource *upstream_resource)\n\n      : upstream_resource_(upstream_resource) {}\n```", "```cpp\nprivate:\n\n  void *do_allocate(size_t bytes, size_t alignment) override {\n\n    std::cout << \"Allocating \" << bytes << \" bytes\\n\";\n\n    return upstream_resource_->allocate(bytes, alignment);\n\n  }\n```", "```cpp\n  void do_deallocate(void *p, size_t bytes, size_t alignment) override {\n\n    std::cout << \"Deallocating \" << bytes << \" bytes\\n\";\n\n    upstream_resource_->deallocate(p, bytes, alignment);\n\n  }\n```", "```cpp\n  [[nodiscard]] bool\n\n  do_is_equal(const memory_resource &other) const noexcept override {\n\n    return this == &other;\n\n  }\n```", "```cpp\nstd::pmr::set_default_resource(null_memory_resource());\n```", "```cpp\n  auto buffer = std::array<std::byte, 640 * 1024>{}; // 640K ought to be enough for anybody\n\n  auto resource = std::pmr::monotonic_buffer_resource{\n\n      buffer.data(), buffer.size(), std::pmr::null_memory_resource()};\n```", "```cpp\n  auto verbose = verbose_resource(std::pmr::get_default_resource());\n\n  auto monotonic = std::pmr::monotonic_buffer_resource(&verbose);\n\n  std::pmr::set_default_resource(&monotonic);\n\n\n  auto alloc = std::pmr::polymorphic_allocator{};\n\n  auto *vector = alloc.new_object<std::pmr::vector<std::pmr::string>>();\n\n  vector->push_back(\"first one\");\n\n  vector->emplace_back(\"long second one that must allocate\");\n```"]