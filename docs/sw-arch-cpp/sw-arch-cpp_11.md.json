["```cpp\n#include \"customer/customer.h\"\n\n#include <gtest/gtest.h>\n\nTEST(basic_responses, given_name_when_prepare_responses_then_greets_friendly) {\n  auto name = \"Bob\";\n  auto code_and_string = responder{}.prepare_response(name);\n  ASSERT_EQ(code_and_string.first, web::http::status_codes::OK);\n  ASSERT_EQ(code_and_string.second, web::json::value(\"Hello, Bob!\"));\n}\n```", "```cpp\n#include \"customer/customer.h\"\n\n#define CATCH_CONFIG_MAIN // This tells Catch to provide a main() - only do\n                           // this in one cpp file\n#include \"catch2/catch.hpp\"\n\nTEST_CASE(\"Basic responses\",\n          \"Given Name When Prepare Responses Then Greets Friendly\") {\n  auto name = \"Bob\";\n  auto code_and_string = responder{}.prepare_response(name);\n  REQUIRE(code_and_string.first == web::http::status_codes::OK);\n  REQUIRE(code_and_string.second == web::json::value(\"Hello, Bob!\"));\n}\n```", "```cpp\n#include <cppunit/BriefTestProgressListener.h>\n#include <cppunit/CompilerOutputter.h>\n#include <cppunit/TestCase.h>\n#include <cppunit/TestFixture.h>\n#include <cppunit/TestResult.h>\n#include <cppunit/TestResultCollector.h>\n#include <cppunit/TestRunner.h>\n#include <cppunit/XmlOutputter.h>\n#include <cppunit/extensions/HelperMacros.h>\n#include <cppunit/extensions/TestFactoryRegistry.h>\n#include <cppunit/ui/text/TextTestRunner.h>\n\n#include \"customer/customer.h\"\n\nusing namespace CppUnit;\nusing namespace std;\n```", "```cpp\nclass TestBasicResponses : public CppUnit::TestFixture {\n  CPPUNIT_TEST_SUITE(TestBasicResponses);\n  CPPUNIT_TEST(testBob);\n  CPPUNIT_TEST_SUITE_END();\n\n protected:\n  void testBob();\n};\n\nvoid TestBasicResponses::testBob() {\n  auto name = \"Bob\";\n  auto code_and_string = responder{}.prepare_response(name);\n  CPPUNIT_ASSERT(code_and_string.first == web::http::status_codes::OK);\n  CPPUNIT_ASSERT(code_and_string.second == web::json::value(\"Hello, Bob!\"));\n}\n\nCPPUNIT_TEST_SUITE_REGISTRATION(TestBasicResponses);\n```", "```cpp\nint main() {\n  CPPUNIT_NS::TestResult testresult;\n\n  CPPUNIT_NS::TestResultCollector collectedresults;\n  testresult.addListener(&collectedresults);\n\n  CPPUNIT_NS::BriefTestProgressListener progress;\n  testresult.addListener(&progress);\n\n  CPPUNIT_NS::TestRunner testrunner;\n  testrunner.addTest(CPPUNIT_NS::TestFactoryRegistry::getRegistry().makeTest());\n  testrunner.run(testresult);\n\n  CPPUNIT_NS::CompilerOutputter compileroutputter(&collectedresults, std::cerr);\n  compileroutputter.write();\n\n  ofstream xmlFileOut(\"cppTestBasicResponsesResults.xml\");\n  XmlOutputter xmlOut(&collectedresults, xmlFileOut);\n  xmlOut.write();\n\n  return collectedresults.wasSuccessful() ? 0 : 1;\n}\n```", "```cpp\n#include \"customer/customer.h\"\n\n#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n#include <doctest/doctest.h>\n\nTEST_CASE(\"Basic responses\") {\n  auto name = \"Bob\";\n  auto code_and_string = responder{}.prepare_response(name);\n  REQUIRE(code_and_string.first == web::http::status_codes::OK);\n  REQUIRE(code_and_string.second == web::json::value(\"Hello, Bob!\"));\n}\n```", "```cpp\n#include <string_view>\n\nconstexpr int generate_lucky_number(std::string_view name) {\n  if (name == \"Bob\") {\n    number = number * 7 + static_cast<int>(letter);\n  }\n  return number;\n}\n\nstatic_assert(generate_lucky_number(\"Bob\") == 808);\n```", "```cpp\n#include \"merchants/reviews.h\"\n\n#include <gmock/gmock.h>\n\n#include <merchants/visited_merchant_history.h>\n\n#include \"fake_customer_review_store.h\"\n\nnamespace {\n\nclass mock_visited_merchant : public i_visited_merchant {\n public:\n  explicit mock_visited_merchant(fake_customer_review_store &store,\n                                 merchant_id_t id)\n      : review_store_{store},\n        review_{store.get_review_for_merchant(id).value()} {\n    ON_CALL(*this, post_rating).WillByDefault([this](stars s) {\n      review_.rating = s;\n      review_store_.post_review(review_);\n    });\n    ON_CALL(*this, get_rating).WillByDefault([this] { return review_.rating; });\n  }\n\n  MOCK_METHOD(stars, get_rating, (), (override));\n  MOCK_METHOD(void, post_rating, (stars s), (override));\n\n private:\n  fake_customer_review_store &review_store_;\n  review review_;\n};\n\n} // namespace\n\nclass history_with_one_rated_merchant : public ::testing::Test {\n public:\n  static constexpr std::size_t CUSTOMER_ID = 7777;\n  static constexpr std::size_t MERCHANT_ID = 1234;\n  static constexpr const char *REVIEW_TEXT = \"Very nice!\";\n  static constexpr stars RATING = stars{5.f};\n\n protected:\n  void SetUp() final {\n    fake_review_store_.post_review(\n        {CUSTOMER_ID, MERCHANT_ID, REVIEW_TEXT, RATING});\n\n    // nice mock will not warn on \"uninteresting\" call to get_rating\n    auto mocked_merchant =\n        std::make_unique<::testing::NiceMock<mock_visited_merchant>>(\n            fake_review_store_, MERCHANT_ID);\n\n    merchant_index_ = history_.add(std::move(mocked_merchant));\n  }\n\n  fake_customer_review_store fake_review_store_{CUSTOMER_ID};\n  history_of_visited_merchants history_{};\n  std::size_t merchant_index_{};\n};\n\nTEST_F(history_with_one_rated_merchant,\n       when_user_changes_rating_then_the_review_is_updated_in_store) {\n  const auto &mocked_merchant = dynamic_cast<const mock_visited_merchant &>(\n      history_.get_merchant(merchant_index_));\n  EXPECT_CALL(mocked_merchant, post_rating);\n\n  constexpr auto new_rating = stars{4};\n  static_assert(RATING != new_rating);\n  history_.rate(merchant_index_, stars{new_rating});\n}\n\nTEST_F(history_with_one_rated_merchant,\n       when_user_selects_same_rating_then_the_review_is_not_updated_in_store) {\n  const auto &mocked_merchant = dynamic_cast<const mock_visited_merchant &>(\n      history_.get_merchant(merchant_index_));\n  EXPECT_CALL(mocked_merchant, post_rating).Times(0);\n\n  history_.rate(merchant_index_, stars{RATING});\n}\n```", "```cpp\n#include \"merchants/reviews.h\"\n\n#include \"fake_customer_review_store.h\"\n\n// order is important\n#define CATCH_CONFIG_MAIN\n#include <catch2/catch.hpp>\n#include <catch2/trompeloeil.hpp>\n\n#include <memory>\n\n#include <merchants/visited_merchant_history.h>\n\nusing trompeloeil::_;\n\nclass mock_visited_merchant : public i_visited_merchant {\n public:\n  MAKE_MOCK0(get_rating, stars(), override);\n  MAKE_MOCK1(post_rating, void(stars s), override);\n};\n\nSCENARIO(\"merchant history keeps store up to date\", \"[mobile app]\") {\n  GIVEN(\"a history with one rated merchant\") {\n    static constexpr std::size_t CUSTOMER_ID = 7777;\n    static constexpr std::size_t MERCHANT_ID = 1234;\n    static constexpr const char *REVIEW_TEXT = \"Very nice!\";\n    static constexpr stars RATING = stars{5.f};\n\n    auto fake_review_store_ = fake_customer_review_store{CUSTOMER_ID};\n    fake_review_store_.post_review(\n        {CUSTOMER_ID, MERCHANT_ID, REVIEW_TEXT, RATING});\n\n    auto history_ = history_of_visited_merchants{};\n    const auto merchant_index_ =\n        history_.add(std::make_unique<mock_visited_merchant>());\n\n    auto &mocked_merchant = const_cast<mock_visited_merchant &>(\n        dynamic_cast<const mock_visited_merchant &>(\n            history_.get_merchant(merchant_index_)));\n\n    auto review_ = review{CUSTOMER_ID, MERCHANT_ID, REVIEW_TEXT, RATING};\n    ALLOW_CALL(mocked_merchant, post_rating(_))\n        .LR_SIDE_EFFECT(review_.rating = _1;\n                        fake_review_store_.post_review(review_););\n    ALLOW_CALL(mocked_merchant, get_rating()).LR_RETURN(review_.rating);\n\n    WHEN(\"a user changes rating\") {\n      constexpr auto new_rating = stars{4};\n      static_assert(RATING != new_rating);\n\n      THEN(\"the review is updated in store\") {\n        REQUIRE_CALL(mocked_merchant, post_rating(_));\n        history_.rate(merchant_index_, stars{new_rating});\n      }\n    }\n\n    WHEN(\"a user selects same rating\") {\n      THEN(\"the review is not updated in store\") {\n        FORBID_CALL(mocked_merchant, post_rating(_));\n        history_.rate(merchant_index_, stars{RATING});\n      }\n    }\n  }\n}\n```", "```cpp\nclass CustomerReviewStore : public i_customer_review_store {\n public:\n  CustomerReviewStore() = default;\n  explicit CustomerReviewStore(const std::ranges::range auto &initial_reviews) {\n    static_assert(is_range_of_reviews_v<decltype(initial_reviews)>,\n                  \"Must pass in a collection of reviews\");\n    std::ranges::copy(begin(initial_reviews), end(initial_reviews),\n                      begin(reviews_));\n  }\n // ...\n private:\n  std::vector<review> reviews_;\n};\n```", "```cpp\ntemplate <typename T>\nconstexpr bool is_range_of_reviews_v =\n    std::is_same_v<std::ranges::range_value_t<T>, review>;\n```", "```cpp\nvoid post_review(review review) final {\n  Expects(review.merchant);\n  Expects(review.customer);\n  Ensures(!reviews_.empty());\n\n  reviews_.push_back(std::move(review));\n}\n```", "```cpp\n# We want to have git 1:2.1.4 installed if we're running Debian\ndescribe package('git'), :if => os[:family] == 'debian' do\n\n  it { should be_installed.with_version('1:2.1.4') }\n\nend\n# We want the file /etc/letsencrypt/config/example.com.conf to:\n\ndescribe file('/etc/letsencrypt/config/example.com.conf') do\n\n  it { should be_file } # be a regular file\n\n  it { should be_owned_by 'letsencrypt' } # owned by the letsencrypt user\n\n  it { should be_mode 600 } # access mode 0600\n\n  it { should contain('example.com') } # contain the text example.com \n                                       # in the content\nend\n```", "```cpp\n# We want Git installed on our host\ndef test_git_is_installed(host):\n    git = host.package(\"git\")\n    # we test if the package is installed\n    assert git.is_installed\n    # and if it matches version 1:2.1.4 (using Debian versioning)\n    assert git.version.startswith(\"1:2.1.4\")\n# We want the file /etc/letsencrypt/config/example.com.conf to:\ndef test_letsencrypt_file(host):\n    le = host.file(\"/etc/letsencrypt/config/example.com.conf\")\n    assert le.user == \"letsencrypt\" # be owned by the letsencrypt user\n    assert le.mode == 0o600 # access mode 0600\n    assert le.contains(\"example.com\") # contain the text example.com in the contents\n```", "```cpp\n# We want Git installed on our host\npackage:\n  git:\n    installed: true # we test if the package is installed\n  versions:\n  - 1:2.1.4 # and if it matches version 1:2.1.4 (using Debian versioning)\nfile:\n  # We want the file /etc/letsencrypt/config/example.com.conf to:\n  /etc/letsencrypt/config/example.com.conf:\n    exists: true\n  filetype: file # be a regular file\n  owner: letsencrypt # be owned by the letsencrypt user\n  mode: \"0600\" # access mode 0600\n  contains:\n  - \"example.com\" # contain the text example.com in the contents\n```"]