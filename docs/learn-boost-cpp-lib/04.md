# 四、使用字符串

文本数据是现代应用处理的最重要和最普遍的数据形式。 通过直观的抽象有效地处理文本数据的能力是文本数据处理有效性的关键标志。 Boost 有许多专门用于有效文本处理的库，这些库增强和扩展了 C++ 标准库提供的功能。

在本章中，我们将介绍三个用于处理文本数据的关键 Boost 库。 我们将从 Boost 字符串算法库开始，这是一个针对文本数据的通用算法库，它提供了许多标准库中经常遗漏的简单文本操作。 然后，我们将介绍 Boost Tokenizer 库，这是一个基于各种条件对字符串数据进行标记化的可扩展框架。 此后，我们将研究用于搜索和解析字符串的正则表达式库 Boost.Regex，它也包含在 C++ 11 标准中。 以下各节将介绍以下主题：

*   使用 Boost 字符串算法库进行文本处理
*   使用 Boost 标记器库拆分文本
*   带 Boost.Regex 的正则表达式

本章应该可以帮助您很好地掌握 Boost 库中提供的文本处理技术。 本书不涉及国际化问题，但本章讨论的大多数概念将适用于具有基于非拉丁字符集的书写系统的语言的文本。

# 使用 Boost 字符串算法库进行文本处理

文本数据通常表示为序列或*字符串*，它们在内存中连续排列，并以特殊标记(空终止符)结束。 虽然用于表示字符的实际数据类型可能会因情况而异，但 C++ 标准库在类模板`std::basic_string`中抽象了字符串概念，类模板将字符数据类型作为参数。 `std::basic_string`模板接受三个类型参数：

*   字符类型
*   封装在特征类中的字符类型的一些内在属性和行为
*   用于为`std::basic_string`分配内部数据结构的分配器类型

默认设置为特征和分配器参数，如以下代码片段所示：

```cpp
template <typename charT,
          typename Traits = std::char_traits<chart>,
          typename Allocator = std::allocator<chart>>
std::basic_string;
```

C++ 03 标准库还提供了`std::basic_string`的两个专门化：

*   `std::string`用于窄字符(8 位`char`)
*   `std::wstring`用于宽字符(16 位或 32 位`wchar_t`)

在 C++ 11 中，我们还有两个：

*   `std::u16string`(用于`u16char_t`)
*   `std::u32string`(用于`u32char_t`)

除了这些类之外，普通的老式 C 样式字符串(即以空字符结尾的`char`或`wchar_t`数组)也很常用，尤其是在遗留 C++ 代码中。

标准库有两个主要缺点，这使得处理文本数据类型有时过于单调乏味。 首先，可以应用于`string`和`wstring`的现成算法集有限。 此外，这些算法大多是`std::basic_string`的成员函数，不适用于其他字符串表示，如字符数组。 甚至可以作为非成员函数模板使用的算法也处理迭代器而不是容器，这使得代码变得单调乏味，灵活性降低。

考虑如何使用 C++ 标准库将字符串转换为大写：

**清单 4.1：使用 std：：Transform**将字符串更改为大写

```cpp
 1 #include <string>
 2 #include <algorithm>
 3 #include <cassert>
 4 #include <cctype>
 5 
 6 int main() {
 7   std::string song = "Green-tinted sixties mind";
 8   std::transform(song.begin(), song.end(), song.begin(),
 9                  ::toupper);
10 
11   assert(song == "GREEN-TINTED SIXTIES MIND");
12 }
```

我们使用`std::transform`算法将字符序列转换为大写形式，并将标准库中的`toupper`函数应用于每个字符(第 8-9 行)。 要转换的字符序列由字符串`song`(`song.begin()`)的第一个字符和最后一个字符(`song.end()`)-的一对迭代器指定，作为前两个参数传递给`std::transform`。 转换后的序列从`song.begin()`开始就地写回，这是`std::transform`的第三个参数。 如果您用 C++ 编程过一段时间，您可能不会发现有很多错误，但是`transform`函数的一般性有点模糊了意图的表达。 这就是 Boost 字符串算法库的用武之地，它提供了大量有用的字符串算法函数模板，这些模板可以直观地命名并有效地工作，有时甚至可以在不同的字符串抽象上使用。 请考虑前面代码的以下替代方案：

**清单 4.2：使用 Boost：：TO_UPPER**将字符串更改为大写

```cpp
 1 #include <string>
 2 #include <boost/algorithm/string.hpp>
 3 #include <cassert>
 4
 5 int main()
 6 {
 7   std::string song = "Green-tinted sixties mind";
 8   boost::to_upper(song);
 9   assert(song == "GREEN-TINTED SIXTIES MIND");
10 }
```

要将字符串`song`转换为大写，可以调用`boost::to_upper(song)`(第 8 行)。 我们包括头`boost/algorithm/string.hpp`(第 2 行)来访问`boost::to_upper`，这是 Boost 字符串算法库中的算法函数模板。 它被命名为`to_upper`，而不是`transform`，并且只接受一个参数，而不是四个，而且没有迭代器--有什么不喜欢的呢？ 此外，您还可以在裸阵列上运行相同的代码：

**清单 4.3：使用 Boost：：TO_UPPER**将字符数组更改为大写

```cpp
 1 #include <string>
 2 #include <boost/algorithm/string.hpp>
 3 #include <cassert>
 4
 5 int main()
 6 {
 7   char song[17] = "Book of Taliesyn";
 8   boost::to_upper(song);
 9   assert(std::string(song) == "BOOK OF TALIESYN");
10 }
```

但是迭代器让选择您想要转换成大写的范围，在这里，我们似乎只能将任何内容应用于整个字符串。 事实上，正如我们将看到的那样，这也不是问题。

### 备注

**升压范围**

Boost 字符串算法库中的算法实际上工作在称为范围的抽象上，而不是容器或迭代器。 **范围**只是可以按某个顺序完全遍历的元素序列。 粗略地说，像`std::string`这样的容器是一个连续的单字节字符序列，而像`std::list<Foo>`这样的容器是一个类型为`Foo`的元素序列。 因此，它们符合有效范围的要求。

一个简单的范围可以由一对迭代器表示-一个指向范围中的第一个元素，另一个指向范围中最后一个元素之后的一个。 范围可以表示容器中的整个元素序列。 进一步概括起来，范围可以描述为容器的子序列，也就是容器中保留了相对顺序的元素的子集。 例如，索引为奇数的容器的元素的子序列是有效范围。 单个迭代器对可能不足以表示这样一个范围；我们需要更多的构造来表示它们。

Boost.Range 库提供了生成和处理各种范围所需的必要抽象和函数。 类模板`boost::iterator_range`用于使用一对迭代器表示不同类型的范围。 Boost 字符串算法中的算法接受范围内的参数，并返回这些参数，从而实现调用链接，这是大多数 STL 算法不可能实现的。 在本章中，我们不会冒险过多地介绍 Boost.Range 的细节，但我们将对在字符串算法库中使用范围所需的知识有一个直观的理解。

如果我们只想转换字符串的一部分，我们将需要构造一个表示该部分的范围。 我们可以使用`boost::iterator_range`类模板来生成任意范围。 我们是这样做的：

**清单 4.4：使用 TO_UPPER**将字符串的一部分更改为大写

```cpp
 1 #include <string>
 2 #include <boost/algorithm/string.hpp>
 3 #include <cassert>
 4
 5 int main()
 6 {
 7   std::string song = "Green-tinted sixties mind";
 8   typedef boost::iterator_range<std::string::iterator>
 9                                                RangeType; 
10   RangeType range = boost::make_iterator_range(
11                        song.begin() + 13, song.begin() + 20);
12   boost::to_upper(range);
13   assert(song == "Green-tinted SIXTIES mind");
14 }
```

具体地说，我们希望使用一个字符串的两个迭代器来构造范围。 因此，范围的类型将是`boost::iterator_range<std::string::iterator>`。 我们为这个相当长的类型名(第 8-9 行)创建了一个 tyecif。 我们希望将字符串`"Green-tinted sixties mind"`中的单词`"sixties"`更改为大写。 该单词从字符串`song`的索引 13 开始，长度为 7 个字符。 因此，定义包含`"sixties"`的范围的迭代器是`song.begin() + 13`和`song.begin() + 13 + 7`，即`song.begin() + 20`。 实际范围(`range`)是通过将这两个迭代器传递给函数模板`boost::make_iterator_range`(第 10-11 行)来构造的。 我们将此范围传递给`boost::to_upper`算法，该算法将更改子字符串`"sixties"`的大小写(第 12 行)，并断言预期的更改(第 13 行)。

这看起来可能有很多代码，但请记住，当您将算法应用于整个字符串或容器时，不必构造一个显式范围。 此外，如果您使用的是 C++ 11，`auto`关键字可以帮助减少冗长；因此，您可以替换突出显示的行(8-11)，如下所示：

```cpp
 8 auto range = boost::make_iterator_range(song.begin() + 13,
 9                                       song.begin() + 20);

```

您可以在[附录](12.html "Appendix A. C++ 11 Language Features Emulation")、*C++ 11 语言功能仿真*中了解有关`auto`关键字的更多信息。

从数组构造迭代器范围也没有太大不同：

**清单 4.5：使用 TO_UPPER**将字符数组的一部分更改为大写

```cpp
 1 #include <string>
 2 #include <boost/algorithm/string.hpp>
 3 #include <cassert>
 4
 5 int main()
 6 {
 7   char song[17] = "Book of Taliesyn";
 8 
 9   typedef boost::iterator_range<char*> RangeType; 
10   RangeType rng = boost::make_iterator_range(song + 8,
11                                              song + 16);
12   boost::to_upper(rng);
13   assert(std::string(song) == "Book of TALIESYN");
14 }
```

范围被定义为类型`boost::iterator_range<char*>`，数组的迭代器类型为`char*`(第 9 行)。 同样，如果我们在 C++ 11 上，我们可以使用`auto`来消除所有语法难题。我们使用适当的偏移量(8 和 16)创建迭代器范围，限定单词`"Taliesyn"`(第 10-11 行)，并使用`boost::to_upper`(第 12 行)转换范围。

## 使用 Boost 字符串算法

在本部分中，我们将探索各种可用的字符串算法，并了解它们适用的条件。 不过，在我们研究具体的算法之前，我们将首先尝试了解事物的总体方案。

考虑算法`boost::contains`。 它检查作为第二个参数传递的字符串是否是作为第一个参数传递的字符串的子字符串：

**清单 4.6：使用 Boost：：Containes**

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <cassert>
 4 
 5 int main() {
 6   std::string input = "linearize";
 7   std::string test = "near";
 8   assert(boost::contains(input, test));
 9 }
```

算法`boost::contains`应该返回 TRUE，因为`"linearize"`包含子字符串`"near"`(第 8 行)。 虽然这个对`boost::contains`的调用返回 TRUE，但如果我们将`test`设置为`"Near"`而不是`"near"`，它将返回 FALSE。 如果我们想要检查子字符串而不考虑大小写，我们必须使用`boost::icontains`来替代`boost::contains`。 与`boost::contains`一样，Boost 字符串算法中的大多数算法都有一个前缀为`i-`的不区分大小写的版本。

与`boost::contains`不同，一些字符串算法基于传递给它的字符串生成修改后的字符串内容。 例如，`boost::to_lower`将传递给它的字符串内容转换为小写。 它通过就地更改字符串来实现这一点，从而修改其参数。 称为`boost::to_lower_copy`的算法的非变异版本复制传递的字符串，转换复制字符串的大小写，然后返回它，而不修改原始字符串。 这种非突变变体的名称中有`_copy`后缀。 下面是一个简短的示例：

**清单 4.7：Boost 字符串算法的 USING_COPY 版本**

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <cassert>
 4 
 5 int main() {
 6   std::string str1 = "Find the Cost of Freedom";
 7   std::string str2 = boost::to_lower_copy(str1);
 8   assert(str1 != str2);
 9   boost::to_lower(str1);
10   assert(str1 == str2);
11   assert(str1 == "find the cost of freedom");
12 }
```

首先使用非变异变量`boost::to_lower_copy`复制字符串`str1`并将其转换为小写，然后将结果赋给`str2`(第 7 行)。 此时，`str1`保持不变。 接下来，使用`boost::to_lower`将`str1`就地转换为小写(第 9 行)。 此时，`str1`和`str2`都有相同的内容(第 10 行)。 在接下来的大部分内容中，我们将在适用的情况下使用区分大小写的变体和变异变体，并理解算法的不区分大小写和非变异(复制)版本也存在。 我们现在开始研究具体的算法。

### 查找算法

Boost 字符串算法库中提供了*Find 算法*的多个变体，所有这些变体都在另一个输入字符串中搜索字符串或模式。 每种算法都将输入字符串和搜索字符串作为参数，将它们转换为范围，然后执行搜索。 每个查找变量返回输入中与搜索字符串或模式匹配的连续子序列作为一个范围。 如果未找到匹配项，则返回空范围。

#### Find_First

我们从查看`boost::find_first`开始，它在另一个字符串中查找一个字符串：

**清单 4.8：使用 Boost：：Find_First**

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <iostream>
 4 
 5 int main()
 6 {
 7   const char *haystack = "Mary had a little lamb";
 8   const char *needles[] = {"little", "Little", 0};
 9 
10   for (int i = 0; needles[i] != 0; ++ i) {
11     auto ret = boost::find_first(haystack, needles[i]);
12   
13     if (ret.begin() == ret.end()) {
14       std::cout << "String [" << needles[i] << "] not found in"
15                 << " string [" << haystack << "\n";
16     } else {
17       std::cout << "String [" << needles[i] << "] found at " 
18                 << "offset " << ret.begin() - haystack
19                 << " in string [" << haystack << "\n";
20     }
21 
22     std::cout << "'" << ret << "'" << '\n';
23   }
24 }
```

我们有一个要搜索的字符串数组，名为`needles`(第 8 行)。 我们还有一个名为`haystack`的 C 样式字符串，我们希望在其中查找包含要搜索的文本的搜索字符串(第 7 行)。 我们遍历`needles`中的每个字符串，并调用`boost::find_first`算法在`haystack`中查找它(第 11 行)。 我们检查搜索是否未能找到匹配项(第 13 行)。 如果找到匹配项，则在找到匹配项的`haystack`中计算偏移量(第 18 行)。 范围`ret`定义了输入字符串`haystack`的范围；因此，我们总是可以执行像`ret.begin() – haystack`这样的偏移量计算。

第一次迭代将能够找到`"little"`，而第二次迭代将无法找到`"Little"`，因为`boost::find_first`区分大小写。 如果我们使用执行不区分大小写搜索的`boost::ifind_first`，那么两者都会匹配。

我们使用 C++ 11`auto`关键字来避免为`ret`编写一个笨拙的类型(第 11 行)，但如果必须编写，它将是`boost::iterator_range<char*>`。 请注意，我们实际上可以将算法返回的范围`ret`流式传输到输出流(第 22 行)。

此示例演示了 C 样式字符数组上的技术，但将其应用于`std::string`需要的更改少得令人惊讶。 如果`haystack`是`std::string`实例，那么唯一的变化将是我们计算偏移量的方式(第 18 行)：

```cpp
               << "offset " << ret.begin() – haystack.begin()
```

由于`haystack`不是字符数组，而是`std::string`，因此通过调用其`begin()`成员函数获得到其起始位置的迭代器。

如果我们想要在`haystack`中找到搜索字符串的最后一个实例，而不是第一个实例，我们可以用`boost::find_last`替换`boost::find_first`。 如果可能存在多个匹配令牌，我们可能会要求按索引进行特定匹配。 为此，我们需要调用`boost::find_nth`，向其传递第三个参数，该参数将是匹配的从零开始的索引。 我们可能会传递一个负索引来请求从末尾开始匹配。 因此，传递`-1`将得到最后一场比赛，传递`-2`将产生倒数第二场比赛，依此类推。

#### FIND_ALL

要在输入字符串中查找所有匹配子字符串，我们必须使用`boost::find_all`并向其传递一个序列容器，以便将所有匹配的子字符串放入其中。 下面是一个简短的示例，说明如何做到这一点：

**清单 4.9：使用 Boost：：Find_All 查找所有匹配子字符串**

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <iostream>
 4 #include <vector>
 5
 6 int main()
 7 {
 8   typedef boost::iterator_range<std::string::const_iterator>
 9                                                 string_range;
10   std::vector<string_range> matches;
11   std::string str = "He deserted the unit while they trudged "
12                     "through the desert one night.";
13 
14   boost::find_all(matches, str, "desert");
15   for (auto match : matches) {
16     std::cout << "Found [" << "desert" << "] at offset "
17           << match.begin() - str.begin() << ".\n";
18   }
19 }
```

我们首先为适当的范围类型创建一个 tyecif`string_range`(第 8-9 行)。 `boost::find_all`算法将所有匹配范围复制到范围矢量`matches`中(第 14 行)。 我们使用 C++ 11 新的**基于范围的 for-loop**语法对向量`matches`进行迭代(第 15 行)，并在找到每个匹配项的处打印偏移量(第 17 行)。 漂亮的基于范围的 for 循环声明了一个循环变量`match`来迭代容器`matches`的连续元素。 使用`auto`关键字，可以根据`matches`中包含的值类型自动推断出`match`的类型。 使用范围向量而不是字符串向量，我们能够计算出`str`中发生匹配的精确偏移量。

#### Find_Token

另一个有趣的查找算法是`boost::find_token`算法。 使用该算法，我们可以找到字符满足指定谓词的子串。 我们可以使用一组预定义的谓词，也可以定义我们自己的谓词，尽管后一种方法需要做大量的工作，我们在本书中不会尝试这样做。 在下一个示例中，我们将搜索字符串中包含四位或更多位的十六进制数。 这还将说明如何使用函数执行重复搜索。

为此，我们使用`boost::is_xdigit`谓词，如果传递给它的特定字符是有效的十六进制字符，则返回 TRUE。 以下是示例代码：

**清单 4.10：使用 Boost：：Find_Token 和谓词**查找子字符串

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <iostream>
 4 
 5 int main()
 6 {
 7   std::string str = "The application tried to read from an "
 8                     "invalid address at 0xbeeffed";
 9 
10   auto token = boost::find_token(str, boost::is_xdigit(), 
11                                boost::token_compress_on);
12   while (token.begin() != token.end()) {
13     if (boost::size(token) > 3) {
14       std::cout << token << '\n';
15     }
16 
17     auto remnant = boost::make_iterator_range(token.end(), 
18                                             str.end());
19     token = boost::find_token(remnant, boost::is_xdigit(),
20                             boost::token_compress_on);
21   }
22 }
```

字符串`str`包含一个有趣的十六进制标记(`0xbeeffed`)。 我们将`str`传递给`boost::find_token`以及谓词`boost::is_xdigit`的一个实例，该实例标识有效的十六进制数字(第 10 行)。 我们使用`boost::token_compress_on`指示应该连接连续的匹配字符(第 11 行)；默认情况下，这个选项是关闭的。 返回的范围`token`表示当前匹配的子字符串。 只要返回的范围`token`不为空，即`token.begin() != token.end()`(第 12 行)，我们就会循环，如果长度大于 3，则打印其内容(第 13 行)。 请注意函数`boost::size`在`token`上的使用。 这是可用于计算范围的属性(如开始迭代器和结束迭代器、大小等)的几个函数之一。 另外，请注意，我们可以将 Range 对象(如令牌)直接流到`ostream`对象(如`std::cout`)，以打印范围内的所有字符(第 14 行)。

在每次迭代中，我们使用`find_token`搜索匹配后的剩余字符串。 剩余的字符串被构造为称为`remnant`的范围(第 17-18 行)。 `remnant`的开头是`token.end()`，它是最后一个匹配令牌之后的第一个位置。 残差的末端就是字符串的末端`str.end()`。

#### ITER_FIND

迭代字符串并找到与某个条件匹配的所有子字符串是非常常见的用例，而 Boost 提供了一种更简单的方法来实现这一点。 通过使用`boost::iter_find`算法，向其传递输入字符串、查找函数和保存匹配范围的序列容器，我们可以在传递的容器中返回匹配子字符串。 以下是使用`boost::iter_find`重写的上述示例：

**清单 4.11：结合使用 Boost：：ITER_FIND 和 Boost：：Token_Finder**

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <iostream>
 4 #include <vector>
 5 #include <iterator>
 6 #include <algorithm>
 7
 8 struct MinLen
 9 {
10   bool operator()(const std::string& s) const 
11   { return s.size() > 3; }
12 };
13 
14 int main() {
15   std::string str = "The application tried to read from an "
16                     "invalid address at 0xbeeffed";
17 
18   std::vector<std::string> v;
19   auto ret = boost::iter_find(v, str, 
20                      boost::token_finder(boost::is_xdigit(), 
21                                   boost::token_compress_on));
22 
23   std::ostream_iterator<std::string> osit(std::cout, ", ");
24   std::copy_if(v.begin(), v.end(), osit, MinLen());
25 }
```

`boost::find_regex`算法可以在字符串中搜索与正则表达式模式匹配的子字符串。 在本章后面的部分，我们将在使用 Boost.Regex 处理正则表达式时介绍此算法。

#### 查找

存在一种通用的`boost::find`算法，根据该算法实现大多数其他查找算法。 使用可用的查找器-函数器模板，作为字符串算法库的一部分，或者编写我们自己的模板，我们可以使通用的`boost::find`字符串算法为我们执行各种搜索任务。 下面是使用`boost::last_finder`函数器和`boost::find`算法查找最后一个匹配子字符串的示例--这正是`boost::ifind_last`所做的事情。 `boost::last_finder`函数器和其他类似函数接受一个可选谓词，可用于影响字符比较的方式。 要模拟`ifind_last`执行的不区分大小写的比较，我们需要传递一个谓词，该谓词以不区分大小写的方式比较两个字符。 为此，我们使用`boost::is_iequal`谓词：

```cpp
  1 std::string haystack = "How little is too little";
  2 std::string needle = "Little";
  3 
 4 auto ret = boost::find(haystack,
 5                       boost::last_finder(needle,
 6                                   boost::is_iequal()));

```

我们调用`haystack`上的`boost::find`，并将其传递给`boost::last_finder`函数器。 因为我们希望`last_finder`执行不区分大小写的比较，所以我们向它传递一个`boost::is_iequal`谓词的实例。 这与`boost::ifind_last`类似，本质上也是它的实现方式。 您甚至可以传递自己的谓词进行字符比较。 假设您收到一条编码消息，其中每个字符都被移位 4，并且它绕回，因此`a`是`e`，`z`是`d`。 您可以在以下代码中使用`equalsShift`函数来检查编码文本中是否存在特定的实词：

**清单 4.12：结合使用定制谓词和 Boost 子串查找器**

```cpp
 1 struct EqualsShift {
 2   EqualsShift(unsigned int n) : shift(n) {}
 3 
 4   bool operator()(char input, char search) const
 5   {
 6     int disp = tolower(input) - 'a' - shift;
 7     return tolower(search) == (disp >= 0)?'a':'z' + disp;
 8   }
 9 
10 private:
11   unsigned long shift;
12 };
13
14 // encoded ... How little is too little
15 std::string encoded = "Lsa pmxxpi mw xss pmxxpi";
16 std::string realWord = "little";
17 auto ret = boost::find(encoded,
18                        boost::first_finder(realWord,
19                                           EqualsShift(4)));

```

在不对变量`encoded`中包含的整个字符串进行解码的情况下，我们希望找到`encoded`的子字符串，该子字符串在解码时将与变量`realWord`中包含的字符串相匹配。 为此，我们使用两个参数调用`boost::find`，一个名为`encoded`的编码输入字符串和一个仅在找到匹配子字符串时返回`true`的谓词(第 17-19 行)。

对于谓词，我们构造了一个类型为`boost::first_finder`的临时类，将两个参数传递给它的构造函数：要查找的单词是`realWord`和二元谓词`EqualShift(4)`。 `EqualsShift`函数器对两个字符执行不区分大小写的比较：一个来自编码输入，另一个来自要查找的单词。 如前所述，如果第一个字符是第二个字符的编码，则根据固定整数 N 移位的方案返回 TRUE(在我们的例子中，N=4)。

#### Find_Head 和 Find_Tail

还有一些*查找*算法，如`boost::find_head`和`boost::find_tail`，它们很可能被命名为`prefix`和`suffix`，因为这正是它们所做的-从字符串中划出指定长度的前缀或后缀：

```cpp
1 std::string run = "Run Forrest run";
2 assert( boost::find_head(run, 3) == "Run");
3 assert( boost::find_head(run, -3) == "Run Forrest ");
4 assert( boost::find_tail(run, 3) == "run");
5 assert( boost::find_ tail(run, -3) == " Forrest run");

```

使用输入字符串和偏移量调用`find_head`。 如果偏移量为正数`N`，则`find_head`返回输入字符串中的前`N`个字符，如果`N`大于字符串的大小，则返回整个字符串。 如果偏移量为负数`-N`，则`find_head`返回前`size - N`个字符，其中`size`表示字符串`run`中的字符总数。

您可以使用一个字符串和一个整数调用`find_tail`。 当传递正整数`N`时，`find_tail`返回输入字符串的最后`N`个字符，如果`N`大于字符串的大小，则返回整个字符串。 当传递负整数`-N`时，`find_tail`返回字符串中的最后`size - N`个字符，其中`size`表示字符串中的字符总数，如果`N > size`，则返回空字符串。

#### 测试字符串属性的其他算法

有几个方便的函数，它们使得某些常见的操作非常容易编码。 像`boost::starts_with`和`boost::ends_with`(及其不区分大小写的变体)这样的算法会测试一个特定字符串是另一个字符串的前缀还是后缀。 要确定两个字符串的字典顺序，可以使用`boost::lexicographical_compare`。 您可以使用`boost::equals`检查是否相等，并使用`boost::contains`检查一个字符串是否是另一个字符串的子字符串。 每个函数都有相应的不区分大小写的变体，并且区分大小写的变体采用可选的谓词来比较字符。 Boost 在线文档充分详细地列出了这些功能及其行为。

### 大小写转换和裁剪算法

更改字符串的大小写或其某个部分以及修剪字符串前面或后面的额外空格是非常常见的任务，仅使用标准库就需要花费一些精力来完成这些任务。 我们已经看到用于执行大小写更改的`boost::to_upper`、`boost::to_lower`及其复制版本。 在这一节中，我们将把这些算法应用到更有趣的范围内，并看看修剪算法。

#### 大小写转换算法

如何将字符串中的备用字符转换为大写，其余字符保持不变？ 由于`boost::to_upper`函数接受范围，我们需要以某种方式从字符串生成包含替代元素的范围。 实现这一点的方法是使用**量程适配器**。 Boost 射程库提供了许多适配器，这些适配器允许从个现有范围模式生成个较新的范围模式。 我们正在寻找的适配器是`strided`适配器，它允许通过在每个步骤跳过固定数量的元素来遍历范围。 我们每一步只需要跳过一个元素：

**清单 4.13：使用 Boost.Range Adaptors**生成非连续范围

```cpp
 1 #include <boost/range.hpp>
 2 #include <boost/range/adaptors.hpp>
 3 #include <string>
 4 #include <iostream>
 5 #include <boost/algorithm/string.hpp>
 6 #include <cassert>
 7
 8 int main()
 9 {
10   std::string str = "funny text";
11   auto range = str | boost::adaptors::strided(2);
12   boost::to_upper(range);
13   assert(str == "FuNnY TeXt");
14 }
```

为了将`boost::to_upper`算法应用于偶数索引字符，我们首先生成正确的范围。 管道操作符(`operator |`)被重载，以创建适配器的直观链接语法，如`strided`。 使用表达式`str | strided(2)`，我们实质上是将参数为`2`的`strided`适配器应用于字符串`str`，以获得包含`str`的偶数索引元素的范围(第 11 行)。 请注意，`strided`适配器始终从输入的第一个字符开始。

同样的效果也可以通过以下方式实现：

```cpp
auto range = boost::adaptors::stride(str, 2);
```

我更喜欢管道表示法，因为它看起来更有表现力，特别是当需要链接更多适配器时。 在生成此`range`之后，我们对其应用`to_upper`(第 12 行)，预计会将`str`的偶数索引字符转换为大写(第 13 行)。

如果我们想对所有奇怪的索引执行相同的操作，那么我们需要解决一个问题。 `strided`适配器将在两个元素之间跳过的数字作为参数，但始终从输入的第一个字符开始。 要从索引为 1 而不是 0 的元素开始，我们必须从要开始的元素(本例中为索引 1)开始取一片容器，然后应用参数为`2`的`strided`。

为了首先获取片，我们使用另一个称为`boost::adaptors::sliced`的适配器。 它将起始位置的索引和结束位置之后的索引作为参数。 在本例中，我们希望从索引 1 开始，然后对容器的其余部分进行切片。 因此，我们可以这样编写整个表达式：

```cpp
auto range = str | boost::adaptors::sliced(1, str.size() – 1)| boost::adaptors::strided(2);
```

以这种方式链接适配器是使用非常易读的语法动态生成范围的一种强大方式。 同样的技术也适用于 C 样式的字符数组。

#### 修剪算法

对于修剪字符串，有三种主要算法：`boost::trim_left`修剪字符串中的前导空格，`boost::trim_right`修剪字符串中的尾随空格，`boost::trim`修剪两者。 修剪算法可能会更改输出的长度。 每个算法都有一个接受谓词的`_if`变体，该谓词用于标识要修剪的字符。 例如，如果您想从从控制台读取的字符串中只删除尾随的换行符(这是一项常见的琐事)，您可以编写一个适当的谓词来仅标识换行符。 最后，还有所有这些算法的副本变体。 如果我们编写一个可用算法的扩展列表，将有 12 个；`trim_left`有 4 个：`trim_left`、`trim_left_copy`、`trim_left_if`和`trim_left_if_copy`；类似地，`trim_right`和`trim`各有 4 个。 以下是对字符串执行修剪的示例：

**清单 4.14：使用 Boost：：Trim 及其变体**

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <iostream>
 4 #include <cassert>
 5 
 6 bool isNewline(char c) {
 7   return c == '\n';
 8 }
 9 
10 int main()
11 {
12   std::string input = "  Hello  ";
13   std::string input2 = "Hello   \n";
14   
15   boost::trim(input);
16   boost::trim_right_if(input2, isNewline);
17 
18   assert(*(input.end() - 1) != ' ');
19   assert(*(input2.end() - 1) != '\n' && 
20          *(input2.end() - 1) == ' ');
21 }
```

在清单 4.14 中，我们有两个字符串：`input`带有前导空格和尾随空格(第 12 行)，`input2`带有个尾随空格，在末尾有一个换行符(第 13 行)。 通过在`input`上应用`boost::trim`，前导空格和尾随空格被修剪(第 15 行)。 如果我们在`input2`上应用了`boost::trim_right`，它将删除所有尾随的空格，包括空格和换行符。 我们只想删除换行符，而不是空格；因此我们编写了一个谓词`isNewline`来帮助选择需要删减的内容。 此技术也可用于非空格字符。

这些函数不适用于 C 样式的数组，非复制版本需要名为`erase`的成员函数。 它们使用标准库中的`basic_string`专门化，以及提供具有相似接口和语义的`erase`成员函数的其他类。

### 替换和擦除算法

替换和擦除算法是对字符串执行搜索和替换操作的便捷函数。 基本思想是查找搜索字符串的一个或多个匹配项，并用不同的字符串替换这些匹配项。 当我们用空字符串替换匹配项时，擦除是替换的一种特殊情况。

当就地执行时，这些操作可能会改变输入的长度，因为匹配的内容及其替换可能具有不同的长度。 库中的核心算法是`boost::find_format`，所有其他算法都是根据它来实现的。 算法`boost::replace_first`、`boost::replace_last`、`boost::replace_nth`和`boost::replace_all`分别用替换字符串替换输入中搜索字符串的第一个、最后一个、第 n 个或所有匹配的匹配项。 相应的擦除算法简单地擦除匹配的区段。 这些算法不适用于 C 样式的数组：

**清单 4.15：使用 Boost：：Replace 和 Boost：：Erase 变体**

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <iostream>
 4 #include <cassert>
 5 
 6 int main()
 7 {
 8   std::string input = "Hello, World! Hello folks!";
 9   boost::replace_first(input, "Hello", "Hola");
10   assert(input == "Hola, World! Hello folks!");
11   boost::erase_first(input, "Hello");
12   assert(input == "Hola, World!  folks!");
13 }
```

在清单 4.15 中，我们首先使用`boost::replace_first`算法将字符串`"Hello"`的第一个实例替换为`"Hola"`(第 9 行)。 如果我们使用`boost::replace_all`，`"Hello"`的两个实例都将被替换，我们将得到`"Hola, World! Hola folks!"`。 然后，我们调用`boost::erase_first`来删除字符串中剩余的`"Hello"`(第 11 行)。 这些算法中的每一个都有一个不区分大小写的变体，它以不区分大小写的方式匹配。 不出所料，它们使用`i-`前缀命名：`ireplace_first`、`ierase_first`，依此类推。

每个算法也有一个`_copy`变体，返回一个新字符串，而不是原地更改。 下面是一个简短的插图：

```cpp
std::string input = "Hello, World! Hello folks!";
auto output = boost::ireplace_last_copy(input, "hello", "Hola");
assert(input == "Hello, World! Hello folks!"); // input unchanged
assert(output == "Hello, World! Hola folks!"); // copy changed
```

请注意`boost::ireplace_last_copy`变量在这里是如何工作的，它以不区分大小写的方式匹配`"hello"`，并在输入的副本中执行替换。

可以使用`boost::replace_head`或`boost::replace_tail`(及其擦除变体)替换或擦除字符串的前缀或后缀。 `boost::replace_regex`和`boost::replace_regex_all`算法接受用于查找匹配的正则表达式，并将其替换为替换字符串。 替换字符串可能包含一种特殊语法来引用匹配字符串的各个部分，详细信息将推迟到本章后面关于 Boost.Regex 的部分。

### 拆分和连接算法

Boost 提供了一种名为`boost::split`的算法，该算法主要用于根据某些分隔符将输入字符串拆分成记号。 向该算法传递一个输入字符串、一个用于标识分隔符的谓词和一个用于存储解析的令牌的序列容器。 下面是一个例子：

**清单 4.16：使用 Boost：：Split**在简单标记上拆分字符串

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <iostream>
 4 #include <vector>
 5 #include <cassert>
 6
 7 int main()
 8 {
 9   std::string dogtypes = "mongrel, puppy, whelp, hound";
10   std::vector<std::string> dogs;
11   boost::split(dogs, dogtypes, boost::is_any_of(" ,"),
12                boost::token_compress_on);
13   
14   assert(dogs.size() == 4);
15   assert(dogs[0] == "mongrel" && dogs[1] == "puppy" &&
16          dogs[2] == "whelp" && dogs[3] == "hound");
17 }
```

清单 4.16 将列出出现在逗号和空格分隔的字符串`dogtypes`中的四种狗(第 9 行)。 它使用`boost::split`算法来执行此操作。 使用谓词`boost::is_any_of(" ,")`将`dogtypes`字符串标记化，该谓词将任何空格或逗号标识为分隔符(第 11 行)。`boost::token_compress_on`选项确保`boost::split`算法不会为每对相邻的分隔符字符返回空字符串，而是将它们组合在一起，将其视为单个分隔符(第 12 行)。 如果我们想要在任何标点符号处拆分字符串，我们将使用`boost::is_punct()`而不是`boost::is_any_of(…)`。 然而，这是一种有点僵化的标记化方案，只有一组有限的谓词可用。

如果您只是想使用另一个字符串作为分隔符来拆分一个字符串，则可以改用`boost::iter_split`：

**清单 4.17：使用 Boost：：ITER_SPLIT 来标记化字符串**

```cpp
 1 #include <boost/algorithm/string.hpp>
 2 #include <string>
 3 #include <iostream>
 4 #include <vector>
 5
 6 int main()
 7 {
 8   std::string dogtypes = 
 9                "mongrel and puppy and whelp and hound";
10   std::vector<std::string> dogs;
11   boost::iter_split(dogs, dogtypes, 
12                     boost::first_finder(" and "));
13   assert(dogs.size() == 4);
14   assert(dogs[0] == "mongrel" && dogs[1] == "puppy" &&
15          dogs[2] == "whelp" && dogs[3] == "hound");
16 }
```

`boost::split`和`boost::iter_split`之间的主要区别在于，在后者中，您使用查找器来标识分隔符，因此分隔符可以是特定的字符串。 `boost::iter_split`和`boost::iter_find`都接受相同类型的参数，并使用查找器搜索匹配子字符串，但是`boost::iter_split`返回位于两个匹配子字符串之间的标记，而它的补码`boost::iter_find`返回匹配子字符串。

最后，当您尝试在连续值之间使用分隔符将一系列值串在一起时，`boost::join`和`boost::join_if`算法非常有用。 当`boost::join`连接序列中的所有值时，`boost::join_if`只连接序列中满足传递的谓词的那些值。 下面是`boost::join`的实际操作，它接受一个字符串向量和一个分隔符，并返回连接的字符串：

```cpp
std::vector<std::string> vec{"mongrel", "puppy", "whelp", "hound"};
std::string joined = boost::join(vec, ", ");
assert(joined == "mongrel, puppy, whelp, hound");
```

在前面的示例中，我们看到另一个有用的 C++ 11 特性正在运行：统一初始化。 我们用用大括号括起来并用逗号分隔的四个字符串序列初始化向量`vec`。 此初始化语法适用于所有 STL 容器，并可用于具有特定构造函数类型的常规类。 现在，如果我们要挑选哪些字符串是串联的，哪些不是，我们将使用`boost::join_if`如下所示：

```cpp
bool fiveOrLessChars(const std::string& s) { return s.size() <= 5; }

std::vector<std::string> vec{"mongrel", "puppy", "whelp", "hound"};
std::string joined = boost::join_if(vec, ", ", fiveOrLessChars);
assert(joined == "puppy, whelp, hound");
```

`fiveOrLessChars`谓词检查传递给它的字符串的长度是否小于等于 5。 因此，字符串`"mongrel"`没有出现在连接的字符串中，因为它的长度大于 5。

# 使用 Boost Tokenizer 库拆分文本

我们在上一节中看到的`boost::split`算法使用谓词拆分字符串，并将标记放入序列容器中。 它需要额外的存储来存储所有令牌，并且用户对使用的令牌化标准的选择有限。 根据各种条件将字符串拆分成一系列令牌是一种常见的编程要求，Boost.Tokenizer 库提供了一个可扩展框架来实现这一点。 此外，这不需要额外的存储来存储令牌。 它提供了从字符串中检索连续令牌的通用接口。 将字符串分割为连续标记的标准作为参数传递。 Tokenizer 库本身为拆分提供了一些可重用的、常用的令牌化策略，但最重要的是，它定义了一个接口，我们可以使用该接口编写自己的拆分策略。 它将输入字符串视为可从中解析出后续令牌的令牌容器。

## 基于分隔符的标记化

从开始，让我们看看如何将字符串拆分成其构成词：

**清单 4.19：使用 Boost Tokenizer 将字符串标记化为单词**

```cpp
 1 #include <iostream>
 2 #include <boost/tokenizer.hpp>
 3 #include <string>
 4 
 5 int main()
 6 {
 7   std::string input = 
 8         "God knows, I've never been a spiritual man!";
 9 
10   boost::tokenizer<> tokenizer(input);
11
12   for (boost::tokenizer<>::iterator token = tokenizer.begin();
13         token != tokenizer.end(); ++ token) {
14     std::cout << *token << '\n';
15   }
16 }
```

`boost::tokenizer`类模板抽象了标记化过程。 我们创建`boost::tokenizer`的默认专门化的一个实例，向其传递我们的输入字符串`input`(第 10 行)。 接下来，使用`boost::tokenizer`的迭代器接口，我们将`input`拆分成连续的标记(第 12-14 行)。 通常，您可以通过传递适当的标记化策略来自定义字符串的拆分方式。 因为我们没有显式地传递给`boost::tokenizer`模板，所以默认的标记化策略使用空格和标点符号作为标记分隔符或分隔符来拆分字符串。 前面的代码将把以下输出打印到标准输出：

```cpp
God
knows
I
ve
never
been
a
spiritual
man
```

因此，它不仅可以拆分空格，还可以拆分逗号和撇号；由于撇号的作用，`"I've"`被拆分为`"I"`和`"ve"`。

如果我们想要根据空格和标点符号拆分输入，而不是用撇号拆分，我们需要做更多的工作。 Boost 为常用的拆分策略提供了一些可重用的模板。 `boost::char_delimiter`模板使用指定的字符作为分隔符来拆分字符串。 以下是代码：

**清单 4.20：将 Boost Tokenizer 与 Boost：：Char_Separator**配合使用

```cpp
 1 #include <boost/tokenizer.hpp>
 2 #include <string>
 3 #include <iostream>
 4
 5 int main()
 6 {
 7   std::string input = 
 8                "God knows, I've never been a spiritual man!";
 9
10   boost::char_separator<char> sep(" \t,.!?;./\"(){}[]<>");
11   typedef boost::tokenizer<boost::char_separator<char> > 
12                                                  tokenizer;
13   tokenizer mytokenizer(input, sep);
14   for (auto& token: mytokenizer) 
16   {
17     std::cout << token << '\n';
18   }
19 }
```

在本例中，我们首先使用`boost::char_separator`模板构造拆分策略`sep`(第 10 行)。 由于我们要拆分字符类型为`char`的`std::string`类型的文本，因此必须将`char`作为参数传递给`boost::char_separator`，以指定分隔符的类型为`char`。 我们也可以写`boost::char_separator<std::string::value_type>`而不是`boost::char_separator<char>`来更好地表达这种关系。 我们构造要用作分隔符的标点符号和空格字符列表，并将其作为`sep`的构造函数参数传递。 最后，我们构造记号器，向其传递输入字符串`input`和拆分策略`sep`。 我们使用基于范围的 for 循环遍历连续的令牌，与使用令牌迭代器相比，这减少了代码的冗长。

## 使用包含元字符的字段标记记录

`boost::char_delimiter`策略不是唯一可用的拆分策略。 考虑一种逗号分隔的数据格式，如以下输出所示：

```cpp
Joe Reed,45,Bristol UK
Ophir Leibovitch,28,Netanya Israel
Raghav Moorthy,31,Mysore India
```

我们每行有条记录，每条记录有三个字段：姓名、年龄和居住城市。 我们可以使用`boost::char_separator`策略解析这样的记录，并将逗号作为分隔符传递给它。 现在，如果我们想让格式更丰富一些，我们可能会包括人们的完整地址，而不是他们当前所在的城市。 但地址是较长的字段，有时会嵌入逗号，这样的地址会破坏基于逗号作为分隔符的解析。 因此，我们决定引用可能包含逗号的字符串：

```cpp
Joe Reed,45,"33 Victoria St., Bristol UK"
Ophir Leibovitch,28,"19 Smilanski Street, Netanya, Israel"
Raghav Moorthy,31,"156A Railway Gate Road, Mysore India"
```

引用本身可能还不够。 某些地址可能带有引号字符串，我们希望保留这些字符串。 为了解决这个问题，我们决定使用反斜杠(`\`)作为转义字符。 以下是地址中带有引号字符串的第四条记录：

```cpp
Amit Gupta,70,"\"Nandanvan\", Ghole Road, Pune, India"
```

现在的问题是不能再使用`boost::char_separator`策略解析前面的记录。 对于这样的记录，我们应该改用`boost::escaped_list_char`。 `boost::escaped_list_char`保单就是为这种用途量身定做的。 默认情况下，它使用逗号(，)作为字段分隔符，双引号(“)作为引号字符，反斜杠(\)作为转义字符。要在字段中包括逗号，请将字段引起来。要在字段中包括引号，请转义嵌入的引号。我们现在可以尝试分析四个人的记录中最复杂的记录，如前所述：

**清单 4.21：将 Boost：：tokenizer 与 Boost：：ESCRIFE_LIST_SEIATOR**配合使用

```cpp
 1 #include <iostream>
 2 #include <boost/tokenizer.hpp>
 3 #include <string>
 4
 5 int main()
 6 {
 7   std::string input = "Amit Gupta,70,\"\\\"Nandanvan\\\", "
 8                       "Ghole Road, Pune, India\"";
 9
10   typedef boost::tokenizer<boost::escaped_list_separator<char> > 
11                                           tokenizer;
12   tokenizer mytokenizer(input);
13  
14   for (auto& tok: mytokenizer) 
15   {
16     std::cout << tok << '\n';
17   }
18 }
```

使用 tyecif 创建`boost::tokenizer<boost::escaped_list_separator<char> >`的实例(第 12 行)(第 10-11 行)。 对于这种新的格式，这真的是唯一需要处理的操作更改。 硬编码在变量`input`中的记录需要一些额外的转义级别才能转换为有效的 C++ 字符串文字(第 7-8 行)。

如果记录有一组不同的元字符，比如连字符(-)用于字段分隔符，正斜杠(/)用于引号，波浪号(~)用于转义，我们将需要显式指定这些字符，因为`boost::escaped_list_separator<<char> >`的默认选项将不再起作用。 想想一个叫阿隆·本-阿里(Alon Ben-Ari)的人，35 岁，住在特拉维夫扎门霍夫街 11/5 号。 使用指定的引号、字段分隔符和转义字符，可以表示为：

```cpp
/Alon Ben-Ari/-35-11~/5 Zamenhoff St., Tel Aviv
```

名称字段在姓氏 Ben-Ari 中有连字符。 由于连字符也是字段分隔符，因此名称字段必须使用正斜杠引起来。 地址字段有一个正斜杠，由于正斜杠是引号字符，因此地址字段必须使用转义字符(~)进行转义。 现在轮到我们将其标记化了：

**清单 4.22：使用带有时髦分隔符的 Boost：：ESCRIFE_LIST_SEIPATOR**

```cpp
 1 #include <iostream>
 2 #include <boost/tokenizer.hpp>
 3 #include <string>
 4
 5 int main()
 6 {
 7   std::string input = 
 8        "/Alon Ben-Ari/-35-11~/5 Zamenhoff St., Tel Aviv";
 9
10   typedef boost::tokenizer<boost::escaped_list_separator<char> > 
11                                               tokenizer;
12   boost::escaped_list_separator<char> sep('~', '-', '/');
13   tokenizer mytokenizer(input, sep);
14  
15   for (auto& tok: mytokenizer) {
16     std::cout << tok << '\n';
17   }
18 }
```

以下是输出：

```cpp
Alon Ben-Ari
35
11/5 Zamenhoff Str., Tel Aviv
```

## 使用固定长度字段标记化记录

在金融交易和其他几个域中频繁出现的一类数据格式由固定偏移量的记录组成。 请考虑以下表示付款指示的记录格式：

```cpp
201408091403290000001881303614419ABNANL2AWSSDEUTDEMM720000000412000EUR…
```

在这里，记录几乎不是人类可读的，并且仅供程序使用。 它具有固定偏移量的字段，其含义必须由解析程序知道。 各个字段如下所述：

```cpp
Offset 0, length 8: date of record in YYYYMMDD format.
Offset 8, length 9: time of record in HHMMSSmmm format where mmm represents milliseconds.
Offset 17, length 16: the transaction identifier for the transaction, numeric format.
Offset 33, length 11: the Swift Bank Identifier Code for the bank from which money is transferred.
Offset 44, length 11: the Swift Bank Identifier Code for the bank to which money is transferred.
Offset 55, length 12: the transaction amount.
Offset 67, length 3: the ISO code for the currency of transaction.
```

为了解析这样的记录，我们使用`boost::offset_separator`分割策略。 这个类(请注意，它不是模板)需要以一对迭代器的形式解析连续标记的长度，限定长度序列。

解析前面的支付指令的代码示例应该有助于说明这一想法：

**清单 4.23：使用固定长度字段标记记录**

```cpp
 1 #include <boost/tokenizer.hpp>
 2 #include <string>
 3 #include <iostream>
 4 
 5 int main()
 6 {
 7   std::string input =  
 8      "201408091403290000001881303614419ABNANL2AWSSDEUTDEMM72"
 9      "0000000412000EUR";
10   int lengths[] = {8, 9, 16, 11, 11, 12, 13};
11 
12   boost::offset_separator ofs(lengths, lengths + 7);
13   typedef boost::tokenizer<boost::offset_separator> tokenizer;
14   tokenizer mytokenizer(input, ofs);
15   
16   for (auto& token: mytokenizer) {
17     std::cout << token << '\n';
18   }
19 }
```

我们首先定义一个包含连续字段长度的数组(第 10 行)，并使用它初始化类型为`boost::offset_separator`的对象`ofs`(第 12 行)。 我们也可以使用向量而不是数组，并将其`begin()`和`end()`迭代器传递给`offset_separator`构造函数。 然后，我们创建一个记号器，它根据`ofs`中指定的偏移量对字符串进行记号(第 13-14 行)，并使用基于范围的 for 循环打印连续的记号(第 16-18 行)。

此程序生成以下输出：

```cpp
20140809
140329000
0001881303614419
ABNANL2AWSS
DEUTDEMM720
000000412000
EUR
```

我们看到在连续的行上列出了日期、时间、ID、发送方 SWIFT 银行代码(发送方银行的标识符)、接收方 SWIFT 银行代码、金额和交易币种的值。

现在，如果所有字段都已解析，但仍有一些输入，会发生什么情况呢？ 默认行为是重新开始解析剩余的文本，并从开头开始对其应用长度偏移量。 这可能对某些格式有意义，但对某些格式可能没有意义。 如果要关闭此行为，以便在使用完所有长度偏移量后停止解析，则应将第三个参数传递给`boost::offset_separator`的构造函数，其值应为`false`，如下所示：

```cpp
boost::offset_separator ofs(lengths, lengths + nfields, 
 false);

```

这里，`lengths`是长度偏移量数组，`nfields`是我们期望解析的字段数。

相反，如果输入的长度小于长度的总和，会发生什么情况？ 默认行为是返回最后一个部分解析的字段并停止。 假设您有一种格式，付款人的备注被附加到每个交易记录中。 注释是可选的，不需要出现在那里。 如果它在那里，它可能有最大大小限制，也可能没有最大大小限制。 第一种行为可以用于解析最后一个注释字段，方法是指定最大大小，或者指定一个您不希望注释达到的任意大小，从而利用最后一个记录的部分解析。 同样，如果要关闭此行为，以便遇到的第一个分部字段停止解析，则应将类型为`bool`的第四个参数传递给`boost::offset_separator`构造函数，其值应为`false`：

```cpp
boost::offset_separator ofs(lengths, lengths + nfields, restart,
 false);

```

## 编写您自己的记号赋值函数

在很多情况下，您需要根据在中不可用的条件来解析字符串，Boost 中的可重用类或模板。 虽然您可以使用其他库(如`boost::split`)，但是也可以通过插入自定义的**令牌生成器**来使用`boost::tokenizer`工具。 令牌生成器类封装令牌化策略，并作为模板参数传递给`boost::tokenizer`。

令牌生成器可以定义为符合以下要求的函数器：

*   是可复制分配的。
*   是可复制构造的。
*   Has an overloaded public function call operator (`operator()`) with the following signature:

    ```cpp
    template <typename InputIterator, typename StringType>bool operator()(InputIterator& next,InputIterator end,StringType& token)
    ```

    向该运算符传递两个迭代器，这两个迭代器定义字符串的一部分，它在其中查找传递的下一个令牌。 当且仅当找到新令牌时，它才返回 TRUE。 在这种情况下，它将其第三个参数设置为令牌，并将其第一个参数设置为令牌结尾后字符串中的第一个位置，从该位置可以继续解析。 如果未找到令牌，则返回 False。 我们必须编写逻辑来标识此函数中的连续令牌。

*   具有公共成员函数`void reset()`。 这可用于清除用于保持字符串解析状态的任何成员变量。 然后，可以使用该对象的同一实例来解析多个输入。

这些函数由`boost::tokenizer`实现调用，而不是由程序员直接调用。

现在，我们编写一个令牌生成器类，从一些文本中挑选带引号或括号的字符串。 例如，给定字符串`"I'm taking a train from Frankfurt (am Main) to Frankfurt (an der Oder)"`，我们希望选择标记`"am Main"`和`"an der Oder"`。 为了简化我们的实现，给定带有嵌套括号或引号的字符串，只需要检索最里面引号的内容。 因此，给定字符串`"tokenizer<char_separator<char> >"`，它应该返回最里面的方括号实体`"char"`。 下面是这样一个名为`qstring_token_generator`的类的代码：

**清单 4.24a：qstring_TOKEN_GENERATOR 接口**

```cpp
 1 class qstring_token_generator
 2 {
 3 public:
 4   typedef std::string::const_iterator iterator;
 5
 6   qstring_token_generator(char open_q = '"',
 7              char close_q = '"', char esc_c = '\\',
 8              bool skip_empty = true);
 9 
10   bool operator() (iterator& next, iterator end,
11                    std::string& token);
12 
13   void reset();
14
15 private:
16   // helper functions to be defined
17
18   char start_marker;
19   char end_marker;
20   char escape_char;
21   bool skip_empty_tokens;
22   bool in_token;
23   bool in_escape;
24 };
```

`qstring_token_generator`类有一个接受必要输入的构造函数：

*   开始和结束标记字符，默认情况下都是双引号(“)
*   转义字符，默认为反斜杠(\)
*   指示是否跳过空令牌的布尔值，缺省情况下为真(第 6-8 行)

定义用于存储这些值的相应私有变量(第 18-21 行)。 该类使用两个额外的状态变量来跟踪解析状态：`in_token`变量(第 22 行)，在解析引号内的内容时为 true，否则为 false；以及`in_escape`变量(第 23 行)，如果当前字符是转义序列的一部分，则为 true，否则为 false。 下面是构造函数的实现：

**清单 4.24b：qstring_TOKEN_GENERATOR 构造函数**

```cpp
 1   qstring_token_generator::qstring_token_generator
 2             (char open_q, char close_q, char esc_c,
 3              bool skip_empty) : 
 4      start_marker(open_q), end_marker(close_q), 
 5      escape_char(esc_c), skip_empty_tokens(skip_empty),
 6      in_token(false), in_escape(false)
 7   {}
```

请注意，`in_token`和`in_escape`被初始化为 FALSE。 每次我们使用记号器接口迭代输入中连续的记号时，记号器实现都会调用记号生成器来再次解析输入。 要重新开始解析，必须重置任何内部解析状态。 `reset`函数封装了这些操作，并在创建新的令牌迭代器时由令牌化器调用。

以下是重置功能的实现：

**清单 4.24c：qstring_TOKEN_GENERATOR 重置函数**

```cpp
 1   void qstring_token_generator::reset()
 2   {
 3     in_token = false;
 4     in_escape = false;
 5   }
```

重置函数确保用于维护解析状态的内部变量被适当地重置，以便重新开始解析。

最后，在重载函数调用运算符成员(`operator()`)中实现解析算法。 为了解析字符串，我们寻找开始和结束标记来标识标记的开始和结束，并将计数转义的开始和结束标记作为标记的一部分，并处理开始标记和结束标记是相同字符的情况。 我们还处理引用的令牌嵌套的情况。 我们将根据`qstring_token_generator`类中的几个助手私有函数来编写算法。

**清单 4.24d：解析算法帮助器**

```cpp
 1 iterator qstring_token_generator::start_token(iterator& next)
 2 {
 3   in_token = true;
 4   return ++ next;
 5 }
 6
 7 std::string qstring_token_generator::end_token(iterator& next,
 8                                         iterator token_start) 
 9 {
10   in_token = false;
11   auto token_end = next++ ;
12   return std::string(token_start, token_end);
13 }
```

`start_token`函数是在我们每次标识新令牌的开始时调用的(第 1 行)。 它将`in_token`标志设置为 true，递增迭代器`next`，并返回其值。

`end_token`函数是在我们每次识别令牌结束时调用的(第 7 行)。 它将`in_token`标志设置为 false，递增迭代器`next`，并以字符串形式返回完整的令牌。

现在我们需要编写逻辑来识别令牌的开始和结束，并适当地调用前面的函数。 我们直接在重载的`operator()`中执行此操作：

**清单 4.24e：解析算法**

```cpp
 1 bool operator() (iterator& next, iterator end,
 2                  std::string& token)
 3 {
 4   iterator token_start;
 5
 6   while (next != end) {
 7     if (in_escape) {
 8       // unset in_escape after reading the next char
 9       in_escape = false;
10     } else if (*next == start_marker) { // found start marker
11       if (!in_token) { // potential new token
12         token_start = start_token(next);
13         continue;
14       } else { // already in a quoted string
15         if (start_marker == end_marker) {
16           // Found end_marker, is equal to start_marker
17           token = end_token(next, token_start);
18           if (!token.empty() || !skip_empty_tokens) {
19             return true;
20           }
21         } else {
22           // Multiple start markers without end marker.
23           // Discard previous start markers, consider
24           //  inner-most token only.
25           token_start = start_token(next);
26           continue;
27         }
28       }
29     } else if (*next == end_marker) {
30       // Found end_marker, is not equal to start_marker
31       if (in_token) {
32         token = end_token(next, token_start);
33         if (!token.empty() || !skip_empty_tokens) {
34           return true;
35         }
36       }
37     } else if (*next == escape_char) {
38       in_escape = !in_escape;  // toggle
39     }
40     ++ next;
41   }
42
43   return false;
44 }
```

我们使用 WHILE 循环遍历输入的连续字符(第 6 行)。 对于每个字符，我们检查其前面是转义字符(第 7 行)，还是开始标记(第 10 行)、结束标记(第 29 行)或转义字符(第 37 行)。

如果找到未转义的开始标记，并且我们还没有在解析令牌(第 11 行)，那么它可能代表新令牌的开始。 因此，我们调用`start_token`，记下令牌的起始位置，然后继续下一次迭代(第 12-13 行)。 但是，如果我们已经在解析令牌，并且找到了开始标记，那么有两种可能性。 如果开始标记和结束标记碰巧相同，则这表示令牌的结束(第 15 行)。 在本例中，我们调用`end_token`来获取完整的令牌并返回它，除非它为空并且设置了`skip_empty_tokens`(第 16-20 行)。 如果开始标记和结束标记不同，则第二个开始标记表示嵌套令牌。 因为我们只想提取嵌套最多的令牌，所以我们丢弃前一个令牌并调用`start_token`来指示我们有一个新令牌的开始(第 25-26 行)。

如果结束标记与开始标记不同，并且我们找到了它(第 29 行)，那么我们调用`end_token`生成并返回找到的完整令牌，除非它为空并且设置了`skip_empty_tokens`。 最后，如果找到转义字符，则设置`in_escape`标志(第 37-38 行)。

我们使用`qstring_token_generator`类来标记化输入字符串：

**清单 4.25：使用自定义记号赋值器**提取带括号的字符串

```cpp
 1  std::string input = "I'm taking a train from Frankfurt "
 2                    "(am Main) to Frankfurt (an der Oder)";
 3  bool skipEmpty = true;
 4  qstring_token_generator qsep('(', ')', '\\', skipEmpty);
 5  typedef boost::tokenizer<qstring_token_generator> qtokenizer;
 6  qtokenizer tokenizer(input, qsep);
 7
 8  unsigned int n = 0;
 9  for (auto& token: tokenizer) {
10    std::cout << ++ n << ':' << token << '\n';
11 }
```

前面突出显示的代码显示了代码中的关键更改。 我们定义了一个`qstring_token_generator`对象，该对象接受左引号和右引号字符(在本例中是左括号和右括号)，并跳过空标记(第 4 行)。 然后，我们为`boost::tokenizer<qstring_token_generator>`创建一个 tyecif(第 4 行)，创建一个该类型的记号器来解析输入(第 6 行)，并打印连续的记号(第 10 行)。

# 使用 Boost.Regex 的正则表达式

当我们编写类似于`boost::find_first("Where have all the flowers gone?", "flowers")`的代码行时，我们请求在更大的字符串`"Where have all the flowers gone?"`(称为**草堆**)中找到字符串`"flowers"`(称为**针**)。 针就是图案；七个特定的字符以特定的顺序出现，必须在干草堆中查找它们的存在。 然而，有时我们不知道我们正在寻找的确切字符串；我们脑海中只有一个抽象的概念或模式。 正则表达式是表达这种抽象模式的强大语言。

## 正则表达式语法

正则表达式是使用常规字符和一些具有特殊解释的字符(统称为*元字符*)的混合来编码文本模式的字符串。 Boost.Regex 库提供使用正则表达式字符串的函数，并生成搜索和验证符合特定模式的文本的逻辑。 例如，要定义模式“a 后跟零个或多个 b”，我们使用正则表达式`ab*`。 此模式将匹配文本，如`a`、`ab`、`abb`、`abbb`等。

### 原子

在非常基本的级别上，正则表达式由一个或多个称为**原子**的字符组组成，每个都有一个关联的**量词**，该量词尾随原子，也可以是**锚点**，它定义了某些文本如何相对于周围的文本定位。 量词可以是隐含的。 原子可以是单个字符(或转义的元字符)、**字符类**、字符串或**通配符**。 如果它是一个字符串，则必须用括号括起来，以表示它是一个原子。 通配符与任何字符(换行符除外)匹配，并使用点(.)。 元字符。

### 量词

没有尾随量词的单个原子只匹配个自身的单个匹配项。 出现时，尾随量词确定前一个原子允许的最小和最大出现次数。 一般量词看起来像`{m, M}`，其中`m`表示最小，`M`表示最大出现频率。 省略`{m,}`中的最大值表示原子可能存在的最大次数是无界的。 还可以使用单个数字作为`{n}`来匹配固定的个实例。 更常见的情况是，我们使用以下快捷量词：

*   `*`：相当于`{0,}`，称为**Kleene 星**。 表示可能不会出现或可能出现任意次数的原子。
*   `+`：等同于`{1,}`。 表示必须至少出现一次的原子。
*   `?`：等同于`{0,1}`。 表示可选原子。

使用上述语法规则，我们在下表中构建了汇总示例：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

正则表达式

 | 

原子

 | 

量词

 | 

等价量词

 | 

匹配文本

 |
| --- | --- | --- | --- | --- |
| （化学元素）钨 | 重量 / 广泛的 / 用 / 随着 | 无(隐式) | `{1}` | 重量 / 广泛的 / 用 / 随着 |
| A* | 在…之前 / 同 arrives | *** | `{0,}` | (白) , , 。 |
| (阿巴)+ | 阿爸父 / 神父 / 阿爸 | ++ | `{1,}` | 阿巴，… |
| A？B | a，b | ？ | `{0,1}` | B、AB |
| (ab){2，4} | [AB] | {2，4} | `{2,4}` | 阿巴布，阿巴布，阿巴布 |
| .*x | 。 和 x | *和无 | `{0,}`和`{1}` | X 和任何以 x 结尾的字符串 |

默认情况下，限定符是*贪婪的*，并且匹配尽可能多的字符。 因此，给定字符串`"abracadabra"`，正则表达式`"a.*a"`将匹配整个字符串，而不是更小的子字符串`"abra"`、`"abraca"`或`"abracada"`，它们也都以`'a'`开始和结束。 如果我们只想匹配最小的匹配子字符串，我们需要覆盖贪婪语义。 要做到这一点，我们打上问号(？)。 量词`"a.*?a"`后的元字符。

### 字符类

字符也可以与字符类进行匹配，后者是一组功能相关字符的简写表示。 以下是 Boost 库中预定义字符类的部分列表：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

字符类

 | 

缩写形式

 | 

意义 / 隐含意思 / 内涵 / 目

 | 

足数 / 补足物 / 补语 / 余角

 |
| --- | --- | --- | --- |
| [[：数字：]] | `\d` | 任意十进制数字(0-9) | \d |
| [[：空格：]] | `\s` | 任何空格字符 | \s |
| [[：单词：]] | `\w` | 任何单词字符：字母、数字和下划线 | \W |
| [[：下限：]] | `\l` | 任何小写字符 |   |
| [[：上部：]] | `\u` | 任何大写字符 |   |
| [[：点：]] | 毫不 / 绝不 | 任何标点符号 |   |

例如，`\d`是匹配单个十进制数字的字符类。 它的补码\`D`匹配任何单个字符，但十进制位除外。 `\s`匹配空格字符，`\S`匹配非空格字符。 即席字符类可以用方括号创建；`[aeiouAEIOU]`匹配任何英语元音字符，`[1-5]`匹配 1 到 5 之间的数字(包括 1 和 5)。 表达式`[^2-4]`匹配除 2、3 和 4 之外的任何字符，并且方括号内的前导插入符号具有否定其后面的字符的效果。 我们可以组合多个字符类，例如-[[：Digit：][：LOWER：]]-来指示小写字母和小数位的集合。

### 锚

某些元字符(称为**锚**)与字符不匹配，但可用于匹配文本中的特定位置。 例如，正则表达式(字符类之外)中的插入符号(`^`)与行首(紧跟在换行符之后)的文本匹配。 美元(`$`)匹配行尾之前的文本(恰好在换行符之前)。 此外，`\b`表示词边界，而`\B`匹配除词边界以外的任何位置。

### 子表达式

通常，字符串中的每个字符被解释为一个不同的原子。 为了将字符串视为单个原子，我们必须用圆括号将其括起来。 正则表达式的带圆括号的子字符串称为**子表达式**。 子表达式后面的量词适用于整个子表达式：

```cpp
([1-9][0-9]*)(\s+\w+)*
```

前面的表达式表示一个数字(`[1-9][0-9]*`)，后面跟着零个或多个单词(`\w+`)，它们之间由一个或多个空格字符(`\s+`)隔开。 由于括号的关系，第二个 Kleene 星号适用于整个子表达式`\s+\w+`。

正则表达式库(包括 Boost.Regex)跟踪与带括号的子表达式匹配的字符串的子字符串。 匹配的子表达式可以使用反向引用(如`\1`、`\2`、`\3`等)从正则表达式中反向引用。 例如，在前面的正则表达式中，术语`\1`匹配前导数字，而`\2`匹配带有前导空格的最后一个匹配词。 如果没有尾随单词，则不匹配任何内容。 子表达式可以嵌套，并从 1 开始按其左圆括号在字符串中从左到右的顺序递增编号。

如果希望使用子表达式将量词和锚点应用于字符组，但不需要捕获它们以供以后引用，则可以使用`(?:expr)`形式的**非捕捉子表达式**，其中圆括号内的前导元字符序列`?:`表示它是一个非捕获子表达式，而`expr`是某个有效的正则表达式。 这将把 expr 视为一个原子，但不会捕获它。 因此，在圆括号内没有前导`?:`的子表达式被称为**捕获组**或**捕获子表达式**。

### 析取

您可以创建一个正则表达式，它是一个或多个正则表达式的逻辑或。 为此，可以使用|**析取运算符**。 例如，要匹配混合包含小写和大写字符的单词，可以使用表达式`(\l|\u)+`。

可以使用析取运算符组合正则表达式并形成更复杂的表达式。 例如，要匹配包含大写或小写字符的单词或正整数，可以使用表达式`(\l|\u)+|\d+`。

## 使用 Boost.Regex 解析正则表达式

正则表达式是一个丰富的主题，我们在前面的段中仅仅触及了它的皮毛。 但是这个的基本熟悉程度足以让我们开始使用 Boost.Regex 库。 Boost.Regex 库是 C++ 11 标准中接受的库之一，现在是 C++ 11 标准库的一部分，不包括它处理 Unicode 字符的能力。

Boost 正则表达式库是*而不是*头的，并且需要链接到 Boost.Regex 共享库或静态库。 它可以从头文件`boost/regex.hpp`中获得。 在通过本机软件包管理器安装 Boost 库的 Linux 桌面上，我使用以下命令行构建 regex 程序：

```cpp
$ g++ source.cpp -o progname -lboost_regex

```

在从源安装 Boost 的 Linux 系统上，头文件可能位于非标准位置(如`/opt/boost/include`)和库(位于`/opt/boost/lib`下)。 在这样的系统上，我必须使用以下命令行来构建我的程序：

```cpp
$ g++ source.cpp -o progname -I/opt/boost/include -L/opt/boost/lib -lboost_regex-mt -Wl,-rpath,/opt/boost/lib

```

`-Wl`，`-rpath`，`/opt/boost/lib`指令告诉链接器硬编码加载个共享库(如`libboost_regex-mt`)的路径，并帮助我们的程序在没有额外设置的情况下运行。 在使用 Visual Studio 的 Windows 上，链接是自动的。

它使用`boost::basic_regex`模板为正则表达式建模，并为类型`char`提供其专门化 `boost::regex`，为类型`wchar_t`提供其专门化`boost::wregex`作为 typedefs。 使用这个库，我们可以检查字符串是否符合模式或包含符合模式的子串，提取符合模式的字符串的所有子字符串，将匹配模式的子串替换为另一个格式化的字符串，并根据匹配的表达式拆分字符串，以命名几个最常用的操作。

### 匹配文本

考虑字符串`"Alaska area"`。 我们希望将其与正则表达式`a.*a`进行匹配，以查看字符串是否符合模式。 为此，我们需要调用`boost::regex_match`函数，该函数返回布尔值 TRUE 以指示匹配成功，否则返回 FALSE。 下面是它的代码：

**清单 4.26：将字符串与正则表达式匹配**

```cpp
1 #include <boost/regex.hpp>
2 #include <string>
3 #include <cassert>
4 int main()
5 {
6   std::string str1 = "Alaska area";
7   boost::regex r1("a.*a");
8   assert(!boost::regex_match(str1, r1));
9 }
```

正则表达式`"a.*a"`封装在`boost::regex`的实例中。 当我们将字符串与此表达式进行匹配时，匹配将失败(第 8 行)，因为字符串以大写字母`'A'`开头，而正则表达式的开头应为小写字母`'a'`。 我们可以通过构造`boost::regex::icase`并将其作为标志传递给`boost::regex`构造函数来请求不区分大小写的正则表达式：

```cpp
7   boost::regex r1("a.*a", boost::regex::icase);
8   assert(boost::regex_match(str1.begin(), str1.end(), r1));
```

注意，我们调用了`boost::regex_match`的另一个重载，它将两个迭代器带到`std::string`(第 8 行)，只是为了说明另一个签名。 您还可以使用清单 4.25 所示的`const char*`或`std::string`调用`boost::regex_match`。 函数的结果与变量无关。

### 搜索文本

如果我们想要搜索与特定正则表达式匹配的字符串的子字符串，我们应该使用`boost::regex_search`函数而不是`boost::regex_match`。 考虑字符串`"An array of papers from the academia on Alaska area's fauna"`。 我们要查找此短语中属于同一单词的所有子字符串，并以`'a'`开始和结束。 要使用的正则表达式为`a\w*a`。 让我们看看如何使用`boost::regex_search`实现这一点：

**清单 4.27：搜索与正则表达式匹配的子字符串**

```cpp
 1 #include <boost/regex.hpp>
 2 #include <string>
 3 #include <iostream>
 4 
 5 int main() {
 6   std::string str2 = "An array of papers from the academia "
 7                      "on Alaska area's fauna";
 8   boost::regex r2("a\\w*a");
 9   boost::smatch matches;
10   std::string::const_iterator start = str2.begin(),
11                               end = str2.end();
12
13   while (boost::regex_search(start, end, matches, r2)) { 
14     std::cout << "Matched substring " << matches.str()
15            << " at offset " << matches[0].first - str2.begin()
16            << " of length " << matches[0].length() << '\n';
17     start = matches[0].second;
18   }
19 }
```

这将打印以下各行，每行都有一个以`'a'`开头和结尾的单词或单词的一部分：

```cpp
Matched substring arra at offset 3 of length 4.
Matched substring academia at offset 28 of length 8.
Matched substring aska at offset 42 of length 4.
Matched substring area at offset 47 of length 4.
Matched substring auna at offset 58 of length 4.
```

在代码示例中，我们构造了字符串(第 6 行)、正则表达式(第 8 行)和`boost::smatch`的实例(第 9 行)，这是输入类型为`std::string`时要使用的模板`boost::match_results`的专门化。 我们在循环中搜索连续的匹配子字符串，调用`boost::regex_search`。 我们将输入字符串的两个迭代器传递给`boost::regex_search`，名为`matches`的`smatch`实例和正则表达式`r2`(第 13 行)。 您必须将`const`迭代器传递给`boost::regex_search`(第 10、11 行)，否则编译将无法解析函数调用，并显示大量不必要的消息。

类型为`boost::smatch`的对象`matches`在调用`regex_search`之后存储与正则表达式匹配的子字符串的信息。 其`str`成员返回与正则表达式匹配的子字符串。 `boost::smatch`是`boost::ssub_match`对象的序列集合。 当正则表达式匹配子字符串时，该子字符串开头和结尾的迭代器对存储在类型为`boost::ssub_match`的对象中。 它存储在`matches`的索引 0 处，并作为`matches[0]`访问。 `ssub_match`的成员`first`和`second`是到比赛开始(第 15 行)的迭代器，并且比比赛结束晚一次。 成员函数`length()`返回匹配的长度(第 16 行)。 在每次迭代结束时，我们将`start`迭代器设置为上次匹配结束后的第一个位置(第 17 行)，以开始查找下一个匹配。 `boost::ssub_match`是当输入字符串是类型`std::string`时要使用的模板`boost::sub_match`的专门化。

假设，对于每一场比赛，我们想要提取位于两个 a 之间的两端的东西。 为此，我们可以使用捕捉子表达式。 正则表达式将稍微修改为`a(\\w*)a`。 要访问与带括号的子表达式匹配的内容，我们再次使用`boost::smatch`对象。 为正则表达式中的每个这样的子表达式构造一个附加的`boost::ssub_match`对象，并将其添加到传递的`boost::smatch`对象的连续索引中。 如果子表达式与字符串中的任何内容匹配，则与该子表达式匹配的子字符串的开始和结束将存储在`ssub_match`对象中。

下面是我们如何将其与修改后的正则表达式一起使用：

**清单 4.28：解析匹配子字符串和子表达式**

```cpp
 1 #include <boost/regex.hpp>
 2 #include <string>
 3 #include <iostream>
 4 int main()
 5 {
 6   std::string str2 = "An array of papers from the academia "
 7                      "on Alaska area's fauna";
 8  boost::regex r2("a(\\w*)a");
 9  boost::smatch matches;
10   std::string::const_iterator start = str2.begin(),
11                               end = str2.end();
12
13   while (boost::regex_search(start, end, matches, r2)) {
14     std::cout << "Matched substring '" << matches.str()
15          << "' following '" << matches.prefix().str()
16          << " preceding '" << matches.suffix().str() << "'\n";
17     start = matches[0].second;
18     for (size_t s = 1; s < matches.size(); ++ s) {
19       if (matches[s].matched) {
20         std::cout << "Matched substring " << matches[s].str()
21            << " at offset " << matches[s].first – str2.begin()
22            << " of length " << matches[s].length() << '\n';
23       }
24     }
25   }
26 }
```

在内部的循环(第 18 行)中，我们迭代所有子表达式，对于匹配任意子字符串的表达式(第 19 行)，我们使用`boost::ssub_match`的`str`成员函数(第 20 行)、子串的偏移量(第 21 行)及其长度(第 22 行)打印匹配的子串。 `matches`对象的`prefix`和`suffix`方法分别返回匹配子字符串之前和之后的部分作为`boost::ssub_match`对象(第 15、16 行)。

`boost::match_results`和`boost::sub_match`模板具有适用于不同类型输入的不同可用专门化，如窄字符或宽字符数组，或`std::basic_string`(`std::string`或`std::wstring`)的专门化。

下表总结了这些专业化认证：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

输入类型

 | 

Std：：Match_Results 专业化认证

 | 

Std：：SUB_MATCH 专业化认证

 |
| --- | --- | --- |
| `std::string` | `std::smatch` | `std::ssub_match` |
| `std::wstring` | `std::wmatch` | `std::wsub_match` |
| `const char*` | `std::cmatch` | `std::csub_match` |
| `const wchar_t*` | `std::wcmatch` | `std::wcsub_match` |

### 使用正则表达式对文本进行标记化

使用正则表达式解析输入是一项非常繁重的工作，应该有更好的抽象可供应用编程人员使用。 实际上，使用`boost::regex_iterator`和`boost::regex_token_iterator`可以简化这类工作。 假设我们要选取字符串中以`'a'`开头和结尾的所有单词。 以下是一种相对无痛的方法：

**清单 4.29：使用 Boost：：regex_iterator**解析字符串

```cpp
 1 #include <boost/regex.hpp>
 2 #include <string>
 3 #include <iostream>
 4
 5 int main()
 6 {
 7   std::string str2 = "An array of papers from the academia "
 8                      "on Alaska area's fauna";
 9   boost::regex r1("\\ba\\w*a\\b", boost::regex::icase);
10   boost::sregex_iterator rit(str2.begin(), str2.end(), r1), rend;
11 
12   while (rit != rend) {
13     std::cout << *rit++ << '\n';
14   }
15 }
```

此程序将以下文本打印到输出，由以`'a'`开头和结尾的三个单词组成：

```cpp
academia
Alaska
area
```

`boost::sregex_iterator`是当输入字符串类型为`std::string`时要使用的模板`boost::regex_iterator`的专门化。 它的实例`rit`使用字符串迭代器进行初始化，定义用于查找连续令牌的输入字符串和正则表达式(第 10 行)。 然后，像任何其他迭代器一样，它被用来迭代连续的令牌(第 12 行)。

在上一个示例中，我们没有处理子表达式。 那么，让我们来看一个包含子表达式的例子。 考虑一个字符串`"animal=Llama lives_in=Llama and is related_to=vicuna"`。 它由一些用等号分隔的键值对以及其他内容组成。 如果我们想要提取所有这样的键-值对，我们可以使用像`\w+=\w+`这样的正则表达式。 我们假设键和值是没有嵌入标点符号或空格的单个单词。 如果我们还想分别挑选键和值，我们可以使用类似`(\w+)=(\w+)`的 Capture-Groups 进行子表达式匹配：

通过使用`boost::sregex_token_iterator`，我们实际上可以相对容易地挑选出与各个子表达式匹配的子字符串。 `boost::sregex_token_iterator`是模板`boost::regex_token_iterator`的专门化，用于类型为`std::string`的输入字符串。 它将迭代器带到输入字符串、正则表达式和指定要迭代的子表达式的可选个参数。 下面是要引导的代码：

**清单 4.30：使用 Boost：：regex_Token_iterator**解析输入字符串

```cpp
 1 #include <boost/regex.hpp>
 2 #include <string>
 3 #include <iostream>
 4
 5 int main()
 6 {
 7   std::string str3 = "animal=Llama lives_in=Chile "
 8                      "and is related_to=vicuna";
 9   boost::regex r3("(\\w+)=(\\w+)");
10   int subindx[] = {2, 1};
11   boost::sregex_token_iterator tokit(str3.begin(), str3.end(),
12                                      r3, subindx), tokend;
13   while (tokit != tokend) {
14     std::cout << *tokit++ << '\n';
15   }
16   std::cout << '\n';
17 }
```

此代码打印以下输出：

```cpp
Llama
animal
Chile
lives_in
vicuna
related_to
```

您可能已经注意到，我们在键后面打印值。 我们使用迭代器初始化`boost::sregex_token_iterator`，这些迭代器定义输入字符串、正则表达式和指定我们感兴趣的子表达式的数组`subindx`(第 11 行)。 因为`subindx`具有值`{2, 1}`(第 10 行)，所以第二个字段在第一个字段之前打印。 除了数组之外，我们还可以传递标识子表达式索引的整数向量，或者传递标识我们感兴趣的唯一子表达式的索引的单个整数。 如果我们省略这一论点，`boost::regex_token_iterator`的行为与`boost::regex_iterator`的行为是相同的。 数组的大小不需要传递，通过模板参数推演自动推导。

Boost 字符串算法库中的一些算法为 Boost.Regex 中的功能提供了方便的包装。 `boost::find_all_regex`算法接受一个 Sequence 容器、一个输入字符串和一个正则表达式，并通过一个函数调用将与正则表达式匹配的输入字符串的所有子字符串放入序列容器中。 `boost::split_regex`容器将字符串拆分成由匹配某个正则表达式的文本分隔的标记，并将标记放入序列容器中。 这两种方法都很实用；`find_all_regex`将句子拆分为单词，`split_regex`将带有竖线字符分隔符的记录拆分为字段：

**清单 4.31：使用 find_all_regex 和 plit_regex**

```cpp
 1 #include <boost/algorithm/string_regex.hpp>
 2 #include <boost/regex.hpp>
 3 #include <string>
 4 #include <iostream>
 5 #include <vector>
 6
 7 int main()
 8 {
 9   std::string line = "All that you touch";
10   std::vector<std::string> words;
11   boost::find_all_regex(words, line, boost::regex("\\w+"));
12
13   std::string record = "Pigs on the Wing|Dogs| Pigs| Sheep";
14   std::vector<std::string> fields;
15   boost::split_regex(fields, record, boost::regex("[\\|]"));
16
17   for (auto word: words) { std::cout << word << ","; }
18   std::cout << '\n';
19   for (auto field: fields) { std::cout << field << ","; }
20 }
```

这将打印以下输出：

```cpp
All,ll,l,that,hat,at,t,you,ou,u,touch,ouch,ch,h,
Pigs on the Wing,Dogs, Pigs, Sheep,
```

请注意，第一行打印与正则表达式`\w+`(第 11 行)匹配的所有可能的子字符串，而不仅仅是最大的不相交匹配子字符串。 这是因为`find_all_regex`在输入中查找每个匹配子字符串。

### 替换文本

正则表达式的一种常见用法是搜索文本并用其他文本替换匹配的文本。 例如，我们可能希望扫描特定段落中的所有格短语(英国女王、印度文化、人们的选择等等)。 并将它们转换成另一种形式(英国女王、印度文化、人的选择等等)。 为此，`boost::regex_replace`函数模板可以派上用场。

首先，我们定义正则表达式`\w+'s\s+\w+`。 因为我们必须对短语重新排序，所以我们必须使用子表达式捕获匹配的部分。 我们使用正则表达式`(\w+)'s\s+(\w+)`进行匹配。 我们可以在替换字符串中使用带编号的反向引用来引用子匹配，因此替换字符串为`"\2 of \1"`。 我们将这些内容与输入字符串一起传递给`boost::regex_replace`，它返回一个字符串，其中匹配的部分被适当替换。 以下是代码：

**清单 4.32：使用正则表达式查找/替换字符串**

```cpp
 1 #include <boost/regex.hpp>
 2 #include <cassert>
 3
 4 int main()
 5 {
 6   std::string str4 = "England's Queen, India's President, "
 7                      "people's choice";
 8   boost::regex r4("(\\w+)'s\\s+(\\w+)");
10   std::string rep = boost::regex_replace(str4, r4, "\\2 of \\1");
11   
12   assert(rep == "Queen of England, President of India, "
13                   "choice of people");
14 }
```

默认情况下，`regex_replace`替换所有匹配子字符串。 如果我们只想替换第一个匹配子字符串，那么我们需要将`boost::regex_constants:: format_first_only`作为第四个参数传递给`regex_replace`。

# 自测题

对于多项选择题，请选择适用的所有选项：

1.  How does Boost Range help Boost Algorithms provide a better interface?

    A.表示为单个参数的任何字符范围，而不是迭代器对

    B.它比迭代器对更快

    C.它支持 C 风格的数组，并且可以扩展到其他抽象

    D.它提供了更好的异常安全性

2.  Which algorithm produces the shortest code for searching all substrings matching a search string or pattern?

    A.°T0_

    B.`boost::find_all_regex`

    C. 089

    D.`boost::regex_iterator`

3.  Which of these are tokenizer functions provided by the Boost Tokenizer library?

    A.°T0_

    B.`boost::split`

    C. 089

    D.`boost::tokenizer`

4.  The regular expression `"\ba.*a"` matches which part of the string `"two giant anacondas creeping around"`?

    A.°T0_

    B.`"anacondas creeping a"`

    C. 089

    D.`"anaconda"`

5.  Which of the following is true of `boost::smatch`?

    A.它是`boost:: match_results`的专门化

    B.它只存储匹配的子表达式

    C.它为每个子表达式存储一个`boost::ssub_match`对象

    D.其`str`成员返回匹配的子字符串

# 摘要

在本章中，我们学习了如何使用 Boost 字符串算法库中的其他函数对字符串数据类型执行各种操作。 然后，我们研究了通用的 Boost String Tokenizer 框架，该框架提供了一种高效且可扩展的方式来根据用户可以定义的条件对字符串进行标记化。 最后，我们介绍了正则表达式，以及 Boost.Regex 库，该库提供了将字符数据与正则表达式进行匹配、搜索模式、使用正则表达式对模式进行标记化和替换模式的功能。

本章应该让您对 Boost 库中提供的基本文本处理工具有一个广泛的了解。 在此过程中，我们还从 Boost Range 抽象中学到了一些有用的技术。 在下一章中，我们将注意力转向 Boost 库中提供的各种数据结构。