["```cpp\n// A struct that defines the data values our tiles need.\nstruct Tile\n{\nTILE type;          // The type of tile this is.\nint columnIndex;    // The column index of the tile.\nint rowIndex;       // The row index of the tile.\nsf::Sprite sprite;  // The tile sprite.\nint H;              // Heuristic / movement cost to goal.\nint G;              // Movement cost. (Total of entire path)\nint F;              // Estimated cost for full path. (G + H)\nTile* parentNode;   // Node to reach this node.\n};\n```", "```cpp\n// All possible tiles.\nenum class TILE {\n  WALL_SINGLE,\n  WALL_TOP_END,\n  WALL_SIDE_RIGHT_END,\n  WALL_BOTTOM_LEFT,\n  WALL_BOTTOM_END,\n  WALL_SIDE,\n  WALL_TOP_LEFT,\n  WALL_SIDE_LEFT_T,\n  WALL_SIDE_LEFT_END,\n  WALL_BOTTOM_RIGHT,\n  WALL_TOP,\n  WALL_BOTTOM_T,\n  WALL_TOP_RIGHT,\n  WALL_SIDE_RIGHT_T,\n  WALL_TOP_T,\n  WALL_INTERSECTION,\n  WALL_DOOR_LOCKED,\n  WALL_DOOR_UNLOCKED,\n  WALL_ENTRANCE,\n  FLOOR,\n  FLOOR_ALT,\n  EMPTY,\n  COUNT\n};\n```", "```cpp\n  for (int i = 0; i < GRID_WIDTH; ++i)\n  {\n    for (int j = 0; j < GRID_HEIGHT; ++j)\n    {\n      m_grid[i][j].markAsSpawnable();\n    }\n  }\n```", "```cpp\nfor (int i = 0; i < GRID_WIDTH; ++i)\n{\n    for (int j = 0; j < GRID_HEIGHT; ++j)\n    {\n        if (m_grid[i][j].type == TILE::FLOOR || m_grid[i][j].type == TILE::FLOOR_ALT)\n        { \n            m_grid[i][j].markAsSpawnable();\n        }\n    }\n}\n```", "```cpp\n// Generate random indices.\nint randomColumn = std::rand() % 10;\nint randomRow = std::rand() % 10;\n\n// Get the tile of the random tile.\nTile* tile = m_level.GetTile(randomColumn, randomRow);\n```", "```cpp\n// Get the type of the random tile.\nTile* tile = m_level.GetTile(1, 1);\n\n// Check if the tile is a floor tile.\nif (m_level.IsFloor(*tile))\n{\n  // tile is valid\n}\n```", "```cpp\n/**\n * Returns the position of a tile on the screen.\n */\nsf::Vector2f GetActualTileLocation(int columnIndex, int rowIndex);\n```", "```cpp\nsf::Vector2f Level::GetActualTileLocation(int columnIndex, int rowIndex)\n{\n    sf::Vector2f location;\n\n    location.x = m_origin.x + (columnIndex * TILE_SIZE) + (TILE_SIZE / 2);\n    location.y = m_origin.y + (rowIndex * TILE_SIZE) + (TILE_SIZE / 2);\n\n    return location;\n}\n```", "```cpp\n// Declare the variables we need.\nint columnIndex(0), rowIndex(0);\nTile tileType;\n\n// Generate a random index for the row and column.\ncolumnIndex = std::rand() % GRID_WIDTH;\nrowIndex = std::rand() % GRID_HEIGHT;\n\n// Get the tile type.\ntileType = m_level.GetTileType(columnIndex, rowIndex);\n```", "```cpp\n// Declare the variables we need.\nint columnIndex(0), rowIndex(0);\n\n// Loop until we select a floor tile.\nwhile (!m_level.IsFloor(columnIndex, rowIndex))\n{\n    // Generate a random index for the row and column.\n    columnIndex = std::rand() % GRID_WIDTH;\n    rowIndex = std::rand() % GRID_HEIGHT;\n}\n```", "```cpp\n/**\n * Returns a valid spawn location from the currently loaded level\n */\nsf::Vector2f GetRandomSpawnLocation();\n```", "```cpp\n// Returns a valid spawn location from the currently loaded level.\nsf::Vector2f Level::GetRandomSpawnLocation()\n{\n    // Declare the variables we need.\n    int rowIndex(0), columnIndex(0);\n\n    // Loop until we select a floor tile.\n    while (!m_level.IsFloor(columnIndex, rowIndex))\n    {\n        // Generate a random index for the row and column.\n        columnIndex = std::rand() % GRID_WIDTH;\n        rowIndex = std::rand() % GRID_HEIGHT;\n    }\n\n    // Convert the tile position to absolute position.\n    sf::Vector2f tileLocation(m_level.GetActualTileLocation(columnIndex, rowIndex));\n\n    // Create a random offset.\n    tileLocation.x += std::rand() % 21 - 10;\n    tileLocation.y += std::rand() % 21 - 10;\n\n    return tileLocation;\n}\n```", "```cpp\n    item->SetPosition(sf::Vector2f(m_screenCenter.x, m_screenCenter.y));\n    item->SetPosition(m_level.GetRandomSpawnLocation());\n    m_items.push_back(std::move(item));\n}\n```", "```cpp\n// Spawnable items.\nenum class ITEM {\n  HEART,\n  GEM,\n  GOLD,\n  POTION,\n  KEY,\n  COUNT\n};\n```", "```cpp\nvoid TestFunction(OBJECT object, sf::Vector2f position);\n```", "```cpp\nvoid TestFunction(OBJECT object, sf::Vector2f position = { -1.f, -1.f } );\n```", "```cpp\n/**\n * Spawns a given item in the level.\n */\nvoid SpawnItem(ITEM itemType, sf::Vector2f position = { -1.f, -1.f });\n```", "```cpp\n// Choose a random, unused spawn location if not overridden.\nsf::Vector2f spawnLocation;\nif ((position.x >= 0.f) || (position.y >= 0.f))\n{\n    spawnLocation = position;\n}\nelse\n{\n    spawnLocation = m_level.GetRandomSpawnLocation();\n}\n```", "```cpp\nSpawnITem(GOLD);\nSpawnITem(GOLD, 100.f, 100.f);\n```", "```cpp\n// Spawns a given object type at a random location within the map. Has the option to explicitly set a spawn location.\nvoid Game::SpawnItem(ITEM itemType, sf::Vector2f position)\n{\n    std::unique_ptr<Item> item;\n\n    int objectIndex = 0;\n\n    // Choose a random, unused spawn location.\n    sf::Vector2f spawnLocation;\n\n    if ((position.x >= 0.f) || (position.y >= 0.f))\n    {\n        spawnLocation = position;\n    }\n    else\n    {\n        spawnLocation = m_level.GetRandomSpawnLocation();\n    }\n\n    // Check which type of object is being spawned.\n    switch (itemType)\n    {\n        case ITEM::POTION:\n            item = std::make_unique<Potion>();\n        break;\n\n        case ITEM::GEM:\n            item = std::make_unique<Gem>();\n        break;\n\n        case ITEM::GOLD:\n            item = std::make_unique<Gold>();\n        break;\n\n        case ITEM::KEY:\n            item = std::make_unique<Key>();\n        break;\n\n        case ITEM::HEART:\n            item = std::make_unique<Heart>();\n        break;\n    }\n\n    // Set the item position.\n    item->SetPosition(spawnLocation);\n\n    // Add the item to the list of all items.\n    m_items.push_back(std::move(item));\n}\n```", "```cpp\nif (canSpawn)\n{\n  int itemIndex = std::rand() % 2;\n SpawnItem(static_cast<ITEM>(itemIndex));\n  std::unique_ptr<Item> item;\n\n  switch (itemIndex)\n  {\n  case 0:\n    item = std::make_unique<Gold>();\n    break;\n\n  case 1:\n    item = std::make_unique<Gem>();\n    break;\n  }\n\n  item->SetPosition(sf::Vector2f(m_screenCenter.x, m_screenCenter.y));\n  item->SetPosition(m_level.GetRandomSpawnLocation());\n  m_items.push_back(std::move(item));\n}\n```", "```cpp\nstatic int const MAX_ITEM_SPAWN_COUNT = 50;\n```", "```cpp\n// Populate the level with items.\nvoid Game::PopulateLevel()\n{\n    // Spawn items.\n    for (int i = 0; i < MAX_ITEM_SPAWN_COUNT; i++)\n    {\n        if (std::rand() % 2)\n        {\n            SpawnItem(static_cast<ITEM>(std::rand() % 2));\n        }\n    }\n}\n```", "```cpp\n/**\n * Spawns a given enemy in the level.\n */\nvoid SpawnEnemy(ENEMY enemyType, sf::Vector2f position = { -1.f, -1.f });\n```", "```cpp\n  static int const MAX_ENEMY_SPAWN_COUNT = 20;\n```", "```cpp\n// Enemy types.\nenum class ENEMY {\n  SLIME,\n  HUMANOID,\n  COUNT\n};\n```", "```cpp\n// Spawns a given number of enemies in the level.\nvoid Game::SpawnEnemy(ENEMY enemyType, sf::Vector2f position)\n{\n    // Spawn location of enemy.\n    sf::Vector2f spawnLocation;\n\n    // Choose a random, unused spawn location.\n    if ((position.x >= 0.f) || (position.y >= 0.f))\n    {\n        spawnLocation = position;\n    }\n    else\n    {\n        spawnLocation = m_level.GetRandomSpawnLocation();\n    }\n\n    // Create the enemy.\n    std::unique_ptr<Enemy> enemy;\n\n    switch (enemyType)\n    {\n        case ENEMY::SLIME:\n            enemy = std::make_unique<Slime>();\n        break;\n        case ENEMY::HUMANOID:\n            enemy = std::make_unique<Humanoid>();\n        break;\n    }\n\n    // Set spawn location.\n    enemy->SetPosition(spawnLocation);\n\n    // Add to list of all enemies.\n    m_enemies.push_back(std::move(enemy));\n}\n```", "```cpp\n// Populate the level with items.\nvoid Game::PopulateLevel()\n{\n    // Spawn items.\n    for (int i = 0; i < MAX_ITEM_SPAWN_COUNT; i++)\n    {\n        if (std::rand() % 2)\n        {\n            SpawnItem(static_cast<ITEM>(std::rand() % 2));\n        }\n    }\n\n    // Spawn enemies.\n    for (int i = 0; i < MAX_ENEMY_SPAWN_COUNT; i++)\n    {\n        if (std::rand() % 2)\n        {\n            SpawnEnemy(static_cast<ENEMY>(std::rand() % static_cast<int>(ENEMY::COUNT)));\n        }\n    }\n}\n```", "```cpp\n/**\n * Spawns a given number of a certain tile at random locations in the level.\n */\nvoid SpawnRandomTiles(TILE tileType, int count);\n```", "```cpp\n// Add the new tile type to level.\nm_level.AddTile(\"../resources/tiles/spr_tile_floor_alt.png\", TILE::FLOOR_ALT);\n```", "```cpp\n// Spawns a given number of a given tile randomly in the level.\nvoid Game::SpawnRandomTiles(TILE tileType, int count)\n{\n    // Declare the variables we need.\n    int rowIndex(0), columnIndex(0), tileIndex(0);\n\n    // Loop the number of tiles we need.\n    for (int i = 0; i < count; i++)\n    {\n        // Declare the variables we need.\n        int columnIndex(0), rowIndex(0);\n\n        // Loop until we select a floor tile.\n        while (!m_level.IsFloor(columnIndex, rowIndex))\n        {\n            // Generate a random index for the row and column.\n            columnIndex = std::rand() % GRID_WIDTH;\n            rowIndex = std::rand() % GRID_HEIGHT;\n        }\n\n        // Now we change the selected tile.\n        m_level.SetTile(columnIndex, rowIndex, tileType);\n    }\n}\n```", "```cpp\n// Change a selection of random tiles to the cracked tile sprite.\nSpawnRandomTiles(TILE::FLOOR_ALT, 15);\n```", "```cpp\n    // change a selection of random tiles to the cracked tile sprite\n    this->SpawnRandomTiles(tileIndex, 15);\n    ```"]