["```cpp\nsf::Color::Color  (\nUint8   red,\nUint8   green,\nUint8   blue,\nUint8   alpha = 255\n)\n```", "```cpp\nsf::Color black       = sf::Color::Black;\nsf::Color white       = sf::Color::White;\nsf::Color red         = sf::Color::Red;\nsf::Color green       = sf::Color::Green;\nsf::Color blue        = sf::Color::Blue;\nsf::Color yellow      = sf::Color::Yellow;\nsf::Color magenta     = sf::Color::Magenta;\nsf::Color cyan        = sf::Color::Cyan;\nsf::Color transparent = sf::Color::Transparent;\n```", "```cpp\n// Colors provided by SFML.\nenum class COLOR {\n  BLACK,\n  WHITE,\n  RED,\n  GREEN,\n  BLUE,\n  YELLOW,\n  MAGENTA,\n  CYAN,\n  TRANSPARENT,\n  COUNT\n};\n```", "```cpp\nint colorIndex = std::rand() % static_cast<int>(COLOR::COUNT);\n```", "```cpp\nswitch (colorIndex)\n{\ncase static_cast<int>(COLOR::BLACK):\n  m_sprite.setColor(sf::Color::Black);\n  break;\n\ncase static_cast<int>(COLOR::BLUE):\n  m_sprite.setColor(sf::Color::Blue);\n  break;\n```", "```cpp\nint r, g, b, a;\n\nr = std::rand() % 256;\ng = std::rand() % 256;\nb = std::rand() % 256;\n```", "```cpp\na = std::rand() % 156 + 100;\n```", "```cpp\nsf::Color color(r, g, b, a);\n```", "```cpp\n// Choose the random sprite color and set it.\nint r, g, b, a;\n\nr = std::rand() % 256;\ng = std::rand() % 256;\nb = std::rand() % 256;\na = std::rand() % 156 + 100;\nsf::Color color(r, g, b, 255);\n\nm_sprite.setColor(color);\n```", "```cpp\nfloat scale;\nscale = (std::rand() % 11 + 5) / 10.f;\n```", "```cpp\n// Generate a random scale between 0.5 and 1.5 and set it.\nfloat scale;\nscale = (std::rand() % 11 + 5) / 10.f;\n\nm_sprite.setScale(sf::Vector2f(scale, scale));\n```", "```cpp\n// Save the sprite to file.\nsf::Image img = m_sprite.getTexture()->copyToImage();\nimg.saveToFile(\"../resources/test.png\");\n```", "```cpp\n// Create a RenderTarget.\nsf::RenderTexture texture;\n\nint textureWidth(m_sprite.getTexture()->getSize().x);\nint textureHeight(m_sprite.getTexture()->getSize().y);\ntexture.create(textureWidth * scale, textureHeight * scale);\n```", "```cpp\n// Draw the sprite to our RenderTexture.\ntexture.draw(m_sprite);\n```", "```cpp\n// Create a RenderTarget.\nsf::RenderTexture texture;\n\nint textureWidth(m_sprite.getTexture()->getSize().x);\nint textureHeight(m_sprite.getTexture()->getSize().y);\ntexture.create(textureWidth * scale, textureHeight * scale);\n\n// Revert changes the animation made.\nm_sprite.setOrigin(sf::Vector2f(0.f, 0.f));\nm_sprite.setTextureRect(sf::IntRect(0, 0, textureWidth, textureHeight));\n\n// Draw the sprite to our RenderTexture.\ntexture.draw(m_sprite);\n\n// Copy the texture to an image and flip it.\nsf::Image img = texture.getTexture().copyToImage();\nimg.flipVertically();\n\n// Save the sprite to file.\nimg.saveToFile(\"../resources/test.png\");\n```", "```cpp\n  /**\n   * An array of modified textures.\n   */\n  sf::Texture m_textures[static_cast<int>(ANIMATION_STATE::COUNT)];\n```", "```cpp\n// Copy textures.\nfor (int i = 0; i < static_cast<int>(ANIMATION_STATE::COUNT); ++i)\n{\n  m_textures[i] = TextureManager::GetTexture(m_textureIDs[i]);\n}\n```", "```cpp\nprivate:\n /**\n  * Generates random armor for the humanoid.\n  */\nvoid GenerateArmor();\n```", "```cpp\n// Randomly generates armor.\nvoid Humanoid::GenerateArmor()\n{\n    // Create arrays of textures.\n    const int textureCount = static_cast<int>(ANIMATION_STATE::COUNT);\n    sf::RenderTexture armorTextures[textureCount];\n    sf::RenderTexture finalTextures[textureCount];\n    sf::Image renderImage;\n    // Setup all render textures.\n    for (int i = 0; i < static_cast<int>(ANIMATION_STATE::COUNT); ++i)\n    {\n        sf::Vector2u textureSize = m_textures[i].getSize();\n        armorTextures[i].create(textureSize.x, textureSize.y);\n        finalTextures[i].create(textureSize.x, textureSize.y);\n    }\n```", "```cpp\n// Create variables to determine what armor be created.\nint hasHelmet(0), hasTorso(0), hasLegs(0);\n\nhasHelmet = std::rand() % 5;\nhasTorso = std::rand() % 5;\nhasLegs = std::rand() % 5;\n\n// Spawn helmet.\nif (hasHelmet == 0)\n{\n}\n\n// spawn torso.\nif (hasTorso == 0)\n{\n}\n\n// spawn legs.\nif (hasLegs == 0)\n{\n}\n```", "```cpp\n// Spawn helmet.\nif (hasHelmet == 0)\n{\n  // Load the default helmet textures.\n  int defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::COUNT)];\n\n  defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::WALK_UP)] = TextureManager::AddTexture(\"../resources/armor/helmet/spr_helmet_walk_front.png\");\n  defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::WALK_DOWN)] = TextureManager::AddTexture(\"../resources/armor/helmet/spr_helmet_walk_front.png\");\n  defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::WALK_RIGHT)] = TextureManager::AddTexture(\"../resources/armor/helmet/spr_helmet_walk_side.png\");\n  defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::WALK_LEFT)] = TextureManager::AddTexture(\"../resources/armor/helmet/spr_helmet_walk_side.png\");\n  defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::IDLE_UP)] = TextureManager::AddTexture(\"../resources/armor/helmet/spr_helmet_idle_front.png\");\n  defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::IDLE_DOWN)] = TextureManager::AddTexture(\"../resources/armor/helmet/spr_helmet_idle_front.png\");\n  defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::IDLE_RIGHT)] = TextureManager::AddTexture(\"../resources/armor/helmet/spr_helmet_idle_side.png\");\n  defaultHelmetTextureIDs[static_cast<int>(ANIMATION_STATE::IDLE_LEFT)] = TextureManager::AddTexture(\"../resources/armor/helmet/spr_helmet_idle_side.png\");\n```", "```cpp\n// Generate random number to determine tier.\nsf::Color tierColor;\nint tierValue = std::rand() % 100 + 1;\n\n// Select which tier armor should be created.\nif (tierValue < 51)\n{\n    tierColor = sf::Color(110, 55, 28, 255); // Bronze.\n}\nelse if (tierValue < 86)\n{\n    tierColor = sf::Color(209, 208, 201, 255); // Silver.\n}\nelse\n{\n    tierColor = sf::Color(229, 192, 21, 255); // Gold.\n}\n```", "```cpp\n// Render helmet to armor texture.\nfor (int i = 0; i < static_cast<int>(ANIMATION_STATE::COUNT); ++i)\n{\n  // Load the default helmet texture and set its color.\n  sf::Sprite tempSprite;\n  tempSprite.setTexture(TextureManager::GetTexture(defaultHelmetTextureIDs[i]));\n  tempSprite.setColor(tierColor);\n\n  // Flip the texture vertically.\n  sf::Vector2u size = armorTextures[i].getTexture().getSize();\n  tempSprite.setTextureRect(sf::IntRect(0, size.y, size.x, -size.y));\n\n  // Draw the texture.\n  armorTextures[i].draw(tempSprite);\n}}\n```", "```cpp\n// Create the final render texture.\nfor (int i = 0; i < static_cast<int>(ANIMATION_STATE::COUNT); ++i)\n{\n    sf::Sprite baseSprite, armorSprite;\n\n    // Draw the default texture.\n    baseSprite.setTexture(m_textures[i]);\n    finalTextures[i].draw(baseSprite);\n\n    // Draw armor on top.\n    armorSprite.setTexture(armorTextures[i].getTexture());\n    finalTextures[i].draw(armorSprite);\n\n    // Flip the texture vertically.\n    sf::Image img = finalTextures[i].getTexture().copyToImage();\n    img.flipVertically();\n\n    // Store the resulting texture.\n    m_textures[i].loadFromImage(img);\n}\n```", "```cpp\n    . . .\n    // Copy textures.\n    for (int i = 0; i < static_cast<int>(ANIMATION_STATE::COUNT); ++i)\n    {\n        m_textures[i] = TextureManager::GetTexture(m_textureIDs[i]);\n    }\n\n    // Generate armor.\n    GenerateArmor();\n}\n```", "```cpp\n/**\n* Overrides the update event of enemy.\n* @param timeDelta The time that has elapsed since the last update.\n*/\nvoid Update(float timeDelta) override;\n```", "```cpp\n// Overrides the update event of enemy.\nvoid Humanoid::Update(float timeDelta)\n{\n    // Call parent functionality.\n    Enemy::Update(timeDelta);\n\n    // Update the texture with our custom textures.\n    m_sprite.setTexture(m_textures[m_currentTextureIndex]);\n}\n```", "```cpp\n// Save the texture to disk.\nif ((hasHelmet == 0) || (hasTorso == 0) || (hasLegs == 0))\n{\n  std::stringstream stream;\n  stream << \"../resources/test_\" << i << \".png\";\n  img.saveToFile(stream.str());\n}\n```", "```cpp\npublic:\n  /**\n   * Sets the overlay color of the level tiles.\n   * @param tileColor The new tile overlay color\n   */\n  void SetColor(sf::Color tileColor);\n```", "```cpp\n// Sets the overlay color of the level tiles.\nvoid Level::SetColor(sf::Color tileColor)\n{\n  for (int i = 0; i < GRID_WIDTH; ++i)\n  {\n    for (int j = 0; j < GRID_HEIGHT; ++j)\n    {\n      m_grid[i][j].sprite.setColor(tileColor);\n    }\n  }\n}\n```", "```cpp\n// Set the color of the tiles\nm_level.SetColor(sf::Color::Magenta);\n```"]