["```cpp\nstd::vector<std::unique_ptr<Item>> m_items;\nstd::vector<std::unique_ptr<Enemy>> m_enemies;\n```", "```cpp\n/**\n * A struct that defines the data values our tiles need.\n */ \nstruct Tile {\nTILE type;         // The type of tile this is.\n\nint columnIndex;   // The column index of the tile.\n\nint rowIndex;      // The row index of the tile.\n\nsf::Sprite sprite; // The tile sprite.\n\nint H;             // Heuristic / movement cost to goal.\n\nint G;             // Movement cost. (Total of entire path)\n\nint F;             // Estimated cost for full path. (G + H)\n\nTile* parentNode;  // Node to reach this node.\n};\n```", "```cpp\n/**\n * An enum denoting all possible input keys.\n */\nenum class KEY\n{\n  KEY_LEFT,\n  KEY_RIGHT,\n  KEY_UP,\n  KEY_DOWN,\n  KEY_ATTACK,\n  KEY_ESC\n};\n```", "```cpp\nVirtual void Attack();\n```", "```cpp\nVoid Attack() override;\n```", "```cpp\nVoid Attack() final;\n```", "```cpp\nVirtual void Attack() = 0;\n```", "```cpp\nWeapon myWeapon = Sword();\nStd::unique_ptr<Weapon> myWeapon = std::make_unique<Sword>();\n```", "```cpp\n#include <iostream>\n\n// We're using namespace std here to avoid having to fully qualify everything with std::\nusing namespace std;\n\nint main()\n{\n\n  // Here we define a base Weapon struct.\n  // It provides a single data type, and a method to return it.\n  struct Weapon\n  {\n    string itemType = \"Generic Weapon\";\n\n    virtual string GetItemType()\n    {\n      return itemType;\n    }\n  };\n\n  // Here we inherit from the generic Weapon struct to make a specific Sword struct.\n  // We override the GetItemType() function to change the itemType variable before returning it.\n  struct Sword : public Weapon\n  {\n    string GetItemType() override\n    {\n      itemType = \"Sword\";\n      return itemType;\n    }\n  };\n\n  Weapon myWeapon = Sword();\n\n  // output the type of item that weapon is then wait.\n  cout << myWeapon.GetItemType().c_str() << endl;\n  std::cin.get();\n\n  return 0;\n}\n```", "```cpp\nWeapon myWeapon = Sword()\n```", "```cpp\n  // Create our weapon object.\n  //Weapon myWeapon = Sword();\n std::unique_ptr<Weapon> myWeapon = std::make_unique<Sword>();\n\n```", "```cpp\n// Output the type of item that weapon is then wait.\n//cout << myWeapon.GetItemType().c_str() << endl;\ncout << myWeapon->GetItemType().c_str() << endl;\n\n```", "```cpp\n// Create a gem object.\nstd::unique_ptr<Gem> gem = std::make_unique<Gem>();\n\n// Set the gem position.\ngem->SetPosition(sf::Vector2f(m_screenCenter.x + 50.f, m_screenCenter.y));\n\n// Add the gem to our collection of all objects.\nm_items.push_back(std::move(gem));\n\n```", "```cpp\n// Update all items.\nUpdateItems(playerPosition);\n```", "```cpp\n// Have all objects draw themselves. \nfor (const auto& item : m_items) \n{ \n    item->Draw(m_window, timeDelta); \n}\n```", "```cpp\n    class A\n    {\n    public:\n        int x;\n    protected:\n        int y;\n    private:\n        int z;\n    };\n\n    class B : protected A\n    {\n\n    };\n    ```"]