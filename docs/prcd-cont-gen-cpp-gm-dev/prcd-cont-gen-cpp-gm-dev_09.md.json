["```cpp\ncase GAME_STATE::PLAYING:\n{\n  // Set the main game view.\n  //m_window.setView(m_views[static_cast<int>(VIEW::MAIN)]);\n```", "```cpp\n// Draw level light.\n//for (const sf::Sprite& sprite : m_lightGrid)\n//{\n//  m_window.draw(sprite);\n//}\n```", "```cpp\npublic:\n/**\n * Generates a random level.\n */\nvoid GenerateLevel();\n```", "```cpp\n// Generates a new level.\nvoid Game::GenerateLevel()\n{\n  // Generate a new level.\n  m_level.GenerateLevel();\n\n  // Add a key to the level.\n  SpawnItem(ITEM::KEY);\n\n  // Populate the level with items.\n  PopulateLevel();\n\n  // 1 in 3 change of creating a level goal.\n  if (((std::rand() % 3) == 0) && (!m_activeGoal))\n  {\n    GenerateLevelGoal();\n  }\n}\n```", "```cpp\n. . .\n\nif (playerTile.type == TILE::WALL_DOOR_UNLOCKED)\n{\n\t// Clear all current items.\n\tm_items.clear();\n\n\t// Clear all current enemies.\n\tm_enemies.clear();\n\n\t// Generate a new room.\n\tGenerateLevel();\n\n\t// Set the key as not collected.\n\tm_keyUiSprite->setColor(sf::Color(255, 255, 255, 60));\n}\n\n. . .\n```", "```cpp\n// Load the level.\n//m_level.LoadLevelFromFile(\"../resources/data/level_data.txt\");\n\n// Set the position of the player.\n//m_player.SetPosition(sf::Vector2f(1155.f, 940.f));\n\n// Populate level.\n//PopulateLevel();\n\n// Generate a level.\nGenerateLevel();\n```", "```cpp\n// Generates a random level.\nvoid Level::GenerateLevel()\n{\n    // Create the initial grid pattern.\n    for (int i = 0; i < GRID_WIDTH; ++i)\n    {\n        for (int j = 0; j < GRID_HEIGHT; ++j)\n        {\n            if ((i % 2 != 0) && (j % 2 != 0))\n            {\n                // Odd tiles, nothing.\n                m_grid[i][j].type = TILE::EMPTY;\n            }\n            else\n            {\n                m_grid[i][j].type = TILE::WALL_TOP;\n                m_grid[i][j].sprite.setTexture(TextureManager::GetTexture(m_textureIDs[static_cast<int>(TILE::WALL_TOP)]));\n            }\n            // Set the position.\n            m_grid[i][j].sprite.setPosition(m_origin.x + (TILE_SIZE * i), m_origin.y + (TILE_SIZE * j));\n        }\n    }\n}\n```", "```cpp\nprivate:\n/**\n * Creates a path between two nodes in the recursive backtracker algorithm.\n */\nvoid CreatePath(int columnIndex, int rowIndex);\n```", "```cpp\n// Create a path between two tiles in the level grid.\nvoid Level::CreatePath(int columnIndex, int rowIndex)\n{\n  // Store the current tile.\n  Tile* currentTile = &m_grid[columnIndex][rowIndex];\n\n  // Create a list of possible directions and sort randomly.\n  sf::Vector2i directions[] = { { 0, -2 }, { 2, 0 }, { 0, 2 }, { -2, 0 } };\n  std::random_shuffle(std::begin(directions), std::end(directions));\n```", "```cpp\n// For each direction.\nfor (int i = 0; i < 4; ++i)\n{\n  // Get the new tile position.\n  int dx = currentTile->columnIndex + directions[i].x;\n  int dy = currentTile->rowIndex + directions[i].y;\n\n  // If the tile is valid.\n  if (TileIsValid(dx, dy))\n  {\n    // Store the tile.\n    Tile* tile = &m_grid[dx][dy];\n\n    // If the tile has not yet been visited.\n    if (tile->type == TILE::EMPTY)\n    {\n```", "```cpp\n  // Mark the tile as floor.\n  tile->type = TILE::FLOOR;\n  tile->sprite.setTexture(TextureManager::GetTexture(m_textureIDs[static_cast<int>(TILE::FLOOR)]));\n\n  // Knock that wall down.\n  int ddx = currentTile->columnIndex + (directions[i].x / 2);\n  int ddy = currentTile->rowIndex + (directions[i].y / 2);\n\n  Tile* wall = &m_grid[ddx][ddy];\n  wall->type = TILE::FLOOR;\n  wall->sprite.setTexture(TextureManager::GetTexture(m_textureIDs[static_cast<int>(TILE::FLOOR)]));\n\n  // Recursively call the function with the new tile.\n  CreatePath(dx, dy);\n}}}}\n```", "```cpp\n// Generates a random level.\nvoid Level::GenerateLevel()\n{\n  // Create the initial grid pattern.\n  for (int i = 0; i < GRID_WIDTH; ++i)\n  {\n\n // Make the first call to CarvePassage, starting the recursive backtracker algorithm.\n CreatePath(1, 1);\n}\n```", "```cpp\n/**\n * Adds a given number of randomly sized rooms to the level to create some open space.\n */\nvoid CreateRooms(int roomCount);\n```", "```cpp\n// Adds a given number of randomly sized rooms to the level to create some open space.\nvoid Level::CreateRooms(int roomCount)\n{\n  for (int i = 0; i < roomCount; ++i)\n  {\n```", "```cpp\n// Generate a room size.\nint roomWidth = std::rand() % 2 + 1;\nint roomHeight = std::rand() % 2 + 1;\n```", "```cpp\n// Choose a random starting location.\nint startI = std::rand() % (GRID_WIDTH - 2) + 1;\nint startY = std::rand() % (GRID_HEIGHT - 2) + 1;\n\nfor (int j = -1; j < roomWidth; ++j)\n{\n  for (int z = -1; z < roomHeight; ++z)\n  {\n```", "```cpp\nint newI = startI + j;\nint newY = startY + z;\n\n// Check if the tile is valid.\nif (TileIsValid(newI, newY))\n{\n  // Check if the tile is not on an outer wall.\n  if ((newI != 0) && (newI != (GRID_WIDTH - 1)) && (newY != 0) && (newY != (GRID_HEIGHT - 1)))\n  {\n    m_grid[newI][newY].type = TILE::FLOOR;\n    m_grid[newI][newY].sprite.setTexture(TextureManager::GetTexture(m_textureIDs[static_cast<int>(TILE::FLOOR)]));\n  }\n}}}}}\n```", "```cpp\n. . .\n\n// Make the first call to CarvePassage, starting the recursive backtracker algorithm.\nCreatePath(1, 1);\n\n// Add some rooms to the level to create some open space.\nCreateRooms(10);\n\n```", "```cpp\n// Tiles.\nenum class TILE {\n  WALL_SINGLE,\n  WALL_TOP_END,\n  WALL_SIDE_RIGHT_END,\n  WALL_BOTTOM_LEFT,\n  WALL_BOTTOM_END,\n  WALL_SIDE,\n  WALL_TOP_LEFT,\n  WALL_SIDE_LEFT_T,\n  WALL_SIDE_LEFT_END,\n  WALL_BOTTOM_RIGHT,\n  WALL_TOP,\n  WALL_BOTTOM_T,\n  WALL_TOP_RIGHT,\n  WALL_SIDE_RIGHT_T,\n  WALL_TOP_T,\n  WALL_INTERSECTION,\n  WALL_DOOR_LOCKED,\n  WALL_DOOR_UNLOCKED,\n  WALL_ENTRANCE,\n  FLOOR,\n  FLOOR_ALT,\n  EMPTY,\n  COUNT\n};\n```", "```cpp\n/**\n * Calculates the correct texture for each tile in the level.\n */\nvoid CalculateTextures();\n```", "```cpp\n// Calculates the correct texture for each tile in the level.\nvoid Level::CalculateTextures()\n{\n  // For each tile in the grid.\n  for (int i = 0; i < GRID_WIDTH; ++i)\n  {\n    for (int j = 0; j < GRID_HEIGHT; ++j)\n    {\n      // Check that the tile is a wall block.\n      if (IsWall(i, j))\n      {\n        // Calculate bit mask.\n        int value = 0;\n\n        // Store the current type as default.\n        TILE type = m_grid[i][j].type;\n```", "```cpp\n// Top.\nif (IsWall(i, j - 1))\n{\n  value += 1;\n}\n\n// Right.\nif (IsWall(i + 1, j))\n{\n  value += 2;\n}\n\n// Bottom.\nif (IsWall(i, j + 1))\n{\n  value += 4;\n}\n\n// Left.\nif (IsWall(i - 1, j))\n{\n  value += 8;\n}\n```", "```cpp\n// Set the new type.\nm_grid[i][j].type = static_cast<TILE>(value);\nm_grid[i][j].sprite.setTexture(TextureManager::GetTexture(m_textureIDs[value]));\n}}}}\n```", "```cpp\n  . . .\n  // Add some rooms to the level to create some open space.\n  CreateRooms(10);\n\n // Finally, give each tile the correct texture.\n CalculateTextures();\n}\n```", "```cpp\n/**\n * The floor number that the player is currently on.\n */\nint m_floorNumber;\n\n/**\n * The room number that the player is currently in.\n */\nint m_roomNumber;\n```", "```cpp\n    . . .\n\n    // Calculate the correct texture for each tile.\n    CalculateTextures();\n\n // Increment our room/floor count and generate new effect if necessary.\n m_roomNumber++;\n\n // Move to next floor.\n if (m_roomNumber == 5)\n {\n m_roomNumber = 0;\n m_floorNumber++;\n }\n}\n```", "```cpp\n// Increment our room/floor count and generate new effect if necessary.\nm_roomNumber++;\n\nif (m_roomNumber == 5)\n{\n  // Move to next floor.\n  m_roomNumber = 0;\n  m_floorNumber++;\n\n // Generate a random color and apply it to the level tiles.\n sf::Uint8 r = std::rand() % 101 + 100;\n sf::Uint8 g = std::rand() % 101 + 100;\n sf::Uint8 b = std::rand() % 101 + 100;\n\n SetColor(sf::Color(r, g, b, 255));\n}\n```", "```cpp\n. . .\n\n// Store the column and row information for each node.\nfor (int i = 0; i < GRID_WIDTH; ++i)\n{\n    for (int j = 0; j < GRID_HEIGHT; ++j)\n    {\n        auto cell = &m_grid[i][j];\n        cell->columnIndex = i;\n        cell->rowIndex = j;\n    }\n}\n\n// Generate a random color and apply it to the level tiles.\nsf::Uint8 r = std::rand() % 101 + 100;\nsf::Uint8 g = std::rand() % 101 + 100;\nsf::Uint8 b = std::rand() % 101 + 100;\n\nSetColor(sf::Color(r, g, b, 255));\n\n```", "```cpp\nprivate:\n/**\n * Generates an entry and exit point for the given level.\n */\nvoid GenerateEntryExit();\n```", "```cpp\n// Generates an entry and exit point for the given level.\nvoid Level::GenerateEntryExit()\n{\n  // Calculates new start and end locations within the level.\n  int startI, endI;\n  startI = endI = -1;\n\n  while (startI == -1)\n  {\n    int index = std::rand() % GRID_WIDTH;\n\n    if (m_grid[index][GRID_HEIGHT - 1].type == TILE::WALL_TOP)\n    {\n      startI = index;\n    }\n  }\n\n  while (endI == -1)\n  {\n    int index = std::rand() % GRID_HEIGHT;\n\n    if (m_grid[index][0].type == TILE::WALL_TOP)\n    {\n      endI = index;\n    }\n}\n```", "```cpp\n  // Set the tile textures for the entrance and exit tiles.\n  SetTile(startI, GRID_HEIGHT - 1, TILE::WALL_ENTRANCE);\n  SetTile(endI, 0, TILE::WALL_DOOR_LOCKED);\n}\n```", "```cpp\n    . . .\n\n        // Generate a random color and apply it to the level tiles.\n        sf::Uint8 r = std::rand() % 101 + 100;\n        sf::Uint8 g = std::rand() % 101 + 100;\n        sf::Uint8 b = std::rand() % 101 + 100;\n\n        SetColor(sf::Color(r, g, b, 255));\n    }\n\n // Add entrance and exit tiles to the level.\n GenerateEntryExit();\n}\n```", "```cpp\n/**\n * The spawn location for the current level.\n */\nsf::Vector2f m_spawnLocation;\n```", "```cpp\n  // Set the tile textures for the entrance and exit tiles.\n  SetTile(startI, GRID_HEIGHT - 1, TILE::WALL_ENTRANCE);\n  SetTile(endI, 0, TILE::WALL_DOOR_LOCKED);\n\n // Save the location of the exit door.\n m_doorTileIndices = sf::Vector2i(endI, 0);\n\n // Calculate the spawn location.\n m_spawnLocation = GetActualTileLocation(startI, GRID_HEIGHT - 2);\n}\n```", "```cpp\n// Returns the spawn location for the current level.\nsf::Vector2f Level::SpawnLocation()\n{\n  return m_spawnLocation;\n}\n```", "```cpp\n// Generates a new level.\nvoid Game::GenerateLevel()\n{\n  // Generate a new level.\n  m_level.GenerateLevel();\n\n  // Add a key to the level.\n  SpawnItem(ITEM::KEY);\n\n  // Populate the level with items.\n  PopulateLevel();\n\n  // 1 in 3 change of creating a level goal.\n  if (((std::rand() % 3) == 0) && (!m_activeGoal))\n  {\n    GenerateLevelGoal();\n  }\n\n // Moves the player to the start.\n m_player.SetPosition(m_level.SpawnLocation());\n}\n```", "```cpp\n. . .\n\ncase GAME_STATE::Playing:\n{\n  // Set the main game view.\n  //m_window.setView(m_views[static_cast<int>(VIEW::MAIN)]);\n\n // Set the main game view.\n m_window.setView(m_views[static_cast<int>(VIEW::MAIN)]);\n\n  // Draw level light.\n  //for (const sf::Sprite& sprite : m_lightGrid)\n  //{\n  //  m_window.draw(sprite);\n  //}\n\n // Draw level light.\n for (const sf::Sprite& sprite : m_lightGrid)\n {\n m_window.draw(sprite);\n }\n\n```"]