["```cpp\n// Calculate the absolute difference in X.\ndiffX = abs(-4 \u2013 5) = 9;\n\n// Calculate the absolute difference in Y.\ndiffY = abs(4 - -3) = 7;\n\n// Add them to get the Manhattan distance.\nmanhattenDistance = 9 + 7 = 16;\n```", "```cpp\n// The level tile/node type.\nstruct Tile {\n    TILE type;          // The type of tile this is.\n    int columnIndex;    // The column index of the tile.\n    int rowIndex;       // The row index of the tile.\n    sf::Sprite sprite;  // The tile sprite.\n    int H;              // Heuristic / movement cost to goal.\n    int G;              // Movement cost. (Total of entire path).\n    int F;              // Estimated cost for full path. (G + H).\n    Tile* parentNode;   // Node to reach this node.\n};\n```", "```cpp\npublic:\n/**\n* Resets the A* data of all level tiles.\n*/\nvoid ResetNodes();\n```", "```cpp\n// Resets the A* data of all tiles.\nvoid Level::ResetNodes()\n{\n    for (int i = 0; i < GRID_WIDTH; ++i)\n    {\n        for (int j = 0; j < GRID_HEIGHT; ++j)\n        {\n            m_grid[i][j].parentNode = nullptr;\n            m_grid[i][j].H = 0;\n            m_grid[i][j].G = 0;\n            m_grid[i][j].F = 0;\n        }\n    }\n}\n```", "```cpp\npublic:\n/**\n* Recalculates the target position of the enemy.\n*/\nvoid UpdatePathfinding(Level& level, sf::Vector2fplayerPosition);\n```", "```cpp\nprivate:\n/**\n* The target positions of the enemy.\n*/\nstd::vector<sf::Vector2f> m_targetPositions;\n\n/**\n* The current target of the enemy.\n*/\nsf::Vector2f m_currentTarget;\n```", "```cpp\n// Updates the target position of the enemy.\nvoid Enemy::UpdatePathfinding(Level& level, sf::Vector2f playerPosition)\n{\n    // . . .\n```", "```cpp\n    // Create all variables.\n    std::vector<Tile*> openList;\n    std::vector<Tile*> closedList;\n    std::vector<Tile*> pathList;\n    std::vector<Tile*>::iterator position;\n    Tile* currentNode;\n```", "```cpp\n// Reset all nodes.\nlevel.ResetNodes();\n```", "```cpp\n// Store the start and goal nodes.\nTile* startNode = level.GetTile(m_position);\nTile* goalNode = level.GetTile(playerPosition);\n```", "```cpp\n// Check we have a valid path to find. If not we can just end the function as there's no path to find.\nif (startNode == goalNode)\n{\n    // Clear the vector of target positions.\n    m_targetPositions.clear();\n\n    // Exit the function.\n    return;\n}\n```", "```cpp\n// Pre-compute our H cost (estimated cost to goal) for each node.\nfor (int i = 0; i < level.GetSize().x; ++i)\n{\n    for (int j = 0; j < level.GetSize().y; ++j)\n    {\n        int rowOffset, heightOffset;\n        Tile* node = level.GetTile(i, j);\n\n        heightOffset = abs(node->rowIndex - goalNode->rowIndex);\n        rowOffset = abs(node->columnIndex - goalNode-> columnIndex);\n\n        node->H = heightOffset + rowOffset;\n    }\n}\n```", "```cpp\n// Add the start node to the open list.\nopenList.push_back(startNode);\n```", "```cpp\n// While we have values to check in the open list.\nwhile (!openList.empty())\n{\n```", "```cpp\n// Find the node in the open list with the lowest F value and mark it as current.\nint lowestF = INT_MAX;\n\nfor (Tile* tile : openList)\n{\n    if (tile->F < lowestF)\n    {\n        lowestF = tile->F;\n        currentNode = tile;\n    }\n}\n```", "```cpp\n// Remove the current node from the open list and add it to the closed list.\nposition = std::find(openList.begin(), openList.end(), currentNode);\nif (position != openList.end())\n    openList.erase(position);\n\nclosedList.push_back(currentNode);\n```", "```cpp\n// Find all valid adjacent nodes.\nstd::vector<Tile*> adjacentTiles;\n\nTile* node;\n\n// Top.\nnode = level.GetTile(currentNode->columnIndex, currentNode-> rowIndex - 1);\nif ((node != nullptr) && (level.IsFloor(*node)))\n{\n    adjacentTiles.push_back(level.GetTile(currentNode-> columnIndex, currentNode->rowIndex - 1));\n}\n\n// Right.\nnode = level.GetTile(currentNode->columnIndex + 1, currentNode-> rowIndex);\nif ((node != nullptr) && (level.IsFloor(*node)))\n{\n    adjacentTiles.push_back(level.GetTile(currentNode->columnIndex + 1, currentNode->rowIndex));\n}\n\n// Bottom.\nnode = level.GetTile(currentNode->columnIndex, currentNode-> rowIndex + 1);\nif ((node != nullptr) && (level.IsFloor(*node)))\n{\n    adjacentTiles.push_back(level.GetTile(currentNode-> columnIndex, currentNode->rowIndex + 1));\n}\n\n// Left.\nnode = level.GetTile(currentNode->columnIndex - 1, currentNode-> rowIndex);\nif ((node != nullptr) && (level.IsFloor(*node)))\n{\n    adjacentTiles.push_back(level.GetTile(currentNode->columnIndex - 1, currentNode->rowIndex));\n}\n```", "```cpp\n// For all adjacent nodes.\nfor (Tile* node : adjacentTiles)\n{\n```", "```cpp\n// If the node is our goal node.\nif (node == goalNode)\n{\n```", "```cpp\n// Parent the goal node to current.\nnode->parentNode = currentNode;\n```", "```cpp\n// Store the current path.\nwhile (node->parentNode != nullptr)\n{\n    pathList.push_back(node);\n    node = node->parentNode;\n}\n```", "```cpp\n    // Empty the open list and break out of our for loop.\n    openList.clear();\n    break;\n}\nelse\n{\n```", "```cpp\n// If the node is not in the closed list.\nposition = std::find(closedList.begin(), closedList.end(), node);\nif (position == closedList.end())\n{\n```", "```cpp\n// If the node is not in the open list.\nposition = std::find(openList.begin(), openList.end(), node);\nif (position == openList.end())\n{\n```", "```cpp\n// Add the node to the open list.\nopenList.push_back(node);\n\n// Set the parent of the node to the current node.\nnode->parentNode = currentNode;\n```", "```cpp\n// Calculate G (total movement cost so far) cost.\nnode->G = currentNode->G + 10;\n```", "```cpp\n// Calculate the F (total movement cost + heuristic) cost.\nnode->F = node->G + node->H;\n```", "```cpp\n}\nelse\n{\n    // Check if this path is quicker that the other.\n    int tempG = currentNode->G + 10;\n\n    // Check if tempG is faster than the other. I.e, whether it's faster to go A->C->B that A->C.\n    if (tempG < node->G)\n    {\n        // Re-parent node to this one.\n        node->parentNode = currentNode;\n    }\n}}}}}\n```", "```cpp\n/**\n* The target positions of the enemy.\n*/\nstd::vector<sf::Vector2f> m_targetPositions;\n```", "```cpp\n// Clear the vector of target positions.\nm_targetPositions.clear();\n```", "```cpp\n// Store the node locations as the enemies target locations.\nfor (Tile* tile : pathList)\n{\n    m_targetPositions.push_back(level.GetActualTileLocation(tile-> columnIndex, tile->rowIndex));\n}\n```", "```cpp\n// Store the node locations as the enemies target locations.\nfor (Tile* tile : pathList)\n{\n    m_targetPositions.push_back(level.GetActualTileLocation(tile-> columnIndex, tile->rowIndex));\n}\n\n// Reverse the target position as we read them from goal to origin and we need them the other way around.\nstd::reverse(m_targetPositions.begin(), m_targetPositions.end());\n\n```", "```cpp\npublic:\n/**\n * Overrides the default Update function in Enemy\n */\nvoid Update(float timeDelta) override;\n```", "```cpp\n// Updates the enemy.\nvoid Enemy::Update(float timeDelta)\n{\n    // Move towards current target location.\n    if (!m_targetPositions.empty())\n    {\n        sf::Vector2f targetLocation = m_targetPositions.front();\n        m_velocity = sf::Vector2f(targetLocation.x - m_position.x, targetLocation.y - m_position.y);\n\n        if (abs(m_velocity.x) < 10.f && abs(m_velocity.y) < 10.f)\n        {\n            m_targetPositions.erase(m_targetPositions.begin());\n        }\n        else\n        {\n            float length = sqrt(m_velocity.x * m_velocity.x + m_velocity.y * m_velocity.y);\n            m_velocity.x /= length;\n            m_velocity.y /= length;\n\n            m_position.x += m_velocity.x * (m_speed * timeDelta);\n            m_position.y += m_velocity.y * (m_speed * timeDelta);\n\n            m_sprite.setPosition(m_position);\n        }\n    }\n\n    // Call character update.\n    Entity::Update(timeDelta);\n}\n```", "```cpp\n/**\n * The last tile that the player was on.\n */\nTile* m_playerPreviousTile;\n```", "```cpp\n// Check if the player has moved grid square.\nTile* playerCurrentTile = m_level.GetTile(playerPosition);\n\nif (m_playerPreviousTile != playerCurrentTile)\n{\n    // Store the new tile.\n    m_playerPreviousTile = playerCurrentTile;\n\n    // Update path finding for all enemies if within range of the player.\n    for (const auto& enemy : m_enemies)\n    {\n        if (DistanceBetweenPoints(enemy->GetPosition(), playerPosition) < 300.f)\n            enemy->UpdatePathfinding(m_level, playerPosition);\n    }\n}\n```", "```cpp\npublic:\n/**\n * Override the default draw function.\n */\nvoid Draw(sf::RenderWindow& window, float timeDelta) override;\n\nprivate:\n/**\n * Debug sprite for path\n */\nsf::Sprite m_pathSprite;\n\n/**\n * Debug font for the path\n */\nsf::Font m_font;\n\n/**\n * Debug text for the path\n */\nsf::Text m_text;\n```", "```cpp\n// Set the sprite.\nint textureID = TextureManager::AddTexture(\"../resources/spr_path.png\");\nm_pathSprite.setTexture(TextureManager::GetTexture(textureID));\n\n// Set the sprite origin.\nsf::Vector2u spriteSize = m_pathSprite.getTexture()->getSize();\nm_pathSprite.setOrigin(sf::Vector2f(static_cast<float>(spriteSize.x / 2), static_cast<float>(spriteSize.y / 2)));\n\n// Set the font.\nm_font.loadFromFile(\"../resources/fonts/04B_03__.TTF\");\n\n// Set the text.\nm_text.setFont(m_font);\nm_text.setCharacterSize(12);\n```", "```cpp\n// Override the default draw function.\nvoid Enemy::Draw(sf::RenderWindow& window, float timeDelta)\n{\n    Object::Draw(window, timeDelta);\n\n    // DEBUG Draw the current path\n    for (int i = 0; i < m_targetPositions.size(); i++)\n    {\n        // draw the path sprite\n        m_pathSprite.setPosition(m_targetPositions[i]);\n        window.draw(m_pathSprite);\n\n        // set the path index\n        std::ostringstream ss;\n        ss << i;\n        std::string str(ss.str());\n        m_text.setString(str);\n        m_text.setPosition(m_targetPositions[i]);\n        window.draw(m_text);\n    }\n}\n```", "```cpp\nprivate:\n/**\n * Generates a level goal.\n */\nvoid GenerateLevelGoal();\n```", "```cpp\nprivate:\n/**\n * The value of gold remaining for the current goal.\n */\nint m_goldGoal;\n\n/**\n * The value of gems remaining for the current goal.\n */\nint m_gemGoal;\n\n/**\n * The number of kills remaining for the current goal.\n */\nint m_killGoal;\n```", "```cpp\n/**\n * A string describing the current level goal.\n */\nsf::String m_goalString;\n\n/**\n * A boolean denoting if a goal is currently active.\n */\nbool m_activeGoal;\n```", "```cpp\n// Generates a random level goal.\nvoid Game::GenerateLevelGoal()\n{\n    std::ostringstream ss;\n\n    // Reset our goal variables.\n    m_killGoal = 0;\n    m_goldGoal = 0;\n    m_gemGoal = 0;\n\n    // Choose which type of goal is to be generated.\n    int goalType = rand() % 3;\n\n    switch (goalType)\n    {\n        case 0:    // Kill X Enemies\n        break;\n\n        case 1:    // Collect X Gold\n        break;\n\n        case 2:    // Collect X Gems\n        break;\n    }\n}\n```", "```cpp\nswitch (goalType)\n{\ncase 0:        // Kill X Enemies\n    m_killGoal = rand() % 6 + 5;\n\n    // Create the string describing the goal.\n    ss << \"Current Goal: Kill \" << m_killGoal << \" enemies\" << \"!\" << std::endl;\n    break;\n\ncase 1:        // Collect X Gold\n    m_goldGoal = rand() % 51 + 50;\n\n    // Create the string describing the goal.\n    ss << \"Current Goal: Collect \" << m_goldGoal << \" gold\" << \"!\" << std::endl;\n    break;\n\ncase 2:        // Collect X Gems\n    m_gemGoal = rand() % 6 + 5;\n\n    // Create the string describing the goal.\n    ss << \"Current Goal: Collect \" << m_gemGoal << \" gems\" << \"!\" << std::endl;\n    break;\n}\n\n// Store our string.\nm_goalString = ss.str();\n```", "```cpp\n    // Set the goal as active.\n    m_activeGoal = true;\n}\n```", "```cpp\n// Generates a random level goal.\nvoid Game::GenerateLevelGoal()\n{\n    std::ostringstream ss;\n\n    // Choose which type of goal is to be generated.\n    int goalType = rand() % 3;\n\n    switch (goalType)\n    {\n    case 0:        // Kill X Enemies\n        m_killGoal = rand() % 6 + 5;\n\n        // Create the string describing the goal.\n        ss << \"Current Goal: Kill \" << m_killGoal << \" enemies\" << \"!\" << std::endl;\n        break;\n\n    case 1:        // Collect X Gold\n        m_goldGoal = rand() % 51 + 50;\n\n        // Create the string describing the goal.\n        ss << \"Current Goal: Collect \" << m_goldGoal << \" gold\" << \"!\" << std::endl;\n        break;\n\n    case 2:        // Collect X Gems\n        m_gemGoal = rand() % 6 + 5;\n\n        // Create the string describing the goal.\n        ss << \"Current Goal: Collect \" << m_gemGoal << \" gems\" << \"!\" << std::endl;\n        break;\n    }\n\n// Store our string.\nm_goalString = ss.str();\n\n    // Set the goal as active.\n    m_activeGoal = true;\n}\n```", "```cpp\n// DEBUG: Generate a level goal.\nGenerateLevelGoal();\n```", "```cpp\n// If the enemy is dead remove it.\nif (enemy.IsDead())\n{\n    enemyIterator = m_enemies.erase(enemyIterator);\n\n    // If we have an active goal decrement killGoal.\n if (m_activeGoal)\n {\n --m_killGoal;\n }\n}\n```", "```cpp\nswitch (m_items[i]->GetType())\n{\ncase GAME_OBJECT::GOLD:\n{\n    // cast the item to a gold type\n    Gold& gold = dynamic_cast<Gold&>(*m_items[i]);\n\n    . . .\n\n    // Check if we have an active level goal.\n if (m_activeGoal)\n {\n m_goldGoal -= gold.GetGoldValue();\n }\n}\nbreak;\n\ncase GAME_OBJECT::GEM:\n{\n    // cast the item to a gem type\n    Gem& gem = dynamic_cast<Gem&>(*m_items[i]);\n\n    . . .\n\n    // Check if we have an active level goal.\n if (m_activeGoal)\n    {\n --m_gemGoal;\n    }\n}\nbreak;\n\n. . .\n```", "```cpp\n// Check if we have completed an active goal.\nif (m_activeGoal)\n{\n    if ((m_gemGoal <= 0) &&\n        (m_goldGoal <= 0) &&\n        (m_killGoal <= 0))\n    {\n        m_scoreTotal += std::rand() % 1001 + 1000;\n        m_activeGoal = false;\n    }\n}\n```", "```cpp\n// Draw the level goal if active.\nif (m_activeGoal)\n{\n    DrawString(m_goalString, sf::Vector2f(m_window.getSize().x / 2, m_window.getSize().y - 75), 30);\n}\n```", "```cpp\n// Check if we have completed an active goal.\nif (m_activeGoal)\n{\n    if ((m_gemGoal <= 0) &&\n        (m_goldGoal <= 0) &&\n        (m_killGoal <= 0))\n    {\n        m_scoreTotal += std::rand() % 1001 + 1000;\n        m_activeGoal = false;\n    }\n    else\n    {\n        std::ostringstream ss;\n\n        if (m_goldGoal > 0)\n            ss << \"Current Goal: Collect \" << m_goldGoal << \" gold\" << \"!\" << std::endl;\n        else if (m_gemGoal > 0)\n            ss << \"Current Goal: Collect \" << m_gemGoal << \" gem\" << \"!\" << std::endl;\n        else if (m_killGoal > 0)\n            ss << \"Current Goal: Kill \" << m_killGoal << \" enemies\" << \"!\" << std::endl;\n\n        m_goalString = ss.str();\n    }\n}\n```"]