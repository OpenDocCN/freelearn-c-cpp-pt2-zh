- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Executing Custom Tasks with CMake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and shipping software can be a complex task, and no tool can ever do
    all the different tasks that are needed to build and ship a project. At some point,
    you may want to execute a task that is not covered by a compiler or CMake’s functionality.
    Common tasks include archiving build artifacts, creating hashes to verify downloads,
    or generating or customizing input files for a build. There are also lots of other
    specialized tasks that depend on the environment that certain software is built
    in.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to include such custom tasks in a CMake project
    and how to create custom build targets and custom commands. We will go over how
    to create and manage dependencies between targets and how to include or exclude
    them from standard builds.
  prefs: []
  type: TYPE_NORMAL
- en: Including such external programs in the build steps of a project can help ensure
    that code is kept consistent, even when many people contribute to it. As a CMake
    build is very easy to automate, using CMake to invoke the necessary commands makes
    it easy to apply these tools to various machines or a CI environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how custom tasks can be defined and how to control
    when they are executed. In particular, we will focus on managing the dependency
    between custom tasks and regular targets. As CMake is often used to provide build
    information across multiple platforms, you will also learn how to define common
    tasks so that they run everywhere where CMake runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using external programs with CMake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing custom tasks at build time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing custom tasks at configuration time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying and modifying files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CMake for platform-independent commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the previous chapters, the examples in this chapter have been tested
    with CMake 3.21 and can run on any of the following compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: GCC 9 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang 12 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSVC 19 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the examples and source code for this chapter are available in this book’s
    GitHub repository at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
    If any of the software is missing, the corresponding examples will be excluded
    from the build.
  prefs: []
  type: TYPE_NORMAL
- en: Using external programs with CMake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CMake has pretty broad functionality, so it can cover many tasks when building
    software. However, there are situations when developers will need to do something
    that is not covered. Common examples include running special tools that do some
    pre-or post-processing of files for a target, using source code generators that
    produce input for the compiler, and compressing and archiving artifacts that are
    not handled with CPack. The list of such special tasks that must be accomplished
    during a build step is probably near-endless. CMake supports three ways of executing
    custom tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: By defining a target that executes a command with `add_custom_target`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By attaching a custom command to an existing target by using `add_custom_command`,
    or by making a target depend on a file that’s been generated by a custom command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using the `execute_process` function, which executes a command during the
    configuration step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever possible, external programs should be called during the build step,
    as the configuration step is far less controllable by the user and should generally
    run as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to define tasks that run at build time.
  prefs: []
  type: TYPE_NORMAL
- en: Executing custom tasks at build time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most generic way to add a custom task is by creating a custom target that
    executes an external task as a sequence of commands. Custom targets are handled
    like any other library or executable target, with the difference that they do
    not invoke the compiler and linker; instead, they do something defined by the
    user. Custom targets are defined using the `add_custom_target` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The core of the `add_custom_target` command is the list of commands that are
    passed with the `COMMAND` option. Although the first command can be passed without
    this option, it is good practice to always add the `COMMAND` option to any `add_custom_target`
    call. By default, custom targets are only executed if they’re explicitly requested
    unless the `ALL` option is specified. Custom targets are always considered out
    of date, so the commands specified internally are always run, regardless of whether
    they produce the same result repeatedly. With the `DEPENDS` keyword, custom targets
    can be made to depend on the files and outputs of custom commands that have been
    defined with the `add_custom_command` function or by other targets. To make the
    custom target depend on another target, use the `add_dependencies` function. The
    same works the other way around – any target may depend on a custom target. If
    the custom target creates files, these can be listed under the `BYPRODUCTS` option.
    Any file that’s listed there will be marked with the `GENERATED` property, which
    is used by CMake to determine whether a build is out of date and to find out which
    files to clean. However, tasks that create files using `add_custom_command` might
    be better suited, as described later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: By default, these commands are executed in the current binary directory, which
    is stored in the `CMAKE_CURRENT_BINARY_DIRECTORY` cache variable. If necessary,
    this can be changed with the `WORKING_DIRECTORY` option. This option can either
    be an absolute path or a relative path, if it is a relative path to the current
    binary directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `COMMENT` option is used to specify a message that is printed right before
    the command runs, which can come in handy if a command runs silently. Unfortunately,
    not all generators show these messages, so using this to display critical information
    is somewhat unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: The `VERBATIM` flag causes all the commands to be passed directly to the platform
    without further escaping or variable substitution by the underlying shell. CMake
    itself will still replace variables that are passed to the commands or the arguments.
    Whenever escaping might be an issue, passing the `VERBATIM` flag is recommended.
    It is also good practice to write custom tasks so that they are independent of
    the underlying platform. You can find more tips on how to create platform-independent
    commands later in this chapter, in the *Using CMake for platform-independent*
    *commands* section.
  prefs: []
  type: TYPE_NORMAL
- en: The `USES_TERMINAL` option instructs CMake to give the command access to the
    terminal if possible. If the Ninja generator is used, this means that it runs
    in the `terminal` job pool. All the commands in this pool are executed serially.
  prefs: []
  type: TYPE_NORMAL
- en: The `JOB_POOL` option can be used when you’re generating with Ninja to control
    the concurrency of a job. It is rarely used and cannot be used together with the
    `USES_TERMINAL` flag. You will rarely need to interfere with Ninja’s job pool,
    and handling it is not trivial. If you wish to learn more, further information
    can be found in the official documentation for CMake’s `JOB_POOLS` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `SOURCES` properties take a list of source files that are associated with
    the custom target. The property does not affect the source files but can help
    make the files visible in some IDEs. If a command relies on files such as scripts
    that are delivered together with a project, these should be added here.
  prefs: []
  type: TYPE_NORMAL
- en: The `COMMAND_EXPAND_LISTS` option tells CMake to expand lists before passing
    them to the command. This is sometimes necessary because, in CMake, lists are
    just strings separated by semicolons, which may lead to syntax errors. When you
    pass the `COMMAND_EXPAND_LISTS` option, the semicolons are replaced with a suitable
    whitespace character, depending on the platform. The expansion includes lists
    that have been generated using the `$<JOIN:` generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a custom target that uses an external program
    called *CreateHash* to create a hash for the output of another target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This example creates a custom target called *CreateHash* that invokes the external
    *SomeHasher* program, with the binary file of the *SomeExe* target as an argument.
    Note that the binary file is retrieved using the `$<TARGET_FILE:SomeExe>` generator
    expression. This serves two purposes – it removes the need for the user to track
    the filename of the binary of the target, and it adds an implicit dependency between
    the two targets. CMake will recognize these implicit dependencies and execute
    the targets in the correct order. If the target that produces the required file
    hasn’t been built yet, CMake will automatically build it. You can also use the
    `$<TARGET_FILE:` generator to directly execute an executable that’s been created
    by another target. The following generator expressions cause implicit dependencies
    between targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$<TARGET_FILE:target>`: This contains the full path to the main binary file
    of the target, such as `.exe`, `.so`, or `.dll`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<TARGET_LINKER_FILE: target >`: This contains the full path to the file that’s
    used to link against the target. This is usually the library file itself, except
    on Windows, where the `.lib` file will be associated with the DLL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<TARGET_SONAME_FILE: target >`: This contains the library file and its full
    name, including any number that’s been set by the `SOVERSION` property, such as
    `.so.3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<TARGET_PDB_FILE: target >`: This contains the full path to the generated
    program database file that’s used for debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom targets is one way to execute external tasks during build time.
    Another way is to define custom commands. Custom commands can be used to add custom
    tasks to existing targets, including custom targets.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom tasks to existing targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to perform an additional, external task when building
    a target. In CMake, you can achieve this with `add_custom_command`, which has
    two signatures. One is used to hook commands into existing targets, while the
    other is used to generate files. We will cover this later in this section. The
    signature to add commands to an existing target looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the options work similarly to those in `add_custom_target`, as described
    earlier. The `TARGET` property can be any target that is defined in the current
    directory, which is a limitation of the command, although it is rarely an issue.
    Commands can be hooked into the build at the following times:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PRE_BUILD`: In Visual Studio, this command is executed before any other build
    steps are executed. When you use other generators, it will run just before the
    `PRE_LINK` commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRE_LINK`: This command will run after the sources have been compiled but
    before the executable or archiver tool has been linked to static libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST_BUILD`: This runs the command after all the other build rules have been
    executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common way to execute custom steps is by using `POST_BUILD`; the other
    two options are rarely used, either because of limited support or because they
    can neither influence the link nor the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a custom command to an existing target is relatively straightforward.
    The following code adds a command that generates and stores the hash of a built
    file after each compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a custom executable called `hasher` is used to generate the
    hash of the output file of the `MyExectuable` target.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the reason you may need to execute something before a build is to change
    files or to generate additional information. For this, a second signature is often
    the better choice. Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Generating files with custom tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typically, we want custom tasks to produce a specific output file. This can
    be done by defining custom targets and setting the necessary dependencies between
    the targets, or by hooking into the build steps, as described earlier. Unfortunately,
    the `PRE_BUILD` hook is unreliable because only the Visual Studio generator supports
    it properly. Therefore, a better way to do this is to create a custom command
    that creates the file, by using the second signature of the `add_custom_command`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This signature of `add_custom_command` defines a command that generates a file
    specified in `OUTPUT`. Most of the options of the command are very similar to
    `add_custom_target` and the signature to hook custom tasks into build steps. The
    `DEPENDS` option can be used to manually specify a dependency to either files
    or targets. Note that, in comparison, the `DEPENDS` option of custom targets can
    only point to files. If any of the dependencies are updated by a build or CMake,
    the custom command is run again. The `MAIN_DEPENDENCY` option is closely related,
    which specifies the primary input file for the command. It works like the `DEPENDS`
    option does, except that it only takes one file. `MAIN_DEPENDENCY` is mainly used
    to tell Visual Studio where to add the custom command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If a source file is listed as `MAIN_DEPENDENCY`, then the custom command replaces
    the normal compilation of the file listed, which can lead to linker errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two dependency-related options, `IMPLICIT_DEPENDS` and `DEPFILE`,
    are rarely used because their support is limited to the Makefile generator. `IMPLICT_DEPENDS`
    tells CMake to use a C or C++ scanner to detect any compile-time dependencies
    of the files listed and create dependencies from that. The other option, `DEPFILE`,
    can be used to point to a `.d` dependency file, which is generated by the Makefile
    project. The `.d` files originally stem from the GNU Make project and can be powerful
    to use, but they are also complex and should not be manually managed for most
    projects. The following example illustrates how a custom command can be used to
    generate a source file before a regular target is run, based on another file that
    is used for input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Several things are happening in this example. First, the custom command defines
    the `main.cpp` file in the current binary directive as an `OUTPUT` file. Then,
    the command that generates this file is defined – here, an imaginary program called
    `sourceFileGenerator` is used – which converts a message file into a `.cpp` file.
    The `DEPENDS` part states that this command should be rerun every time the `message.txt`
    file changes.
  prefs: []
  type: TYPE_NORMAL
- en: Later, the target for the executable is created. Since the executable references
    the `main.cpp` file specified in the `OUTPUT` section of the custom command, CMake
    will implicitly add the necessary dependency between the command and the target.
    Using custom commands in this way is much more reliable and portable than using
    the `PRE_BUILD` directive, as it works with all generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, to create the desired output, more than one command is needed. If
    a previous command that produces the same output exists, commands can be chained
    by using the `APPEND` option. Custom commands that use `APPEND` may only define
    additional `COMMAND` and `DEPENDS` options; the other options are ignored. If
    two commands produce the same output file, CMake will print an error unless `APPEND`
    is specified. This is mainly useful if a command is only optionally executed.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the output file of a target, `MyTarget`, has been added to
    a `tar.gz` archive; later, another file is added to the same archive. Note that
    the first command automatically depends on `MyTarget` because it uses the binary
    file that was created in the command. However, it will not automatically be executed
    by a build. The second custom command lists the same output file as the first
    command but adds the compressed file as a second output. By specifying `APPEND`,
    the second command is automatically executed whenever the first command is executed.
    If the `APPEND` keyword is missing, CMake will print out an error, similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, the custom commands in this example implicitly
    depend on `MyTarget`, but they will not be executed automatically. To execute
    them, the recommended practice is to create a custom target that depends on the
    output file, which can be generated like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, a custom target called `create_archive` has been created that is executed
    as part of the `All` build. Since it depends on the output of the custom commands,
    building the target will invoke the custom commands. The custom commands, in turn,
    depend on `MyTarget`, so building `create_archive` will also trigger a build of
    `MyTarget` if it is not already up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `add_custom_command` and `add_custom_target` custom tasks are executed
    during the build step of CMake. It is possible to add tasks at configuration time
    if necessary. We’ll look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Executing custom tasks at configuration time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To execute custom tasks at configuration time, you can use the `execute_process`
    function. Common needs for this are if the build requires additional information
    before a build, or if files need to be updated for any rerun of CMake. Another
    common case is when either the `CMakeLists.txt` file or other input files are
    generated during the configuration step, although this can also be achieved with
    the specialized `configure_file` command, as shown later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `execute_process` function works very similarly to the `add_custom_target`
    and `add_custom_command` functions we saw earlier. However, one distinction is
    that `execute_process` can capture output to `stdout` and `stderr` in a variable
    or files. The signature of `execute_process` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `execute_process` function takes a list of `COMMAND` properties to be executed
    in `WORKING_DIRECTORY`. The return codes of the last command to be executed can
    be stored in the variable defined with `RESULT_VARIABLE`. Alternatively, a semicolon-separated
    list of variables can be passed to `RESULTS_VARIABLE`. If you use the `list` version,
    the commands will store the return code of the commands in the same order as the
    variables that have been defined. If fewer variables have been defined than commands,
    any surplus return code will be ignored. If `TIMEOUT` was defined and any of the
    child processes failed to return, the result variables will contain `timeout`.
    Since CMake version 3.19, the convenient `COMMAND_ERROR_IS_FATAL` option is available,
    which tells CMake to abort execution if any (or just the last) of the processes
    fails. This is much more convenient than retrieving all the return codes and then
    checking them individually after their execution. In the following example, if
    any of the commands return a non-zero value, the configuration step of CMake will
    fail with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Any output to `stdout` or `stderr` can be captured using the `OUTPUT_VARIABLE`
    or `ERROR_VARIABLE` variable, respectively. As an alternative, they can be redirected
    to files by using `OUTPUT_FILE` or `ERROR_FILE`, or can be completely ignored
    by passing `OUTPUT_QUIET` or `ERROR_QUIET`. Capturing the output in both a variable
    and a file is not possible and will result in either of the two being empty. Which
    one is kept and which is discarded depends on the platform. If not, the `OUTPUT_*`
    option specifies that the output is sent to the CMake process itself.
  prefs: []
  type: TYPE_NORMAL
- en: If the output is captured in a variable but can still be displayed, `ECHO_<STREAM>_VARIABLE`
    can be added. CMake can also be told to output the command itself by passing `STDOUT`,
    `STDERR`, or `NONE` to the `COMMAND_ECHO` option. However, if the output is captured
    in files, this will have no effect. If the same variable or file is specified
    for both `stdout` and `stderr`, then the results will be merged. If necessary,
    the input stream of the first command can be controlled by passing a file to the
    `INPUT_FILE` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to variables can be controlled in a limited way by using the `<STREAM>_STRIP_TRAILING_WHITESPACE`
    option, which will trim any whitespace at the end of the output. When you’re redirecting
    output to files, this has no effect. On Windows, the `ENCODING` option can be
    used to control the output. It takes the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NONE`: Performs no re-encoding. This will keep CMake’s internal encoding,
    which is UTF-8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTO`: Uses the current console’s encoding. If this is not available, it uses
    ANSI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANSI`: Uses the ANSI code page for encoding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OEM`: Uses the code page defined by the platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UTF8` or `UTF-8`: Forced to use the UTF-8 encoding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common reason for using `execute_process` is gathering information that is
    needed for a build and then passing it to a project. Consider an example where
    we want to compile the git revision into an executable by passing it as a preprocessor
    definition. The downside of this approach is that for the custom tasks to be executed,
    CMake has to be invoked, not just the build system. So, using `add_custom_command`
    with an `OUTPUT` parameter would probably be the more realistic solution here,
    but for illustrative purposes, this example should serve well enough. The following
    is an example where the git hash is read out at configuration time and passed
    as a compile definition to a target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `git` command that’s passed to `execute_process` is executed
    in the directory containing the `CMakeLists.txt` file, which is currently being
    executed. The resulting hash is stored in the `GIT_REVISION` variable, and if
    the command fails for any reason, the configuration process is halted with an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the information from `execute_process` into the compiler by using a
    preprocessor definition is far from optimal. A much nicer solution would be if
    we could generate a header file to be included that contains this information.
    CMake has another feature called `configure_file` that can be used for this purpose,
    as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and modifying files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A relatively common task when building software is that some files must be
    copied to a specific location before the build. Most file operations can be done
    using the `file()` command at configuration time. For instance, copying files
    is done by invoking the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several file operations available, such as `file(REMOVE)` and `file(REMOVE_RECURSE)`
    to delete files or directory trees, `file(RENAME)` to move files, and `file(CHMOD)`
    to change permissions on systems that support it. The full documentation of the
    `file` command is available here: [https://cmake.org/cmake/help/latest/command/file.html](https://cmake.org/cmake/help/latest/command/file.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to copy and modify a file at the same time? In the *Executing
    custom tasks at configuration time* section, we saw an example where the git revision
    was retrieved and passed to the compiler as a preprocessor definition. A much
    nicer way to do this would be to generate a header file containing the necessary
    information. While just echoing the code snippet and writing it into a file would
    be possible, it is dangerous, as it may lead to platform-specific code. CMake’s
    solution to this is the `configure_file` command, which can copy files from one
    location to another and modify their content while doing so. The signature of
    `configure_file` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `configure_file` function will copy the `<input>` file to the `<output>`
    file. If necessary, the path to the output file will be created, and the paths
    can be relative or absolute. If you’re using relative paths, the input file will
    be searched from the current source directory, but the path of the output file
    will be relative to the current build directory. If the output file cannot be
    written, the command will fail, and the configuration will be halted. By default,
    the output file has the same permissions as the target file, although ownership
    may change if the current user is a different one than the one that the input
    file belongs to. If `NO_SOURCE_PERMISSION` is added, the permissions are not transferred,
    and the output file gets the default `rw-r--r--` value. Alternatively, the permissions
    can be manually specified with the `FILE_PERMISSIONS` option, which takes a three-digit
    number as an argument. The `USE_SOURCE_PERMISSION` is already the default, and
    the option is only there to state the intent more explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, `configure_file` will also replace parts of the input
    file when you’re copying to the output path unless `COPYONLY` is passed. By default,
    `configure_file` will replace all the variables referenced as `${SOME_VARIABLE}`
    or `@SOME_VARIABLE@` with the value of any variable of the same name. If a variable
    is defined in `CMakeLists.txt`, when `configure_file` is called, the respective
    value is written into the output file. If a variable is not specified, the output
    file will contain an empty string in the respective place. Consider a `hello.txt.in`
    file that contains the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In a `CMakeLists.txt` file, the `configure_file` function is used to configure
    the `hello.txt.in` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the resulting `hello.txt` file will contain `Hello World from
    The Universe`. If the `@ONLY` option is passed to `configure_file`, only `@GREETER@`
    is replaced, and the resulting content is `Hello ${GUEST} from The Universe`.
    Using `@ONLY` is useful when you’re transforming CMake files that may contain
    brace-enclosed variables that should not be replaced. `ESCAPE_QUOTES` will escape
    any quotes in the target file with a backslash. By default, `configure_file` will
    transform the newline character so that the target file matches the current platform.
    The default behavior can be changed by setting `NEWLINE_STYLE`. `UNIX` or `LF`
    will use `\n` for newlines, while `DOS`, `WIN32`, and `CRLF` will use `\r\n`.
    Setting the `NEWLINE_STYLE` and `COPYONLY` options together will cause an error.
    Note that setting `COPYONLY` will not affect the newline style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the example where we want to compile the git revision into
    an executable. Here, we would write a header file as input. It may contain a line
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the example in the previous section, where the version information
    was passed as a compile definition, the git revision is first retrieved with `execute_process`.
    Later, the file is copied using `configure_file`, and `@GIT_REVISION@` is replaced
    with the short hash of the current commit.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with preprocessor definitions, `configure_file` will replace any
    lines in the form of `#cmakedefine VAR ...` with either `#define VAR` or `/* undef
    VAR */`, depending on whether `VAR` contains a value that CMake interprets as
    `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a file called `version.in.h` that contains the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The accompanying `CMakeLists.txt` file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the configuration has been run, if `GIT_REVISION_ENABLE` is on, the resulting
    file will contain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If `GIT_REVISION_ENABLE` is off, the resulting file will contain the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All in all, the `configure_file` command is quite useful to prepare input for
    a build. Apart from generating source files, it is often used to generate CMake
    files that are then included in a `CMakeLists.txt` file. One of the strengths
    of this is that it allows you to copy and modify files independent of the platform,
    which is a major advantage when you’re working cross-platform. Since `configure_file`
    and `execute_process` often go hand in hand, ensure that the commands that are
    executed are also platform-independent.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how CMake can be used to define platform-agnostic
    commands and scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Using CMake for platform-independent commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the keystones for the success of CMake is that it allows you to build
    the same software on a multitude of platforms. Conversely, this means that `CMakeLists.txt`
    must be written in a way that does not assume a certain platform or compiler must
    be used. This can be challenging, especially when you’re working with custom tasks.
    A big help here is that the `cmake` command-line utility supports the `-E` flag,
    which can be used to perform common tasks such as file operations and creating
    hashes. Most of the `cmake -E` commands are for file-related operations such as
    creating, copying, renaming, and deleting files, as well as creating directories.
    On systems that support filesystem links, CMake can also create symbolic links
    or hard links between files. Since CMake version 3.21, most of them are also available
    by using the `file()` command, but not all of them. Notably, creating hashes from
    files can be done in a platform-independent way with `cmake –``E <alogrithm>`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, CMake can create file archives using the `tar` command and concatenate
    text files with the `cat` command. It can also be used to create various hashes
    for files.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a few operations that provide information about the current system.
    The `capabilities` operation will print out CMake’s capabilities, such as knowing
    which generators are supported and the version that CMake is currently running.
    The `environment` command will print a list of environment variables that have
    been set.
  prefs: []
  type: TYPE_NORMAL
- en: You can get a full reference to the command-line options by running `cmake -E`
    without any other arguments. The online documentation for CMake can be found at
    [https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool](https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-command-line-tool).
  prefs: []
  type: TYPE_NORMAL
- en: Platform-agnostic file operations
  prefs: []
  type: TYPE_NORMAL
- en: Whenever file operations must be performed by a custom task, use `cmake –``E`
    .
  prefs: []
  type: TYPE_NORMAL
- en: With `cmake -E`, you can get pretty far in most cases. Sometimes, however, more
    complex operations need to be done. For this, CMake can run in script mode, which
    executes CMake files.
  prefs: []
  type: TYPE_NORMAL
- en: Executing CMake files as scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMake’s script mode is a very powerful feature when it comes to creating cross-platform
    scripts. It’s powerful because it allows you to create scripts that are completely
    platform-agnostic. By invoking `cmake -P <script>.cmake`, a specified CMake file
    is executed. The script files may not contain any commands that define a build
    target. Arguments may be passed as variables with the `-D` flag, but this must
    be done before the `-P` option. Alternatively, the arguments may only be appended
    after the script name so that they can be retrieved with the `CMAKE_ARGV[n]` variables.
    The number of arguments is stored in the `CMAKE_ARGC` variable. The following
    script, which generates the hash of a file and stores it in another, demonstrates
    how to use positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This script can be invoked with `cmake -P CreateSha256.cmake <input file> <output_file>`.
    Note that the first three arguments are occupied with `cmake`, `-P`, and the name
    of the script (`CreateSha256.cmake`). Although not strictly required, script files
    should always contain a `cmake_minimum_required` statement at the beginning. An
    alternative way to define the script without positional arguments would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the script would have to be invoked with the variables passed
    explicitly, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'These two approaches can also be combined. A common pattern is to expect all
    simple mandatory arguments as positional arguments and any optional or more complex
    arguments as defined variables. Combining script mode with `add_custom_command`,
    `add_custom_target`, or `execute_process` is a good way to create platform-independent
    build instructions. An example of generating hashes from the earlier sections
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Combining the script mode of CMake with the various ways to execute custom commands
    during the configuration or build phase of a project provides a lot of freedom
    when you’re defining build processes, even for different platforms. However, beware
    that adding too much logic to a build process may make it harder to maintain it
    than it should be. Whenever you need to write a script or add a custom command
    to a `CMakeLists.txt` file, it pays to take a quick break and consider whether
    this step belongs to the build process, or whether it is something better left
    to the user when they’re setting up the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to customize a build by executing external
    tasks and programs. We covered how to add custom build actions as targets, how
    to add them to existing targets, and how to execute them during the configuration
    step. We explored how commands can generate files and how CMake can copy and modify
    files with the `configure_file` command. Finally, we learned how the CMake command-line
    utility can be used to perform tasks in a platform-independent manner.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to customize a CMake build is a very powerful asset, but it also
    tends to make builds more brittle, as their complexity often increases when any
    customized tasks are performed. Although sometimes not avoidable, relying on external
    programs other than a compiler and linker being installed may mean that a piece
    of software can be built on a platform where those programs haven’t been installed
    or available. This means special care must be taken to ensure that custom tasks
    do not assume anything about the system using CMake if possible. Lastly, executing
    custom tasks may carry a performance penalty for a build system, especially if
    they do heavy work on each build.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are careful with custom build steps, they are a great way of
    increasing the cohesion of a build, as many of the build-related tasks can be
    defined where the build definition is. This can make automating tasks such as
    creating hashes of the build artifacts or assembling all the documents in a common
    archive much easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to make the build environment portable
    between different systems. You will learn how to use presets to define common
    ways to configure a CMake project, how to wrap your build environment into a container,
    and how to use `sysroots` to define toolchains and libraries as being portable
    between systems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the main difference between `add_custom_command` and `execute_process`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two signatures of `add_custom_command` used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the problem with the `PRE_BUILD`, `PRE_LINK`, and `POST_BUILD` options
    of `add_custom_command`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two ways of defining variables so that they can be substituted
    with `configure_file`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the substitution behavior of `configure_file` be controlled?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two flags for the CMake command-line tool to execute tasks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Commands that are added with `add_custom_command` are executed at build time,
    while commands that are added with `execute_process` are executed at configuration
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One signature is used to create custom build steps, while the other is used
    to generate files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only `POST_BUILD` is reliably supported across all generators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variables can be defined either as `${VAR}` or `@VAR@`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variable substitution can be controlled by either passing `@ONLY`, which only
    replaces variables defined as `@VAR@`, or by specifying the `COPYONLY` option,
    which does not perform any substitution at all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With `cmake -E`, common tasks can be executed directly. With `cmake -P`, `.cmake`
    files can be executed as scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
