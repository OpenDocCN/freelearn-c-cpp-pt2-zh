- en: '*Chapter 5*: Compiling C++ Sources with CMake'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simple compilation scenarios are usually handled by a default configuration
    of a toolchain or just provided out of the box by an IDE. However, in a professional
    setting, business needs often call for something more advanced. It could be a
    requirement for higher performance, smaller binaries, more portability, testing
    support, or extensive debugging capabilities – you name it. Managing all of these
    in a coherent, future-proof way quickly becomes a complex, tangled mess (especially
    when there are multiple platforms to support).
  prefs: []
  type: TYPE_NORMAL
- en: The process of compilation is often not explained well enough in books on C++
    (in-depth subjects such as virtual base classes seem to be more interesting).
    In this chapter, we'll go through the basics to ensure success when things don't
    go as planned. We'll discover how compilation works, what its internal stages
    are, and how they affect the binary output.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will focus on the prerequisites – we'll discuss what commands
    we can employ to tweak a compilation, how to require specific features from a
    compiler, and how to provide the compiler with the input files that it has to
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we'll focus on the first stage of compilation – the preprocessor. We'll
    be providing paths for included headers, and we'll study how to plug in variables
    from CMake and environments with preprocessor definitions. We'll cover some interesting
    use cases and learn how to expose CMake variables to C++ code in bulk.
  prefs: []
  type: TYPE_NORMAL
- en: Right after that, we'll talk about the optimizer and how different flags can
    affect performance. We'll also become painfully aware of the costs of optimization
    – how hard it is to debug mangled code.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we'll explain how to manage the compilation process in terms of reducing
    the compilation time using precompiled headers and unity builds, preparing for
    the discovery of mistakes, debugging a build, and storing the debugging information
    in the final binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preprocessor configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the optimizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the process of compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter05](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: 'To build examples provided in this book always use recommended commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compilation can be roughly described as a process of translating instructions
    written in a higher-level programming language to a low-level machine code. This
    allows us to create our applications using abstract concepts such as classes and
    objects and not bother with the tedious details of processor-specific assembly
    languages. We don't need to work directly with CPU registers, think about short
    or long jumps, and manage stack frames. Compiled languages are more expressive,
    readable, secure, and foster more maintainable code (but are still as performant
    as possible).
  prefs: []
  type: TYPE_NORMAL
- en: In C++, we rely on static compilation – an entire program has to be translated
    into native code before it is executed. This is an alternative approach to languages
    such as Java or Python, which compile a program on the fly with a special, separate
    interpreter every time a user runs it. There are certain advantages to each method.
    The policy of C++ is to provide as many high-level tools as possible while still
    being able to deliver native performance in a complete, self-contained application
    for almost every architecture out there.
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes a few steps to create and run a C++ program:'
  prefs: []
  type: TYPE_NORMAL
- en: Design your application and carefully write the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile individual `.cpp` implementation files (called translation units) to
    *object files*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link *object files* together in a single executable and add all other dependencies
    – dynamic and static libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run the program, the OS will use a tool called *loader* to map its machine
    code and all required dynamic libraries to the virtual memory. The loader then
    reads the headers to check where the program starts and hands over control to
    the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C++ runtime kicks in; a special `_start` function is executed to collect the
    command-line arguments and environment variables. It starts threading, initializes
    static symbols, and registers cleanup callbacks. Only then will it call `main()`,
    which is filled with code by the programmer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, quite a lot of work happens behind the scenes. This chapter
    is about the second step in the preceding list. By taking the whole picture into
    consideration, we can understand better where some of the possible issues come
    from. After all, there's no black magic in software (even if the impenetrable
    complexity makes it seem that way). Everything has an explanation and a reason.
    Things may fail during the runtime of a program because of how we compiled it
    (even if the compilation step itself has passed successfully). It's just not possible
    for a compiler to check all the edge cases during its work.
  prefs: []
  type: TYPE_NORMAL
- en: How compilation works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, compilation is the process of translating a higher-level
    language into a lower-level language – specifically, by producing machine code
    (instructions that a specific processor can directly execute) in a binary *object
    file* format specific for a given platform. On Linux, the most popular format
    is the **Executable and Linkable Format** (**ELF**). Windows uses a PE/COFF format
    specification. On macOS, we'll find Mach objects (the Mach-O format).
  prefs: []
  type: TYPE_NORMAL
- en: '*Object files* are the direct translation of a single source file. Each one
    of them has to be compiled separately and later joined by a linker into one executable
    or library. Thanks to this, when you change your code, you can save time by recompiling
    only the affected files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler has to execute the following stages to create an *object file*:'
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linguistic analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code emission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include` directives, replaces identifiers with defined values (`#define`
    directives and `-D` flags), invokes simple macros, and conditionally includes
    or excludes parts of code based on the `#if`, `#elif`, and `#endif` directives.
    The preprocessor is blissfully unaware of the actual C++ code and, in general,
    is just a slightly more advanced find-and-replace tool. Nevertheless, its job
    is critical in building advanced programs; the ability to break code up into parts
    and share declarations across multiple translation units is the foundation of
    code reusability.'
  prefs: []
  type: TYPE_NORMAL
- en: Next up is **linguistic analysis**. This is where more interesting things happen.
    The compiler will scan the file (containing all the headers included by the preprocessor)
    character by character and perform lexical analysis, grouping them into meaningful
    tokens – keywords, operators, variable names, and so on. Then, tokens are grouped
    into token chains and verified if their order and presence follow the rules of
    C++ – this process is called syntax analysis or parsing (usually, it's the most
    vocal part in terms of printed errors). Finally, semantic analysis is performed
    – the compiler tries to detect whether statements in a file actually make sense.
    For example, they have to meet type correctness checks (you can't assign an integer
    to a string variable).
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly** is nothing more than a translation of these tokens to CPU-specific
    instructions based on an instruction set available for the platform. Some compilers
    actually create an assembler output file, which is later passed to a dedicated
    assembler program to produce machine code that the CPU can execute. Others produce
    the same machine code directly from memory. Usually, such compilers include an
    option to produce a textual output of human-readable assembly code (although,
    just because you can read it, it doesn''t mean that it''s worth it).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimization** happens throughout the whole compilation, little by little,
    at every stage. There''s an explicit stage after producing the first assembly
    version, which is responsible for minimizing the usage of registers and removing
    unused code. One interesting and important optimization is in-line expansion or
    *inlining*. The compiler will "cut" the body of a function and "paste" it instead
    of its call (standard doesn''t define in which cases this happens – it depends
    on the implementation of the compiler). This process speeds up execution and reduces
    memory usage but has significant disadvantages for debugging (the executed code
    is no longer at the original line).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code emission** consists of writing the optimized machine code into an *object
    file* according to the format specified by the target platform. This *object file*
    is not ready to be executed – it has to be passed to the next tool, the linker,
    which will appropriately relocate the sections of our *object file* and resolve
    references to external symbols. This is the transformation from the ASCII source
    code into binary *object files* that are digestible by processors.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these stages is significant and can be configured to meet our specific
    needs. Let's look at how we can manage this process with CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Initial configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMake offers multiple commands to affect each stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target_compile_features()`: Require a compiler with specific features to compile
    this target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target_sources()`: Add sources to an already defined target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target_include_directories()`: Set up the preprocessor *include paths*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target_compile_definitions()`: Set up preprocessor definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target_compile_options()`: Compiler-specific options for the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target_precompile_headers()`: Optimize the compilation of external headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the preceding commands accept similar arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This means that they support property propagation, as discussed in the previous
    chapter, and can be used both for executables and libraries. Also, a reminder
    here – all of these commands support generator expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring specific features from the compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in the *Checking for supported compiler features* section in [*Chapter
    3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078), *Setting Up Your First CMake
    Project*, prepare for things going wrong and aim to provide the user of your software
    with a clear message – **available compiler X isn't providing required feature
    Y**. This is a much better experience than the user deciphering whatever error
    is produced by the incompatible toolchain they might have. We don't want users
    to assume that your code is at fault instead of their outdated environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command allows you to specify all the features that your target
    needs to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake understands C++ standards and supported compiler features for these `compiler_ids`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppleClang`: Apple Clang for Xcode versions 4.4+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clang`: Clang Compiler versions 2.9+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GNU`: GNU Compiler versions 4.4+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MSVC`: Microsoft Visual Studio versions 2010+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SunPro`: Oracle Solaris Studio versions 12.4+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Intel`: Intel Compiler versions 12.1+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can, of course, use any of the `CMAKE_CXX_KNOWN_FEATURES` variable, but
    I recommend sticking to a general C++ standard – `cxx_std_98`, `cxx_std_11`, `cxx_std_14`,
    `cxx_std_17`, `cxx_std_20`, or `cxx_std_23`. Check out the *Further reading* section
    for more details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Managing sources for targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already know how to tell CMake which source files make up a single target
    – an executable or a library. We provide the list of files whenever we use `add_executable()`
    or `add_library()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you grow your solution, the list of files for each target grows too. We
    can end up with some really lengthy `add_...()` commands. How do we deal with
    that? One temptation might be to utilize the `file()` command in `GLOB` mode –
    it can collect all the files from subdirectories and store them in a variable.
    We could pass it as an argument to the target declaration and not bother with
    list files again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, the previously mentioned approach is not recommended. Let's figure
    out why. CMake generates buildsystems based on changes in the list files, so if
    no changes are made, your builds might break without any warning (which, as we
    know from long hours spent debugging, is the worst kind of breakage). Other than
    that, not having all sources listed in the target declaration will break code
    inspection in IDEs such as CLion (CLion only parses some of the commands to understand
    your project).
  prefs: []
  type: TYPE_NORMAL
- en: If it's not recommended to use variables in target declarations, how can we
    add source files conditionally, for example, when dealing with platform-specific
    implementation files such as `gui_linux.cpp` and `gui_windows.cpp`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `target_sources()` command to append files to a previously created
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/01-sources/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This way, each platform gets its own set of compatible files. That's great,
    but what about long lists of sources? Well, we'll just have to accept that some
    things aren't perfect just yet and keep adding them manually.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have established the key facts about compilation, let's take a closer
    look at the first step – preprocessing. As with all things in computer science,
    the devil is in the details.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessor configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preprocessor plays a huge role in the process of building. Maybe this is
    a little surprising, given how simple and limited its functionality is. In following
    sections, we'll cover providing paths to included files and using the preprocessor
    definitions. We'll also explain how we can use CMake to configure included headers.
  prefs: []
  type: TYPE_NORMAL
- en: Providing paths to included files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most basic feature of the preprocessor is the ability to include `.h`/`.hpp`
    header files with the `#include` directive. It comes in two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#include <path-spec>`: Angle-bracket form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#include "path-spec"`: Quoted form'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we know, the preprocessor will replace these directives with the contents
    of the file specified in `path-spec`. Finding these files may be an issue. Which
    directories do we search and in what order? Unfortunately, the C++ standard doesn't
    exactly specify that; we need to check the manual for the compiler we use.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the angle-bracket form will check standard *include directories*,
    including the directories where standard C++ library and standard C library headers
    are stored in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The quoted form will start searching for the included file in the directory
    of the current file and then check directories for the angle-bracket form.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake provides a command to manipulate paths being searched for the included
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can add custom paths that we'd like the compiler to check. CMake will add
    them to compiler invocations in the generated buildsystem. They will be provided
    with a flag appropriate for the specific compiler (usually, it's `-I`).
  prefs: []
  type: TYPE_NORMAL
- en: Using `BEFORE` or `AFTER` determines whether the path should be prepended or
    appended to the target `INCLUDE_DIRECTORIES` property. It's still up to the compiler
    to decide whether directories provided here will be checked before or after the
    default ones (usually, it's before).
  prefs: []
  type: TYPE_NORMAL
- en: The `SYSTEM` keyword informs the compiler that the provided directories are
    meant as standard system directories (to be used with the angle-bracket form).
    For many compilers, this value will be provided as a `-isystem` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessor definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember how I mentioned the preprocessor''s `#define` and `#if`, `#elif`,
    and `#endif` directives when describing the stages of compilation? Let''s consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/02-definitions/definitions.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As it is, this example does nothing; neither `ABC` nor `DEF` is defined (`DEF`
    would default to `0` in this example). We can easily change that by adding two
    lines at the top of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After compiling and executing this code, we can see both messages in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This seems easy enough, but what happens if we want to condition these sections
    based on external factors, such as an operating system, architecture, or something
    else? Good news! You can pass values from CMake to a C++ compiler, and it's not
    complicated at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `target_compile_definitions()` command will do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/02-definitions/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will behave exactly like the two `#define` statements, but
    we have the freedom to use CMake's variables and generator expressions, and we
    can put the command in a conditional block.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'These definitions are traditionally passed to the compiler with the `-D` flag
    – `-DFOO=1` – and some programmers still use that flag in this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target_compile_definitions(hello PRIVATE -DFOO)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake recognizes this and will remove any leading `-D` flags. It will also
    ignore empty strings, so it''s even okay to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target_compile_definitions(hello PRIVATE -D FOO)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-D` is a separate argument; it will become an empty string after removal,
    and then get ignored, correctly behaving as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: Common gotchas in unit-testing private class fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some online resources recommend using a combination of specific `-D` definitions
    with `#ifdef/ifndef` directives for the purposes of unit testing. The simplest
    possible approach is to wrap access specifiers in conditional inclusion and ignore
    them when `UNIT_TEST` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While this use case is very convenient (it allows tests to directly access private
    members), it's not very clean code. Unit tests should only test whether methods
    in the public interface work as expected and treat underlying implementation as
    a black-box mechanism. I recommend that you only use this as a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: Using git commit to track a compiled version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s think about use cases that benefit from knowing details about the environment
    or filesystem. One great example for professional settings might be passing the
    revision or commit `SHA` that was used to build the binary:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/03-git/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use it in our application, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/03-git/print_commit.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the preceding code requires a user to have `git` installed and available
    in their `PATH`. This is useful when programs running on our production hosts
    come from a continuous integration/deployment pipeline. If there's an issue with
    our software, we can quickly check which exact Git commit was used to build the
    faulty product.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of an exact commit is really useful for debugging purposes. For
    a single variable, it's not a lot of work, but what happens when we have dozens
    of variables we'd like to pass to our headers?
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passing definitions through `target_compile_definitions()` can be a bit of overhead
    if we have multiple variables. Can't we just provide a header file with placeholders
    referencing various variables and get CMake to fill them in?
  prefs: []
  type: TYPE_NORMAL
- en: 'Sure we can! With the `configure_file(<input> <output>)` command, we can generate
    new files from templates like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/04-configure/configure.h.in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/04-configure/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have CMake build an output file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/04-configure/<build_tree>/configure.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `@VAR@` and `${VAR}` variable placeholders were replaced
    with the values from the CMake list file. Additionally, `#cmakedefine` was replaced
    with `#define` for defined variables and `/* #undef VAR */` for undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need an explicit `#define 1` or `#define 0` for `#if` blocks, use `#cmakedefine01`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we use such a configured header in the application? We can simply include
    it in our implementation file:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/04-configure/configure.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And because we have added the binary tree to our *include paths* with the `target_include_directories()`
    command, we can compile the example and receive output populated from CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `configure_file()` command also has a number of formatting and file-permission
    options. Describing them here would be a bit too lengthy. If you're interested,
    check out the online documentation for details (the link is in the *Further reading*
    section).
  prefs: []
  type: TYPE_NORMAL
- en: After preparing a complete composite of our headers and source file, we can
    talk about how the output code is shaped during the next steps. As we can't influence
    the linguistic analysis or assembling directly (these steps follow strict standards),
    we definitely have access to the configuration of the optimizer. Let's learn how
    it can affect the end result.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the optimizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The optimizer will analyze the output of previous stages and use a multitude
    of tricks, which programmers would consider dirty, as they don't adhere to clean-code
    principles. That's okay – the critical role of the optimizer is to make code performant
    (that is, use few CPU cycles, few registers, and less memory). As the optimizer
    goes through the source code, it will transform it heavily so that it almost becomes
    unrecognizable. It turns into a specially prepared version for the target CPU.
  prefs: []
  type: TYPE_NORMAL
- en: The optimizer will not only decide which functions could be removed or compacted;
    it will also move code around or even significantly duplicate it! If it can determine
    with full certainty that some lines of code are meaningless, it will wipe them
    out from the middle of an important function (you won't even notice). It will
    reuse memory, so numerous variables can occupy the same slot in different periods
    of time. And it will transform your control structures into totally different
    ones if that means it can shave off a few cycles here and there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The techniques described here, if applied manually to source code by a programmer,
    would turn it into a horrible, unreadable mess. It would be hard to write and
    reason about. On the other hand, they are great if applied by compilers, which
    will follow the orders exactly as written. The optimizer is a ruthless beast that
    serves only one purpose: make the execution fast, no matter how mangled the output
    will be. Such output may contain some debugging information if we are running
    it in our test environment, or it may not, in order to make it difficult for unauthorized
    people to tamper with it.'
  prefs: []
  type: TYPE_NORMAL
- en: Each compiler has its own tricks up its sleeve, aligned with the platform and
    philosophy it follows. We'll take a look at the most common ones, available in
    GNU GCC and LLVM Clang, so that we can understand what is useful and possible.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the thing – many compilers won't enable any optimization by default (GCC
    included). This is okay in some cases but not so much in others. Why go slow when
    you can go fast? To change things, we can use the `target_compile_options()` command
    and specify exactly what we want from the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of this command is similar to others in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We provide the `target` command-line options to add and we specify the propagation
    keyword. When this command is executed, CMake will append the given options to
    the appropriate `COMPILE_OPTIONS` variable of the target. The optional `BEFORE`
    keyword may be used to specify that we'd like to prepend them instead. Order matters
    in some cases, so it's good that we can choose.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '`target_compile_options()` is a general command. It can also be used to provide
    other arguments to compiler-like `-D` definitions, for which CMake offers the
    `target_compile_definition()` command as well. It is always recommended to use
    the CMake commands wherever possible, as they work the same way across all supported
    compilers.'
  prefs: []
  type: TYPE_NORMAL
- en: Time to discuss the details. The subsequent sections will introduce various
    kinds of optimizations you can enable in most compilers.
  prefs: []
  type: TYPE_NORMAL
- en: General level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the different behaviors of the optimizer can be configured in depth by specific
    flags that we can pass as *compile options*. Getting to know all of them is time-consuming
    and requires a lot of knowledge about the internal workings of compilers, processors,
    and memory. What can we do if we just want the best possible scenario that works
    well in most cases? We can reach for a general solution – an optimization-level
    specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Most compilers offer four basic levels of optimization, from `0` to `3`. We
    specify them with the `-O<level>` option. `-O0` means *no optimization* and, usually,
    it's the default level for compilers. On the other hand, `-O2` is considered a
    *full optimization*, one that generates highly optimized code but at the cost
    of the slowest compilation time.
  prefs: []
  type: TYPE_NORMAL
- en: There's an in-between `-O1` level, which (depending on your needs) can be a
    good compromise – it enables a reasonable amount of optimization mechanisms without
    slowing the compilation too much.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can reach for `-O3`, which is *full optimization*, like `-O2`, but
    with a more aggressive approach to subprogram inlining and loop vectorization.
  prefs: []
  type: TYPE_NORMAL
- en: There are also some variants of the optimization that will optimize for the
    size (not necessarily the speed) of the produced file – `-Os`. There is a super-aggressive
    optimization, `-Ofast`, which is an `-O3` optimization that doesn't comply strictly
    with C++ standards. The most obvious difference is the usage of `-ffast-math`
    and `-ffinite-math` flags, meaning that if your program is about precise calculations
    (as most are), you might want to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake knows that not all compilers are made equal, and for that reason, it
    standardizes the experience for developers by providing some default flags for
    compilers. They are stored in system-wide (not target-specific) variables for
    used language (`CXX` for C++) and build configuration (`DEBUG` or `RELEASE`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_CXX_FLAGS_DEBUG` equals `-g`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CXX_FLAGS_RELEASE` equals `-O3 -DNDEBUG`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the debug configuration doesn't enable any optimizations and
    the release configuration goes straight for `O3`. If you like, you can change
    them directly with the `set()` command or just add a target compilation option,
    which will override this default behavior. The other two flags (`-g,` `-DNDEBUG`)
    are related to debugging – we'll discuss them in the *Providing information for
    the debugger* section.
  prefs: []
  type: TYPE_NORMAL
- en: Variables such as `CMAKE_<LANG>_FLAGS_<CONFIG>` are global – they apply to all
    targets. It is recommended to configure your targets through properties and commands
    such as `target_compile_options()` rather than relying on global variables. This
    way, you can control your targets at higher granularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'By choosing an optimization level with `-O<level>`, we indirectly set a long
    list of flags, each controlling a specific optimization behavior. We can then
    fine-tune the optimization by appending more flags, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable them with an `-f` option: `-finline-functions`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disable them with an `-fno` option: `-fno-inline-functions`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these flags are worth understanding better as they will often impact
    how your program works and how you can debug it. Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Function inlining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you will recall, compilers can be encouraged to inline some functions, either
    by *defining* a function inside a class *declaration* block or by explicitly using
    the `inline` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It's up to the compiler to decide whether a function will be inlined. If inlining
    is enabled and the function is used in a single place (or is a relatively small
    function used in a few places), then inlining will most likely happen.
  prefs: []
  type: TYPE_NORMAL
- en: It's a really curious optimization technique. It works by extracting the code
    from the function in question and putting it in all the places the function was
    called, replacing the original call and saving precious CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example using the class we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Without inlining, the code would execute in the `main()` frame until a method
    call. Then, it would create a new frame for `im_inlined()`, execute in a separate
    scope, and go back to the `main()` frame. The same would happen for the `me_too()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when inlining takes place, the compiler will replace the calls, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This isn't an exact representation because inlining happens at the level of
    assembly or machine code (and not the source code), but it conveys a general picture.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler does it to save time; it won't have to go through the creation
    and teardown of a new call frame, it doesn't have to look up the address of the
    next instruction to execute (and return to), and it can cache the instructions
    better as they are nearby.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, inlining has some important side effects; if the function is used
    more than once, it has to be copied to all places (meaning a bigger file size
    and more memory being used). Nowadays, this may not be so critical as it was in
    the past, but it's still relevant, as we constantly develop software that has
    to run on low-end devices without much RAM to spare.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, it affects us critically when we're debugging the code we wrote.
    Inlined code is no longer at the line number it was originally written, so it's
    not as easy (or sometimes even possible) to track. This is the exact reason why
    a debugger breakpoint placed in a function that was inlined never gets hit (although
    the code is still somehow executed). To avoid this issue, we simply have to disable
    inlining for debug builds (at the cost of not testing the exact same version as
    the release build).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that by specifying the `-O0` level for the target or going straight
    after the flags responsible:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-finline-functions-called-once`: GCC only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-finline-functions`: Clang and GCC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-finline-hint-functions`: Clang only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-finline-functions-called-once`: GCC only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can explicitly disable inlining with `-fno-inline-...`. In any case, for
    details, refer to the documentation of the specific version of your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Loop unrolling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loop unrolling is an optimization technique that is also known as loop unwinding.
    The general approach is to transform loops into a set of statements that achieve
    the same effect. By doing so, we'll trade the size of the program for execution
    speed, as we'll reduce or eliminate the instruction that controls the loop – pointer
    arithmetic or end-of-loop tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will be transformed into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The outcome will be the same, but we no longer have to allocate the `i` variable,
    increment it, or compare it three times with a value of `3`. If we call `func()`
    enough times in the lifetime of the program, unrolling even such a short and small
    function will make a significant difference.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to understand two limiting factors. Loop unrolling
    will only work if the compiler knows or can effectively estimate the amount of
    iterations. Secondly, loop unrolling can produce undesirable effects on modern
    CPUs, as increased code size might prevent effective caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each compiler offers a slightly different version of this flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-floop-unroll`: GCC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-funroll-loops`: Clang'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're in doubt, test extensively whether this flag is affecting your particular
    program and explicitly enable or disable it. Do note that on GCC, it is implicitly
    enabled with `-O3` as part of the implicitly enabled `-floop-unroll-and-jam` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Loop vectorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Single Instruction Multiple Data** (**SIMD**) is one of the mechanisms developed
    in the early 1960s to achieve parallelism. It works exactly as the name suggests;
    it can perform the same operation on multiple pieces of information at the same
    time. What does it mean in practice? Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, the preceding code would loop 128 times, but with a capable CPU,
    we can execute the code much faster by calculating two or more elements of the
    array at the same time. This works because there''s no dependency between consecutive
    elements and no overlap of data between arrays. Smart compilers can transform
    the preceding loop into something similar to this (which happens on the assembly
    level):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'GCC will enable such automatic vectorization of loops at `-O3`. Clang enables
    it by default. Both compilers offer different flags to enable/disable vectorization
    in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-ftree-vectorize -ftree-slp-vectorize` to enable in GCC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-fno-vectorize -fno-slp-vectorize` to disable in Clang (if things break)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance of vectorization comes from utilizing special instructions that
    CPU manufacturers provide, rather than just simply replacing the original form
    of the loop with the unrolled version. Therefore, it's not possible to achieve
    the same level of performance by doing it manually (also, it's not very clean
    code).
  prefs: []
  type: TYPE_NORMAL
- en: The role of the optimizer is important in enhancing the performance of the program
    during runtime. By employing its strategies effectively, we'll get more bang for
    our buck. Efficiency is important not only after the coding is completed but also
    as we work on the software. If the compilation times are lengthy, we can improve
    them by managing the process better.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the process of compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As programmers and build engineers, we need to consider the other aspects of
    compilation as well – the time it takes to complete, and how easy it is to spot
    and fix mistakes made during the process of building a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing compilation time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In busy projects that require many dozens of recompilations per day (or per
    hour), it's paramount that compilation is as quick as possible. This not only
    affects how tight your code-compile-test loop is but also affects your concentration
    and flow of work. Luckily, C++ is already pretty good at managing compilation
    time, thanks to separate translation units. CMake will take care of recompiling
    only sources that were impacted by recent changes. However, if we need to improve
    things even more, there are a couple of techniques we can use – header precompilation
    and unity builds.
  prefs: []
  type: TYPE_NORMAL
- en: Precompilation of headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Header files (`.h`) are included in the translation unit by the preprocessor
    before the actual compilation begins. It means that they have to be recompiled
    every time the `.cpp` implementation files change. On top of that, if multiple
    translation files are using the same shared header, it has to be compiled every
    time it's included. This is wasteful, but that's how things were for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, since version 3.16, CMake offers a command to enable header precompilation.
    This allows a compiler to process headers separately from the implementation file
    and speed up the compilation. This is the syntax for the provided command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The list of added headers is stored in the `PRECOMPILE_HEADERS` target property.
    As you'll know from [*Chapter 4*](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106),
    *Working with Targets*, we can use the propagated properties to share the headers
    with any depending targets by using the `PUBLIC` or `INTERFACE` keyword; however,
    this shouldn't be done for targets exported with the `install()` command. Other
    projects shouldn't be forced to consume our precompiled headers (as it's unconventional).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If you need precompiled headers internally and still want to install-export
    the target, the `$<BUILD_INTERFACE:...>` generator expression described in [*Chapter
    4*](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106), *Working with Targets*, will
    prevent headers from appearing in usage requirements. However, they will still
    be added to targets exported from the build tree with the `export()` command.
  prefs: []
  type: TYPE_NORMAL
- en: CMake will put all headers' names in a `cmake_pch.h|xx` file, which will then
    be precompiled to a compiler-specific binary file with a `.pch`, `.gch`, or `.pchi`
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/06-precompile/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: chapter05/06-precompile/hello.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that in our `main.cpp` file, we don't need to include `cmake_pch.h` or
    any other header – it will be force-included by CMake with compiler-specific command-line
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, I have used a built-in header; however, you can easily
    add your own headers with class or function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`header.h` is interpreted as relative to the current source directory and will
    be included with an absolute path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[["header.h"]]` is interpreted according to the compiler''s implementation
    and is usually found in the `INCLUDE_DIRECTORIES` variable. Use `target_include_directiories()`
    to configure it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some online references will discourage precompiling headers that aren't part
    of a standard library, such as `<iostream>`, or using precompiled headers altogether.
    This is because changing the list or editing a custom header will cause recompilation
    of all translation units in the target. With CMake, you don't need to worry as
    much, especially if you structure your project right (with relatively small targets,
    focused on a narrow domain). Every target has a separate precompiled header file
    that limits the fallout of header changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if your headers are considered fairly stable, you might
    decide that it''s a good idea to reuse precompiled headers from one target in
    another. CMake provides a handy command for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This sets the `PRECOMPILE_HEADERS_REUSE_FROM` property of the target reusing
    the headers and creates a dependency between these targets. By using this method,
    the consuming target can no longer specify its own precompiled headers. Additionally,
    all *compile options*, *compile flags*, and *compile definitions* must match between
    targets. Pay attention to requirements, especially if you have any headers that
    use the double bracket format (`[["header.h"]]`). Both targets need to set their
    *include paths* appropriately to make sure those headers are found by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Unity builds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CMake 3.16 also introduced another compilation time optimization feature – unity
    builds, also known as *unified build* or *jumbo build*. Unity builds combine multiple
    implementation source files with the `#include` directive (after all, a compiler
    doesn't know whether it's including headers or implementation). This has a few
    interesting implications – some are really useful and others are potentially harmful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the most obvious one – avoiding recompilation of headers
    in different translation units when CMake creates a unified build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When both of these sources contain a `#include "header.h"` line, it will only
    be parsed once thanks to *include guards* (assuming we didn't forget to add those).
    This isn't as elegant as precompiled headers, but it's an option.
  prefs: []
  type: TYPE_NORMAL
- en: The second benefit from this type of build is the fact that the optimizer may
    now act on a greater scale and optimize interprocedural calls across all bundled
    sources. This is similar to link-time optimization, as we discussed in [*Chapter
    2*](B17205_02_Final_JC_ePub.xhtml#_idTextAnchor051), *The CMake Language*.
  prefs: []
  type: TYPE_NORMAL
- en: However, these benefits come at a price. As we reduced the number of the *object
    files* and processing steps, we also increased the amount of necessary memory
    to process much larger files. Additionally, we reduced the amount of parallelizable
    work. Compilers aren't really that great at multithreaded compiling because they
    don't need to be – the buildsystem will usually kick-start many compilation tasks
    to execute all the files simultaneously on different threads. When we clump all
    files together, we make it much harder, as CMake will now schedule parallel builds
    across however many jumbo builds we create.
  prefs: []
  type: TYPE_NORMAL
- en: With unity builds, you also need to consider some C++ semantic implications
    that might not be so obvious to catch – anonymous namespaces hiding symbols across
    files are now scoped to the group. The same thing happens with static global variables,
    functions, and macro definitions. It may cause name collisions, or incorrect function
    overloads to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Jumbo builds are not desirable when recompiling, as they will compile many more
    files than needed. They work best when the code is meant to compile all files
    as fast as possible as a whole. Tests done on Qt Creator show that you can expect
    an improvement anywhere between 20% to 50% (depending on the compiler used).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable unity builds, we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `CMAKE_UNITY_BUILD` variable to `true` – it will initialize the `UNITY_BUILD`
    property on every target defined thereafter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually define `UNITY_BUILD` as `true` on every target that should use unity
    builds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second option is achieved by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By default, CMake will create builds containing eight source files, as specified
    by the `UNITY_BUILD_BATCH_SIZE` property of a target (copied at the creation of
    a target from the `CMAKE_UNITY_BUILD_BATCH_SIZE` variable). You can change the
    target property or default variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since version 3.18, you may decide that you''d like to explicitly define how
    files should be bundled with named groups. To do so, change the target''s `UNITY_BUILD_MODE`
    property to `GROUP` (the default is always `BATCH`). Then, you''ll need to assign
    your source files to groups by setting their `UNITY_GROUP` property to the name
    of your choosing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: CMake will then disregard `UNITY_BUILD_BATCH_SIZE` and add all files from the
    group to a single jumbo build.
  prefs: []
  type: TYPE_NORMAL
- en: CMake's documentation advises against enabling unity builds for public projects
    by default. It is recommended that the end user of your application should be
    able to decide whether they want jumbo builds or not by providing the `DCMAKE_UNITY_BUILD`
    command-line argument. What's more, if they cause issues because of how your code
    is written, you should explicitly set the target's property to `false`. However,
    nothing is stopping you from enabling this feature for code that will be used
    internally, such as inside a company or for your private project.
  prefs: []
  type: TYPE_NORMAL
- en: Unsupported C++20 modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you follow the C++ standard releases closely, you will be aware of the new
    feature introduced in C++20 – modules. This is a significant game changer. It
    allows you to avoid many nuisances when using headers, reduces build time, and
    allows for cleaner, more compact code that is easier to navigate and reason about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, instead of creating a separate header and implementation file,
    we can create a single file with module declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use it in your code by simply importing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note how we aren't relying on a preprocessor anymore; modules have their own
    keywords – `import`, `export`, and `module`. The latest versions of the most popular
    compilers can already perform all the necessary tasks to support modules as the
    new method of writing and building C++ solutions. It was my hope that by the time
    this chapter was started, some early support for modules would already have been
    provided in CMake. Unfortunately, this hasn't happened just yet.
  prefs: []
  type: TYPE_NORMAL
- en: However, it might be available by the time you have bought this book (or soon
    after). There are some really good indicators; Kitware developers have created
    (and released in 3.20) a new, experimental feature to support C++20 module dependency
    scanning for the Ninja generator. For now, it's only intended for compiler writers
    so that they can test their dependency scanning tools as they are being developed.
  prefs: []
  type: TYPE_NORMAL
- en: When this much-anticipated feature is finished and available in a stable release,
    I suggest researching it thoroughly. I expect it will simplify and speed up the
    compilation way beyond anything available today.
  prefs: []
  type: TYPE_NORMAL
- en: Finding mistakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As programmers, we spend a lot of time bug hunting. It's a sad fact. Finding
    errors and solving them can often get under our skin, especially if it takes long
    hours. It's even more difficult when we are flying blind, without instruments
    to help us navigate through the storm. This is why we should apply great care
    to set our environment in a way that makes this process as easy and as bearable
    as possible. We do this by configuring the compiler with `target_compile_options()`.
    Which *compile options* could help us then?
  prefs: []
  type: TYPE_NORMAL
- en: Configuring errors and warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many great stressful things about software development – fixing critical
    bugs in the middle of the night, working on high-visibility, costly failures in
    large systems, and dealing with annoying compilation errors, especially with those
    that are hard to understand or impossibly tedious to fix. When researching a subject
    in order to simplify your work and reduce the chance of failure, you'll find a
    lot of recommendations on how to configure the compiler's warnings.
  prefs: []
  type: TYPE_NORMAL
- en: One such fine piece of advice is to enable the `-Werror` flag as default for
    all builds. What this flag does is innocently simple – all warnings are treated
    as errors, and the code won't compile unless you resolve all of them. While it
    may seem like a good idea, it hardly ever is.
  prefs: []
  type: TYPE_NORMAL
- en: You see, warnings aren't errors for a reason. They're meant to warn you about
    things. It's up to you to decide what to do about that. Having the freedom to
    ignore a warning, especially when you experiment with and prototype your solution,
    is often a blessing.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you have a perfect, no-warnings, all-shiny piece of code,
    it's a shame to allow future changes to ruin this state of things. What harm could
    come from enabling it and just keeping it there? Seemingly none. At least until
    your compiler gets upgraded, that is. New versions of compilers tend to be stricter
    about deprecated features or just get better about suggesting things to improve.
    This is great when you don't treat all warnings as errors, but when you do, you'll
    discover one day that your build starts breaking without changes in the code or,
    even more frustrating, when you need to quickly fix a problem totally unrelated
    to a new warning.
  prefs: []
  type: TYPE_NORMAL
- en: What is this "hardly ever" case, when you actually should enable all the warnings
    possible? The quick answer is when you're writing a public library. Then, you
    really want to avoid issue tickets complaining about your code being naughty just
    because it is compiled in a stricter environment than yours. If you decide to
    enable it, make sure that you're up to speed with new versions of the compiler
    and the warnings it introduces.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, let warnings be warnings, and focus on errors. If you feel an internal
    need to be pedantic, use the `-Wpedantic` flag. This is an interesting one – it
    enables all the warnings demanded by strict ISO C and ISO C++. Do note that you
    can't check whether the code is conforming to the standard with this flag – it
    will only find non-ISO practices that require a diagnostic message.
  prefs: []
  type: TYPE_NORMAL
- en: More lenient and down-to-earth coders will be satisfied with `-Wall` and optionally
    with `-Wextra` for that extra-fancy feel. These are considered to be actually
    useful and meaningful warnings that you should fix in your code when you have
    a spare moment.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of other warning flags, which might be useful depending on
    the kind of project. I recommend that you read the manual for your chosen compiler
    and see what's available.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Occasionally, compilation will break. This usually happens when we try to refactor
    a bunch of code or clean up our buildsystem. Sometimes, things get resolved easily,
    but then there are much more complex problems that require a deep dive into the
    steps of the configuration. We already know how to print more verbose CMake outputs
    (as discussed in [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014),
    *First Steps with CMake*), but how do we analyze what actually happens under the
    hood at each stage?
  prefs: []
  type: TYPE_NORMAL
- en: Debugging individual stages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is a `-save-temps` flag we can pass to the compilers (both GCC and Clang
    have it) that will force the output of each stage to be stored in a file instead
    of memory:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/07-debug/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet will usually produce two extra files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<build-tree>/CMakeFiles/<target>.dir/<source>.ii`: Stores the output of the
    preprocessing stage, with comments explaining where each part of the source code
    comes from:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`<build-tree>/CMakeFiles/<target>.dir/<source>.s`: The output of the linguistic
    analysis stage, ready for the assembler stage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on the kind of problem, we can usually discover what the actual issue
    is. The output of the preprocessor can be useful to discover bugs such as incorrect
    *include paths* (providing the wrong version of libraries) and mistakes with definitions
    causing incorrect `#ifdef` evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the linguistic analysis is useful for targeting specific processors
    and solving critical optimization problems.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging issues with header file inclusion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Incorrectly included files can be a really hard problem to debug. I should
    know – it was my first corporate job to port an entire code base from one buildsystem
    to another. If you ever find yourself in a position that requires an exact understanding
    of which paths are being used to include a requested header, use `-H`:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter05/07-debug/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The printed output will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After the name of *object file*, each row in the output contains a path to a
    header. A single dot at beginning of the line means top-level inclusion (the `#include`
    directive is in `hello.cpp`). Two dots mean that this file is included by `<iostream>`.
    Every further dot indicates yet another level of nesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this output, you may also find suggestions of possible improvements
    to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You're not required to fix the standard library, but you might see some of your
    own headers. You may want to correct them.
  prefs: []
  type: TYPE_NORMAL
- en: Providing information for the debugger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Machine code is a cryptic list of instructions and data encoded in binary format.
    It doesn't convey any meaning or objective. This is because the CPU doesn't care
    what the goal of the program is or what the sense of all of the instructions is.
    The only requirement is the correctness of the code. The compiler will translate
    all of the preceding into numeric identifiers of CPU instructions, some data to
    initialize the memory, and thousands of memory addresses. In other words, the
    final binary doesn't need to contain the actual source code, variable names, signatures
    of functions, or any other details that programmers care about. And that's the
    default output of the compiler – raw and dry.
  prefs: []
  type: TYPE_NORMAL
- en: This is done primarily to save space and execute without too much overhead.
    By coincidence, we are also (somewhat) protecting our application from reverse
    engineering. Yes, you can understand what each CPU instruction does without the
    source code (for example, copy this integer to that register). But in the end,
    even basic programs contain too many of them to easily think about the big picture.
  prefs: []
  type: TYPE_NORMAL
- en: If you're a particularly driven individual, you can use a tool called a **disassembler**,
    and with a lot of knowledge (and a little luck), you'll be able to understand
    what might be going on. This approach isn't very practical, as disassembled code
    doesn't have original symbols, so it's extremely hard and slow to untangle what
    goes where.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can ask the compiler to store the source code in the produced binary
    along with the map containing references between compiled and original code. Then,
    we can hook a debugger to a running program and see which source line is being
    executed at any given moment. This is indispensable when we're working on code,
    such as writing new functionality or correcting mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two use cases are the reason for two configs: `Debug` and `Release`.
    As we saw earlier, CMake will provide some flags to the compiler by default to
    manage this process, storing them first in global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_CXX_FLAGS_DEBUG` contains `-g`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CXX_FLAGS_RELEASE` contains `-DNDEBUG`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-g` flag simply means *add debugging information*. It's provided in the
    operating system's native format – stabs, COFF, XCOFF, or DWARF. These formats
    can be then accessed by debuggers such as `gdb` (the GNU debugger). Usually, this
    is good enough for IDEs such as CLion (as they use `gdb` under the hood). In other
    cases, refer to the manual of the provided debugger and check what the appropriate
    flag is for the compiler of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `RELEASE` config, CMake will add the `-DNDEBUG` flag. It''s a preprocessor
    definition, which simply means *not a debug build*. Some debug-oriented macros
    may not work when this option is enabled. One of them is `assert`, available in
    the `<assert.h>` header file. If you decide to use assertions in your production
    code, they simply won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `assert(my_boolean)` call won''t have any effect in the `Release` config,
    but it will work just fine in `Debug`. What do you do if you''re practicing assertive
    programming and still need to use `assert()` for release builds? Either change
    the defaults that are provided by CMake (remove `NDEBUG` from `CMAKE_CXX_FLAGS_RELEASE`)
    or implement a hardcoded override by undefining the macro before the header inclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the assert reference for more information: [https://en.cppreference.com/w/c/error/assert](https://en.cppreference.com/w/c/error/assert).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have completed yet another chapter! There is no doubt that compilation is
    a complex process. With all its edge cases and specific requirements, it can be
    difficult to manage without a good tool. Thankfully, CMake is doing a great job
    in supporting us here.
  prefs: []
  type: TYPE_NORMAL
- en: What have we learned so far? We started by discussing what compilation is and
    where it fits in the larger story of building and running applications in the
    operating system. We then examined what the stages of compilation are and the
    internal tools that manage them. This is very useful in resolving all the issues
    in more advanced cases that we might encounter down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at how to ask CMake to verify whether the compiler available
    on the host is meeting all the necessary requirements for our code to build. As
    we have already established, it's a much better experience for users of our solution
    to see a friendly message asking them to upgrade, rather than some arcane error
    printed by an old compiler that is confused by the new features of the language.
  prefs: []
  type: TYPE_NORMAL
- en: We shortly discussed how to add sources to already defined targets, and moved
    on to the configuration of the preprocessor. This was quite a big subject, as
    this stage brings all bits of the code together and decides which of them will
    be ignored. We talked about providing paths to files and adding custom definitions
    as single arguments and in bulk (along with some use cases).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed the optimizer; we explored all the general levels of optimization
    and what kind of flags they imply, but we also went into details about a few of
    them – `finline`, `floop-unroll`, and `ftree-vectorize`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it was time to research the bigger picture again and study how to manage
    the viability of compilation. We tackled two main aspects here – reducing the
    time of compilation (and, by extension, strengthening the focus of the programmer)
    and finding mistakes. The latter is extremely important for discovering what is
    broken and how. Setting the tools correctly and understanding why things happen
    goes a long way in ensuring the quality of the code (and our mental health).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about linking, and all the things we need to
    consider to build libraries and use them in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following: *CMake-supported compile features and compilers:* [https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Managing sources for targets:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil](https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cmake.org/cmake/help/latest/command/target_sources.html](https://cmake.org/cmake/help/latest/command/target_sources.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Providing paths to included files:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.cppreference.com/w/cpp/preprocessor/include](https://en.cppreference.com/w/cpp/preprocessor/include)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cmake.org/cmake/help/latest/command/target_include_directories.html](https://cmake.org/cmake/help/latest/command/target_include_directories.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Configuring headers:* [https://cmake.org/cmake/help/latest/command/configure_file.html](https://cmake.org/cmake/help/latest/command/configure_file.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pre-compilation of headers:* [https://cmake.org/cmake/help/latest/command/target_precompile_headers.html](https://cmake.org/cmake/help/latest/command/target_precompile_headers.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unity builds:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html](https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake](https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Finding mistakes – compiler flags:* [https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags](https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why use libraries and not object files:* [https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why](https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Separation of concerns:* [https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
