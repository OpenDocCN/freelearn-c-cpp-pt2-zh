- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Program Analysis Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Producing high-quality code is not an easy task, even for highly experienced
    developers. By including tests in our solution, we lower the chance of making
    basic mistakes in the main code. But that won’t be enough to avoid more intricate
    problems. Every piece of software consists of so many details that keeping track
    of them all becomes a full-time job. Various conventions and specific design practices
    are established by teams responsible for maintaining the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some questions relate to consistent coding style: should we use 80 or 120 columns
    in our code? Should we allow `std::bind` or stick to lambda functions? Is it acceptable
    to use C-style arrays? Should small functions be written in a single line? Should
    we always use auto, or only when it improves readability? Ideally, we should steer
    clear of statements known to be generally incorrect: infinite loops, the use of
    identifiers reserved by a standard library, unintended data loss, unnecessary
    `if` statements, and anything else that is not a “best practice” (see the *Further
    reading* section for more information).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect to consider is code modernization. As C++ evolves, it introduces
    new features. Keeping track of all the spots where we can update to the latest
    standard can be challenging. Moreover, doing this manually takes time and increases
    the risk of introducing errors, especially in a large code base. Finally, we should
    check how things operate when set into motion: running the program and checking
    its memory. Is the memory properly released after use? Are we accessing data that
    was correctly initialized? Or does the code attempt to access non-existent pointers?'
  prefs: []
  type: TYPE_NORMAL
- en: Managing all these challenges and questions manually is both time-consuming
    and prone to errors. Fortunately, we can use automated tools to inspect and enforce
    rules, correct mistakes, and bring our code up to date. It’s time to explore tools
    for program analysis. Our code will be scrutinized during every build to make
    sure it meets industry standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing formatting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static checkers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic analysis with Valgrind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch12](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch12).
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the examples provided in this book, always use these recommended commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to replace the placeholders `<build tree>` and `<source tree>` with
    appropriate paths. As a reminder, **build tree** is the path to target/output
    directory, and **source tree** is the path where your source code is located.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Professional developers usually follow rules. It’s said that senior developers
    know when to break them because they can justify the need. On the flip side, very
    senior developers often avoid breaking rules to save time explaining their choices.
    The key is to focus on issues that genuinely affect a product, rather than getting
    caught up in minor details.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to coding style and formatting, developers face many options:
    should we use tabs or spaces for indentation? If spaces, how many? What should
    be the character limit in a column or a file? These choices typically don’t change
    the program’s behavior but can trigger lengthy discussions that add little value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Common practices do exist, but debates often center on personal preference
    and anecdotal evidence. For instance, choosing 80 characters per column over 120
    is arbitrary. What matters is maintaining a consistent style, as inconsistency
    can hinder the code’s readability. To ensure consistency, it’s advisable to use
    a formatting tool like `clang-format`. This tool can notify us if the code isn’t
    formatted correctly and even make corrections. Here’s an example command for formatting
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` option instructs clang-format to edit files directly, while `--style`
    specifies the formatting style to use, such as `LLVM`, `Google`, `Chromium`, `Mozilla`,
    `WebKit`, or a custom style provided in a file (more details are available in
    the *Further reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we don’t want to execute this command manually every time we make
    a change; `CMake` should handle this as part of the building process. We already
    know how to locate `clang-format` on the system (we’ll need to install it manually
    beforehand). What we haven’t covered is how to apply this external tool to all
    our source files. To do it, we’ll create a convenient function that can be included
    from the `cmake` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/01-formatting/cmake/Format.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Format` function accepts two arguments: `target` and `directory`. It will
    format all source files from the directory, right before the target is built.'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, not all files in the directory must belong to the target, and the
    target’s sources could be spread across multiple directories. However, tracking
    down all the source files and headers related to the target is complicated, especially
    when we need to exclude headers from external libraries. In this case, it’s easier
    to focus on directories than on logical targets. We can call the function for
    each directory that needs formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the installed `clang-format` binary. The `REQUIRED` keyword will halt the
    configuration with an error if the binary wasn’t found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a list of file extensions to format (to be used as a **globbing expression**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepend each expression with a path to `directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search recursively for sources and headers (using the previously created list),
    put found file paths into the `SOURCE_FILES` variable (but skip any directory
    paths found)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the formatting command to the `PRE_BUILD` step of `target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This approach works well for small to medium-sized code bases. For larger code
    bases, we might need to convert absolute file paths to relative ones and run the
    formatting command, using the directory as a working directory. This could be
    necessary due to character limits in shell commands, which usually cap at around
    13,000 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how to use this function in practice. Here’s our project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we set up the project and add the `cmake` directory to the module path
    for later inclusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/01-formatting/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we populate the `listfile` for the `src` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/01-formatting/src/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is straightforward. We create an executable target named `main`, include
    the `Format.cmake` module, and call the `Format()` function for the `main` target
    in the current directory (`src`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need some unformatted source files. The header contains a simple `unused`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/01-formatting/src/header.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also include a source file with excessive, incorrect whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/01-formatting/src/main.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost there. We just need the formatter’s configuration file, enabled via
    the `--style=file` command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/01-formatting/.clang-format**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`ClangFormat` will scan the parent directories for the `.clang-format` file,
    which specifies the exact formatting rules. This lets us customize every detail.
    In my case, I’ve started with Google’s coding style and made a few adjustments:
    a 140-character column limit, no tabs, and no short loops, functions, or `if`
    statements on a single line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After building the project (formatting occurs automatically before compilation),
    our files look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/01-formatting/src/header.h (formatted)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The header file was formatted, even though it isn’t used by the target. Short
    functions can’t be on a single line, and as expected, new lines were added. The
    `main.cpp` file also looks pretty slick now. Unneeded whitespace is gone, and
    indentations are standardized:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/01-formatting/src/main.cpp (formatted)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Automating formatting saves time during code reviews. If you’ve ever had to
    amend a commit just because of whitespace issues, you know the relief this brings.
    Consistent formatting keeps your code clean effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Applying formatting to an entire code base will most likely introduce a big
    one-off change to the majority of the files in the repository. This may cause
    *a lot* of merge conflicts if you (or your teammates) have some ongoing work.
    It’s best to coordinate such efforts to happen after all pending changes are done.
    If this isn’t possible, consider gradual adoption, perhaps on a per-directory
    basis. Your teammates will appreciate it.
  prefs: []
  type: TYPE_NORMAL
- en: Although the formatter excels in making code visually consistent, it’s not a
    comprehensive program analysis tool. For more advanced needs, other utilities
    designed for static analysis are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Using static checkers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static program analysis involves examining source code without running the compiled
    version. Consistently using static checkers can significantly improve code quality
    by making it more consistent and less susceptible to bugs and known security vulnerabilities.
    The C++ community offers a wide range of static checkers like `Astrée`, `clang-tidy`,
    `CLazy`, `CMetrics`, `Cppcheck`, `Cpplint`, `CQMetrics`, `ESBMC`, `FlawFinder`,
    `Flint`, `IKOS`, `Joern`, `PC-Lint`, `Scan-Build`, `Vera++`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these tools recognize `CMake` as an industry standard and offer ready-to-use
    support or integration tutorials. Some build engineers prefer not to write `CMake`
    code and instead include static checkers through external modules available online.
    An example is the collection by Lars Bilke on his GitHub repository: [https://github.com/bilke/cmake-modules](https://github.com/bilke/cmake-modules).'
  prefs: []
  type: TYPE_NORMAL
- en: A common belief is that setting up static checkers is complicated. This perception
    exists because static checkers often emulate the behavior of a real compiler to
    understand the code. But it doesn’t have to be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: '`Cppcheck` outlines the following simple steps in its manual:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the static checker’s executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generate a *compile database* with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the checker using the generated JSON file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<path-to-cppcheck> --project=compile_commands.json`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These steps should be integrated into the build process to ensure they are not
    overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `CMake` knows how to build our targets, can it also support any static
    checkers? Absolutely, and it’s easier than you might think. `CMake` allows you
    to enable checkers on a per-target basis for the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`include-what-you-use` ([https://include-what-you-use.org](https://include-what-you-use.org))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clang-tidy` ([https://clang.llvm.org/extra/clang-tidy](https://clang.llvm.org/extra/clang-tidy))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Link What` `You Use` (a built-in `CMake` checker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cpplint` ([https://github.com/cpplint/cpplint](https://github.com/cpplint/cpplint))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cppcheck` ([https://cppcheck.sourceforge.io](https://cppcheck.sourceforge.io))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enable these checkers, set a target property to a semicolon-separated list
    containing the path to the checker’s executable and any command-line options to
    forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<LANG>_CLANG_TIDY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_CPPCHECK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_CPPLINT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_INCLUDE_WHAT_YOU_USE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LINK_WHAT_YOU_USE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Replace `<LANG>` with `C` for C sources and `CXX` for C++. If you want to enable
    a checker for all project targets, set a global variable prefixed with `CMAKE_`
    – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Any target defined after this statement will have its `CXX_CLANG_TIDY` property
    set to this value. Remember that enabling this analysis may slightly extend your
    build time. On the other hand, having more detailed control over how targets are
    tested by the checker can be useful. We can create a straightforward function
    to handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/02-clang-tidy/cmake/ClangTidy.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddClangTidy` function follows two basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `clang-tidy` binary and store its path in `CLANG-TIDY_PATH`. The
    `REQUIRED` keyword ensures that configuration stops with an error if the binary
    is not found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable `clang-tidy` for the target by providing the binary path and specific
    options to activate all checks and treat warnings as errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use this function, we just need to include the module and call it for the
    chosen target:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/02-clang-tidy/src/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is concise and very effective. When building the solution, the
    `clang-tidy` output will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that unless you add the `--warnings-as-errors=*` option to the command-line
    arguments, the build will succeed. Organizations should decide on a set of rules
    that must be strictly followed to prevent non-compliant code from entering the
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: '`clang-tidy` also offers a useful `--fix` option that automatically corrects
    your code when possible. This feature is a valuable time-saver and is particularly
    helpful when expanding the list of checks. Just like with formatting, be cautious
    of merge conflicts when adding changes made by static analysis tools to existing
    code bases.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your situation, the repository size, and team preferences, you
    should select a handful of checkers that best suit your needs. Including too many
    can become disruptive. Here’s a brief overview of the checkers supported by `CMake`
    right out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: clang-tidy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s what the official website says about clang-tidy:'
  prefs: []
  type: TYPE_NORMAL
- en: clang-tidy is a clang-based C++ “linter” tool. Its purpose is to provide an
    extensible framework for diagnosing and fixing typical programming errors, like
    style violations, interface misuse, or bugs that can be deduced via static analysis.
    clang-tidy is modular and provides a convenient interface for writing new checks.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The tool is quite versatile, offering more than 400 checks. It pairs well with
    `ClangFormat`, enabling automatically applied fixes (over 150 are available) to
    conform to the same format file. The checks it offers cover performance, readability,
    modernization, C++ core guidelines, and bug-prone areas.
  prefs: []
  type: TYPE_NORMAL
- en: Cpplint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a description of `Cpplint` from its official website:'
  prefs: []
  type: TYPE_NORMAL
- en: Cpplint is a command-line tool to check C/C++ files for style issues following
    Google’s C++ style guide. Cpplint is developed and maintained by Google Inc. at
    google/styleguide.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This linter aims to align your code with Google’s style guide. Written in Python,
    it may introduce an unwanted dependency for some projects. The fixes are offered
    in formats consumable by `Emacs`, `Eclipse`, `VS7`, `Junit`, and as `sed` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Cppcheck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s what the official website says about `Cppcheck`:'
  prefs: []
  type: TYPE_NORMAL
- en: Cppcheck is a static analysis tool for C/C++ code. It provides unique code analysis
    to detect bugs and focuses on detecting undefined behaviour and dangerous coding
    constructs. The goal is to have very few false positives. Cppcheck is designed
    to be able to analyze your C/C++ code even if it has non-standard syntax (common
    in embedded projects).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This tool is particularly good for minimizing false positives, making it a reliable
    option for code analysis. It has been around for over 14 years and is still actively
    maintained. It’s especially useful if your code is not compatible with Clang.
  prefs: []
  type: TYPE_NORMAL
- en: include-what-you-use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a description of include-what-you-use from its official website:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main goal of include-what-you-use is to remove superfluous #includes. It
    does this both by figuring out what #includes are not actually needed for this
    file (for both .cc and .h files), and replacing #includes with forward-declares
    when possible.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While having too many included headers may not seem like a significant issue
    in small projects, the time saved from avoiding needless compilation of header
    files can quickly accumulate in larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: Link What You Use
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a description of “Link what you use” on `CMake`''s blog:'
  prefs: []
  type: TYPE_NORMAL
- en: This is a built in CMake feature that uses options of ld and ldd to print out
    if executables link more libraries than they actually require.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Static analysis plays a crucial role in industries like medicine, nuclear power,
    aviation, automotive, and machinery, where software errors could be life-threatening.
    Wise developers also adopt these practices in less critical environments, especially
    when the costs are low. Using static analysis during the build process is not
    only more cost-effective than manual bug finding and fixing, but it’s also easy
    to enable with `CMake`. I’d go as far as to say that there’s almost no reason
    to skip these checks in any quality-sensitive software, which includes any software
    involving people other than just the developer.
  prefs: []
  type: TYPE_NORMAL
- en: This feature also helps speed up the build time by focusing on eliminating unneeded
    binary artifacts. Unfortunately, not all bugs can be detected before running a
    program. Luckily, we can take additional steps to gain a deeper understanding
    of our projects, like using `Valgrind`.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis with Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Valgrind` ([https://www.valgrind.org](https://www.valgrind.org)) is an *nix
    instrumentation framework for building dynamic analysis utilities, which means
    it performs analysis during a program’s runtime. It comes with a wide range of
    tools for various types of investigations and checks. Some of the tools include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Memcheck`: detects memory management problems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cachegrind`: profiles CPU caches, and identifies cache misses and other issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Callgrind`: an extension of `Cachegrind` that provides extra information on
    call graphs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Massif`: a heap profiler that shows how different parts of the program use
    the heap over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Helgrind`: a thread debugger for data race issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DRD`: a lighter, more limited version of `Helgrind`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each tool on this list is highly useful when the situation calls for it. Most
    system package managers know `Valgrind` and can install it on your OS with ease.
    If you’re using Linux, it may already be installed. Additionally, the official
    website provides the source code for those who prefer to build it themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Our discussion will primarily focus on `Memcheck`, the most commonly used tool
    in the `Valgrind` suite (when developers refer to `Valgrind`, they often mean
    `Valgrind`'s `Memcheck`). We’ll explore how to use it with `CMake`, which will
    make it easier to adopt other tools from the suite if you find them necessary
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: Memcheck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Memcheck` is invaluable for debugging memory issues, a topic that can be especially
    complex in C++. Programmers have extensive control over memory management, making
    various mistakes possible. These can range from reading unallocated or already
    freed memory to freeing memory multiple times, and even writing to incorrect addresses.
    These bugs can easily go unnoticed and creep into even straightforward programs.
    Sometimes, a single forgotten variable initialization is all it takes to run into
    trouble.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking `Memcheck` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Memcheck` is `Valgrind`''s default tool, but you can also explicitly specify
    it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Running `Memcheck` can slow down your program considerably; the manual (see
    the link in *Further reading*) says that programs instrumented with it can be
    10–15 times slower. To avoid waiting for `Valgrind` every time we run tests, we’ll
    create a separate target that will be called from the command line whenever we
    need to test our code. Ideally, this will be done before any new code is merged
    into the main code base. You can include this step in an early Git hook or as
    part of your **Continuous Integration** (**CI**) pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom target for `Valgrind`, you can use this command after the
    `CMake` generation stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you can add such a target in `CMake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/03-valgrind/cmake/Valgrind.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we define a `CMake` function named `AddValgrind` that takes
    the target to be tested (we’ll be able to reuse it across projects). Two main
    things occur here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMake` checks default system paths for the `valgrind` executable and stores
    its path in the `VALGRIND_PATH` variable. The `REQUIRED` keyword will halt the
    configuration with an error if the binary isn’t found.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A custom target, `valgrind`, is created. It runs `Memcheck` on the specified
    binary, with an option to always check for memory leaks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Valgrind` options can be set in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `~/.valgrindrc` file (in your home directory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the `$VALGRIND_OPTS` environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `./.valgrindrc` file (in the working directory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are checked in that order. Also, note that the last file will only be
    considered if it belongs to the current user, is a regular file, and isn’t marked
    as world-writable. This is a safety mechanism, as options given to `Valgrind`
    can be potentially harmful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `AddValgrind` function, we provide it with a `unit_tests` target,
    as we want to run it in a finely controlled environment like unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/03-valgrind/test/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remember that generating build trees with the `Debug` config allows `Valgrind`
    to tap into the debug information, making its output much clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This configures the project, builds the `sut` and `unit_tests` targets, and
    starts the execution of `Memcheck`, which will provide us with general information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `==954==` prefix contains the process `ID`, helping to distinguish `Valgrind`
    commentary from the output of the tested process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, tests are run as usual with `gtest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, a summary is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh-oh! We are still using at least 1 byte. Allocations made with `malloc()`
    and `new` aren’t matched with the appropriate `free()` and `delete` operations.
    It seems we have a memory leak in our program. `Valgrind` provides more details
    to find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines starting with `by 0x<address>` indicate individual functions in a call
    stack. I’ve truncated the output (it had some noise from `GTest`) to focus on
    the interesting bit – the topmost function and source reference, `run()(run.cpp:6)`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the summary is found at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`Valgrind` is excellent at finding complex issues. Sometimes, it can dig even
    deeper to find issues that aren’t easily categorized. These will show up in the
    “`possibly lost`" row.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the issue found by `Memcheck` was in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/03-valgrind/src/run.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s right: the highlighted code is faulty. We do, in fact, create an object
    that isn’t deleted before the test ends. This is the exact reason why having extensive
    test coverage is so important.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Valgrind` is a helpful tool, but its output can become overwhelming in complex
    programs. There is a way to manage this information more efficiently – it’s the
    `Memcheck`-`Cover` project.'
  prefs: []
  type: TYPE_NORMAL
- en: Memcheck-Cover
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commercial IDEs like CLion can directly parse `Valgrind`''s output, making
    it easier to navigate through a graphical interface without having to scroll in
    the console. If your editor lacks this feature, a third-party report generator
    can offer a clearer view. `Memcheck`-`Cover`, developed by *David Garcin*, gives
    a better experience by creating an HTML file, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_12_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: A report generated by Memcheck-Cover'
  prefs: []
  type: TYPE_NORMAL
- en: 'This neat little project is available on GitHub ([https://github.com/Farigh/memcheck-cover](https://github.com/Farigh/memcheck-cover));
    it requires `Valgrind` and `gawk` (the GNU AWK tool). To use it, we’ll prepare
    a setup function in a separate `CMake` module. It will consist of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching and configuring the tool
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a custom target to run `Valgrind` and generate a report
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s how the configuration looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/04-memcheck/cmake/Memcheck.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first part, we follow the same practices as with a regular dependency:
    include the `FetchContent` module, and specify the project’s repository and desired
    Git tag with `FetchContent_Declare`. Next, we initiate the fetch process and configure
    the binary path, using the `memcheck-cover_SOURCE_DIR` variable set by `FetchContent_Populate`
    (called implicitly by `FetchContent_MakeAvailable`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the function is creating the target to generate reports.
    We’ll call it `memcheck` (so that it doesn’t overlap with the previous `valgrind`
    target if we want to keep both options for some reason):'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/04-memcheck/cmake/Memcheck.cmake (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens in two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll run the `memcheck_runner.sh` wrapper script, which will execute
    `Valgrind`'s `Memcheck` and collect the output to the file provided with the `-o`
    argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we’ll parse the output and create the report with `generate_html_report.sh`.
    This script requires input and output directories provided with the `-i` and `-o`
    arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both steps should be executed in the `CMAKE_BINARY_DIR` working directory so
    that the unit test binary can access files through relative paths if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to add to our listfiles is, of course, a call to this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch12/04-memcheck/test/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After generating a buildsystem with the `Debug` config, we can build the target
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can enjoy our formatted report, generated as an HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “You’ll spend more time reading code than writing it, so optimize for readability
    over writability.” This principle is often echoed in various books on clean code.
    It’s supported by the experiences of many software developers, which is why even
    small details like the number of spaces, newlines, and the order of `#import`
    statements are standardized. This standardization isn’t just for the sake of being
    meticulous; it’s about saving time. Following the practices in this chapter, you
    can forget about manually formatting code. It gets automatically formatted when
    you build, a step you’d do anyway to test the code. With `ClangFormat`, you can
    make sure the formatting is up to the standard of your choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond simple whitespace adjustments, code should also meet numerous other
    guidelines. That’s where clang-tidy comes in. It helps enforce coding that your
    team or organization agreed on. We discussed this static checker in depth and
    also touched on other options like `Cpplint`, `Cppcheck`, include-what-you-use,
    and Link What You Use. Since static linkers are relatively fast, we can add them
    to our builds with little investment, and it will usually be well worth the price.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined `Valgrind` utilities, focusing on `Memcheck` to identify issues
    with memory management, such as incorrect reads and writes. This tool is invaluable
    for avoiding hours of manual debugging and keeping bugs out of a production environment.
    We introduced a way to make `Valgrind`'s output more user-friendly with `Memcheck`-`Cover`,
    an HTML report generator. This is especially useful in environments where running
    an IDE is not possible, like CI pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is just a starting point. Many other tools, both free and commercial,
    are available to help you with code quality. Explore them to find what suits you
    best. In the next chapter, we’ll dive into generating documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ Core guidelines, curated by Bjarne Stroustrup, author of C++: [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ClangFormat` reference: [https://clang.llvm.org/docs/ClangFormat.html](https://clang.llvm.org/docs/ClangFormat.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Static analyzers for C++ – a curated list: [https://github.com/analysis-tools-dev/static-analysis#cpp](https://github.com/analysis-tools-dev/static-analysis#cpp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in static checker support in `CMake`: [https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/](https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A target property enabling `clang-tidy`: [https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html](https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Valgrind` manual: [https://www.valgrind.org/docs/manual/manual-core.html](https://www.valgrind.org/docs/manual/manual-core.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Review_Copy.png)'
  prefs: []
  type: TYPE_IMG
