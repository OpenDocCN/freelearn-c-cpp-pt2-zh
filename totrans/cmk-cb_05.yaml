- en: Creating and Running Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a unit test using the Catch2 library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a unit test and linking against Google Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a unit test and linking against Boost test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using dynamic analysis to detect memory defects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing expected failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using timeouts for long tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a subset of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using test fixtures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a core component of the code development toolbox. Performing automated
    testing by using unit and integration tests not only helps the developer to detect
    functionality regressions early, but can also serve as a starting point for developers
    joining the project. It can help new developers to submit changes to the code
    project, with assurance that the expected functionality is preserved. For users
    of the code, automated tests can be essential when verifying that the installation
    preserves the functionality of the code. A nice byproduct of employing tests for
    units, modules, or libraries right from the start is that it can guide the programmer
    towards more modular and less complex code structures, using a pure, functional
    style, that minimizes and localizes global variables and the global state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will demonstrate how to integrate testing into the CMake
    build structure, using popular testing libraries and frameworks, with the following
    goals in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Making it easy for users, developers, and continuous integration services to
    run the test set. When using Unix Makefiles, it should be as simple as typing
    `make test`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests efficiently by minimizing the total test time, in order to maximize
    the probability that tests are run often-ideally, with each code change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-01),
    and includes a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will introduce unit tests using CTest, the testing tool distributed
    as a part of CMake. In order to keep the focus on the CMake/CTest aspect and to
    minimize the cognitive load, we wish to keep the code that is to be tested as
    simple as possible. Our plan is to write and test code that can sum up integers,
    and nothing more. Just like in primary school, when we learned multiplication
    and division after learning how to add, at this point, our example code will only
    add and will only understand integers; it will not need to deal with floating
    point numbers. And, just as the young Carl Friedrich Gauss was tested by his teacher
    to sum all natural numbers from 1 to 100, we will ask our code to do the same-albeit
    without using the clever grouping trick employed by Gauss. To show that CMake
    does not impose any restrictions on the language to implement the actual tests,
    we will test our code using not only a C++ executable, but also using a Python
    script and a shell script. For simplicity, we will do this without using any testing
    libraries, but we will introduce C++ testing frameworks in later recipes in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our code example consists of three files. The implementation source file, `sum_integers.cpp`,
    does the work of summing up over a vector of integers, and returns the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, it does not matter whether this is the most elegant implementation
    of a sum over a vector. The interface is exported to our example library in `sum_integers.hpp`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the main function is defined in `main.cpp`, which collects the command-line
    arguments from `argv[]`, converts them into a vector of integers, calls the `sum_integers` function,
    and prints the result to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to test this code using a C++ executable (`test.cpp`), a Bash shell
    script (`test.sh`), and a Python script (`test.py`), to demonstrate that CMake
    does not really mind which programming or scripting language we prefer, as long
    as the implementation can return a zero or non-zero value that CMake can interpret
    as a success or failure, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the C++ example (`test.cpp`), we verify that 1 + 2 + 3 + 4 + 5 equals 15,
    by calling `sum_integers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The Bash shell script test example calls the executable, which is received
    as a positional argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the Python test script calls the executable (passed using the `--executable`
    command-line argument) directly, and allows it to be executed with the `--short` command-line
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now describe, step by step, how to set up testing for our project,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we require C++11 support, a working Python interpreter, and
    the Bash shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the library, the dependencies of the main executable, and the
    testing executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we turn on the testing functionality and define four tests. The last
    two tests call the same Python script; first without any command-line argument,
    and then with `--short`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to configure and build the code. First, we test it manually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can run the test set with `ctest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should also try to break the implementation, to verify whether the test
    set catches the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two key commands here are `enable_testing()`, which enables testing for
    this directory and all subfolders within it (in this case, the entire project,
    since we place it in the main `CMakeLists.txt`), and `add_test()`, which defines
    a new test and sets the test name and the command to run; an example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we employed a generator expression: `$<TARGET_FILE:cpp_test>`.
    Generator expressions are expressions that are evaluated at **build system generation
    time**. We will return to generator expressions in more detail in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml),
    *Configure-time and Build-time Operations*, Recipe 9, *Fine-tuning configuration
    and compilation with generator expressions*. At this point, we can state that
    `$<TARGET_FILE:cpp_test>` will be replaced by the full path to the `cpp_test`
    executable target.'
  prefs: []
  type: TYPE_NORMAL
- en: Generator expressions are extremely convenient in the context of defining tests,
    because we do not have to explicitly hardcode the locations and names of the executables
    into the test definitions. It would be very tedious to achieve this in a portable
    way, since both the location of the executable and the executable suffix (for
    example, the `.exe` suffix on Windows) can vary between operating systems, build
    types, and generators. Using the generator expression, we do not have to explicitly
    know the location and name.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to pass arguments to the test command to run; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we run the tests sequentially (Recipe 8, *Running tests in
    parallel*, will show you how to shorten the total test time by executing tests
    in parallel), and the tests are executed in the same order that they are defined
    (Recipe 9, *Running a subset of tests*, will show you how to change the order
    or run a subset of tests). It is up to the programmer to define the actual test
    command, which can be programmed in any language supported by the operating system
    environment running the test set. The only thing that CTest cares about, in order
    to decide whether a test has passed or failed, is the return code of the test
    command. CTest follows the standard convention that a zero return code means success,
    and a non-zero return code means failure. Any script that can return zero or non-zero can
    be used to implement a test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to define and execute tests, it is also important that
    we know how to diagnose test failures. For this, we can introduce a bug into our
    code and let all of the tests fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then wish to learn more, we can inspect the file `Testing/Temporary/LastTestsFailed.log`.
    This file contains the full output of the test commands, and is the first place
    to look during a postmortem analysis. It is possible to obtain more verbose test
    output from CTest by using the following CLI switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--output-on-failure`: Will print to the screen anything that the test program
    produces, in case the test fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-V`: Will enable verbose output from tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-VV`: Enables even more verbose output from tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CTest offers a very handy shortcut to rerun only the tests that have previously
    failed; the CLI switch to use is `--rerun-failed`, and it proves extremely useful
    during debugging.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding definition can be re-expressed by explicitly specifying the `WORKING_DIRECTORY` in
    which the script will be run, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also mention that test names can contain the `/` character, which may
    be useful when organizing related tests by name; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we need to set environment variables for a test script. This can
    be achieved with `set_tests_properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach might not always be robust across different platforms, but CMake
    offers a way around this potential lack of robustness. The following snippet is
    equivalent to the one given above and invokes CMake, *via* `CMAKE_COMMAND`, to
    prepend environment variables before executing the actual Python test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once again, note the use of the generator expression `$<TARGET_FILE:account>`
    to pass the location of the library file without explicitly hardcoding paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have executed the test set using the `ctest` command, but CMake will also
    create targets for the generator in question (`make test` for Unix Makefile generators,
    `ninja test` for the Ninja tool, or `RUN_TESTS` for Visual Studio). This means
    that there is yet another (almost) portable way to run the test step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this fails when using the Visual Studio generator where we have
    to use `RUN_TESTS` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The command `ctest` offers a wealth of command-line arguments. Some of these
    will be explored in later recipes. For a full list, try `ctest --help`. The command
    `cmake --help-manual ctest` will output the full CTest manual to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a unit test using the Catch2 library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-02),
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we used an integer return code to signal success or
    failure in `test.cpp`. This is fine for simple tests, but typically, we would
    like to use a testing framework that offers an infrastructure to run more sophisticated
    tests with fixtures, comparisons with numerical tolerance, and better error reporting
    if a test fails. A modern and popular test library is Catch2 ([https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2)).
    One nice feature of this test framework is the fact that it can be included in
    your project as a single-header library, which makes compilation and updating
    the framework particularly easy. In this recipe, we will use CMake in combination
    with Catch2, to test the summation code introduced in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will keep the `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp` unchanged
    from the previous recipe, but will update the `test.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We also need the `catch.hpp` header, which we can download from [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2) (we
    have used version 2.0.1) and place in the root of our project, alongside `test.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the Catch2 library, we will modify `CMakeLists.txt` from the previous
    recipe, to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can keep most of `CMakeLists.txt` unchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change, with respect to the previous recipe, is to remove all of the
    tests except for one, and rename it (to make clear what we have changed). Note
    that we pass the `--success` option to our unit tests executable. This is a Catch2
    option, and will produce output from tests, even upon success:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Let us configure, build, and test. The tests will be run using
    the `-VV` option in CTest, to get output from the unit tests executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also try the `cpp_test` binary directly, and can see output directly
    from Catch2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Catch will generate an executable with a command-line interface. We invite
    you to  also try to execute the following command to explore the options offered
    by the unit testing framework:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Catch2 is a single-header framework, no additional targets have to be
    defined and built. We only have to make sure that CMake can find `catch.hpp`,
    to build `test.cpp`. For convenience, we placed it in the same directory as `test.cpp`,
    but we could have chosen a different location and indicated that location by using
    `target_include_directories`. Yet another approach would be to wrap the header
    into an `INTERFACE` library. This can be done as illustrated in the Catch2 documentation
    (`https://github.com/catchorg/Catch2/blob/master/docs/build-systems.md#cmake`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We would have then linked against the library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We recall from the discussion in Recipe 3, *Building and linking static and
    shared libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries* that `INTERFACE` libraries are pseudo-targets
    offered by CMake that are useful to specify usage requirements for targets outside
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a simple example, with a focus on CMake. Catch2 offers much more, of
    course. For a full documentation of the Catch2 framework, visit [https://github.com/catchorg/Catch2](https://github.com/catchorg/Catch2).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Catch2 code repository contains a contributed CMake function to parse Catch
    tests and automatically create CMake tests, without explicitly typing `add_test()`
    functions; see [https://github.com/catchorg/Catch2/blob/master/contrib/ParseAndAddCatchTests.cmake](https://github.com/catchorg/Catch2/blob/master/contrib/ParseAndAddCatchTests.cmake).
  prefs: []
  type: TYPE_NORMAL
- en: Defining a unit test and linking against Google Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-03),
    and has a C++ example. The recipe is valid with CMake version 3.11 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows. The code repository also
    contains an example compatible with CMake 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will demonstrate how to implement unit testing using the
    Google Test framework, with the help of CMake. In contrast to the previous recipe,
    the Google Test framework is more than a header file; it is a library containing
    a couple of files that need to be built and linked against. We could place these
    alongside our code project, but to make the code project more lightweight, we
    will choose to download a well-defined version of the Google Test sources at configure
    time, and then build the framework and link against it. We will use the relatively
    new `FetchContent` module (available since CMake version 3.11). We will revisit `FetchContent`
    in [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The Superbuild Pattern*,
    where we will discuss how the module works under the hood, and where we will also
    illustrate how to emulate it by using `ExternalProject_Add`. This recipe is inspired
    by (and adapted from) the example at [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will keep `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp` unchanged
    from the previous recipes, but will update the `test.cpp` source code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As indicated in the preceding code, we chose to explicitly place neither `gtest.h` nor
    other Google Test sources in our code project repository, but will download them
    at configure time by using the `FetchContent` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps describe how you can set up a `CMakeLists.txt` step by
    step, to compile the executable and its corresponding test using GTest:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The beginning of `CMakeLists.txt` is mostly unchanged, as compared to the previous
    two recipes, except that we require CMake 3.11 to have access to the `FetchContent`
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then introduce an if-clause, checking for `ENABLE_UNIT_TESTS`. By default,
    it is `ON`, but we want to have the possibility to turn it `OFF`, in case we do
    not have any network to download the Google Test sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the if-clause, we first include the `FetchContent` module, declare
    a new content to fetch, and query its properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the content is not yet populated (fetched), we fetch and configure it. This
    will add a couple of targets that we can link against. In this example, we are
    interested in `gtest_main`. The example also contains some workarounds, for compilation
    using Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the `cpp_test` executable target and specify its sources, using
    the `target_sources` command and its link libraries, using the `target_link_libraries`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the now familiar `enable_testing` and `add_test` commands to
    define the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to configure, build, and test the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also try to run `cpp_test` directly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FetchContent` module enables populating content at configure time, *via*
    any method supported by the `ExternalProject` module, and has become a standard
    part of CMake in its 3.11 version. Whereas `ExternalProject_Add()` downloads at
    build time (as seen in [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The
    Superbuild Pattern*), the `FetchContent` module makes content available immediately,
    such that the main project and the fetched external project (in this case, the
    Google Test) can be processed when CMake is first invoked, and can be nested using `add_subdirectory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch Google Test sources, we have first declared the external content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we fetched a Git repository with a specific tag (`release-1.8.0`),
    but we could also fetch an external project from a Subversion, Mercurial, or HTTP(S)
    source. For available options, consult the options of the corresponding `ExternalProject_Add`
    command at [https://cmake.org/cmake/help/v3.11/module/ExternalProject.html](https://cmake.org/cmake/help/v3.11/module/ExternalProject.html).
  prefs: []
  type: TYPE_NORMAL
- en: We checked whether content population was already processed with the `FetchContent_GetProperties()`
    command, before calling `FetchContent_Populate()`; otherwise, `FetchContent_Populate()`
    would have thrown an error if it was called more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command `FetchContent_Populate(googletest)` populates the sources and defines `googletest_SOURCE_DIR`
    and `googletest_BINARY_DIR`, which we can use to process the Google Test project
    (using `add_subdirectory()`, since it happens to be a CMake project, as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding defines the following targets: `gtest`, `gtest_main`, `gmock`,
    and `gmock_main`. In this recipe, we were only interested in the `gtest_main`
    target, as a library dependency for the unit test example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When building our code, we can see how it correctly triggers the configure and
    build steps for Google Test. One day, we will wish to upgrade to a later Google
    Test release, and the only line that we will probably need to change is the one
    detailing the `GIT_TAG`.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have scraped the surface of `FetchContent` and its build-time cousin, `ExternalProject_Add`,
    and we will revisit these commands in [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml),
    *The Superbuild Pattern*. For a detailed discussion of the available options,
    please consult [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we fetched the sources at configure time, but we could have
    also installed them on the system environment and used the `FindGTest` module
    to detect the library and header files ([https://cmake.org/cmake/help/v3.5/module/FindGTest.html](https://cmake.org/cmake/help/v3.5/module/FindGTest.html)).
    From version 3.9, CMake also offers a `GoogleTest` module ([https://cmake.org/cmake/help/v3.9/module/GoogleTest.html](https://cmake.org/cmake/help/v3.9/module/GoogleTest.html)),
    which provides a `gtest_add_tests` function. This function can be used to automatically
    add tests, by scanning the source code for Google Test macros.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, Google Test has a myriad of features that are outside the scope of
    this recipe, as listed at [https://github.com/google/googletest](https://github.com/google/googletest).
  prefs: []
  type: TYPE_NORMAL
- en: Defining a unit test and linking against Boost test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-04),
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Boost test is another very popular unit testing framework in the C++ community,
    and in this example, we will demonstrate how to unit test our familiar summing
    example code using Boost test.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will keep the `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp` unchanged
    from the previous recipes, but we will update `test.cpp` as a minimal example
    of a unit test using the Boost test library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the steps to follow to build our project using Boost test:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start out with the now familiar `CMakeLists.txt` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We detect the Boost library and link `cpp_test` against it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is everything we need to configure, build, and test the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used `find_package` to detect the `unit_test_framework` component of
    Boost (see [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 8, *Detecting the Boost libraries*).
    We have insisted that this component is `REQUIRED`, and the configuration will
    stop if it cannot be found in the system environment. The `cpp_test` target needs
    to know where to find Boost header files, and needs to be linked against the corresponding
    libraries; these are both provided by the `IMPORTED` library target, `Boost::unit_test_framework`,
    set by a successful call to `find_package`. We recall from the discussion in Recipe
    3, *Building and linking static and shared libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries* that `IMPORTED` libraries are pseudo-targets
    offered by CMake to represent pre-existing dependencies and their usage requirements.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we assumed that Boost was installed on the system. Alternatively,
    we could have fetched and built the Boost dependency at compile-time (see [Chapter
    8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The Superbuild Pattern*, Recipe
    2, *Managing dependencies with a superbuild: I. The Boost libraries*). However,
    Boost is not a lightweight dependency. In our example code, we used only the most
    basic infrastructure, but Boost offers a wealth of features and options, and we
    will refer the interested reader to [http://www.boost.org/doc/libs/1_65_1/libs/test/doc/html/index.html](http://www.boost.org/doc/libs/1_65_1/libs/test/doc/html/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic analysis to detect memory defects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-05),
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Memory defects, such as writing to or reading from memory beyond allocated bounds,
    or memory leaks (memory that is allocated, but never released), can create nasty
    bugs that are difficult to track down, and it is useful to detect them early.
    Valgrind ([http://valgrind.org](http://valgrind.org)) is a popular and versatile
    tool to detect memory defects and memory leaks, and in this recipe, we will use
    Valgrind to alert us about memory problems when running tests using CMake/CTest
    (see [Chapter 14](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml), *Testing Dashboards*,
    for a discussion of the related `AddressSanitizer` and `ThreadSanitizer`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we require three files. The first is the implementation that
    we wish to test (we can call the file `leaky_implementation.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the corresponding header file (`leaky_implementation.hpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we need the test file (`test.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We expect the test to pass, since the `return_code` is hardcoded to `0`. However,
    we also hope to detect a memory leak, since we forgot to de-allocate `my_array`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following shows how to set up `CMakeLists.txt` to perform the dynamic analysis
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define the minimum CMake version, project name, language, targets,
    and dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define not only the test, but also the `MEMORYCHECK_COMMAND`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the test set reports that the test is passing, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we wish to check for memory defects, and can observe that the memory leak
    is detected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As a final step, you should try to fix the memory leak and verify that `ctest
    -T memcheck` reports no errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used `find_program(MEMORYCHECK_COMMAND NAMES valgrind)` to find Valgrind
    and set `MEMORYCHECK_COMMAND` to its full path. We also needed to explicitly include
    the `CTest` module to enable the `memcheck` test action, which we can employ by
    using `ctest -T memcheck`. Also, observe that we were able to pass options to
    Valgrind using `set(MEMORYCHECK_COMMAND_OPTIONS "--trace-children=yes --leak-check=full")`.
    The memory checking step creates a log file, which can be used to inspect the
    memory defect in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Some tools, like code coverage and static analysis tools, can be set up similarly.
    The use of some of these tools is, however, more complicated, since specialized
    builds and toolchains are required. Sanitizers are one such example. For more
    information, see [https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake).
    Also, check out [Chapter 14](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml), *Testing
    Dashboards*, for a discussion of the `AddressSanitizer` and `ThreadSanitizer`.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be used to report memory defects to a nightly testing dashboard,
    but we demonstrated here that this functionality can also be used independent
    of a testing dashboard. We will revisit discuss usage in conjunction with CDash
    in [Chapter 14](6ba7b67c-0921-45f5-b7e0-948627e165ec.xhtml), *Testing Dashboards*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For documentation on Valgrind and its features and options, see [http://valgrind.org](http://valgrind.org).
  prefs: []
  type: TYPE_NORMAL
- en: Testing expected failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-06).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we want all of our tests to always pass on every platform. However,
    we may want to test whether an expected failure or exception will occur in a controlled
    setting, and in that case, we would define the expected failure as a successful
    outcome. We believe that typically, this is a task that should be given to the
    test framework (such as Catch2 or Google Test), which should check for the expected
    failure and report successes to CMake. But, there may be situations where you
    wish to define a non-zero return code from a test as success; in other words,
    you may want to invert the definitions of success and failure. In this recipe,
    we will demonstrate such a situation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ingredient for this recipe will be a tiny Python script (`test.py`) that
    always returns `1`, which CMake interprets as a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Step by step, this is how to write `CMakeLists.txt` to accomplish our task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will not require any language support from CMake, but we
    will need to locate a working Python interpreter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the test and tell CMake that we expect it to fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we verify that it is reported as a successful test, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `set_tests_properties(example PROPERTIES WILL_FAIL true)`, we set the
    property `WILL_FAIL` to `true`, which inverts success/failure. However, this feature
    should not be used to temporarily fix broken tests.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need more flexibility, you can use the test properties `PASS_REGULAR_EXPRESSION`
    and `FAIL_REGULAR_EXPRESSION` in combination with `set_tests_properties`. If these
    are set, the test output will be checked against a list of regular expressions
    given as arguments, and, if at least one of the regular expressions matches, the
    test either passes or fails, respectively. Many other properties can be set on
    tests. A full list of available properties can be found at [https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#properties-on-tests](https://cmake.org/cmake/help/v3.5/manual/cmake-properties.7.html#properties-on-tests).
  prefs: []
  type: TYPE_NORMAL
- en: Using timeouts for long tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-07).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the test set should take only a short time, in order to motivate developers
    to run the test set often, and to make it possible (or easier) to test every commit
    (changeset). However, some tests might take longer or get stuck (for instance,
    due to a high file I/O load), and we may need to implement timeouts to terminate
    tests that go overtime, before they pile up and delay the entire test and deploy
    pipeline. In this recipe, we will demonstrate one way of implementing timeouts,
    which can be adjusted separately for each test.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ingredient for this recipe will be a tiny Python script (`test.py`) that
    always returns `0`. To keep it super simple and to maintain focus on the CMake
    aspect, the test script does nothing other than wait for two seconds; but, we
    can imagine that in real life, this test script would perform more meaningful
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to inform CTest that tests need to be terminated if they go into overtime,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the project name, enable testing, and define the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we specify a `TIMEOUT` for the test, and set it to 10 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We know how to configure and build, and we expect the test to pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to verify that the `TIMEOUT` works, we increase the sleep command in `test.py`
    to 11 seconds, and rerun the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TIMEOUT` is a handy property that can be used to specify a timeout for individual
    tests, by using `set_tests_properties`. If the test goes past that time, for whatever
    reason (the test has stalled or the machine is too slow), the test is terminated
    and marked as failed.'
  prefs: []
  type: TYPE_NORMAL
- en: Running tests in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-08).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern computers have four or more CPU cores. One fantastic feature of
    CTest is its ability to run tests in parallel, if you have more than one core
    available. This can significantly reduce the total time to test, and reducing
    the total test time is what really counts, to motivate developers to test frequently.
    In this recipe, we will demonstrate this feature and discuss how you can optimize
    the definition of your tests for maximum performance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us assume that our test set contains tests labeled *a, b, ..., j*, each
    with a specific time duration:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tests | Duration (in time units) |'
  prefs: []
  type: TYPE_TB
- en: '| *a, b, c, d* | 0.5 |'
  prefs: []
  type: TYPE_TB
- en: '| *e, f, g* | 1.5 |'
  prefs: []
  type: TYPE_TB
- en: '| *h* | 2.5 |'
  prefs: []
  type: TYPE_TB
- en: '| *i* | 3.5 |'
  prefs: []
  type: TYPE_TB
- en: '| *j* | 4.5 |'
  prefs: []
  type: TYPE_TB
- en: 'The time units can be minutes, but to keep it simple and short, we will use
    seconds. For simplicity, we can represent test *a*, which consumes 0.5 time units,
    with a Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The other tests can be represented accordingly. We will place these scripts
    one directory below `CMakeLists.txt`, in a directory called `test`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we need to declare a list of tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMakeLists.txt` is very brief:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can configure the project and run the tests using `ctest`, which takes 17
    seconds in total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we happen to have four cores available, we can run the test set on
    four cores in less than five seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can see that in the parallel case, tests *j, i, h*, and *e* started at the
    same time. The reduction in total test time when running in parallel can be significant.
    Looking at the output from `ctest --parallel 4`, we can see that the parallel
    test run started with the longest tests, and ran the shortest tests at the end.
    Starting with the longest tests is a very good strategy. It is like packing moving
    boxes: we start with larger items, and fill in the gaps with smaller items. Comparing
    the stacking of the *a-j* tests on four cores, when starting with the longest,
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Running tests in the order in which they are defined looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the tests in the order in which they are defined takes more time overall,
    since it leaves two cores idle for most of the time (here, cores 3 and 4). How
    did CMake know which tests would take the longest? CMake knew the time cost for
    each test because we ran the test sequentially first, and this recorded the cost
    data for each test in the file `Testing/Temporary/CTestCostData.txt`, which looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had started with the parallel test right after configuring the project,
    it would run the tests in the order in which they were defined, and on four cores,
    the total test time would be noticeably longer. What does this mean for us? Does
    it mean that we should order tests according to decreasing time costs? This is
    an option, but it turns out that there is another way; we can indicate the time
    cost for each test by ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `COST` parameter can be either an estimate or extracted from `Testing/Temporary/CTestCostData.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of using `ctest --parallel N`, you can also use the environment variable `CTEST_PARALLEL_LEVEL`,
    and set it to the desired level.
  prefs: []
  type: TYPE_NORMAL
- en: Running a subset of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-09).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to run tests in parallel with the help
    of CMake, and we discussed that it is advantageous to start with the longest tests.
    While this strategy minimizes the total test time, during the code development
    of a particular feature, or during debugging, we may not wish to run the entire
    test set. We may prefer to start with the longest tests, especially while debugging
    functionality that is exercised by a short test. For debugging and code development,
    we need the ability to only run a selected subset of tests. In this recipe, we
    will present strategies to accomplish that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we assume that we have six tests in total; the first three
    tests are shorter, and have the names `feature-a`, `feature-b`, and `feature-c`.
    We also have three longer tests, with the names `feature-d`, `benchmark-a`, and
    `benchmark-b`. In this recipe, we can represent these tests with Python scripts,
    where we can adjust the sleep time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a detailed breakdown of the contents of our `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start out with a relatively compact `CMakeLists.txt`, which defines the
    six tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we give the shorter tests the label `"quick"` and the longer tests
    the label `"long"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to run the test set, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each test now has a name and a label. In CMake, all tests are numbered, so they
    also carry a unique number. Having defined the test label, we can now either run
    the entire set or run tests by their names (using regular expressions), their
    labels, or their numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running tests by their names (here, we run all tests with names matching `feature`)
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Running tests by their labels (here, we run all `long` tests) produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Running tests by their numbers (here, we run tests 2 to 4) yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try using `**$ ctest --help**`, and you will see a wealth of options to choose
    from to customize your testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using test fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-10](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-04/recipe-10).
    The recipe is valid with CMake version 3.5 (and higher), and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe was inspired by the work of Craig Scott, and we recommend the reader
    to also consult the corresponding blog post for more background, at [https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/](https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/).
    The motivation for this recipe was to demonstrate how to employ test fixtures.
    These are useful for more sophisticated tests that require setup actions before
    the test is run, and cleanup actions after it has completed (such as creating
    an example database, setting up a connection, disconnecting, cleaning up the test
    database, and so on). We want to make sure that running a test that requires a
    setup or cleanup action automatically triggers these steps in a predictable and
    robust way, without introducing code repetition. These setup and cleanup steps
    can be delegated to the testing framework, such as Google Test or Catch2, but
    here, we demonstrate how to implement test fixtures at the CMake level.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will prepare four tiny Python scripts, and place them under the `test` directory: `setup.py`,
    `feature-a.py`, `feature-b.py`, and `cleanup.py`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start with a familiar `CMakeLists.txt` structure, with some additional steps,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We prepare the now familiar infrastructure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the four test steps and bind them with a fixture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the entire set brings no surprises, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the interesting part is when we try to run the test `feature-a` alone.
    It correctly invokes both the `setup` step and the `cleanup` step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we defined a text fixture and called it `my-fixture`. We gave
    the setup test the `FIXTURES_SETUP` property and the cleanup test the `FIXTURES_CLEANUP`
    property, and, using `FIXTURES_REQUIRED`, we made sure that the tests `feature-a`
    and `feature-b` both required the setup and cleanup steps in order to be run.
    Binding these together ensures that we always enter and leave steps in a well-defined
    state.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more background and an excellent motivation for using this technique for
    fixtures see [https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/](https://crascit.com/2016/10/18/test-fixtures-with-cmake-ctest/).
  prefs: []
  type: TYPE_NORMAL
