- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using CMake in Popular IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming is as much an art as it is a deeply technical process, and as we
    know all too well, it’s very difficult. Therefore, we should be looking to optimize
    this process as much as possible. There aren’t too many instances where we can
    just flip a switch and get better outcomes, but using **Integrated Development
    Environments** (**IDEs**) is definitely one of those rare cases.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t worked with a proper IDE before (or you believe that a text processor
    like Emacs or Vim is the best you can hope for), this chapter is for you. If you’re
    a seasoned professional and are already familiar with the subject, you can use
    this chapter as a quick overview of the current top choices and maybe consider
    a switch or, even better, get clear confirmation that your current tool is the
    best.
  prefs: []
  type: TYPE_NORMAL
- en: With an emphasis on accessibility for those new to the field, this chapter provides
    a gentle introduction to the critical choice of an IDE. We will cover why you’d
    want one and how to pick one that best suits your needs. Sure, there are many
    choices out there, but as usual, some are just better than others. Unfortunately,
    this isn’t a universal, one-size-fits-all kind of deal. Many factors contribute
    toward the productivity levels that you might get if you choose right. We’ll discuss
    a few considerations that might be important if your work is in an organization
    of a certain size, ensuring that you grasp the nuances without becoming mired
    in complexity. This will be followed by a quick introduction to toolchains, where
    we’ll discuss available choices.
  prefs: []
  type: TYPE_NORMAL
- en: We will then highlight the distinctive qualities of several popular IDEs, such
    as the sophisticated CLion, the adaptable nature of Visual Studio Code, and then
    the powerhouse that is the Visual Studio IDE. Each section is tailored to showcase
    the strengths and advanced features that these environments offer, providing you
    with the knowledge of how to take your initial steps with the IDE. Additionally,
    we highlight one advanced feature that was subjectively picked from many others,
    just to let you know what you might expect if you decide to use this suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with the CLion IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting with the Visual Studio IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss IDEs and how they can significantly enhance
    development speed and code quality. Let’s begin by explaining what an IDE is for
    those new to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why and how do you choose an IDE? An IDE, or integrated development environment,
    is a comprehensive tool that combines various specialized tools to simplify the
    software development process. The journey of creating a professional project involves
    numerous steps: designing, coding, building, testing, packaging, releasing, and
    maintaining. Each step comprises many smaller tasks, and the complexity can be
    overwhelming. IDEs offer a solution by providing a platform with a set of tools
    that are curated and configured by the IDE creators. This integration allows you
    to use these tools seamlessly without having to set them up individually for each
    project.'
  prefs: []
  type: TYPE_NORMAL
- en: IDEs are mainly centered around the code editor, compiler, and debugger. They
    are designed to provide sufficient integration, enabling you to edit code, compile
    it immediately, and run it with a debugger attached. IDEs can include build toolchains
    or allow developers to choose their preferred compilers and debuggers. Editors
    are usually a core part of the software but can often be greatly extended with
    plugins, like code highlighting, formatting, and more.
  prefs: []
  type: TYPE_NORMAL
- en: More advanced IDEs offer very sophisticated features like Hot Reload debugging
    (available in Visual Studio 2022; read on to learn more). This feature lets you
    run your code in a debugger, edit it, and continue execution without restarting
    the program. You will also find refactoring tools to rename symbols or extract
    code into a separate function, and static analysis to identify errors before compilation.
    Additionally, IDEs provide tools to work with Git and other version control systems,
    which are invaluable for resolving conflicts, among other benefits.
  prefs: []
  type: TYPE_NORMAL
- en: I’m sure you can see now how beneficial it can be to learn how to use an IDE
    early and standardize this usage in your organization. Let’s find out why choosing
    an IDE that is *right for you* is important.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are plenty of code editors that are on the verge of being recognized by
    the community as fully featured IDEs. It’s always recommended to research the
    space a bit before committing to a specific choice, especially because of the
    pace of current software release cycles and rapid changes in the space.
  prefs: []
  type: TYPE_NORMAL
- en: In my few years of corporate experience, it’s quite uncommon for an IDE to offer
    a feature compelling enough to make someone switch from one IDE to another. Force
    of habit is really second nature to a developer, and it shouldn’t be ignored.
    Remember that as soon as you feel comfortable in an IDE, it’s likely going to
    be your tool of choice for the considerable future. This is why you still see
    developers using Vim (a console-based text editor released in 1991), extended
    with a bunch of plugins to make it as powerful as more modern, GUI-based IDEs.
    No pressure then.
  prefs: []
  type: TYPE_NORMAL
- en: There are varied reasons why programmers choose one IDE over another; some of
    them are really important (speed, reliability, comprehensiveness, completeness),
    while others… not so much. I’d like to share my subjective perspective on this
    choice, which I hope you’ll find useful too.
  prefs: []
  type: TYPE_NORMAL
- en: Choose a comprehensive IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re just starting out, you might think about using a simple text editor
    and running a few commands to build your code. This approach is definitely workable,
    especially when you’re trying to understand the basics (I encourage you to use
    the actual commands to monitor your progress throughout this book). It also helps
    you grasp what a beginner might experience without an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, IDEs are created for a purpose. They streamline numerous
    processes that developers handle during a project’s lifecycle, which can be extremely
    valuable. Although it might seem overwhelming initially, choose a comprehensive
    IDE that includes all the necessary features. Ensure it’s as complete as possible,
    but be mindful of the cost, as IDEs can be expensive for small businesses or individual
    developers. It’s a balance between the time spent on manual management and the
    cost of the features provided by the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the cost, always select an IDE with strong community support to
    assist you if you encounter issues. Explore community forums and popular Q&A sites
    like [StackOverflow.com](http://StackOverflow.com) to check if users get their
    questions answered. Additionally, choose an IDE that is actively developed by
    a reputable company. You don’t want to waste your time on something that hasn’t
    been updated in a while and might get deprecated or abandoned in the near future.
    For example, not so long ago, Atom, an editor created by GitHub, was sunset after
    7 years of releases.
  prefs: []
  type: TYPE_NORMAL
- en: Choose an IDE that is widely supported in your organization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Counterintuitively, this might not align with every developer’s preference.
    You may already be comfortable with a different tool from your university, previous
    job, or a personal project. Such a habit, as mentioned earlier, can tempt you
    to ignore your company’s recommendations and stick with what you know. Resist
    this. Such a choice becomes increasingly challenging over time. From my experiences
    at Ericsson, Amazon, and Cisco, only once did the effort to configure and maintain
    a non-standard IDE prove worthwhile. That was because I managed to get enough
    organizational support to address issues collectively.
  prefs: []
  type: TYPE_NORMAL
- en: Your primary goal should be writing code, not struggling with an unsupported
    IDE. Learning the recommended software may require effort, but it’s less than
    what’s needed to go against the norm (and yes, Vim lost this battle; it’s time
    to move on).
  prefs: []
  type: TYPE_NORMAL
- en: Don’t pick an IDE based on the target OS and platform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might think that if you’re developing software for Linux, you need to use
    a Linux machine and a Linux-based IDE. However, C++ is a portable language, which
    means it should compile and run the same way on any platform, provided you’ve
    written it correctly. Of course, you might encounter issues with libraries, as
    not all of them are installed by default, and some may be specific to your platform.
  prefs: []
  type: TYPE_NORMAL
- en: Adhering strictly to the target platform isn’t always necessary and can sometimes
    be counterproductive. For instance, if you’re targeting an older or **Long-Term
    Support** (**LTS**) version of an OS, you might not be able to use the latest
    toolchain versions. If you wish to develop on a different platform than your target,
    you can.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, consider **cross-compilation** or **remote development**. Cross-compilation
    involves using a specialized toolchain that allows a compiler running on one platform
    (like Windows) to produce artifacts for another platform (like Linux). This approach
    is widely used in the industry and is supported by CMake. Alternatively, I recommend
    remote development, where you send your code to the target machine and build it
    there using the local toolchain. This method is supported by many IDEs and offers
    several benefits, which we’ll explore in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pick an IDE with remote development support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it shouldn’t be your primary criterion, considering remote development
    support in an IDE is beneficial after meeting other requirements. Over time, even
    seasoned developers encounter projects requiring a different target platform than
    their usual OS due to changing teams, projects, or even companies.
  prefs: []
  type: TYPE_NORMAL
- en: If your preferred IDE supports remote development, you can continue using it,
    leveraging the ability to compile and debug code on a different OS and view results
    in the IDE’s GUI. The main advantage of remote development over cross-compilation
    is its integrated debugger support, offering a cleaner process without needing
    CMake project-level configuration. Additionally, companies often provide powerful
    remote machines, allowing developers to use less expensive, lightweight local
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, there’s an argument to be made that cross-compilation offers greater control
    over the development environment, allowing temporary changes for testing. It doesn’t
    necessitate bandwidth for code transfers, supporting low-end internet connections,
    or offline work. However, considering most software development involves internet
    access for information, this might be a less critical advantage. Using virtualized
    environments like Docker enables running a local production copy and setting up
    remote development connections, offering security, customizability, and the ability
    to build and deploy containers.
  prefs: []
  type: TYPE_NORMAL
- en: The considerations mentioned here are slightly tilted toward working in big
    corporations, where things move slower, and it’s difficult to make highly impactful
    changes. These suggestions don’t negate the possibility of having a perfectly
    complete experience with CMake if you decide to prioritize other aspects of IDEs,
    as needed by your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Installing toolchains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed earlier, an IDE integrates all the necessary tools to streamline
    software development. A key part of this process is building binaries, sometimes
    in the background or on the fly, to provide additional information to developers.
    Toolchains are collections of tools like compilers, linkers, archivers, optimizers,
    debuggers, and implementations of the standard C++ library. They may also include
    other handy utilities like `bash`, `make`, `gawk`, `grep`, and so on, which are
    used to build programs.
  prefs: []
  type: TYPE_NORMAL
- en: Some IDEs come with toolchains or toolchain downloaders, while others do not.
    It’s best to just run an installed IDE and check if you’re able to compile a basic
    test program. CMake typically does this by default during the configuration stage,
    which most IDEs execute as part of the initialization of new projects. If this
    process fails, you might be prompted by the IDE or the OS’s package manager to
    install the necessary tools. Just follow along, as this flow is usually well prepared.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not prompted, or if you’d like to use a specific toolchain, here
    are some options based on your platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GNU GCC** ([https://gcc.gnu.org/](https://gcc.gnu.org/)) for Linux, Windows
    (via MinGW or Cygwin), macOS, and many others. GCC is one of the most popular
    and widely used C++ compilers, supporting a wide range of platforms and architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clang/LLVM** ([https://clang.llvm.org/](https://clang.llvm.org/)) for Linux,
    Windows, macOS, and many others. Clang is a compiler frontend for the C, C++,
    and Objective-C programming languages, utilizing LLVM as its backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Visual Studio/MSVC** ([https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/))
    for Windows primarily, with cross-platform support via Visual Studio Code and
    CMake. MSVC is the C++ compiler provided by Microsoft, typically used within the
    Visual Studio IDE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MinGW-w64** ([http://mingw-w64.org/](http://mingw-w64.org/)) for Windows.
    MinGW-w64 is an advancement of the original MinGW project, aimed at providing
    better support for 64-bit Windows and new APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apple Clang** ([https://developer.apple.com/xcode/cpp/](https://developer.apple.com/xcode/cpp/))
    for macOS, iOS, iPadOS, watchOS, and tvOS. Apple’s version of Clang, optimized
    for Apple’s hardware and software ecosystem, is integrated with Xcode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cygwin** ([https://www.cygwin.com/](https://www.cygwin.com/)) for Windows.
    Cygwin provides a POSIX-compatible environment on Windows, allowing the use of
    GCC and other GNU tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re looking to start quickly without delving deeply into the specifics
    of each toolchain, you can follow my personal preference: if there’s no toolchain
    provided by the IDE, go with MinGW on Windows, Clang/LLVM on Linux, and Apple
    Clang on macOS. Each of these is well suited to its primary platform and typically
    offers the best experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this book’s examples with IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book comes with an extensive collection of examples of CMake projects,
    available in the official GitHub repository here: [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, as we explore the subject of IDEs, a question arises: how do we
    use this repository with all the IDEs presented here? Well, we need to recognize
    that the book teaching you how to create professional projects isn’t a professional
    project itself. It’s a collection of such projects with varied levels of completion,
    reasonably simplified where possible. Unfortunately (or, maybe fortunately?),
    IDEs aren’t built to load tens of projects and conveniently manage them. They
    generally focus their features on loading one actively edited project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This puts us in a somewhat awkward position: it’s really difficult to navigate
    the example set with IDEs. Upon using an IDE to load the example set, by selecting
    the example directory to open it, most IDEs will detect multiple `CMakeLists.txt`
    files and ask you to pick one. After doing so, the usual initialization process
    will occur, temporary files will be written, and essentially, the CMake configuration
    and generation stages will be run to get the project into a state where it can
    be built. As you might guess, this only works for the example whose `CMakeLists.txt`
    file was selected. Most IDEs do offer ways to switch between different directories
    (or projects) in the workspace, but it might not be as straightforward as we’d
    like it to be.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re struggling with this, there are two options: either don’t use the
    IDE to build examples (and go with console commands instead) or load an example
    into a fresh project every time. I would recommend the first option if you’re
    keen on practicing the commands, as they may come in handy in the future and will
    give you a better understanding of what is going on behind the scenes. This is
    usually a good choice for build engineers, as this knowledge will be used often.
    On the other hand, if you’re working on a single project, mostly as a developer
    focusing on the business side of the code, perhaps going with the IDEs early on
    is the best. In any case, choosing one doesn’t prevent you from going with the
    other from time to time.'
  prefs: []
  type: TYPE_NORMAL
- en: With this out of the way, let’s focus on reviewing today’s top IDEs and seeing
    which one might be the best for you. All of them will serve you well, regardless
    of whether you work in a corporation or not.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the CLion IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CLion is a paid, cross-platform IDE available for Windows, macOS, and Linux,
    developed by JetBrains. That’s right – this piece of software is subscription-based;
    starting from $99.00 (early 2024), you can get a one-year license for individual
    use. Bigger organizations pay more, and startups pay less. If you’re a student
    or release an open-source project, you can get a free license. On top of that,
    there’s a 30-day trial to test the software. This is the only IDE in this listing
    that doesn’t offer a “community” or stripped-down version available free of charge.
    Regardless, this is a solid piece of software that is developed by a reputable
    company, and it very well might be worth the cost.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.1* shows how the IDE looks in light mode (dark mode is the default
    option):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The main window of the CLion IDE'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is a fully featured IDE, ready for anything and everything
    you might throw at it. Let’s talk about how it stands out.
  prefs: []
  type: TYPE_NORMAL
- en: Why you might like it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike the alternatives, C and C++ are the first and only languages supported
    by CLion. Many features of this IDE are specifically designed to support this
    environment and align with the C/C++ mindset. This is very visible when we compare
    features from other IDEs: code analysis, code navigation, integrated debugger,
    and refactoring tools can be found in competing software like the Visual Studio
    IDE. However, they are not as deeply and robustly oriented toward C/C++. This,
    of course, is a very difficult thing to measure objectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, CMake is fully integrated into CLion out of the box and is the primary
    choice for the project format in this IDE. However, alternatives like Autotools
    and Makefile projects are in early support and can be used to eventually migrate
    toward CMake. It’s worth noting that CLion natively supports CMake’s CTest with
    many unit-testing frameworks and has dedicated flows to generate code, run tests,
    and collect and present results. You can use Google Test, Catch, Boost.Test, and
    doctest.
  prefs: []
  type: TYPE_NORMAL
- en: A feature I especially like is the ability to work with Docker to develop C++
    programs in containers – more on that later. Meanwhile, let’s see how to start
    with CLion.
  prefs: []
  type: TYPE_NORMAL
- en: Take your first steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After downloading CLion from the official website ([https://www.jetbrains.com/clion](https://www.jetbrains.com/clion)),
    you can proceed with the usual installation process on the platform you’re using.
    CLion comes with an adequate visual installer on Windows (*Figure 3.2*) and macOS
    (*Figure 3.3*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: CLion Setup for Windows'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: CLion Setup for macOS'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux, you’ll need to unpack the downloaded archive and run the installation
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These instructions may be outdated, so make sure to confirm with the CLion website.
  prefs: []
  type: TYPE_NORMAL
- en: On the first run, you’ll be asked to provide a license code or to start a 30-day
    free trial. Selecting the second option will allow you to experiment with the
    IDE and determine if it’s right for you. Next, you’ll be able to create a new
    project and select the targeted C++ version. Immediately after, CLion will detect
    the available compilers and CMake versions and attempt to build a test project
    to confirm everything is set up correctly. On some platforms (like macOS), you
    may get an automatic prompt to install developer tools as needed. On others, you
    may need to set them up yourself and ensure they’re available in the `PATH` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, ensure your toolchain is configured according to your needs. Toolchains
    are configured per project, so go ahead and create a default CMake project. Then,
    navigate to your **Settings**/**Preferences** (*Ctrl*/*Command* + *Alt* + *S*)
    and select **Build, Execution, Deployment** > **CMake**. On this tab, you can
    configure the build profile (*Figure 3.3*). It may be useful to add a `Release`
    profile to build optimized artifacts without the debugging symbols. To add one,
    simply press the plus icon above the profile list. CLion will create a default
    `Release` profile for you. You can switch between profiles using the dropdown
    at the top of the main window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can simply press *F9* to compile and run the program with the debugger
    attached. Follow up by reading the official documentation of CLion, as there are
    plenty of useful features to explore. I’d like to introduce you to one of my favorites:
    the debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced feature: Debugger on steroids'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The debugging capabilities of CLion are truly cutting-edge and especially designed
    for C++. I was very pleased to discover one of the latest additions, CMake debugging,
    which includes many standard debugging features: stepping through code, breakpoints,
    watches, inlined value exploration, and more. The ability to explore variables
    in different scopes (cache, `ENV`, and the current scope) is extremely convenient
    when things don’t quite work as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For C++ debugging, you will get many standard features provided by the **GNU
    Project Debugger** (**GDB**), such as assembly view, breakpoints, step through,
    watchpoints, and so on, but there are also some major enhancements. In CLion,
    you’ll find a parallel stack view, which enables you to see all the threads in
    a graph-like diagram with all the current stack frames for each thread. There’s
    an advanced memory view feature to see the layout of the running program in RAM
    and modify the memory on the fly. CLion provides multiple other tools to help
    you understand what’s happening: register view, code disassembly, debugger console,
    core dump debugging, debugging of arbitrary executables, and many more.'
  prefs: []
  type: TYPE_NORMAL
- en: To top it off, CLion has a very well-executed **Evaluate Expression** feature,
    which works wonders and even allows you to modify objects during program execution.
    Just right-click on a line of code and select this feature from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all on CLion; it’s time to take a look at another IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**) is a free, cross-platform IDE available
    for Windows, macOS, and Linux, developed by Microsoft. Don’t confuse it with another
    Microsoft product, the Visual Studio IDE (usually named after the year it was
    released, for example, Visual Studio 2022).'
  prefs: []
  type: TYPE_NORMAL
- en: VS Code is favored for its vast extension ecosystem and support for hundreds
    of programming languages (an estimated are over 220 different languages!). When
    GitHub was acquired by Microsoft, VS Code was introduced as something of a replacement
    for Atom.
  prefs: []
  type: TYPE_NORMAL
- en: The overall design of the IDE is top-notch, as you can see in *Figure 3.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The main window of VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s find out what makes VS Code so special.
  prefs: []
  type: TYPE_NORMAL
- en: Why you might like it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ isn’t the priority in terms of languages supported by VSC, but it’s quite
    close to the top, thanks to the many sophisticated language extensions available.
    This trade-off is rewarded with the ability to switch between many languages as
    needed while working in the same environment.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a bit of a learning curve to this tool, as most extensions conform to
    the basic UI functionalities provided, rather than implementing advanced interfaces
    on their own. Many of the features will be available through the command palette
    (accessible by pressing *F1*), which requires you to type the name of the command
    instead of clicking an icon or a button. This is a reasonable sacrifice to keep
    VSC clean, fast, and free of charge. In fact, this IDE is so quick to load that
    I prefer to use it as a general-purpose text editor, even when I’m not working
    on a project.
  prefs: []
  type: TYPE_NORMAL
- en: That said, VS Code is truly powerful thanks to an enormous library of really
    good extensions, the vast majority of which are available for free. There are
    special extensions available for C++ and CMake, so let’s see how to configure
    them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Take your first steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'VSC is available from the official website: [https://code.visualstudio.com/](https://code.visualstudio.com/).
    The website provide quite an extensive list of downloads for Windows and macOS,
    as well as for many Linux distributions: Debian, Ubuntu, Red Hat, Fedora, and
    SUSE. Follow the usual process on your platform to install the software. After
    that, you’ll want to install a bunch of extensions by going to the **Extensions
    Marketplace** (*Ctrl*/*Command + Shift + X*). The following are recommended to
    start with:'
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ by Microsoft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C/C++ Extension Pack by Microsoft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake by twxs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake Tools by Microsoft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They will provide the usual code highlighting and the ability to compile, run,
    and debug code straight from the IDE, but you might need to install the toolchain
    yourself. Usually, VS Code will suggest extensions to install in a pop - up window
    as you start opening relevant files, so you don’t necessarily need to go out on
    a hunt.
  prefs: []
  type: TYPE_NORMAL
- en: I also suggest installing the **Remote – SSH by Microsoft** extension if you’re
    involved with remote projects, as this will make the experience much more coherent
    and comfortable; this extension not only takes care of file synchronization but
    will also enable you to remotely debug by attaching to the debugger on the remote
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: However, there’s one more interesting extension that shifts the paradigm of
    working with projects; let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced feature: Dev Containers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re deploying your application to a production environment, whether you’re
    shipping the compiled artifact or running a build process, it’s crucial to ensure
    that all dependencies are present. Otherwise, you’ll get all sorts of problems.
    Even with all dependencies accounted for, different versions or configurations
    might cause your solution to behave differently from the development or staging
    environment. I’ve experienced such cases on numerous occasions. Before virtualization
    became prevalent, dealing with environmental issues was just a part of life.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of lightweight containers like Docker, things got much
    simpler. Suddenly, you were able to run a minified operating system with your
    service isolated to its own space. This isolation allowed all dependencies to
    be packaged with the container, freeing developers from a major headache.
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, developing inside a container involved manually building, running,
    and connecting to the container with a remote session from the IDE. This process
    wasn’t overly difficult, but it required manual steps that could be executed differently
    by various developers.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, Microsoft released an open standard called Dev Containers ([https://containers.dev/](https://containers.dev/))
    to help address this slight inconvenience. The specification mainly consists of
    a `devcontainer.json` file that you can place in your project repository, instructing
    IDEs on how to set up their development environment in a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this feature, simply install the **Dev Containers by Microsoft** extension
    and point it to a repository of an appropriately prepared project. If you’re undeterred
    by the challenges of switching the main `CMakeLists.txt`, feel free to try it
    with the book’s repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[git@github.com:PacktPublishing/Modern-CMake-for-Cpp-2E.git](mailto:git@github.com:PacktPublishing/Modern-CMake-for-Cpp-2E.git
    )'
  prefs: []
  type: TYPE_NORMAL
- en: I can confirm that other IDEs, like CLion, are adopting this standard, so it
    seems like a good practice to adopt if you’re facing the circumstances described.
    Time to move on to the next product from the Microsoft family.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the Visual Studio IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Visual Studio** (**VS**) IDE is an IDE available for Windows developed
    by Microsoft. VS was available for macOS but is being deprecated in August 2024\.
    It’s important to distinguish it from VS Code, *the other IDE* by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: 'VS comes in a few flavors: Community, Professional, and Enterprise. The Community
    version is free, allowing up to five users in a company. More mature companies
    will need to pay licensing fees, which start from $45 per user monthly. *Figure
    3.5* shows what VS Community looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: The main window of VS 2022'
  prefs: []
  type: TYPE_NORMAL
- en: Like the other IDEs discussed in this chapter, you can enable dark mode if you
    prefer. Let’s move on to the noteworthy features of this IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Why you might like it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This IDE shares many features with VS Code, offering an experience of a similar
    flavor but in a much more refined form. The suite is full of features, many of
    which utilize GUIs, wizards, and visual elements. Most of these features are available
    straight out of the box, rather than through extensions (although there is still
    a large and extensive package marketplace for additional functionality). In other
    words, it’s like VSC but much more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the version, your testing tools will cover a wide range of tests:
    unit testing, performance testing, load testing, manual testing, Test Explorer,
    test coverage, IntelliTest, and code profiling. The profiler, in particular, is
    quite a valuable tool, and it’s available in the Community edition.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re designing Windows desktop applications, VS provides visual editors
    and a large collection of components. There’s extensive support for the **Universal
    Windows Platform (UWP)**, which is the UI standard for Windows-based applications
    introduced in Windows 10\. This support allows for a sleek, modern design, heavily
    optimized for adaptive controls that scale well on different screens.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing worth mentioning is that even though VS is a Windows-only IDE,
    you can develop projects targeted for Linux and mobile platforms (Android and
    iOS). There’s also support for game developers using Windows-native libraries
    and Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Ready to see for yourself how it works? Here’s how to start.
  prefs: []
  type: TYPE_NORMAL
- en: Take your first steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This IDE is only available for Windows, and it follows a standard installation
    process. Start by downloading the installer from [https://visualstudio.microsoft.com/free-developer-offers/](https://visualstudio.microsoft.com/free-developer-offers/).
    After running the installer, you’ll be asked to pick the version (Community, Professional,
    or Enterprise) and select the workloads you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Installer window for the VS IDE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Workloads are simply feature sets that allow VS to support the specific language,
    environment, or format of the program. Some workloads include Python, Node.js,
    or .NET. We’re of course interested in the ones related to C++ (*Figure 3.6*);
    there’s extensive support available for different use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Desktop development with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Universal Windows Platform development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game development with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile development with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux development with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pick the ones that fit your desired application and press **Install**. Don’t
    worry about installing all options just in case – you can always modify your selection
    later by running the installer again. If you decide to configure the workload
    components more precisely, ensure to keep the **C++ CMake tools for Windows**
    or **C++ CMake tools for Linux** option enabled to get access to CMake support.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, you can start the IDE and select **Create a new project**
    on the start window. You’ll be presented with multiple templates based on the
    workloads you installed previously. To work with CMake, choose the **CMake Project**
    template. Other options don’t necessarily use it. Upon creating your project,
    you can start it by pressing the green play button at the top of the window; the
    code will compile, and you’ll see the basic program executed with the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, you’re ready to work with CMake in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced feature: Hot Reload debugging'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While running Visual Studio might be more resource-intensive and take more
    time to start, it offers numerous unmatched features. One significant game-changer
    is Hot Reload. Here’s how it works: open a C++ project, start it with a debugger
    attached, make a change in a code file, press the **Hot Reload** button (or *Alt
    + F10*), and your changes will immediately be reflected in the running application
    while maintaining the state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure Hot Reload support is enabled, set these two options in the **Project
    > Properties > C/C++ > General** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debug Information Format** must be set to **Program Database for Edit and
    Continue /ZI**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable Incremental Linking** must be set to **Yes /INCREMENTAL**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The behind-the-scenes mechanics of Hot Reload might seem like sorcery, but it’s
    an incredibly useful feature to have. There are some limitations, such as changes
    to global/static data, object layouts, or “time-traveling” changes (like altering
    the constructor of an already constructed object).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more about Hot Reload in the official documentation here: [https://learn.microsoft.com/en-us/visualstudio/debugger/hot-reload](https://learn.microsoft.com/en-us/visualstudio/debugger/hot-reload).'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discovery of the three main IDEs. The initial learning curve
    might look steep, but I promise that the effort put in to learn any of these platforms
    will pay off very quickly when you move on to more advanced tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides an in-depth look at using IDEs to optimize the programming
    process, particularly focusing on IDEs that deeply integrate with CMake. It offers
    a comprehensive guide for both beginners and experienced professionals, detailing
    the benefits of using an IDE and how to select one that best fits individual or
    organizational needs.
  prefs: []
  type: TYPE_NORMAL
- en: We started with a discussion on the importance of IDEs in enhancing development
    speed and code quality, explaining what an IDE is and how it simplifies the various
    steps involved in software development by integrating tools like code editors,
    compilers, and debuggers. This was followed by a short reminder about toolchains,
    where we explained the necessity of their installation if they aren’t present
    in the system, and we presented a short list of the most common choices.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how to start with CLion and its unique features, and we took an
    advanced look at its debugging capabilities. VS Code, a free, cross-platform IDE
    by Microsoft, is recognized for its vast extension ecosystem and support for numerous
    programming languages. We guided you through the initial setup and its key extension
    installations, and we introduced an advanced feature called Dev Containers. The
    VS IDE, exclusive to Windows, provides a refined, feature-rich environment tailored
    to various user needs. The setup process, key features, and the advanced Hot Reload
    debugging feature were also covered.
  prefs: []
  type: TYPE_NORMAL
- en: Each IDE section provided insights into why you might choose a particular IDE,
    the steps to get started, and a look at an advanced feature that sets the IDE
    apart. We also emphasized the concept of remote development support, highlighting
    its growing importance in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, this chapter serves as a foundational guide for programmers seeking
    to understand and choose an IDE, offering a clear overview of the top options,
    their unique benefits, and how to effectively use them in conjunction with CMake
    to enhance coding efficiency and project management. In the next chapter, we’ll
    learn the basics of project setup using CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt Creator IDE, another CMake-supporting option to explore:[https://www.qt.io/product/development-tools](https://www.qt.io/product/development-tools)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse IDE for C/C++ developers, which supports CMake as well:[https://www.eclipse.org/downloads/packages/release/2023-12/r/eclipse-ide-cc-developers](https://www.eclipse.org/downloads/packages/release/2023-12/r/eclipse-ide-cc-developers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode for macOS can also be used with CMake:[https://medium.com/practical-coding/migrating-to-cmake-in-c-and-getting-it-working-with-xcode-50b7bb80ae3d](https://medium.com/practical-coding/migrating-to-cmake-in-c-and-getting-it-working-with-xcode-50b7bb80ae3d)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeLite is another choice, thanks to the CMake plugin:[https://docs.codelite.org/plugins/cmake/](https://docs.codelite.org/plugins/cmake/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code94081075213645359.png)'
  prefs: []
  type: TYPE_IMG
