- en: Mixed-language Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building Fortran projects that use C/C++ libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building C/C++ projects that use Fortran libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building C++ and Python projects using Cython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building C++ and Python projects using Boost.Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building C++ and Python projects using pybind11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing C, C++, Fortran, and Python using Python CFFI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are plenty of existing libraries that excel at very specific tasks. It''s
    generally a very good idea to reuse such libraries in our own codebases, because
    we can rely on years of experience from other groups of experts. As computer architectures
    and compilers evolve, so do programming languages. Whereas years ago most scientific
    software was written in Fortran, nowadays C, C++, and interpreted languages –
    first and foremost Python – are taking the center stage. It is indeed more and
    more common to integrate code written in a compiled language with bindings to
    an interpreted language, since it affords the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: End-users can customize and expand the capabilities offered by the code itself
    to fully suit their needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One is able to combine the expressiveness of a language such as Python with
    the performance of a compiled language that is closer "to the metal" in terms
    of memory addressing, getting the best of both worlds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have consistently shown throughout the previous recipes, the `project`
    command can be used to set the languages used in the project *via* the `LANGUAGES`
    keyword. CMake has support for many – but not all – compiled programming languages.
    As of CMake 3.5, various flavors of assembly (such as ASM-ATT, ASM, ASM-MASM,
    and ASM-NASM), C, C++, Fortran, Java, RC (Windows Resource Compiler), and Swift
    are valid choices. CMake 3.8 added support for two more languages: C# and CUDA
    (see the release notes here: [https://cmake.org/cmake/help/v3.8/release/3.8.html#languages](https://cmake.org/cmake/help/v3.8/release/3.8.html#languages)).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will show how to integrate codes written in different compiled
    (C, C++, and Fortran) and interpreted (Python) languages in a way that is portable
    and cross-platform. We will show how to leverage CMake and tools intrinsic to
    the different programming languages we aim to integrate.
  prefs: []
  type: TYPE_NORMAL
- en: Building Fortran projects that use C/C++ libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-01) and
    has two examples: one mixing Fortran and C, and the other mixing Fortran and C++.
    The recipe is valid with CMake version 3.5 (and higher). Both versions of the
    recipe have been tested on GNU/Linux and macOS.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortran has a venerated history as the language of high-performance computing.
    Many numerical linear algebra libraries are still written primarily in Fortran,
    as are many big number-crunching packages that need to preserve compatibility
    with legacy code amassed in the past decades. Whereas Fortran presents a very
    natural syntax for handling numerical arrays, it is lacking when it comes to interaction
    with the operating system, primarily because an interoperability layer with C,
    the *de facto lingua franca* of computer programming, was not mandated until the
    release of the Fortran 2003 standard. This recipe will show how to interface a
    Fortran code with both C system libraries and custom C code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring
    Projects*, we will structure our project as a tree. Each subdirectory has a `CMakeLists.txt`
    file with instructions pertaining to that directory. This allows us to confine
    as much information as possible within the leaf directories as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we have a `src` subdirectory containing the sources, including `bt-randomgen-example.f90`,
    our executable. Two further subdirectories, `interfaces` and `utils`, contain
    more source code that will be compiled into libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code in the `interfaces` subdirectory shows how to wrap the backtrace
    C system library. For example, the `interface_backtrace.f90` contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example shows the use of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The intrinsic `iso_c_binding` module, which ensures interoperability of Fortran
    and C types and functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `interface` declaration, which binds the functions to symbols in a separate
    library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bind(C)` attribute, which fixes name-mangling of the declared functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This subdirectory contains two more source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`randomgen.c`, which is a C source file that exposes a function, using the
    C standard `rand` function, to generate random integers within an interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interface_randomgen.f90`, which wraps the C functions for use within a Fortran
    executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have four `CMakeLists.txt` instances to look at: one root and tree leaves.
    Let us start with the root `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a mixed-language Fortran and C project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We direct CMake to save static and shared libraries under the `lib` subdirectory
    of the build directory. Executables will be saved under `bin`, while Fortran compiled
    module files will be saved under `modules`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move on to the first leaf, `CMakeLists.txt`, by adding the `src` subdirectory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/CMakeLists.txt` file adds two more subdirectories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `interfaces` subdirectory, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We include the `FortranCInterface.cmake` module and verify that the C and Fortran
    compilers can talk properly to each other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we find the backtrace system library, since we want to use it within
    our Fortran code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a shared library target with the source files for the backtrace
    wrapper, the random number generator, and its Fortran wrapper:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also set the link libraries for the newly generated library target. We use
    the `PUBLIC` attribute, so that additional targets linking to our libraries will
    see dependencies properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `utils` subdirectory, we have one more `CMakeLists.txt`. This is a one-liner:
    we create a new library target into which the source file in this subdirectory
    will be compiled. There are no dependencies for this target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us return to `src/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add an executable target, with `bt-randomgen-example.f90` as source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we link the library targets, generated in the `CMakeLists.txt` leaf,
    into our executable target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having identified the correct libraries to link to, we need to make sure that
    our program can correctly call the functions they define. Every compiler performs
    name mangling when generating machine code and, unfortunately, conventions for
    this operation are not universal, but compiler-dependent. `FortranCInterface`,
    which we have already encountered in [Chapter 3](c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml),
    *Detecting External Libraries and Programs*, Recipe 4, *Detecting the BLAS and
    LAPACK math libraries*, checks the compatibility of the selected C compiler with
    the Fortran compiler. For our current purposes, name mangling is not really an
    issue. The Fortran 2003 standard defines a `bind` attribute for functions and
    subroutines that accepts an optional `name` argument. If this argument is provided,
    the compiler will generate symbols for those subroutines and functions using the
    name fixed by the programmers. For example, the backtrace function can be exposed
    to Fortran from C, preserving the name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CMake code in `interfaces/CMakeLists.txt` also showed that it is possible
    to create a library from source files in different languages. CMake is evidently
    able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Discern which compiler to use to get object files from the listed source files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the linker appropriately to build a library (or executable) from these
    object files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How does CMake determine which compiler to use? Specifying the `LANGUAGES`
    option to the `project` command will let CMake check for working compilers for
    the given languages on your system. When a target is added with lists of source
    files, CMake will appropriately determine the compiler based on the file extension.
    Hence, files terminating with `.c` will be compiled to object files using the
    C compiler already determined, whereas files terminating with `.f90` (or `.F90`
    if they need preprocessing) will be compiled using the working Fortran compiler.
    Similarly for C++, the `.cpp` or `.cxx` extensions will trigger usage of the C++
    compiler. We have only listed some of the possible, valid file extensions for
    the C, C++, and Fortran languages, but CMake can recognize many more. What if
    the file extensions in your project are, for any reason, not among the ones that
    are recognized? The `LANGUAGE` source file property can be used to tell CMake
    which compiler to use on specific source files, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, what about the linker? How does CMake determine the linker language
    for targets? For targets that **do not mix** programming languages, the choice
    is straightforward: invoke the linker *via* the compiler command that was used
    to generate the object files. If the targets **do mix** programming languages,
    as in our example, the linker language is chosen based on that whose preference
    value is highest among the ones available in the language mix. With our example
    mixing Fortran and C, the Fortran language has higher preference than the C language
    and is hence used as linker language. When mixing Fortran and C++, it is the latter
    to have higher preference and is hence used as the linker language. Much as with
    the compiler language, we can force CMake to use a specific linker language for
    our target *via* the corresponding `LINKER_LANGUAGE` property on targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Building C/C++ projects that use Fortran libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-02) and
    has an example mixing C++, C, and Fortran. The recipe is valid with CMake version
    3.5 (and higher) and has been tested on GNU/Linux and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recipe 4, *Detecting the BLAS and LAPACK math libraries,* in [Chapter 3](c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml), *Detecting
    External Libraries and Programs*, showed how to detect BLAS and LAPACK linear
    algebra libraries, written in Fortran, and how to use them in C++ code. Here we
    will revisit this recipe, but this time from a different angle: focusing less
    on detecting the external libraries but rather discussing the aspect of mixing
    C++ and Fortran and the name mangling in more depth.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will reuse the sources from [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 4, *Detecting the BLAS and LAPACK math
    libraries*. Although we will not modify the actual implementation sources or header
    files, we will modify the project tree structure following the recommendations
    discussed in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring
    Projects*, and arrive at the following source code structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we have collected all the wrappers to BLAS and LAPACK, which provide the
    `math` library under `src/math`. The main program is `linear-algebra.cpp`. All
    sources are thus organized under the `src` subdirectory. To localize the scope,
    we have also split the CMake code over three `CMakeLists.txt` files, which we
    will discuss now.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This project mixes C++, which is the language of the main program, Fortran,
    because this is the language the libraries are written in, and C, which is needed
    to wrap the Fortran subroutines. In the root `CMakeLists.txt` file, we need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the project as mixed-language and set the C++ standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `GNUInstallDirs` module to direct CMake to save static and shared
    libraries and the executable into standard directories. We also instruct CMake
    to place Fortran compiled module files under `modules`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then move on to the next leaf subdirectory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The leaf file `src/CMakeLists.txt` adds yet another subdirectory, `math`, which
    contains the linear algebra wrappers. In  `src/math/CMakeLists.txt`, we need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We invoke `find_package` to get the location of the  BLAS and LAPACK libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the `FortranCInterface.cmake` module and verify that the Fortran,
    C and, C++ compilers are compatible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to generate preprocessor macros to take care of the name mangling
    of the BLAS and LAPACK subroutines. Once again, `FortranCInterface` comes to the
    rescue by generating a header file called `fc_mangle.h` in the current build directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a library with our sources for the BLAS and LAPACK wrappers. We
    also specify the directories where the header files and libraries are to be found.
    Notice the `PUBLIC` attribute, which will allow other targets depending on `math`
    to properly get their dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Stepping back to `src/CMakeLists.txt`, we finally add an executable target
    and link it to our `math` library of BLAS/LAPACK wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `find_package`, we have identified the correct libraries to link to.
    As in the previous recipe, we need to make sure that our program can correctly
    call the functions they define. As in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 4, *Detecting the BLAS and LAPACK math
    libraries, *we face the problem of compiler-dependent name mangling of symbols.
    We use the `FortranCInterface` CMake module to check the compatibility of the
    selected C and C++ compilers with the Fortran compiler. We also use the `FortranCInterface_HEADER`
    function to generate a header file with macros to take care of name mangling of
    Fortran subroutines. This was achieved with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will generate the `fc_mangle.h` header file with name-mangling
    macros, as inferred from the Fortran compiler, and save it into the current binary
    directory, `CMAKE_CURRENT_BINARY_DIR`. We were careful to set `CMAKE_CURRENT_BINARY_DIR` as
    an include path for our `math` target. Consider the following generated `fc_mangle.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The compiler in this example uses underscores for mangling. Since Fortran is
    case-insensitive, the subroutine might appear in either lowercase or uppercase,
    justifying the need to pass both cases to the macro. Notice that CMake will also
    generate macros for mangling symbols hidden behind Fortran modules.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, many implementations of BLAS and LAPACK ship with a thin C layer wrapper
    around the Fortran subroutines. These wrappers have been standardized over the
    years and are called CBLAS and LAPACKE, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have carefully organized the sources into a library target and an
    executable target, we should comment on the use of the `PUBLIC`, `INTERFACE`,
    and `PRIVATE` visibility attributes for the targets. These are essential for a
    clean CMake project structure. As with sources, include directories, compile definitions,
    and options, the meaning of these attributes remains the same when used in conjunction
    with `target_link_libraries`:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `PRIVATE` attribute, libraries will only be linked to the current target,
    but not to any other targets consuming it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `INTERFACE` attribute, libraries will only be linked to targets consuming
    the current target as a dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `PUBLIC` attribute, libraries will be linked to the current target
    and to any other target consuming it as a dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building C++ and Python projects using Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-03) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Cython is an optimizing static compiler that allows to write C extensions for
    Python. Cython is a very powerful tool and uses the extended Cython programming
    language (based on Pyrex). A typical use case for Cython is speeding up Python
    code, but it can also be used to interface C/C++ with Python *via* a Cython layer.
    In this recipe, we will focus on the latter use case and demonstrate how to interface C/C++
    and Python using Cython with the help of CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, we will use the following C++ code (`account.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code provides the following interface (`account.hpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using this example code, we can create bank accounts that start with a balance
    of zero. We can deposit to and withdraw from an account and also query the account
    balance using `get_balance()`. The balance itself is a private member of the `Account`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to be able to interact with this C++ class directly from Python
    – in other words, on the Python side, we wish to be able to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve this, we will need a Cython interface file (we will call this file `account.pyx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us look at how to generate the Python interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `CMakeLists.txt` starts out defining the CMake dependency, project name,
    and language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, it is best not to keep the build type undefined, so that we can
    match the build type of this project with the build type of the Python environment.
    Here we default to the `Release` build type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we will also require the Python interpreter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following CMake code will allow us to build the Python module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define a test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`python_test` executes `test.py`, where we make a couple of deposits and withdrawals
    and verify the balances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we are ready to configure, build, and test the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we have interfaced Python and C++ using a relatively compact
    `CMakeLists.txt` file, but we have achieved this by using the `FindCython.cmake`
    and `UseCython.cmake` modules, which have been placed under `cmake-cython`. These
    modules are included using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`FindCython.cmake` is included in `UseCython.cmake` and locates and defines `${CYTHON_EXECUTABLE}`.
    The latter module defines the `cython_add_module` and `cython_add_standalone_executable` functions,
    which can be used to create Python modules and standalone executables, respectively.
    Both modules have been downloaded from [https://github.com/thewtex/cython-cmake-example/tree/master/cmake](https://github.com/thewtex/cython-cmake-example/tree/master/cmake).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we use `cython_add_module` to create a Python module library.
    Note how we set the non-standard `CYTHON_IS_CXX` source file property to `TRUE`,
    so that the `cython_add_module` function will know to compile `pyx` as a C++ file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python module is created inside `${CMAKE_CURRENT_BINARY_DIR}`, and in order
    for the Python `test.py` script to locate it, we pass the relevant path with a
    custom environment variable, which is used inside `test.py` to set the `PATH`
    variable. Note how the `COMMAND` is set to call the CMake executable itself to
    set the local environment right before executing the Python script. This affords
    us platform-independence and avoids polluting the environment with spurious variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also take a look at the `account.pyx` file, which is the interface
    file between Python and C++ and describes the C++ interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can see `except +` in the `Account` class constructor. This directive allows
    Cython to handle exceptions raised by the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `account.pyx` interface file also describes the Python interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can see how the `cinit` constructor, the `__dealloc__` destructor, and the `deposit`
    and `withdraw` methods, are matched with the corresponding C++ implementation
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we have found a mechanism to couple Python and C++ by introducing
    a dependency on the Cython module. This module can preferably be installed by
    `pip` into a virtual environment or Pipenv, or by using Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C could be coupled analogously. If we wish to take advantage of constructors
    and destructors, we could write a thin C++ layer around the C interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed Memoryviews offer the interesting functionality to map and access memory
    buffers allocated by C/C++ directly in Python, without creating any overhead:
    [http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html](http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html).
    They make it possible to map NumPy arrays directly to C++ arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Building C++ and Python projects using Boost.Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-04) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The Boost libraries offer another popular alternative to interface C++ code
    with Python. This recipe will show how to use CMake for C++ projects that rely
    on Boost.Python to expose their functionality as a Python module. We will reuse
    the example from the previous recipe and attempt to interact with the same C++
    implementation (`account.cpp`) as in the Cython example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we keep `account.cpp` unchanged, we modify the interface file from the
    previous recipe (`account.hpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the required steps to use Boost.Python with your C++ project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous recipe, we start by defining the minimum version, the project
    name, supported language, and the default build type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we depend on the Python and Boost libraries as well as the
    Python interpreter for testing. The name of the Boost.Python component depends
    on the Boost version and the Python version, so we probe a couple of possible
    component names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following commands, we define the Python module and its dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define a test for this implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The code can now be configured, compiled, and tested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of depending on the Cython module, this recipe now depends on locating
    the Boost libraries on the system, in combination with the Python development
    headers and library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python development headers and library are searched for with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note how we first searched for the interpreter and then for the development
    headers and libraries. Moreover, the search for `PythonLibs` asks for the exact
    same major and minor versions for the development headers and libraries as were
    found for the interpreter. This is necessary for ensuring that consistent versions
    of interpreter and libraries are used throughout the project. However, this command
    combination will not guarantee that an exactly matching version of the two will
    be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'When locating the Boost.Python component, we have met the difficulty that the
    name of the component that we try to locate depends both on the Boost version
    and our Python environment. Depending on the Boost version, the component can
    be called `python`, `python2`, `python3`, `python27`, `python36`, `python37`,
    and so on. We have solved this problem by searching from specific to more generic
    names and only failing if no match can be located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Discovery and usage of the Boost libraries can be tweaked by setting additional
    CMake variables. For example, CMake offers the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost_USE_STATIC_LIBS` can be set to `ON` to force the use of the static version
    of the Boost libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost_USE_MULTITHREADED` can be set to `ON` to ensure that the multithreaded
    version is picked up and used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost_USE_STATIC_RUNTIME` can be set to `ON` such that our targets will use
    the variant of Boost that links the C++ runtime statically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another new aspect introduced by this recipe is the use of the `MODULE` option
    to the `add_library` command. We already know from Recipe 3, *Building and linking
    shared and static libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml), *From
    a Simple Executable to Libraries*, that CMake accepts the following options as
    valid second argument to `add_library`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`STATIC`, to create static libraries; that is, archives of object files for
    use when linking other targets, such as executables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHARED`, to create shared libraries; that is, libraries that can be linked
    dynamically and loaded at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBJECT`, to create object libraries; that is, object files without archiving
    them into a static library, nor linking them into a shared object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `MODULE` option introduced here will generate a *plugin library;* that
    is, a Dynamic Shared Object (DSO) that is not linked dynamically into any executable,
    but can still be loaded at runtime. Since we are extending Python with our own
    functionality written in C++, the Python interpreter will need to be able to load
    our library at runtime. This can be achieved by using the `MODULE` option to `add_library`
    and by preventing the addition of any prefix (for example, `lib` on Unix systems)
    to the name of our library target. The latter operation is carried out by setting
    the appropriate target property, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'One aspect of all recipes that demonstrate the interfacing of Python and C++
    is that we need to describe to the Python code how to hook up to the C++ layer
    and to list the symbols which should be visible to Python. We also have the possibility
    to (re)name these symbols. In the previous recipe, we did this in a separate `account.pyx`
    file. When using `Boost.Python`, we describe the interface directly in the C++
    code, ideally close to the definition of the class or function we wish to interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BOOST_PYTHON_MODULE` template is included from `<boost/python.hpp>` and
    is responsible for creating the Python interface. The module will expose an `Account`
    Python class that maps to the C++ class. In this case, we do not have to explicitly
    declare a constructor and destructor – these are created for us and called automatically
    when the Python object is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The destructor is called when the object goes out of scope and is collected
    by the Python garbage collection. Also, observe how `BOOST_PYTHON_MODULE` exposes
    the `deposit`, `withdraw`, and `get_balance` functions, and maps them to the corresponding
    C++ class methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, the compiled module can be found by Python when placed in `PYTHONPATH`.
    In this recipe, we have achieved a relatively clean separation between the Python
    and C++ layers. The Python code is not restricted in functionality, does not require
    type annotation or rewriting of names, and remains *pythonic*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we rely on Boost being installed on the system and so the CMake
    code tries to detect the corresponding library. Alternatively, we could have shipped
    the Boost sources together with our project and build this dependency as part
    of the project. Boost is a portable way to interface Python with C(++). The portability
    with respect to compiler support and C++ standard however comes at a price: Boost.Python
    is not a lightweight dependency. In the following recipe, we will discuss a lightweight
    alternative to Boost.Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Building C++ and Python projects using pybind11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-05) and
    has a C++ example. The recipe is valid with CMake version 3.11 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous recipe, we have used Boost.Python to interface Python with
    C(++). In this recipe, we will try to interface Python with C++ using pybind11
    as a lightweight alternative that makes use of C++11 features and therefore requires
    a compiler with C++11 support. As an additional variation to the previous recipe
    we will demonstrate how to fetch the pybind11 dependency at configure time and
    build our project including a Python interface using the FetchContent approach,
    which we met in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests*, Recipe 3, *Define a unit test and linking against Google Test,*
    and discussed in [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The
    Superbuild Pattern*, Recipe 4, *Managing dependencies with a superbuild: III.
    The Google Test framework*. In [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml), *Packaging
    Projects*, Recipe 2, *Distributing a C++/Python project built with CMake/pybind11
    via PyPI*, we will revisit this example and show how to package it and make it
    installable with pip.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will keep `account.cpp` unchanged with respect to the previous two recipes
    and only modify `account.hpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We will follow the pybind11 documentation "Building with CMake" ([https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-cmake](https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-cmake))
    and introduce the pybind11 CMake code using `add_subdirectory`. However, we will
    not place the pybind11 source code explicitly into our project directory, but
    rather demonstrate how to fetch pybind11 sources at configure time using `FetchContent`
    ([https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For better code reuse in the next recipe, we will also place all sources into
    a subdirectory and use the following project layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us analyze in detail the contents of the various `CMakeLists.txt` files
    in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The root `CMakeLists.txt` file contains the familiar header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, we also query the Python interpreter that will be used for testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We then include the account subdirectory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we define the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `account/CMakeLists.txt`, we fetch pybind11 sources at configure time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the Python module. Once again we use the `MODULE` option
    to `add_library`. We also set the prefix and suffix properties for our library
    target to the values `PYTHON_MODULE_PREFIX` and `PYTHON_MODULE_EXTENSION`, which
    are appropriately inferred by pybind11:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us test it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The functionality and use of pybind11 is very similar to Boost.Python, the
    bonus being that pybind11 is a more lightweight dependency – although we will
    require C++11 support from the compiler. The interface definition in `account.hpp`
    is rather similar to that in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can clearly recognize how Python methods are mapped to C++ functions.
    The library that interprets `PYBIND11_MODULE` is defined in the imported target
    `pybind11::module`, which we have included using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two differences with respect to the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not require pybind11 to be installed on the system and therefore do not
    try to locate it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `${pybind11_sources_SOURCE_DIR}` subdirectory, which contains pybind11 `CMakeLists.txt`,
    does not exist when we start building our project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One solution for this challenge is to use the `FetchContent` module, which
    fetches the pybind11 sources and CMake infrastructure at configure time so that
    we can reference it using `add_subdirectory`. Using the `FetchContent` pattern,
    we can now assume that pybind11 is available within the build tree, which allows
    us to build and link the Python module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the following command to make sure that the Python module library gets
    a well-defined prefix and suffix, compatible with the Python environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the top-level `CMakeLists.txt` file is testing (we use the same `test.py` as
    in the previous recipe).
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could have included the pybind11 sources as part of our project source code
    repository, which would simplify the CMake structure and remove the requirement to
    have network access to the pybind11 sources at compile time. Alternatively, we
    could have defined the pybind11 source path as a Git submodule ([https://git-scm.com/book/en/v2/Git-Tools-Submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules))
    to simplify the updating of the pybind11 source dependency.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have solved this using `FetchContent`, which provides a very
    compact approach to referencing a CMake subproject without explicitly tracking
    its sources. Also, we could have solved this recipe using the so-called superbuild
    approach (see [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml), *The Superbuild
    Pattern*).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see how you can expose simple functions, define docstrings, map memory buffers,
    and find further reading, we refer to the pybind11 documentation: [https://pybind11.readthedocs.io](https://pybind11.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: Mixing C, C++, Fortran, and Python using Python CFFI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06) and
    has C++ and Fortran examples. The recipes are valid with CMake version 3.5 (and
    higher). Both versions of the recipe have been tested on GNU/Linux, macOS, and
    Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous three recipes, we have discussed Cython, Boost.Python, and pybind11
    as tools to interface Python and C++ providing a modern and clean approach. The
    main interface in the previous recipes was a C++ interface. However, we may be
    in a situation where we do not have a C++ interface to hook on to and where we
    would like to interface Python with Fortran or other languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will demonstrate an alternative approach for interfacing
    Python using the Python C Foreign Function Interface (CFFI; see also [https://cffi.readthedocs.io](https://cffi.readthedocs.io)).
    Since C is the *lingua franca* of programming languages and most programming languages
    (including Fortran) are able to talk to a C interface, Python CFFI is a tool to
    couple Python with a large number of languages. A very nice feature of Python
    CFFI is that the resulting interface is thin and non-intrusive, meaning that it
    neither restricts the Python layer in language features, nor does it impose any
    restrictions on the code below the C layer, apart from requiring a C interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will apply Python CFFI to couple Python and C++ *via* a C
    interface using the bank account example introduced in preceding recipe. Our goal
    is to arrive at a context-aware interface where we can instantiate several bank
    accounts, each carrying its internal state. We will conclude this recipe by commenting
    on how to couple Python and Fortran using Python CFFI. In [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml), *Packaging
    Projects*, Recipe 3, *Distributing a C/Fortran/Python project built with CMake/CFFI
    via PyPI*, we will revisit this example and show how to package it and make it
    installable with pip.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will require a couple of files for this recipe. Let us start with the C++
    implementation and interface. We will place these in a subdirectory called `account/implementation`.
    The implementation file (`cpp_implementation.cpp`) is similar to that in previous
    recipes but contains additional `assert` statements, since we will keep the state
    of the object in an opaque handle and we will have to make sure that the object
    is created before we try to access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface file (`cpp_implementation.hpp`) contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we isolate a C—C++ interface (`c_cpp_interface.cpp`). This will
    be the interface we will try to hook into with Python CFFI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'One directory up, under `account`, we describe the C interface (`account.h`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We also describe the Python interface, which we will comment on below (`__init__.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a handful of files, but, as we will see, most of this interface work
    is generic and reusable and the actual interface is rather thin. To summarize,
    this is the layout of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us now use CMake to combine these files to form a Python module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level `CMakeLists.txt` file contains a familiar header. In addition,
    we also set the location of our compiled library according to GNU standards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step is to include definitions for interfaces and implementation
    sources under the `account` subdirectory, which we will detail further down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-level `CMakeLists.txt` file concludes with the definition of a test
    (which requires the Python interpreter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The included `account/CMakeLists.txt` defines the shared library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we generate a portable export header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to take the Python—C interface for a spin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the previous recipes required us to explicitly declare the Python—C interface
    and to map Python names to C(++) symbols, Python CFFI infers this mapping on its
    own from the C header file (in our case, `account.h`). The only thing we need
    to provide to our Python CFFI layer is the header file describing the C interface
    and a shared library containing the symbols. We have done this using environment
    variable set in the main `CMakeLists.txt` file, and these environment variables
    are queried in `__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `get_lib_handle` function opens and parses the header file (using `ffi.cdef`),
    loads the library (using `ffi.dlopen`), and returns the library object. The preceding
    file is in principle generic, and can be reused without modification for other
    projects interfacing Python and C or other languages using Python CFFI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_lib` library object could be exported directly, but we do one additional
    step so that the Python interface feels more *pythonic* when used Python-side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative would be less intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we are able to instantiate and track isolated contexts with our context-aware
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to import the `account` Python module, we need to provide the `ACCOUNT_HEADER_FILE` and `ACCOUNT_LIBRARY_FILE` environment
    variables, as we do for the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml), *Packaging Projects*,
    we will discuss how to create a Python package that can be installed with pip
    where the header and library files will be installed in well-defined locations
    so that we do not have to define any environment variables to use the Python module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having discussed the Python aspect of the interface, let us now consider the
    C-side of the interface. The essence of `account.h` is this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The opaque handle, `account_context`, holds the state of the object. `ACCOUNT_API`
    is defined in `account_export.h`, which is generated by CMake in `account/interface/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `account_export.h` export header defines the visibility of the interface
    functions and makes sure this is done in a portable way. We will discuss this
    point in further detail in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*. The actual implementation can be found in `cpp_implementation.cpp`.
    It contains the `is_initialized` boolean, which we can check to make sure that
    API functions are called in the expected order: the context should not be accessed
    before it is created or after it is freed.'
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing a Python—C interface, it is important to carefully consider
    on which side to allocate arrays: arrays can be allocated either on the Python
    side and passed to the C(++) implementation, or they can be allocated on the C(++)
    implementation that returns a pointer. The latter approach is convenient for situations
    where the buffer sizes are *a priori* not known. However, returning pointers to
    arrays allocated C(++)-side can be problematic since it can lead to memory leaks
    due to Python garbage collection, which does not "see" the allocated arrays. We
    recommend to design the C API such that arrays can be allocated outside and passed
    to the C implementation. These arrays can then be allocated within `__init__.py`,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `return_array` function returns a Python list. Since we have done all the
    allocation work on the Python side, we do not have to worry about memory leaks
    and can leave the cleanup to the garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a Fortran example, we refer the reader to the following recipe repository: [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06/fortran-example](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-09/recipe-06/fortran-example).
    The main difference compared to the C++ implementation is that the account library
    is compiled from a Fortran 90 source file that we account for in `account/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The context is kept in a user-defined type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The Fortran implementation is able to resolve symbols and methods defined in
    the unchanged `account.h` by using the `iso_c_binding` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe and solution has been inspired by Armin Ronacher's post, "Beautiful
    Native Libraries", [http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/](http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/).
  prefs: []
  type: TYPE_NORMAL
