- en: Structuring Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Code reuse with functions and macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting CMake sources into modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a function to test and set compiler flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a function or macro with named arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redefining functions and macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecating functions, macros, and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting scope with `add_subdirectory`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding global variables using `target_sources`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing Fortran projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have discovered a number of building blocks to
    create projects configured and built using CMake. In this chapter, we will discuss
    how to combine these building blocks and introduce abstractions to avoid huge
    `CMakeLists.txt` files and minimize code repetition, global variables, global
    state, and explicit ordering. Our goal will be to present patterns for a modular
    CMake code structure and for limiting the scope of variables. We will discuss
    strategies that will also help us control CMake code complexity for medium to
    large code projects.
  prefs: []
  type: TYPE_NORMAL
- en: Code reuse with functions and macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-01)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In any programming language, functions allow us to abstract (hide) details and
    avoid code repetition, and CMake is no exception. In this recipe, we will discuss
    macros and functions as an example, and we will introduce a macro to make it more
    convenient for us to define tests and set the ordering of tests. Instead of calling `add_test`
    and `set_tests_properties` to define each set and to set the expected `COST` of
    each test ([Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests*, Recipe 8, *Running tests in parallel*), our goal is to define
    a macro that will be able to take care of both in one go.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the example presented in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml),
    *Creating and Running Tests*, Recipe 2, *Defining a unit test using the Catch2
    library*. The `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp` files are
    unchanged and can be used to compute the sum of integers provided as command line
    arguments. The source code for the unit tests (`test.cpp`) is used unchanged,
    as well. We also require the Catch2 header file, `catch.hpp`. In contrast to [Chapter
    4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running Tests,* Recipe
    2, *Defining a unit test using the Catch2 library*, we will structure the source
    files into subdirectories and form the following file tree (we will discuss the
    CMake code later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us follow the required steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level `CMakeLists.txt` defines the minimum CMake version, project name,
    and supported language, and requires the C++11 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We further define binary and library paths according to GNU standards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we use `add_subdirectory` calls to structure our CMake code into `src/CMakeLists.txt`
    and `tests/CMakeLists.txt` parts. We also enable testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/CMakeLists.txt` file defines the source code targets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In `tests/CMakeLists.txt`, we first build and link the `cpp_test` executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a new macro, `add_catch_test`, which we will discuss later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define two tests using `add_catch_test` and in addition, we set
    and print the value of a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to test it out. First, we configure the project (the interesting
    output lines are shown):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we build and run the tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that the long test is started first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new feature in this recipe is the `add_catch_test` macro. The macro expects
    two arguments, `_name` and `_cost`, and we can use these arguments inside the
    macro to call `add_test` and `set_tests_properties`. The leading underscores are
    our choice, but with this we indicate to the reader that these arguments have
    local scope and can only be accessed within the macro. Also, note that the macro
    automatically populates `${ARGC}` (number of arguments) and `${ARGV}` (list of
    arguments), and we verified this in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro also defines `${ARGN}`, which holds the list of arguments past the
    last expected argument. In addition, we can also address arguments with `${ARGV0}`, `${ARGV1}`,
    and so on. Observe how we caught the unexpected argument (`extra_argument`) in
    this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have done that using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this if-check, we had to introduce a new variable and could not query `ARGN`
    directly since it is not a variable in the usual CMake sense. With this macro,
    we were not only able to define tests by their name and command but also indicate
    the expected cost, which led to the "long" test being started before the "short"
    test thanks to the `COST` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have implemented this using a function instead of a macro with the
    same syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between macros and functions is their variable scope. Macros
    are executed in the scope of the caller whereas functions have own variable scope.
    In other words, if we need to set or modify variables that should be available
    to the caller, we typically use a macro. If no output variables are set or modified,
    we preferably use a function. We remark that it is possible to modify parent scope
    variables also in a function, but this has to be explicitly indicated using `PARENT_SCOPE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the scope, we have written the following call after the definition
    of the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the macro, we increase `num_macro_calls` by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the output produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we changed the macro to a function, the tests would still work but `num_macro_calls`
    would remain 0 throughout the calls in the parent scope. It is useful to imagine
    CMake macros as being like functions, which are substituted directly into the
    place where they are called (inlined in the C language sense). It is useful to
    imagine CMake functions as black boxes where nothing comes back unless you explicitly
    define it as `PARENT_SCOPE`. Functions in CMake do not have return values.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to nest function calls in macros and macro calls in functions,
    but we need to carefully consider the scope of the variables. If a feature can
    be implemented using a function, then this is probably preferable to a macro since
    it gives more default control over the parent scope state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also mention the use of `CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE` in `src/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command adds the current directory to the `INTERFACE_INCLUDE_DIRECTORIES`
    property for all targets defined in this `CMakeLists.txt` file. In other words,
    we did not have to use `target_include_directories` to indicate the header file
    location for `cpp_test`.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting CMake sources into modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-02).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Projects typically start with a single `CMakeLists.txt` file, but over time
    this file grows and in this recipe we will demonstrate one mechanism for splitting `CMakeLists.txt`
    up into smaller units. There are several motivations for splitting up `CMakeLists.txt`
    into modules that can be included in the main `CMakeLists.txt` or other modules:'
  prefs: []
  type: TYPE_NORMAL
- en: The main `CMakeLists.txt` is easier to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake modules can be reused in other projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In combination with functions, modules can help us limit the scope of variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will demonstrate how to define and include a macro that allows
    us to get colored CMake output (for important status messages or warnings).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will use two files, the main `CMakeLists.txt` and `cmake/colors.cmake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cmake/colors.cmake` file contains definitions for colored output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how we can use the color definitions to generate colored status messages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start out with a familiar preamble:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we append the `cmake` subdirectory to the list of module paths that CMake
    will search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then include the `colors.cmake` module and call the macro defined within:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we print a couple of messages in different colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us test it out (this output should appear colored on your screen if you
    use macOS or Linux):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cac2beae-84fd-4a10-9dd5-c9925e2f1f6a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is an example where no code is compiled and no language support is required,
    and we have indicated this by `LANGUAGES NONE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined the `define_colors` macro and placed it in `cmake/colors.cmake`.
    We chose to use a macro and not a function since we also wish to use the variables
    defined inside the macro in the scope of the call to change colors in the messages.
    We have included the macro and called `define_colors` using the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we also need to tell CMake where to look for the macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `include(colors)` command instructs CMake to search `${CMAKE_MODULE_PATH}`
    for a module with the name `colors.cmake`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have used an explicit include as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recommended practice is to define macros or functions in modules and then
    call the macro or function. It is not good practice to use module includes as
    function calls. Including a module should not do more than defining functions
    and macros and discovering programs, libraries, and paths. The actual include
    command should not define or modify variables and the reason for this is that
    a repeated include, which may be accidental, should not introduce any unwanted
    side effects. In Recipe 5, *Redefining functions and macros*, we will create a
    guard against accidental includes.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a function to test and set compiler flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-03)
    and has a C/C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous two recipes, we used macros; in this recipe, we will use a
    function to abstract away details and avoid code repetition. In the example, we
    will implement a function that accepts a list of compiler flags. The function
    will try to compile a test code with these flags, one by one, and return the first
    flag that was understood by the compiler. By doing so, we will learn a couple
    of new features: functions, list manipulations, string manipulations, and checking
    whether compiler flags are supported by the compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following the recommended practice of the previous recipe, we will define the
    function in a module (`set_compiler_flag.cmake`), include the module, and then
    call the function. The module contains the following code, which we will discuss
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how we can use the `set_compiler_flag` function in our `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preamble, we define the minimum CMake version, project name, and supported
    languages (in this case, C and C++):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we include `set_compiler_flag.cmake`, in this case explicitly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we try a list of C flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And we try a list of C++ flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can configure the project and verify the output. Only the relevant
    output is shown and the output may differ depending on the compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pattern that we have used here is:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a function or macro and place it in a module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the module
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the function or macro
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the output, we can see that the code checks each flag in the list and
    as soon as the check is successful, it prints the successful compile flag. Let
    us look inside the `set_compiler_flag.cmake` module. This module, in turn, includes
    three modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These are standard CMake modules and CMake will locate them in `${CMAKE_MODULE_PATH}`.
    These modules provide the `check_c_compiler_flag`, `check_cxx_compiler_flag`,
    and `check_fortran_compiler_flag` macros, respectively. Then comes the function
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `set_compiler_flag` function expects two arguments and we call them `_result`
    (this will hold the successful compile flag or the empty string "") and `_lang`
    (which specifies the language: C, C++, or Fortran).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to be able to call the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This call has five arguments, but the function header only expects two. This
    means that `REQUIRED`, `"-Wall"`, and `"-warn all"` will be placed in `${ARGN}`.
    From `${ARGN}`, we first build a list of flags using `foreach`. At the same time,
    we filter out `REQUIRED` from the list of flags and use it to set `_flag_is_required`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will loop over `${_list_of_flags}`, try each flag, and if `_flag_works`
    is set to `TRUE`, we set `_flag_found` to `TRUE` and abort a further search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `unset(_flag_works CACHE)` line is there to make sure that the result of `check_*_compiler_flag`
    is not cached between calls using the same `_flag_works` result variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a flag is found and `_flag_works` set to `TRUE`, we define the variable
    mapped to by `_result`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This needs to be done with `PARENT_SCOPE` since we are modifying a variable
    that we wish to print and use outside the function body. Note, in addition, how
    we dereferenced the variable `_result` passed from parent scope using the `${_result}`
    syntax. This is necessary to ensure that the working flag is set as value of the
    variable passed from parent scope when invoking the function, regardless of its
    name. If no flag is found and the `REQUIRED` keyword was provided, we stop the
    configuration with an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could have achieved this task with a macro, but with a function, we have
    more control over the scope. We know that the only variable that can be modified
    by the function is the result variable.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that some flags need to be set both at compile and link time by setting
    `CMAKE_REQUIRED_FLAGS` for the `check_<LANG>_compiler_flag` function to report
    success correctly. This was the case for the sanitizers, as we discussed in [Chapter
    5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml), *Configure-time and Build-time
    Operations*, Recipe 7, *Probing compiler flags*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a function or macro with named arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-04)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous recipes, we explored functions and macros and used positional
    arguments. In this recipe, we will define a function with named arguments. We
    will enhance the example from Recipe 1, *Code reuse with functions and macros*
    and instead of defining tests using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the example from Recipe 1, *Code reuse with functions and macros*
    and keep the C++ sources unchanged and the file tree essentially the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will introduce small modifications in the CMake code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only one additional line is added in the top-level `CMakeLists.txt`, since
    we will include a module located under `cmake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We keep `src/CMakeLists.txt` unmodified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `tests/CMakeLists.txt`, we move the `add_catch_test` function definition
    to `cmake/testing.cmake` and define two tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add_catch_test` function is now defined in `cmake/testing.cmake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to test the output. First, we configure the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, compile and test the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new aspects in this recipe are the named arguments so we can focus on the `cmake/testing.cmake` module.
    CMake provides the `cmake_parse_arguments` command, which we call with the function
    name (`add_catch_test`) options (in our case, none), one-value arguments (here, `NAME`
    and `COST`), and multi-value arguments (here, `LABELS`, `DEPENDS`, and `REFERENCE_FILES`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cmake_parse_arguments` command parses options and arguments, and defines
    the following in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_catch_test_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_catch_test_COST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_catch_test_LABELS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_catch_test_DEPENDS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_catch_test_REFERENCE_FILES`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can then query and use these variables inside our function. This approach
    gives us the chance to implement functions and macros with more robust interfaces
    and more readable function/macro calls.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Option keywords (which we have not used in this example) are defined by `cmake_parse_arguments`
    to either `TRUE` or `FALSE`. A further enhancement of the `add_catch_test` function
    could be to also provide the test command as a named argument, which we have omitted
    for the benefit of a more concise example.
  prefs: []
  type: TYPE_NORMAL
- en: The `cmake_parse_arguments` command was made available within the `CMakeParseArguments.cmake`
    module prior to the release of CMake 3.5\. Thus, this recipe can be made to work
    with earlier versions of CMake by using the `include(CMakeParseArguments)` command
    at the top of the `cmake/testing.cmake` module file.
  prefs: []
  type: TYPE_NORMAL
- en: Redefining functions and macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-05).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We have mentioned that module includes *should not* be used as function calls
    since modules could be (accidentally) included multiple times. In this recipe,
    we will program our own simple include guard, which will warn us if we try to
    include a module multiple times. The built-in `include_guard` command is available
    in CMake since version 3.10 and behaves like `#pragma once` for C/C++ header files.
    For this version of CMake, we will discuss and demonstrate how functions and macros
    can be redefined. We will show how we can check the CMake version and for versions
    below 3.10, we will use our custom include guard.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will use three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom `custom.cmake` module contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss `cmake/include_guard.cmake` and `CMakeLists.txt` later.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a step-by-step breakdown of our three CMake files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will not compile any code and our language requirement is
    therefore `NONE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define an `include_guard` macro, which we place in a separate module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cmake/include_guard.cmake` file contains the following (we will discuss
    it in detail shortly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the main `CMakeLists.txt`, we then simulate including the custom module
    accidentally twice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we configure with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The result using CMake 3.10 and higher is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The result using CMake below 3.10 is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `include_guard` macro contains two branches, one for CMake below 3.10 and
    one for CMake 3.10 and higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If CMake version is below 3.10, we enter the first branch and an intrinsic
    `include_guard` is not available, so we define our own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If the macro is called the first time, then the `included_modules` variable is
    not defined so we set it to an empty list. We then check whether `${CMAKE_CURRENT_LIST_FILE}`
    is an element of the `included_modules` list. If yes, we issue a warning. If no,
    we append `${CMAKE_CURRENT_LIST_FILE}` to this list. In the CMake output, we can
    verify that a second include of the custom module indeed leads to the warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation is different for CMake 3.10 and higher; in this case, an intrinsic `include_guard`
    exists and we call it with the arguments received by our own macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, `_include_guard(${ARGV})` points to the built-in `include_guard`. In this
    case, we have augmented the built-in command with a custom message ("calling the
    built-in `include_guard`"). This pattern provides us with a mechanism to redefine
    own or built-in functions and macros. This can be useful for debugging or logging
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern can be useful but it should be applied with care since CMake will
    not warn about the redefinition of macros or functions.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecating functions, macros, and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-06).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecation is an important mechanism in the development of an evolving project
    to signal to developers that a function or macro or a variable will be removed
    or replaced at some point in the future. For a certain period, the function, macro,
    or variable will continue being accessible but signal a warning, which eventually
    can be elevated to an error.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start out with the following CMake project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a custom include guard, includes a custom module (the same
    module as in the previous recipe), and prints the list of all included modules.
    For CMake 3.10 and higher, we now know from the previous recipe that there is
    a built-in `include_guard`. But instead of simply removing `custom_include_guard`
    and `${included_modules}`, we will deprecate the macro and the variable with a
    deprecation warning, which at some point we can flip into a `FATAL_ERROR` to make
    the code stop and force the developers to switch to the built-in command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deprecating functions, macros, and variables can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a function that we will use to deprecate a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if the version of CMake is greater than 3.9, we redefine `custom_include_guard`
    and attach `variable_watch` to `included_modules`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuring the project on CMake below version 3.10 produces the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake 3.10 and higher will produce the expected deprecation warnings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deprecating a function or a macro is equivalent to redefining it, as demonstrated
    in the previous recipe, and printing a message with `DEPRECATION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecating a variable can be achieved by first defining the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is then attached to the variable that is about to be deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If in this case `${included_modules}` is read (`READ_ACCESS`), then the `deprecate_variable` function issues
    the message with `DEPRECATION`.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting scope with add_subdirectory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-07)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the remaining recipes of this chapter, we will discuss strategies to structure
    projects and limit the scope of variables and side effects with the goal to lower
    code complexity and simplify the maintenance of the project. In this recipe, we
    will split a project into several `CMakeLists.txt` files with limited scope, which
    will be processed using the `add_subdirectory` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we wish to show and discuss how to structure a non-trivial project, we
    need an example that is more than a "hello world" project. We will develop a relatively
    simple code that can compute and print elementary cellular automata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Cellular_automaton#Elementary_cellular_automata](https://en.wikipedia.org/wiki/Cellular_automaton#Elementary_cellular_automata)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://mathworld.wolfram.com/ElementaryCellularAutomaton.html](http://mathworld.wolfram.com/ElementaryCellularAutomaton.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our code will be able to compute any of the 256 elementary cellular automata,
    for instance rule 90 (Wolfram code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of our example code project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have split the code into many libraries to simulate a real-world medium
    to large project, where sources can be organized into libraries that are then
    linked into an executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main function is in `src/main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `external/conversion.cpp` file contains code to convert from decimal to
    binary. We simulate here that this code is provided by an "external" library outside
    of `src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/evolution/evolution.cpp` file propagates the system in a time step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/initial/initial.cpp` file produces the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/io/io.cpp` file contains a function to print a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/parser/parser.cpp` file parses the command-line input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, `tests/test.cpp` contains two unit tests using the Catch2 library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding header files contain the function signatures. One could argue
    that the project contains too many subdirectories for this little code example,
    but please remember that this is only a simplified example of a project typically
    containing many source files for each library, ideally organized into separate
    directories like here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us dive into a detailed explanation of the CMake infrastructure needed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level `CMakeLists.txt` is very similar to Recipe 1, *Code reuse with
    functions and macros*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Targets and sources are defined in `src/CMakeLists.txt` (except the conversion
    target):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion library is defined in `external/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/CMakeLists.txt` file adds further subdirectories, which in turn contain
    `CMakeLists.txt` files. They are all similar in structure; `src/evolution/CMakeLists.txt`
    contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The unit tests are registered in `tests/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuring and building the project yields the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we run the unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could have put all the code into one source file. This would be impractical;
    every edit would require a full recompilation. Splitting source files into smaller,
    more manageable units makes sense. We could have equally well compiled all sources
    into a single library or executable, but in practice, projects prefer to split
    the compilation of sources into smaller, well-defined libraries. This is done
    both to localize scope and simplify dependency scanning, but also to simplify
    code maintenance. This means that building a project out of many libraries as
    we have done here is a typical situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To discuss the CMake structure we can proceed bottom-up from the individual
    `CMakeLists.txt` files defining each library, such as `src/evolution/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'These individual `CMakeLists.txt` files define libraries as close as possible
    to the sources. In this example, we first define the library name with `add_library`
    and then define its sources and include directories, as well as their target visibility:
    the implementation files (here `evolution.cpp`) are `PRIVATE`, whereas the interface
    header file `evolution.hpp` is defined as `PUBLIC` since we will access it in
    `main.cpp` and `test.cpp`. The advantage of defining targets as close as possible
    to the code is that code developers with knowledge of this library and possibly
    limited knowledge of the CMake framework only need to edit files in this directory;
    in other words, the library dependencies are encapsulated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving one level up, the libraries are assembled in `src/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This file, in turn, is referenced in the top-level `CMakeLists.txt`. This means
    that we have built our project from a tree of libraries using a tree of `CMakeLists.txt`
    files. This approach is typical for many projects and it scales to large projects
    without the need to carry lists of source files in global variables across directories.
    An added bonus of the `add_subdirectory` approach is that it isolates scopes since
    variables defined in a subdirectory are not automatically accessible in the parent
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One limitation of building a project using a tree of `add_subdirectory` calls
    is that CMake does not allow us to use `target_link_libraries` with targets that
    are defined outside of the current directory scope. This was not a problem for
    the example shown in this recipe. In the next recipe, we will demonstrate an alternative
    approach where we assemble the different `CMakeLists.txt` files not using `add_subdirectory`,
    but using module includes, which allows us to link to targets defined outside
    the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake can use the Graphviz graph visualization software ([http://www.graphviz.org](http://www.graphviz.org/))
    to generate the dependency graph of a project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated diagram will show dependencies between targets in different directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cae65879-e147-4142-bcf4-fca0337c2e16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Throughout the book, we have been building the code *out-of-source* to keep
    the source tree and build tree separate. This is the recommended practice to allow
    us to configure different builds (sequential or parallel, `Debug` or `Release`)
    with the same source code, without duplicating the source code and without spilling
    generated and object files across the source tree. With the following snippet,
    you can protect your project against in-source builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'It is useful to recognize that the structure of the build tree mimics the structure
    of the source tree. In our example here, it is rather instructive to insert the
    following `message` printout into `src/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: When configuring the project to `build`, we will see that the printout refers
    to `build/src`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We note that, as of version 3.12 of CMake, `OBJECT` libraries are another viable
    approach to organizing large projects. The only modification to our example would
    be in the `CMakeLists.txt` for the libraries. The sources would be compiled into
    object files: neither archived into a static archive, nor linked into a shared
    library. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-level `CMakeLists.txt` remains unchanged: the `automata` executable
    target links these object files into the final executable. Usage requirements,
    such as include directories, compile flags, and link libraries set on the `OBJECT`
    libraries will correctly be inherited. For more details on this new feature of
    `OBJECT` libraries introduced in CMake 3.12 refer to the official documentation:
    [https://cmake.org/cmake/help/v3.12/manual/cmake-buildsystem.7.html#object-libraries](https://cmake.org/cmake/help/v3.12/manual/cmake-buildsystem.7.html#object-libraries)'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding global variables using target_sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-08)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss an alternative approach to the previous recipe
    and assemble the different `CMakeLists.txt` files without using `add_subdirectory`,
    but using module includes. This approach is inspired by [https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/](https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/)
    and allows us to use `target_link_libraries` to link to targets defined outside
    of the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the same source code as in the previous recipe. The only changes
    will be in `CMakeLists.txt` files and we will discuss these changes in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us look in detail at the various files needed by CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level `CMakeLists.txt` contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The `external/CMakeLists.txt` file is unchanged compared to the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `src/CMakeLists.txt` file defines two libraries (`automaton` and `evolution`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/evolution/CMakeLists.txt` file contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining `CMakeLists.txt` files are equivalent to `src/initial/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuring, building, and testing yields a result equivalent to the previous
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In contrast to the previous recipe, we have defined three libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conversion` (defined in `external`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`automaton` (containing all sources except conversion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`evolution` (defined in `src/evolution` and linked against by `cpp_test`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we keep all targets available in the parent scope by referencing
    `CMakeLists.txt` files using `include()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build a tree of includes, remembering that when stepping into subdirectories
    (`src/CMakeLists.txt`), we need to use paths relative to the parent scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can define and link to the targets anywhere within the file tree
    accessed *via* `include()` statements. However, we should choose to define them
    at a place that is most intuitive for maintainers and code contributors.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can once again use CMake and Graphviz ([http://www.graphviz.org/](http://www.graphviz.org/))
    to generate the dependency graph of this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'For the current setup, we obtain the following dependency graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5d0ac0-84c8-40e7-8cc8-6da65f4e0b0f.png)'
  prefs: []
  type: TYPE_IMG
- en: Organizing Fortran projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-07/recipe-09)
    and has a Fortran example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We devote one recipe to the discussion of how to structure and organize Fortran
    projects for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: There are still many Fortran projects out there, in particular in numerical
    software (for a more comprehensive list of general purpose Fortran software projects,
    see [http://fortranwiki.org/fortran/show/Libraries](http://fortranwiki.org/fortran/show/Libraries)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fortran 90 (and later) can be more difficult to build for projects not using
    CMake, since Fortran module files impose a compilation order. In other words,
    for manually written Makefiles one typically needs to program a dependency scanner
    for Fortran module files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we will see in this recipe, modern CMake allows us to express the configuration
    and build process in a very compact and modular way. As an example, we will use
    the elementary cellular automata from the previous two recipes, now ported to
    Fortran.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The file tree structure is very similar to the previous two recipes. We have
    replaced C++ with Fortran sources and in this case, we have no header files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The main program is in `src/main.f90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous recipe, we have placed the `conversion` module in `external/conversion.f90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The `evolution` library, which implements the time step, is artificially split
    into three files. The bulk is collected in `src/evolution/evolution.f90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The computation of ancestors is performed in `src/evolution/ancestors.f90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have an "empty" module in `src/evolution/empty.f90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: We will explain these choices in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the starting condition is located in `src/initial/initial.f90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/io/io.f90` file contains a function to print a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/parser/parser.f90` file parses the command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the test sources in `tests/test.f90`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now discuss the corresponding CMake structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level `CMakeLists.txt` is similar to Recipe 7; we only exchange `CXX`
    for `Fortran` and remove the C++11 requirement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Targets and sources are defined in `src/CMakeLists.txt` (except the `conversion`
    target):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The `conversion` library is defined in `external/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/CMakeLists.txt` file adds further subdirectories, which in turn contain `CMakeLists.txt` files.
    They are all similar in structure; for example, `src/initial/CMakeLists.txt` contains
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception is the `evolution` library in `src/evolution/CMakeLists.txt`,
    which we have split into three source files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The unit tests are registered in `tests/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuring and building the project yields the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we run the unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following Recipe 7, *Limiting scope with `add_subdirectory`*, we will discuss
    the CMake structure from the bottom up, from the individual `CMakeLists.txt` files
    defining each library, such as `src/evolution/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'These individual `CMakeLists.txt` files define libraries as close as possible
    to the sources, following the same reasoning as in previous two recipes: code
    developers with knowledge of this library and possibly limited knowledge of the
    CMake framework only need to edit files in this directory: divide and conquer.'
  prefs: []
  type: TYPE_NORMAL
- en: We first define the library name with `add_library` and then define its sources
    and include directories, as well as their target visibility. In this case, both
    `ancestors.f90` and `evolution.f90` are `PUBLIC` since their module interfaces
    are accessed outside the library, whereas the module interface of `empty.f90`
    is not accessed outside the file and therefore we mark this source as `PRIVATE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving one level up, the libraries are assembled in `src/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This file, in turn, is referenced in the top-level `CMakeLists.txt`. This means
    that we have built our project from a tree of libraries using a tree of `CMakeLists.txt` files,
    added using `add_subdirectory`. As discussed in Recipe 7, *Limiting scope with*
    `add_subdirectory`, this approach scales to large projects without the need to
    carry lists of source files in global variables across directories, with the added
    bonus of isolating scopes and namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing this Fortran example with the C++ version (Recipe 7), we can note
    that we had to do less CMake work in the Fortran case; we do not have to use `target_include_directories`
    since there are no header files and interfaces are communicated *via* the generated
    Fortran module files. Also, observe that we neither have to worry about the order
    of source files listed in `target_sources`, nor do we have to impose any explicit
    dependencies between libraries! CMake is able to infer Fortran module dependencies
    from the source file dependencies. Using `target_sources` in combination with
    `PRIVATE` and `PUBLIC` allows us to express interfaces in a compact and robust
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we have not specified a directory where Fortran module files
    should be placed and we have kept this transparent. The location for module files
    can be specified by setting the `CMAKE_Fortran_MODULE_DIRECTORY` CMake variable.
    Note that it is also possible to set this as a target property, `Fortran_MODULE_DIRECTORY`,
    thus achieving a finer level of control. See [https://cmake.org/cmake/help/v3.5/prop_tgt/Fortran_MODULE_DIRECTORY.html](https://cmake.org/cmake/help/v3.5/prop_tgt/Fortran_MODULE_DIRECTORY.html#prop_tgt:Fortran_MODULE_DIRECTORY).
  prefs: []
  type: TYPE_NORMAL
