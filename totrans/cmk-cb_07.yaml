- en: Generating Source Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating sources at configure time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating source code at configure time using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating source code at build time using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording the project version information for reproducibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording the project version from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording the Git hash at configure time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording the Git hash at build time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most projects, the source code is tracked using a version control system;
    it typically serves as input for the build system, which transforms it into objects,
    libraries, and executables. In certain cases, we use the build system to generate
    source code during the configuration or build steps. This can be useful to fine-tune
    the source code based on information gathered in the configuration step, or to
    automatize an otherwise error-prone mechanical generation of repetitive code. Another
    frequent use case for generating source code is to record information about the
    configuration or compilation for reproducibility. In this chapter, we will illustrate
    various strategies to generate source code, using the powerful tools provided
    by CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Generating sources at configure time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-01),
    including a Fortran/C example. The recipe is valid with CMake version 3.10 (and
    higher), and has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: The most straightforward code generation happens at configure time. For example,
    CMake can detect the operating system and available libraries; based on that information,
    we can tailor what sources are built, to offer maximum performance to the end
    user of our library or program. In this and some of the following recipes, we
    will illustrate how to generate a simple source file that defines a function to
    report the build system configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code sample for this recipe is in Fortran and C, setting the stage for
    [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language Projects*,
    where mixed-language programming will be discussed. The main program is a simple
    Fortran executable that calls a C function, `print_info()`, which will print the
    configuration information. It is worth noting that with Fortran 2003, the compiler
    will take care of name mangling (given a proper interface declaration of the C
    function), as seen in the simple `example.f90` source file that we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print_info()` C function is defined in the template file, `print_info.c.in`.
    The variables starting and ending with `@` will be substituted for their actual
    values at configure time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our `CMakeLists.txt`, we first have to collect the configuration options,
    and can then substitute their values for the corresponding placeholders in `print_info.c.in`;
    we compile both the Fortran and C sources into one executable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a mixed Fortran-C project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain the username for the user configuring the project by using `execute_process`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `cmake_host_system_information()` function (which we already encountered
    in [Chapter 2](c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml), *Detecting the Environment*,
    Recipe 5, *Discovering the host processor instruction set*), we can query for
    more system information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also obtain a timestamp for the configuration, by using a string manipulation
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to configure the template file, `print_info.c.in`, by using
    CMake''s own `configure_file` function. Notice that we only require the strings
    starting and terminating with `@` to be substituted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add an executable target and define the target sources, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The command `configure_file` can copy files and replace their contents with
    variable values. In our example, we used `configure_file` to both modify the contents
    of our template file and copy it to a location where it could then be compiled
    into our executable. Let us look at our invocation of `configure_file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the name of the scaffold: `print_info.c.in`. CMake assumes
    that the input file is located relative to the root directory of the project;
    that is, in `${CMAKE_CURRENT_SOURCE_DIR}/print_info.c.in`. The second argument
    is the name of the configured file, which we chose to be `print_info.c`. The output
    file is assumed to be located relative to the project build directory; that is,
    in `${CMAKE_CURRENT_BINARY_DIR}/print_info.c`.
  prefs: []
  type: TYPE_NORMAL
- en: When limiting the invocation to just two arguments, the input and output files,
    CMake will not only configure variables of the form `@VAR@`, but also those of
    the form `${VAR}`. This can be inconvenient when `${VAR}` is part of the syntax
    and should not be touched (such as in shell scripts). To instruct CMake in this
    regard, the option `@ONLY` should be passed to the invocation of `configure_file`,
    as we illustrated previously.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that the substitution of placeholders with values expects the variable
    names in CMake to be exactly the same as those used in the to-be configured file,
    and placed in between `@`-markers. Any CMake variable defined at the point where
    `configure_file` is invoked can be used. This includes all built-in CMake variables,
    such as `CMAKE_VERSION` or `CMAKE_GENERATOR`, in our example. Moreover, whenever
    the template file is modified, rebuilding the code will trigger a regeneration
    of the build system. In this way, the configured file will always be up to date.
  prefs: []
  type: TYPE_NORMAL
- en: A complete list of internal CMake variables can be obtained from the CMake manual
    by using `cmake --help-variable-list`.
  prefs: []
  type: TYPE_NORMAL
- en: The command `file(GENERATE ...)` provides an interesting alternative to `configure_file`
    as it allows generator expressions to be evaluated as part of the configured file.
    However, `file(GENERATE ...)` updates the output file every time CMake is run
    which forces a rebuild of all targets which depend on that output. See also [https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/](https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/).
  prefs: []
  type: TYPE_NORMAL
- en: Generating source code at configure time using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-02),
    including a Fortran/C example. The recipe is valid with CMake version 3.10 (and
    higher), and has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will revisit the previous example, and will again generate
    `print_info.c` from the template `print_info.c.in`. However, this time, we will
    imagine that the CMake function `configure_file()` has not been invented yet,
    and will emulate it with a Python script. The goal of this recipe is to learn
    how we can generate source code at configure time by using a now familiar example.
    Of course, we will probably favor `configure_file()` for a real project, but when
    faced with the challenge of generating sources using Python at configure time,
    we will know how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: We should point out that this recipe has a serious limitation and cannot emulate `configure_file()`
    fully. The approach that we will present here cannot generate an automatic dependency
    which would regenerate `print_info.c` at build time. In other words, if you remove
    the generated `print_info.c` after the configure step, this file will not be regenerated
    and the build step will fail. To properly mimic the behavior of `configure_file()`
    we would require `add_custom_command()` and `add_custom_target()`, which we will
    use in the subsequent Recipe 3, *Generating source code at build time using Python*,
    where we will overcome this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use a relatively simple Python script which we will
    detail below. This script will read in `print_info.c.in` and replace the placeholders
    in the file with parameters passed to the Python script from CMake. For more sophisticated
    templating, we recommend external tools, such as Jinja (see [http://jinja.pocoo.org](http://jinja.pocoo.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The files `print_info.c.in` and `example.f90` are unchanged with respect to
    the previous recipe. In addition, we will use a Python script, `configurator.py`,
    which provides one function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function reads an input file, goes over all of the keys of a `vars_dict`
    dictionary, replaces the pattern `@key@` with its corresponding value, and writes
    the results to an output file. The key-value pairs will be provided by CMake.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the previous recipe, we need to configure a template file, but this
    time, we will emulate the `configure_file()` function with a Python script. We
    keep the `CMakeLists.txt` largely unchanged, but we replace `configure_file(print_info.c.in
    print_info.c @ONLY)` with a set of commands, which we will introduce step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we construct a variable, `_config_script`, which will hold a Python
    script that we will execute a moment later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use `find_package` to ensure that the Python interpreter is available
    for CMake to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Python interpreter was found, we can execute `_config_script` from within
    CMake, to generate the `print_info.c` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After that, we define the executable target and dependencies, but this is unchanged
    from the previous recipe. Also, the obtained output is unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us examine the changes that we applied to `CMakeLists.txt`, by discussing
    them backwards.
  prefs: []
  type: TYPE_NORMAL
- en: We executed a Python script that generates `print_info.c`. To run the Python
    script, we first had to detect Python and construct the Python script. The Python
    script imports the `configure_file` function, which we defined in `configurator.py`.
    It requires that we provide it with file locations for reading and writing, as
    well as a dictionary holding CMake variables and their values as key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe has shown an alternative way of generating a configuration report
    that can be compiled into an executable, or even a library target, by delegating
    the generation of sources to an external script. The first approach that we discussed
    in the previous recipe was cleaner and simpler, but with the approach that we
    have presented in this recipe, we have the flexibility to implement, in principle,
    any configure-time step that Python (or another language) allows. Using the present
    approach, we can perform actions that go *beyond* what `cmake_host_system_information()`
    currently provides.
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to remember the limitation of this approach which cannot generate
    an automatic dependency which would regenerate `print_info.c` at build time. In
    the next recipe we will overcome this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to express this recipe more compactly. Instead of explicitly
    constructing `vars_dict`, which felt a bit repetitive, we could have used `get_cmake_property(_vars
    VARIABLES)` to obtain a list of *all* variables defined at this particular time,
    and could have looped over all elements of `_vars` to access their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using this approach, it is possible to build `vars_dict` implicitly. However,
    care has to be taken to escape values that contain characters such as "`;`", which
    Python interprets as terminating an instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Generating source code at build time using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-03),
    including a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to generate source code at build time is a powerful feature in the
    toolbox of the pragmatic developer who wishes to generate possibly lengthy and
    repetitive code based on some rules, while at the same time avoiding tracking
    the generated code explicitly in the source code repository. We can, for instance,
    imagine generating different source code, based on the detected platform or architecture.
    Or, we can use the simplicity of Python to generate explicit and efficient C++
    code at build time, based on the input that we gathered during the configuration
    step. Other relevant examples are parser generators, such as Flex ([https://github.com/westes/flex](https://github.com/westes/flex))
    and Bison ([https://www.gnu.org/software/bison/](https://www.gnu.org/software/bison/)),
    meta-object compilers, such as Qt moc ([http://doc.qt.io/qt-5/moc.html](http://doc.qt.io/qt-5/moc.html)),
    and serialization frameworks, such as Google protobuf ([https://developers.google.com/protocol-buffers/](https://developers.google.com/protocol-buffers/)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To provide a concrete example, we imagine that we need to write a code to verify
    whether a number is prime. Many algorithms exist, and we can, for instance, use
    the sieve of Eratosthenes to separate prime numbers from non-primes. If we have
    to verify many numbers, we will not want to run the sieve of Eratosthenes algorithm
    for every single one of them. What we would like to do instead is tabulate all
    prime numbers once, up to a certain limit, and use a table lookup to verify a
    large set of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will generate the C++ code for the lookup table (a vector
    of prime numbers) by using Python at compile time. Of course, to solve this particular
    programming problem, we could also generate the lookup table using C++, and we
    could do it at runtime instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start out with the following Python script, called `generate.py`. This
    script takes two command-line arguments - an integer that will limit the search,
    and an output filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Our goal is to generate a header file, `primes.hpp`, at compile time, and include
    it in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a breakdown of the commands in `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the project and detect the Python interpreter, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We decided to place the to-be-generated code under `${CMAKE_CURRENT_BINARY_DIR}/generated`,
    and we need to instruct CMake to create this directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python script expects an upper bound for the prime numbers, and, with the
    following command, we can set a default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a custom command to generate the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the executable and its target, including the directory and
    dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to test the implementation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate the header file, we defined a custom command that executes the
    `generate.py` script and takes `${MAX_NUMBER}` and the file path (`${CMAKE_CURRENT_BINARY_DIR}/generated/primes.hpp`)
    as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to trigger the source code generation, we need to add it as a source
    code dependency in the definition of the executable, a task easily achieved with
    `target_sources`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we do not have to define a new custom target. The header
    file will be generated as a dependency of `example`, and will be rebuilt every
    time the `generate.py` script changes. If the code generation script produces
    several source files, it is important that all generated files are listed as dependencies
    of some target.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We mentioned that all generated files should be listed as dependencies of some
    target. However, we might be in a situation where we do not know this list of
    files, since it is determined by the scripts generating the files, depending on
    input that we provide to the configuration. In this case, we might be tempted
    to use `file(GLOB ...)` to collect generated files into a list (see [https://cmake.org/cmake/help/v3.5/command/file.html](https://cmake.org/cmake/help/v3.5/command/file.html)).
  prefs: []
  type: TYPE_NORMAL
- en: However, remember that `file(GLOB ...)` is executed at configure time, whereas
    code generation happens at build time. Therefore, we may need an additional level
    of indirection, where we place the `file(GLOB ...)` command in a separate CMake
    script which we execute at using `${CMAKE_COMMAND} -P`, in order to get the list
    of generated files at build time.
  prefs: []
  type: TYPE_NORMAL
- en: Recording the project version information for reproducibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-04),
    including C and Fortran examples. The recipe is valid with CMake version 3.5 (and
    higher), and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Code versions matter, not only for reproducibility but also to document API
    capabilities or simplify support requests and bug reporting. The source code is
    typically under some version control, and additional semantic version numbers
    (see e.g. [https://semver.org](https://semver.org)) can be attached using Git
    tags, for example. However, not only does the source code need to be versioned,
    but the executable needs to record the project version so that it can be printed
    to the code output or user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will define the version number inside of the CMake sources.
    Our goal is to record the program version to a header file at the moment when
    we configure the project. The generated header file can then be included in the
    code at the right place and time, to print the code version to the output file(s)
    or screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following C file (`example.c`) to print the version information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we assume that `PROJECT_VERSION_MAJOR`, `PROJECT_VERSION_MINOR`, and
    `PROJECT_VERSION` are defined in `version.h`. Our goal is to generate `version.h`
    from the following scaffold, `version.h.in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will use preprocessor definitions, but we could also employ string or integer
    constants for more type safety (and we will demonstrate that later). From the
    CMake perspective, the approach is the same.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will follow these steps to register the version in our template header file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To track the code version, we can define the project version when invoking
    the CMake `project` command in `CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We then configure `version.h`, based on `version.h.in`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the executable and provide the target include path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When invoking the CMake `project` command with a `VERSION` argument, CMake will
    set the `PROJECT_VERSION_MAJOR`, `PROJECT_VERSION_MINOR`, and `PROJECT_VERSION_PATCH`
    for our project. The key command in this recipe is `configure_file`, which takes
    an input file (in this case, `version.h.in`) and generates an output file (in
    this case, `generated/version.h`) by expanding all placeholders between `@` to
    their corresponding CMake variables. It replaces `@PROJECT_VERSION_MAJOR@` with
    `2`, and so on. With the keyword `@ONLY`, we limit `configure_file` to only expand
    `@variables@`, but to not touch `${variables}`. The latter form is not used in
    `version.h.in`, but they frequently appear when configuring a shell script using
    CMake.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated header file can be included in our example code, and the version
    information is available to be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: CMake understands version numbers given in the format `X.Y.Z.t`, and will set
    the variables `PROJECT_VERSION` and `<project-name>_VERSION` to the passed value.
    In addition, the `PROJECT_VERSION_MAJOR` (`<project-name>_VERSION_MAJOR`), `PROJECT_VERSION_MINOR`
    (`<project-name>_VERSION_MINOR`), `PROJECT_VERSION_PATCH` (`<project-name>_VERSION_PATCH`),
    and `PROJECT_VERSION_TWEAK` (`<project-name>_VERSION_TWEAK`), will be set to `X`,
    `Y`, `Z`, and `t`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make sure that the preprocessor variables are only defined if the CMake variable
    is considered a true constant, one can employ `#cmakedefine` instead of `#define`
    in the header files that are about to be configured, by using `configure_file`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on whether the CMake variable is defined and evaluates to a true
    constant, `#cmakedefine YOUR_VARIABLE` will then be replaced with either `#define
    YOUR_VARIABLE ...` or `/* #undef YOUR_VARIABLE */`. There is also `#cmakedefine01`,
    which will set a variable to either `0` or `1`, depending on whether the variable
    is defined.'
  prefs: []
  type: TYPE_NORMAL
- en: Recording the project version from a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-05),
    including a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this recipe is similar to the previous one, but the starting point
    is different; our plan is to read the version information from a file, rather
    than setting it inside of `CMakeLists.txt`. The motivation for keeping the version
    in a separate file, outside of CMake sources, is to allow other build frameworks
    or development tools to use the information, independent of CMake, without duplicating
    the information in several files. One example of a build framework that you might
    like to employ in parallel to CMake is the Sphinx documentation framework, generating
    documentation and deploying it to the Read the Docs service to serve your code
    documentation online.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with a file called `VERSION`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we will choose to go for more type safety, and will define `PROGRAM_VERSION`
    as a string constant in `version.hpp.in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will include the generated `version.hpp` in the following example source
    code (`example.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following shows how to accomplish our task, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMakeLists.txt` defines the minimum version, project name, language, and standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the version information from the file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We then configure the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the executable and its dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We are then ready to test it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We used the following construct to read the version string from a file called
    `VERSION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we first check that this file exists, and issue an error message if it
    does not. If it exists, we read its contents into a variable called `PROGRAM_VERSION`,
    which we strip of any trailing whitespace. Once the variable `PROGRAM_VERSION`
    is set, it can be used to configure `version.hpp.in` to generate `generated/version.hpp`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Recording the Git hash at configure time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-06),
    including a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern source code repositories are tracked using Git as version control
    system, a fact that can be attributed to the huge popularity of the repository
    hosting platform GitHub. We will, therefore, use Git in this recipe; the motivation
    and implementation will, however, translate to other version control systems.
    If we look at Git as an example, the Git hash of a commit uniquely determines
    the state of the source code. Therefore, to uniquely brand the executable, we
    will try to burn the Git hash into the executable by recording the hash string
    in a header file that can be included and used at the right place in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need two source files, both very similar to the previous recipe. One
    will be configured with the recorded hash (`version.hpp.in`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need an example source file (`example.cpp`), which will print
    the hash to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This recipe also assumes that we are in a Git repository with at least one commit.
    So, initialize this example with `git init`, and create commits with `git add
    <filename>`, followed by `git commit`, in order to get a meaningful example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following illustrates the steps to record versioning information from Git:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `CMakeLists.txt`, we first define the project and language support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the following code snippet to define a variable, `GIT_HASH`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of `CMakeLists.txt` is similar to the one in the previous recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the output as follows (the hash will differ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use `find_package(Git QUIET)` to detect whether Git is available on the
    system. If it is (if `GIT_FOUND` is true), we run a Git command: `${GIT_EXECUTABLE}
    log -1 --pretty=format:%h`. This command gives us the short version of the current
    commit hash. Of course, we have full flexibility to run another Git command, instead.
    We ask the `execute_process` command to place the result of the command into a
    variable called `GIT_HASH`, which we subsequently strip of any trailing whitespace.
    With `ERROR_QUIET`, we ask the command to not stop the configuration if the Git
    command fails for some reason.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the Git command might fail (the source code might have been distributed
    outside of the Git repository) or Git might not even be available on the system,
    we wish to set a default for the variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: One problem with this recipe is that the Git hash is recorded at configure time,
    not at build time. In the next recipe, we will demonstrate how to implement the
    latter approach.
  prefs: []
  type: TYPE_NORMAL
- en: Recording the Git hash at build time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-07),
    including a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we recorded the state of the code repository (Git hash)
    at configure time, and it is very useful to have the state of the repository recorded
    in the executable. However, one unsatisfactory aspect of the previous approach
    is that if we changed branches or committed changes after having configured the
    code, the version record included in our source code could point to the wrong
    Git hash. In this recipe, we wish to go a step further and demonstrate how to
    record the Git hash (or, generally, perform other actions) at build time, to make
    sure that these actions are run every time we build the code, since we may configure
    only once but build several times.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the same `version.hpp.in` as in the previous recipe, and will modify
    the `example.cpp` file only minimally, to make it clear that it prints a build-time
    Git hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Saving the Git information to the `version.hpp` header file at build time will
    require the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will move most of the code from the `CMakeLists.txt` of the previous recipe
    to a separate file, and will call the file `git-hash.cmake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` is now left with a part that we recognize very well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining part of `CMakeLists.txt` records the Git hash every time we build
    the code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we achieved the execution of CMake code at build time. For
    this, we defined a custom command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We also defined a custom target, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The custom command invokes CMake to execute the `git-hash.cmake` CMake script.
    This is achieved by using the `-P` CLI switch, to pass the location of the script.
    Notice that we can pass options with the `-D` CLI switch, as we usually would.
    The `git-hash.cmake` script generates `${TARGET_DIR}/generated/version.hpp`. The
    custom target is added to the `ALL` target, and depends on the output of the custom
    command. In other words, when we build the default target, we make sure that the
    custom command is run. Also, observe that the custom command has the `ALL` target
    as output. With that, we make sure that `version.hpp` is generated every time.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could enhance the recipe in order to include extra information in addition
    to the recorded Git hash. It is not unusual to detect whether the build environment
    is "dirty", that is, whether it contains uncommitted changes and untracked files,
    or "clean". This information could be detected using `git describe --abbrev=7
    --long --always --dirty --tags`. Depending on the ambition for reproducibility
    one could even record the full output of `git status` into a header file but we
    leave these enhancements as an exercise.
  prefs: []
  type: TYPE_NORMAL
