["```cpp\ncd <your-dev-folder>\ngit clone https://github.com/PacktPublishing/Minimal-CMake.git mc\ncode mc\n```", "```cpp\n{\n  \"folders\": [\n    {\n      \"name\": \"minimal-cmake\",\n      \"path\": \".\"\n    },\n    {\n      \"name\": \"ch8_part-2_app\",\n      \"path\": \"ch8/part-2/app\"\n    },\n    {\n      \"name\": \"ch11_part-3_app\",\n      \"path\": \"ch11/part-3/app\"\n    }\n  ],\n  \"settings\": {}\n}\n```", "```cpp\ncd ch2/part-1\ncode .\n```", "```cpp\n\"cmake.debugConfig\": {\n    \"miDebuggerPath\": \"/Users/<username>/.vscode/extensions/ms-vscode.cpptools-1.21.6-darwin-arm64/debugAdapters/lldb-mi/bin/lldb-mi\"\n}\n```", "```cpp\n{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": []\n}\n```", "```cpp\n{\n  \"name\": \"(lldb) Launch\",\n  \"type\": \"cppdbg\",\n  \"request\": \"launch\",\n  \"program\": \"${workspaceFolder}/build/Debug/minimal-cmake_game-of-life\",\n  \"args\": [],\n  \"stopAtEntry\": false,\n  \"cwd\": \"${workspaceFolder}\",\n  \"environment\": [],\n  \"externalConsole\": false,\n  \"MIMode\": \"lldb\"\n}\n```", "```cpp\n\"condition\": {\n  \"type\": \"equals\",\n  \"lhs\": \"${hostSystemName}\",\n  \"rhs\": \"Windows\"\n},\n```", "```cpp\ncmake -B build -G Ninja compile_commands.json, is a compilation database, which essentially describes how code is compiled, independent of the build system being used (for more information, see https://clang.llvm.org/docs/JSONCompilationDatabase.html). What’s useful about this file is it’s used by a variety of other tools to perform operations on your code (this covers things such as static analysis, improved editor support, such as navigation and refactoring, and code coverage analysis). Visual Studio Code can also use this file to give improved completions and navigation (e.g., Go to definition).\n\t\t\tTo set it, open the Command Palette, type `edit configurations`, and then select `\"compileCommands\"`, and set the value to something resembling `\"${workspaceFolder}/build/multi-ninja/compile_commands.json\"`. If the file can be found, the yellow squiggle underneath the path should disappear. In context, it looks like this:\n\n```", "```cpp\n\n\t\t\tWhen using CMake Tools, this shouldn’t be strictly necessary, as the IntelliSense support from the `\"ms-vscode.cmake-tools\"` provider should work out of the box. However, knowing how to generate a `compile_commands.json` file is useful, as well as how to set it in Visual Studio Code to get improved suggestions/completions and navigation support.\n\t\t\tCode auto-formatting\n\t\t\tTo make formatting your `CMakeLists.txt` files much easier, there is an application to automatically format your CMake files available called `cmake-format` (the repository is hosted on GitHub and can be found here: [https://github.com/cheshirekow/cmake_format](https://github.com/cheshirekow/cmake_format)).\n\t\t\tIt comes bundled as part of a Python package called `cmakelang`. To install it, first, ensure you have a recent version of Python installed on your system (to download the latest version of Python, please see [https://www.python.org/downloads/](https://www.python.org/downloads/)). On Linux/Ubuntu, you may wish to use a package manager to do this; it may also be necessary to run `sudo apt install python3-pip` before trying to install `cmake-format`.\n\t\t\tOnce Python and Pip (Python’s package manager) are downloaded and available in your path, you can run the following commands:\n\n```", "```cpp\n\n\t\t\tYou can then run `cmake-format` from the command line, passing the name of the `CMakeLists.txt` file you wish to format. On Linux (Ubuntu), you may first need to add `~/.local/bin` to your path, as this is the default location Pip installs executables and it might not already be in your path. To achieve this, simply add the following to your `.bashrc` file (found in your `$``HOME` directory):\n\n```", "```cpp\n\n\t\t\tWhen running `cmake-format` from the terminal, pass the `-i` command-line argument to have the file updated in place (if you don’t pass `-i`, the result of the formatting operation will be output to the console). An example command might look like the following:\n\n```", "```cpp\n\n\t\t\tTo take advantage of `cmake-format` inside of Visual Studio Code, you need to install the `cmake-format` Visual Studio Code extension. This can be installed either through Visual Studio Marketplace ([https://marketplace.visualstudio.com/items?itemName=cheshirekow.cmake-format](https://marketplace.visualstudio.com/items?itemName=cheshirekow.cmake-format)) or through the integrated Visual Studio Code extension manager. Once `cmake-format` is installed, running the `cmake-format` will process the open file. Unfortunately, at the time of writing, this does not seem to work reliably on Linux but should work on macOS and Windows.\n\t\t\tThere are several configuration options to control how the formatting looks; these are added to a file called `.cmake-format.yaml` that lives at the root of the project. (`cmake-format` will search up the folder structure until it finds a `.cmake-format.yaml` file. In the case of *Minimal CMake*, there’s just one file at the root of the repo used to format all examples.) The contents of the *Minimal CMake* `.cmake-format.yml` file are as follows:\n\n```", "```cpp\n\n\t\t\tFeel free to experiment with different settings to find a style that works for you. To learn more about `cmake-format`, see the documentation available at [https://cmake-format.readthedocs.io/en/latest/index.html](https://cmake-format.readthedocs.io/en/latest/index.html). Regrettably, `cmake-format` is no longer under active maintenance, so it’s possible that if issues are discovered, fixes may not be forthcoming, and it may not be updated to handle newer versions of CMake. Even with that being the case, it’s still an incredibly useful tool, and infinitely superior to formatting things manually. There is also an alternative tool called `gersemi` ([https://github.com/BlankSpruce/gersemi](https://github.com/BlankSpruce/gersemi)), which also formats CMake code and is under active development; it may be worth exploring in the future.\n\t\t\tDiff Folders\n\t\t\tOne last tool worth briefly mentioning is an extension called `build`, `build-third-party`, `install`, `package`, and `.vscode` folders to the Diff Folders exclude list (`l13Diff.exclude` in `settings.json`). The diff panel allows you to clearly view changes between multiple files at once.\n\t\t\t![Figure 11.10: Diff panel display in Diff Folders](img/B21152_11_11.jpg)\n\n\t\t\tFigure 11.10: Diff panel display in Diff Folders\n\t\t\tThe options along the top-left panel are useful for customizing the display to show all files, added files, changed files, or deleted files. Diff Folders can be a helpful companion tool when the built-in **Compare Active File With...** Visual Studio Code command is not sufficient.\n\t\t\tCMake with other IDEs\n\t\t\tThroughout this book, we’ve focused exclusively on Visual Studio Code, primarily because it provides a consistent experience across Windows, macOS, and Linux. It is sometimes necessary and useful to use an editor or IDE for a specific platform and knowing how to configure it to play nicely with CMake can be helpful. We’ll briefly cover a few useful settings for Visual Studio, Xcode, and CLion.\n\t\t\tVisual Studio\n\t\t\tIf developing on Windows, using the fully-fledged Visual Studio development environment can be especially useful at times. *Visual Studio Community Edition* is completely free and comes with a host of useful features when developing in C++ (see [*Chapter 1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*, for instructions on how to install it).\n\t\t\tWhen trying to run projects from within Visual Studio (especially examples from earlier parts of this book), things unfortunately might not work as expected. The reason for this is, by default, the working directory Visual Studio uses is the folder of the executable, not the project root that we relied on up until [*Chapter 10*](B21152_10.xhtml#_idTextAnchor214), *Packaging the Project for Sharing* (this is because we’d normally launch our executable from the command line).\n\t\t\tTo try things out, configure the project using the Visual Studio generator. This can either be done by using the `vs` preset in later chapters, or by specifying the generator directly:\n\n```", "```cpp\n\n\t\t\tDepending on the `ch<n>/part<n>` directory you’re trying this from, you will need to have built the third-party dependencies first, either separately, or as part of a super build. For simplicity, in later examples, we’ll assume you’ve used `cmake --preset multi-ninja-super` to configure and build the project using Ninja, and then can use `cmake --preset vs` to create the Visual Studio generator files. It’s also possible to perform the super build using Visual Studio; there’s just a possibility it might take slightly longer than with Ninja:\n\n```", "```cpp\n\n\t\t\tTo open our project in Visual Studio, after running one of the configure steps mentioned previously, open the `build/vs` folder, and double-click the `.sln` file (for example, `minimal-cmake_game-of-life_window.sln`). When inside Visual Studio, the first thing we need to do is review the **Solution Explorer** window (by default, on the right of the screen) and set the project that’s been created for us as **Startup Project** (this corresponds to our executable target):\n\t\t\t![Figure 11.11: Visual Studio Solution Explorer](img/B21152_11_12.jpg)\n\n\t\t\tFigure 11.11: Visual Studio Solution Explorer\n\t\t\tThis can be achieved by right-clicking the project and selecting the **Set as Startup** **Project** option:\n\t\t\t![Figure 11.12: The Visual Studio Set as Startup Project context menu](img/B21152_11_13.jpg)\n\n\t\t\tFigure 11.12: The Visual Studio Set as Startup Project context menu\n\t\t\tWe’ll then see our project displayed in bold:\n\t\t\t![Figure 11.13: Application set at Startup Project](img/B21152_11_14.jpg)\n\n\t\t\tFigure 11.13: Application set at Startup Project\n\t\t\tTo avoid having to make this change manually every time the solution is generated from scratch, it’s possible to use the `VS_STARTUP_PROJECT` CMake property to refer to the target we want to be the startup project. This can be achieved with the following addition to our `CMakeLists.txt` file:\n\n```", "```cpp\nShaders not found. Have you built them using compile-shader-<platform>.sh/bat script?\n```", "```cpp\nset_target_properties(\n  ${PROJECT_NAME}\n  PROPERTIES\n    cmake --preset vs), and if it’s open, Visual Studio will show a popup letting us know the solution has been changed and needs to be reloaded.\n\t\t\tSelect **Reload All** and then build and run again from within Visual Studio. The application should now run successfully as it will be looking for the shader files in the location we expect. This isn’t something to use when reaching the stage of making your application sharable; the technique outlined in [*Chapter 10*](B21152_10.xhtml#_idTextAnchor214), *Packaging the Project for Sharing*, is more appropriate, but this can be a useful tool in the initial stages of development.\n\t\t\tVisual Studio is a great tool and well worth exploring if you’re developing on Windows. The debugging features, profiling tools, and code analysis support are all high quality and provide a lot of utility while developing larger more complex projects. Visual Studio also provides the ability to debug CMake scripts just as Visual Studio Code does (see [https://learn.microsoft.com/en-us/cpp/build/configure-cmake-debugging-sessions](https://learn.microsoft.com/en-us/cpp/build/configure-cmake-debugging-sessions) for more information).\n\t\t\tXcode\n\t\t\t`Info.plist` file, which were discussed in [*Chapter 10*](B21152_10.xhtml#_idTextAnchor214), *Packaging the Project* *for Sharing*.\n\t\t\tTo generate a project for Xcode, either use the existing CMake preset we defined or name the generator manually (Xcode will need to be installed before trying this):\n\n```", "```cpp\n\n\t\t\tTo open the Xcode project, navigate to `build/xcode` (in `.xcodeproj` extension (for example, `minimal-cmake_game-of-life_window.xcodeproj`).\n\t\t\tThere, like in Visual Studio, we need to change the working directory to be the root of our project for things to work correctly in some of the earlier examples. Fortunately, this is simple to do, and like how we set `VS_DEBUGGER_WORKING_DIRECTORY` in the case of Visual Studio.\n\t\t\tIn our application’s `CMakeLists.txt` file, we need to add the following settings:\n\n```", "```cpp\n\n\t\t\tThis will update the Xcode scheme for the executable target. This can be viewed by clicking the top bar in Xcode, selecting the name of the target, and then clicking **Edit scheme...**. Clicking the **Options** tab will then display a series of settings, including **Working Directory**:\n\t\t\t![Figure 11.15: Custom working directory in Xcode](img/B21152_11_16.jpg)\n\n\t\t\tFigure 11.15: Custom working directory in Xcode\n\t\t\tThere are a lot more `XCODE_SCHEME_` variables that can also be set to configure a scheme outside of Xcode; for a full list, please see [https://cmake.org/cmake/help/latest/prop_tgt/XCODE_GENERATE_SCHEME.html](https://cmake.org/cmake/help/latest/prop_tgt/XCODE_GENERATE_SCHEME.html). To view other `Info.plist` options that can be configured, click the top-level project in the left-hand sidebar and click the **Build Settings** tab from the top bar. Either scroll down or use the filter to search for the **Info.plist** **Values** section.\n\t\t\tXcode is necessary when it comes to publishing your app on macOS or iOS. The code signing functionality must be used for this; see [https://developer.apple.com/documentation/xcode/distribution](https://developer.apple.com/documentation/xcode/distribution) for more information on this topic. Xcode also comes bundled with an application called **Instruments**, which includes a suite of tools to perform memory tracking, profiling, and more.\n\t\t\tCLion\n\t\t\t`CMakeLists.txt` file of your project. CLion then stores project-specific settings in a hidden `.idea` folder. Very much like Visual Studio Code, one of the most convenient ways to use CLion with CMake is by using our existing CMake presets. CLion currently only supports CMake presets up to version `6`, so we need to drop our version from `8` to `6` for things to work correctly. With that change applied, it’s possible to load the CMake presets we’ve already defined with all the right settings. CLion doesn’t handle super builds by default so it’s recommended to build a super build configuration separately outside of CLion, and then use a normal preset when working with CLion.\n\t\t\tIDEs can be a huge productivity boost once they’re configured, but they take time to master and can come with a relatively steep learning curve, along with their own quirks and idiosyncrasies. Knowing how to get by without them is useful but don’t be afraid to try them out and see what they have to offer.\n\t\t\tWe’re now going to turn our attention to some important topics to be aware of when building our C and C++ code.\n\t\t\tC/C++ build recommendations\n\t\t\tTo ensure the code we write is as correct as possible, it’s a wise move to enable as many warnings and checks as we can while working on our project. There are a few ways to achieve this using CMake. The first is ensuring we’re using standard C++ and avoiding any compiler-specific extensions to guarantee our code is cross-platform. This can be achieved with `CXX_STANDARD_REQUIRED` and `CXX_EXTENSIONS`, as shown in the following code (for C, just replace `CXX_` with `C_`):\n\n```", "```cpp\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS OFF)\n```", "```cpp\nstring(\n  APPEND\n  compile_options\n    \"$<$<OR:\"\n    \"$<CXX_COMPILER_ID:Clang>,\"\n    \"$<CXX_COMPILER_ID:AppleClang>>:\"\n      \"-Weverything;-Wno-c++98-compat;-Wno-;\"\n      \"-Wno-global-constructors;-Wno-;\"\n      \"-Wno-c++98-compat-pedantic;-Wno->\"\n    ...\ntarget_compile_options(\n  ${PROJECT_NAME} PRIVATE ${compile_options})\n```", "```cpp\nif(MC_GOL_APP_BUILD_TESTING)\n  enable_testing()\n  add_subdirectory(tests)\nendif()\nadd_subdirectory(packaging)\n```", "```cpp\nset_target_properties(\n  ${PROJECT_NAME}-test PROPERTIES RUNTIME_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR})\n```", "```cpp\ninclude(cmake/CPM.cmake)\nCPMAddPackage(\"gh:catchorg/Catch2@3.6.0\")\ntarget_link_libraries(\n  ${PROJECT_NAME} ... Catch2::Catch2WithMain)\n```", "```cpp\n\n```", "```cpp\n\n```"]