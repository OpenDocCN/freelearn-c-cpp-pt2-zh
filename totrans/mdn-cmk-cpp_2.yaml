- en: 1 First steps with CMake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is something magical about turning source code into a working application.
    Not only the effect itself: a working mechanism that we devised and brought to
    life, but the very process, the very act of exercising the idea into existence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As programmers we work in this loop: designing-coding-testing. We invent changes,
    we phrase them in a language that the compiler understands and we check if they
    work as intended. To create a proper, high-quality application from our source
    code we need to meticulously execute repetitive, error-prone tasks: invoking right
    commands, checking syntax, linking binary files, running tests, reporting issues
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: It takes effort to remember every step all the time. Instead, we want to stay
    focused on the actual coding, and delegate everything else to the automated tooling.
    Ideally - this process would be started with a single button, right after we changed
    our code. It would be smart, fast, extensible and work the same way across different
    operating systems and environments. It would be supported by multiple IDEs, but
    also by Continuous Integration pipelines which test our software after a change
    is submitted to a shared repository.
  prefs: []
  type: TYPE_NORMAL
- en: CMake is the answer to many such needs, but it requires a bit of work to configure
    and use correctly. This is not because CMake is unnecessarily complex, but because
    the subject that we're dealing with here is. Don't worry. We'll do with this whole
    learning process very methodically, and before you know it - you will become a
    building guru.
  prefs: []
  type: TYPE_NORMAL
- en: I know you're eager to rush off, and start writing your own CMake projects,
    and I applaud your attitude. Since your projects will be primarily for users (yourself
    included), it's important that you understand that perspective as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with just that: becoming a CMake power user. We’ll go through
    a few basics: what is this tool, how it works in principle and how to install
    it. Then we''ll do a deep-dive on the command line and modes of operation. Finally,
    we''ll wrap up with purposes of different files in a project and we''ll touch
    on using CMake without one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing CMake on different platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering the Command Line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the Project Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering Scripts and Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp](https://github.com/PacktPublishing/Modern-CMake-for-Cpp)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compilation of C++ source code seems like a fairly straightforward process.
    When we take a small program like a classic `hello.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/01-hello/hello.cpp
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need to do to get an executable is to run a single command. We call
    the compiler with a file name as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code is correct so the compiler will silently produce an executable binary
    file that our machine can understand. We can run it by calling its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: However, as our projects grow – we quickly understand that keeping everything
    in a single file is simply not possible. Clean code practices recommend that files
    should be kept small and in well-organized structures. Manual compilation of every
    file will be a tiresome and fragile process. There must be a better way.
  prefs: []
  type: TYPE_NORMAL
- en: What is CMake?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we automate building by writing a script that goes through our project
    tree and compiles everything. To avoid unnecessary compilation our script will
    detect if the source was modified since last time. Now we’d like a convenient
    way to manage arguments that are passed to the compiler for each file - preferably
    do that based on configurable criteria. Our script should also know how to link
    all the compiled files in a binary, or even better: build whole solutions that
    can be reused, and incorporated as modules in bigger projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The more features we will add – the more we will get to a full-fledged solution.
    Building software is a very versatile process and can span multiple different
    aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling executables and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing some more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would take a really long time to come up with a truly modular and powerful
    C++ building application fit for every purpose. And it did. Bill Hoffman at Kitware
    implemented the first versions of CMake over 20 years ago. As you already guessed
    – it is very successful, has a lot of features and support from the community.
    Today CMake is being actively developed and has become the industry standard for
    C and C++ programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem of building code in an automated way is much older than CMake,
    so naturally there are plenty of options out there: Make, Autotools, SCons, Ninja,
    Premake and many others. But why does CMake have the upper hand?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of things about CMake I find (granted, subjectively) really important:'
  prefs: []
  type: TYPE_NORMAL
- en: It stays focused on supporting modern compilers and toolchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake is truly cross-platform – it supports building for Windows, Linux, macOS
    and Cygwin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It generates project files for popular IDEs: Microsoft Visual Studio, Xcode,
    Eclipse CDT, and it is a project model for others like CLion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake operates on just the right level of abstraction – it allows to group files
    in reusable targets and projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are tons of projects that are built with CMake, and offer an easy way
    to include them in your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake sees testing, packaging and installing as an inherent part of the build
    process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old, unused features get deprecated to keep CMake lean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CMake provides this unified, streamlined experience across the board: building
    in your IDE, from the command line and (what’s really important) on later stages
    as well. Your CI/CD pipeline can easily use the same exact CMake configuration
    and build projects using a single standard even if all above environments differ.'
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might get an impression that CMake is a tool that reads source code on one
    end, and produces binaries on the other – while that’s true in principle, it’s
    not the full picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake can’t build anything on its own – it relies on other tools in the system
    to perform the actual compilation, linking and other tasks. Think of it as an
    orchestrator of your building process: it knows what steps need to be done, what
    is the end goal and how to find the right workers and materials for the job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This process has three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This stage is about reading project details stored in a directory called **source
    tree**, and preparing an output directory **build tree** for generation stage.
  prefs: []
  type: TYPE_NORMAL
- en: CMake starts by creating an empty build tree and collecting all the details
    about the environment it is working in - architecture, available compilers, linkers,
    archivers and checks if a simple test program can be compiled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `CMakeLists.txt` project configuration file is parsed and executed
    (yes, CMake projects are configured with CMake''s own coding language). This file
    is the bare minimum of a CMake project (source files can be added later). It tells
    CMake about the project structure, targets and dependencies: libraries and other
    CMake packages. During this process CMake stores collected information in the
    build tree: system details, project configuration, logs, and temp files used for
    the next step. Specifically, a `CMakeCache.txt` file is created to store more
    stable variables (like paths to compilers and other tools), and save time during
    the next configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Generation stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After reading the project configuration CMake will **generate a buildsystem**
    for the exact environment it is working in. Buildsystems are nothing else but
    cut-to-size configuration files for other build tools (for example Makefiles for
    GNU Make or Ninja and IDE project files for Visual Studio). During this stage
    CMake can still apply some final touches to the build configuration by evaluating
    **generator expressions**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Generation stage is executed with configuration one (unless you specifically
    ask CMake not to, through cmake-gui). For that reason when we mention generation
    stage – we mean both.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Building stage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To produce the final artifacts specified in our project we have to run the appropriate
    **build tool**. It can be invoked directly, through IDE or with CMake command.
    These build tools will in turn execute steps to produce **targets** with compilers,
    linkers, static and dynamic analysis tools, test frameworks, reporting tools and
    everything else you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this solution lies in the ability to produce buildsystems on demand
    for every platform with a single configuration (the same project files).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: CMake stages](img/file0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: CMake stages'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember our `hello.cpp` application from the first section? CMake makes it
    really easy to build it. All we need is following `CMakeLists.txt` file next to
    our source and two simple commands: `cmake -B buildtree` and `cmake --build buildtree`'
  prefs: []
  type: TYPE_NORMAL
- en: 'chapter01/01-hello/CMakeLists.txt: Hello world in CMake language'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output from dockerized Linux system (we''ll discuss Docker in the
    next section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left is to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I have generated a build system stored in the `buildtree` directory, then we
    executed the build stage and produced a final binary that I was able to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you know how the end result looks like, I''m sure you''re full of
    questions: what are the prerequisites to this process? What do these commands
    mean? Why do we need two of them? How to write my own project files? Not to worry
    - these questions will be answered on the following pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting help**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This book will provide you with most important information relevant to the
    current version of CMake (as of today: 3.20). To provide you with best advice
    I explicitly avoided any deprecated and no longer recommended features. I highly
    recommend using at least version 3.15 which is considered as "the Modern CMake".
    If you need more information - you can find the latest, complete documentation
    online: [https://cmake.org/cmake/help/](https://cmake.org/cmake/help/).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Installing CMake on different platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMake is a cross-platform, open-source software written in C++. That means
    you can of course compile it yourself, but most likely you don’t have to, as pre-compiled
    binaries are available for you to download from official webpage: [https://cmake.org/download/](https://cmake.org/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: Unix-based systems provide packages ready to install straight from the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember that CMake doesn't come with compilers, so if your system doesn't have
    anything installed - you'll need to provide them on your own. Be sure to add a
    path to their executables to the `PATH` environment variable so CMake can find
    them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To avoid solving tooling and dependency problems while learning from this book,
    I recommend choosing the first installation method - Docker.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker ([https://www.docker.com/](https://www.docker.com/)) is a cross-platform
    tool that provides OS-level virtualization, allowing applications to be shipped
    in complete packages called containers. These are self-sufficient bundles that
    contain all the libraries, dependencies and tools. Docker executes its containers
    in lightweight environments that are isolated one from another.
  prefs: []
  type: TYPE_NORMAL
- en: This concept makes it extremely convenient to share whole toolchains necessary
    for a given process, configured and ready to go. I can't stress enough how easy
    things become when you don't need to worry about miniscule environment differences.
  prefs: []
  type: TYPE_NORMAL
- en: Docker platform has a public repository of container images [https://registry.hub.docker.com/](https://registry.hub.docker.com/),
    which provides millions of images ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For your convenience I have published two docker repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`swidzinski/cmake:toolchain` - containing curated tools and dependencies necessary
    to build with CMake'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swidzinski/cmake:examples` - containing above toolchain and all the projects
    and examples from this book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is for readers who just want a clean slate image ready to build
    their own projects, and the second for hands-on practice with examples as we go
    through the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install docker following instructions from its documentation [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)and
    execute following commands in your terminal to download image and start the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All examples will be available in `/home/root/chapter-<N>/<M>-<title>` directories.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Installing in Windows is straightforward – download version for 32 or 64 bits.
    You can pick a portable zip or msi package for Windows Installer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With zip package you will have to add CMake bin directory to `PATH` environment
    variable to be able to use it in any directory without such errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer convenience – use msi installer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Installation wizard can set up the PATH environment variable
    for you.](img/file1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Installation wizard can set up the PATH environment variable for
    you.'
  prefs: []
  type: TYPE_NORMAL
- en: As I have mentioned – this is an open-source software, so it is possible to
    build CMake yourself, however – you will first have to get a binary copy of CMake
    on your system. Why use other build tools if you have your own, right? This scenario
    is used by CMake contributors to generate new versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'On windows we also need a build tool that can finalize the build process started
    by CMake. Good common choice here is Visual Studio, available for free in Community
    version from Microsoft’s website: [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)'
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting CMake on Linux is exactly the same as getting any other popular package.
    Just use your package manager from the command line. Packages are usually kept
    up to date with fairly recent versions, but if you are after the latest version
    – download the installation script from the website.
  prefs: []
  type: TYPE_NORMAL
- en: Script for Linux x86_64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Script for Linux aarch64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Package for Debian / Ubuntu
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Package for Redhat
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: MacOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This platform is also strongly supported by CMake developers. Most popular
    choices of installation are through MacPorts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively – you can use Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Building from source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If everything else fails, or you’re on a special platform – download the source
    from official website and compile it yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Building from source is a bit slower and requires more steps, but this way
    you''re guaranteed to use the latest version of CMake. This is especially visible
    in comparison to packages available for Linux: the older version of the system,
    the less updates it gets.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our CMake readily installed - let's learn how to use it!
  prefs: []
  type: TYPE_NORMAL
- en: Mastering the Command Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of this book will teach you how to prepare CMake projects for your users.
    In order to cater to their needs - we need to thoroughly understand how users
    interact with CMake in different scenarios. This will allow you to test your project
    files and make sure they're working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake is a family of tools, and consists of five executables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake` – main executable that configures, generates and builds projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctest` – test driver program used to run and report test results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cpack` – packaging program used to generate installers and source packages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake-gui` – graphical wrapper around cmake'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ccmake` – console-based gui wrapper around cmake'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This binary provides a few modes of operation (also called actions):'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Project Buildsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a Project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a Script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a Command-Line Tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a Project Buildsystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is the first step required to build our project. Here are a few options
    how CMake build action can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of the generation mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll discuss options in next sections - right now let''s focus on choosing
    the right form of command. Important feature of CMake are out-of-source builds,
    or producing artifacts in an indicated directory. In contrast to tools like GNU Make
    - this keeps source directory clean of any build-related files and avoids polluting
    our version control systems with unnecessary files or ignore directives. This
    is why it''s best to use the first form of generation mode, and specify directory
    of produced buildsystem with `-B` and path to source tree `-S` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Above will generate buildsystem in the `./build` directory (and create it if
    it’s missing) from source in `./project` directory.
  prefs: []
  type: TYPE_NORMAL
- en: We can skip one of the arguments and `cmake` will "guess" that we intended to
    use current directory for it, but watch out – skipping both will get you in-source
    build, and that is messy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Not recommended**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Do not use second or third form of the command: `$ cmake <directory>` as it
    can produce messy in-source build (we’ll learn how to block that in *Chapter 3*).
    As hinted in the syntax snippet – the same command behaves differently if a previous
    build already exists in `<directory>`: it will use the cached path to sources
    and rebuild from there. Since we often invoke the same commands from terminal
    command history, we might get in trouble here: before using this form always check
    if your shell is currently working in the right directory.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Build in current directory, but take source from one directory up (`-S` is
    optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Build in `./build` directory, and use source from current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Generators'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As shown in the synopsis - you can specify a few options during the generation
    step. Selecting and configuring a generator decides which build tool from our
    system will be used for building, how build files will look like and what will
    be the structure of the Build Tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, should you care? Luckily – the answer often is “no”. CMake does support
    multiple native build systems on many platforms, but unless you have few of them
    installed at the same time – CMake will correctly select it for you. This can
    be overridden by the `CMAKE_GENERATOR` environment variable, or by specifying
    the generator directly on command line like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Some generators (like Visual Studio) support more in-depth specification of
    a toolset (compiler), and platform (compiler or SDK). These also have respective
    environment variables which override default value: `CMAKE_GENERATOR_TOOLSET`
    and `CMAKE_GENERATOR_PLATFORM`. We specify them directly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Windows users usually want to generate buildsystem for their favorite IDE, on
    Linux and macOS – it’s very common to use Unix Makefiles or Ninja generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check which generators are available on your system use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of help printout, you will see a full list like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of generators available on Windows 10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Cache'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: CMake queries the system for all kinds of information during the configuration
    stage – this information is cached in `CMakeCache.txt` in the build tree directory.
    There are few options that allow more convenient management of that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First at our disposal is ability to **prepopulate cached information**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can provide a path to CMake script which contains (only) a list of `set()`
    commands to specify variables that will be used to initialize an empty build tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization and modification** of existing cache variables can be done
    in another way (when creating a file is bit much to only set a few of them). You
    can just set them in command line like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `:<type>` section is optional (it is used by GUIs), use one of `BOOL`, `FILEPATH`,
    `PATH`, `STRING`, `INTERNAL`. If you omit the type – it will be set to the type
    of already existing variable, or `UNITIALIZED` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'One particularly important variable contains the type of the build: debug,
    release and so on. Many CMake projects will read it on numerous occasions to decide
    things like verbosity of messages, presence of debugging information and level
    of optimization for built artifacts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For single-configuration generators (such as Makefile and Ninja) you''ll need
    to specify it during the configuration phase with `CMAKE_BUILD_TYPE` variable,
    and generate a separate build tree for every type of config: `Debug`, `Release`,
    `MinSizeRel`, or `RelWithDebInfo`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Multi-Configuration generators are configured during the build stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can **list cache** variables with -L option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Such a list will contain cache variables that aren't marked as `ADVANCED`, we
    can change that by adding the `A` modifier. If we're interested in reading help
    for each variable we can add the `H` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, custom variables added manually with the `-D` option won't be
    visible unless you specify one of supported types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Removal** of one or more variables can be done with following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The globbing expression supports wildcard `*` and any character `?` symbols.
    Be careful when using, as you may break things.
  prefs: []
  type: TYPE_NORMAL
- en: Both `-U` and `-D` options can be repeated multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options: Debugging & Tracing'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'CMake can be run with multitude of options that allow it to peek into its bellows
    and check different settings. To **get general information** about variables,
    commands, macros and other settings run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Optional file argument allows you to store the output in a file. Running it
    in the build tree directory will print extra information about cache variables
    and build messages from log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our projects we’ll be using `message()` commands to report details of the
    build process. CMake **filters log output** of these based on current log-level
    (`STATUS` by default). Following line specifies what log level we’re interested
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `level` can be any of: `ERROR`, `WARNING`, `NOTICE`, `STATUS`, `VERBOSE`,
    `DEBUG` and `TRACE`. You can specify this setting permanently in `CMAKE_MESSAGE_LOG_LEVEL`
    cache variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting option allows us to **display log context** with each `message()`
    call. To debug very complex projects use `CMAKE_MESSAGE_CONTEXT` variable as stack
    and push strings on it going into narrower context, and pop them on leaving. If
    we enable displaying log context as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our messages will be decorated with current `CMAKE_MESSAGE_CONTEXT` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We’ll talk more about logging in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything else fails, and we need to use the big guns – there is always
    the **trace mode**. It will print every command with filename and exact line number
    it is called from alongside its arguments. Enable it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Presets'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As you can tell - there are many, many options that users can specify to generate
    a build tree from your project. Between build tree path, generators, cache and
    environmental variables - it's easy to get confused or miss something. Developers
    can simplify how users interact with their project, and provide a `CMakePresets.json`
    file that specifies some defaults. Check the *Navigating the Project Files* section
    in this chapter to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list available presets, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can use one of the available presets like so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: These values override system defaults and environment, but at the same time
    - can be overridden with any arguments that are explicitly passed in the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: How presets override CmakeCache.txt and system environment variables](img/file2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: How presets override CmakeCache.txt and system environment variables'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After generating our build tree we’re ready for the next stage: **running the
    builder tool**. CMake not only knows how to generate input files for many different
    builders, but can also run them for you with arguments specific for our project.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not recommended**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Many online sources recommend calling GNU Make directly after the generation
    stage: `make`. This is a default generator for Linux and MacOS, and it usually
    works. We however prefer the method described in this section, as it is generator-independent
    and is supported across all platforms. This way we don’t need to worry about the
    exact environment of every user of our application.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Syntax of the build mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In majority of the cases it is enough to provide just bare minimum to get a
    successful build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: CMake needs to know where the build tree is which we generated. This is the
    same path we passed with `-B` argument in the generation step.
  prefs: []
  type: TYPE_NORMAL
- en: 'By providing a few options CMake allows specifying key build parameters that
    work for every builder. If you need to provide special arguments to your chosen,
    native builder - pass them at the end of the command after `--` token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Parallel builds'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Many build tools will by default use multiple concurrent processes to leverage
    modern processors and compile your sources in parallel. Builders know the structure
    of project dependencies, so they can simultaneously process steps that have their
    dependencies met in order to save users' time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to override that setting if you''re building on a powerful machine
    (or to force a single threaded build for debugging), just **specify the number
    of jobs** with either of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The alternative is to set it with the `CMAKE_BUILD_PARALLEL_LEVEL` environment
    variable. As usual - we can always use the above option to override the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options: Target'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We''ll talk more about targets in the second part of the book. For now, let''s
    just say that every project is made up from one of more parts called targets.
    Usually - we''ll want to build all of them, but on occasion we might be interested
    in skipping some, or **explicitly building a target** that was deliberately excluded
    from normal builds. We can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you see - we can specify multiple targets separated by colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of such targets that isn''t normally built is `clean`. It will remove all
    artifacts from the build directory. This is how you call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake also offers a convenient alias if you''d like to **clean first and then
    do a normal build**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Multi-Configuration Generators'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already know a bit about generators. They come in different shapes and sizes.
    Some of them offer more features than others, and one of such is the ability to
    build both `Debug` and `Release` build types in a single build tree.
  prefs: []
  type: TYPE_NORMAL
- en: Generators supporting this feature are Ninja Multi-Config, XCode and Visual
    Studio. Every other is a single-configuration generator, and requires a separate
    build tree for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select one of `Debug`, `Release`, `MinSizeRel`, or `RelWithDebInfo` and specify
    it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise CMake will use `Debug` as default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options: Debugging'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When things go bad - first things to check are the output messages. However
    - veteran developers know that printing all the details all the time is confusing,
    so they often hide them by default. When we need to peek under the hood, we can
    ask for much more detailed logs by telling CMake to be verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The same effect can be achieved by setting `CMAKE_VERBOSE_MAKEFILE` cached variable.
  prefs: []
  type: TYPE_NORMAL
- en: Install a Project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When artifacts are built, users can install them in the system. This usually
    means copying files into correct directories, installing libraries, or running
    some custom installation logic from a CMake script.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of the Installation mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As with other modes of operation - CMake requires path to generated build tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Multi-Configuration Generators'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Exactly like in the build stage we can specify which build type we want to
    use for our installation (more details in "Building a Project"). Available types
    are `Debug`, `Release`, `MinSizeRel`, or `RelWithDebInfo`. Signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Components'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As a developer you may choose to split your project into components that can
    be installed independently. We''ll discuss the concept of components in detail
    in *Chapter 11*, for now let''s just assume they represent different parts of
    the solution. This might be something like: "application", "docs" and "extra tools".'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a single component use this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Permissions'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If installation is done on Unix-like platform you can specify default permissions
    for installed directories with following option, using this format: `u=rwx,g=rx,o=rx`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Options: Installation Directory'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can prepend the installation path specified in the project configuration
    with a prefix of our choice (for example when we have limited write access to
    some directories). Path `/usr/local` prefixed with `/home/user` becomes `/home/user/usr/local`.
    Signature for this option is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that this won't work on Windows as paths on this platform usually start
    with the drive letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options: Debugging'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Similarly to the build stage - we can also choose to view detailed output of
    the installation stage. Use any of following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Same effect can be achieved if the `VERBOSE` environment variable is set.
  prefs: []
  type: TYPE_NORMAL
- en: Run a Script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CMake projects are configured using CMake's custom language. It's cross-platform,
    quite powerful and it's already there. Why not make it available for other tasks?
    Sure enough - you can write standalone scripts (we'll get to that at the end of
    this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake can run these like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of the Run a Script mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Running such a script won''t run any configure or generate stages and won''t
    affect cache. There are two ways of passing values to this script:'
  prefs: []
  type: TYPE_NORMAL
- en: Through variables defined with `-D` option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through arguments that can be passed after a `--` token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake will create `CMAKE_ARGV<n>` variables for all arguments passed to the
    script (including the `--` token).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run a Command-Line Tool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On a rare occasion we might need to run just a single command in a platform-independent
    way - perhaps copy a file or compute a checksum. Not all platforms were created
    equal, so not all commands are available in every system, or they have a different
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake offers a mode to execute the most common ones in the same way across
    platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of the Run Command-Line Tool mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As the use of this mode is fairly limited we won''t cover them in-depth. If
    you''re interested in the details, I recommend calling `cmake -E` to list all
    available commands. Just to get a glimpse, CMake 3.20 supports these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`capabilities`, `cat`, `chdir`, `compare_files`, `copy`, `copy_directory`,
    `copy_if_different`, `echo`, `echo_append`, `env`, `environment`, `make_directory`,
    `md5sum`, `sha1sum`, `sha224sum`, `sha256sum`, `sha384sum`, `sha512sum`, `remove`,
    `remove_directory`, `rename`, `rm`, `server`, `sleep`, `tar`, `time`, `touch`,
    `touch_nocreate`, `create_symlink`, `create_hardlink`, `true`, `false`'
  prefs: []
  type: TYPE_NORMAL
- en: If a command you'd like to use is missing, or you need a more complex behavior,
    consider wrapping it in a script and running it in a `-P` mode.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It comes without a surprise that CMake offers extensive help accessible through
    its command-line.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of the Help mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: CTest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automated testing is very important to produce and maintain high-quality code.
    That's why we devoted an entire *Chapter 8* to this subject, and we'll do a deep-dive
    into the usage of CTest there. It is one of the available command-line tools so
    let's briefly introduce it for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'CTest is about wrapping CMake in a higher layer of abstraction, where building
    becomes just one of the stepping stones in the process of developing our software.
    Other tasks that CMake can do for us are: updating, running all kinds of tests,
    reporting the state of the project to external dashboards, and running scripts
    written in CMake language.'
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly CTest standardizes **running tests and reporting** for solutions
    built with CMake. As a user - you don't need to know which testing framework the
    project is using or how to run it. CTest provides a convenient façade to list,
    filter, shuffle, retry and timebox test runs. It can also call CMake for you if
    build is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplest way to run tests for a built project is just calling `ctest` in the
    generated build tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: CPack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we built and tested our amazing software, we are ready to share it with
    the world. In rare few cases - power users are completely fine with source code,
    and that's what they want. Vast majority of the world however is using pre-compiled
    binaries because of convenience, time saved and many other reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake doesn''t leave you stranded here - it comes with batteries included.
    CPack is built for the exact purpose of **creating packages for different platforms**:
    compressed archives, executable installers, wizards, NuGet packages, MacOs bundles,
    DMG packages, RPMs and many, many more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CPack works very much like CMake: it is configured with CMake language and
    has many package generators to pick from (don''t confuse them with CMake buildsystem
    generators). We''ll go through all the details in *Chapter 11*, as this is quite
    a hefty tool meant for last stages of CMake projects.'
  prefs: []
  type: TYPE_NORMAL
- en: CMake-GUI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CMake for Windows comes with a GUI version to configure the building process
    of previously prepared projects. For Unix-like platforms there is a version built
    with QT libraries. Ubuntu offers it in the `cmake-qt-gui` package.
  prefs: []
  type: TYPE_NORMAL
- en: To access CMake-GUI run the `cmake-gui` executable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: CMake GUI: configuring stage for a buildsystem using a generator
    for Visual Studio 2019](img/file3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: CMake GUI: configuring stage for a buildsystem using a generator
    for Visual Studio 2019'
  prefs: []
  type: TYPE_NORMAL
- en: GUI application is really a convenience tool for users of your application,
    as the options there are rather limited. It can be helpful for those who aren’t
    familiar with the command line and would prefer a window-based interface.
  prefs: []
  type: TYPE_NORMAL
- en: '**Not Recommended**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I would definitely recommend GUI to end-users craving convenience, but as a
    programmer I avoid introducing any manual, blocking steps that would require clicking
    on forms every time I build my programs. This is especially important for build
    automation in continuous integration pipelines. These tools require headless applications,
    so build can be fully executed without users' interaction.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CCMake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ccmake` executable is the CMake `curses` interface for Unix-like platforms
    (it's unavailable for Windows). It's not available as part of the CMake package,
    so users have to install it separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command for Debian/Ubuntu systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Project configuration settings may be specified interactively through this GUI.
    Brief instructions are provided at the bottom of the terminal when the program
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of CCMake command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: CCMake uses the same set of options as `cmake`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Configure stage in ccmake](img/file4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Configure stage in ccmake'
  prefs: []
  type: TYPE_NORMAL
- en: Like with graphical GUI - this mode is fairly limited and intended to be used
    by less experienced users. If you're using a Unix machine - I recommend you take
    a quick look and move on even quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the project files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CMake uses quite a few files to manage its projects. Let's get a general idea
    what each file does before tinkering with their contents. It's not only a good
    practice, but changes in random files can get easily lost. You see, even though
    a file contains CMake Language commands - it's not certain that it's meant for
    developers to edit. Some files are generated to be used by subsequent tools and
    any work done there can get written over at some stage. Other files are meant
    for advanced users, to adjust your project to their individual needs. Finally,
    there are some temporary files that provide valuable information in specific contexts.
    This section will also tell you which of them should be in the ignore file of
    your version control system.
  prefs: []
  type: TYPE_NORMAL
- en: Source Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the directory where your project will live (also called **project root**).
    It contains all C++ sources and CMake project files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key takeaways:'
  prefs: []
  type: TYPE_NORMAL
- en: It is required to provide a `CMakeLists.txt` configuration file in its top directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be managed with a Version Control System (or VCS) like git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can provide a path to this directory with `-S` argument to the `cmake` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid hardcoding any absolute paths to it - your users may store it elsewhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CMake uses this directory to store everything that gets generated during the
    build: artifacts of the project, transient configuration, cache, build logs, and
    anything that your native build tool will create. Other names for this directory
    are: **build root** and **binary tree**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key takeaways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your binary files will be created here: executables and libraries, but also
    object files and archives used for final linking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't add this directory to your VCS - it's specific to your system. If you
    decide to put it inside the source tree - make sure to add it to the VCS ignore
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake recommends **out-of-source builds**, or builds that produce artifacts
    in a directory that is separate from all source files. This way we can avoid polluting
    our project's source tree with temporary, system-specific files (or **in-source-builds**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is specified with `-B`, or as a last argument to the `cmake` command if
    you have provided path to source: `cmake -S ../project ./`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`It''s recommended that projects provide an installation step to put the final
    artifacts in a correct place in the system, so all temporary files used for building
    can be removed.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listfiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Files which contain CMake language are called Listfiles and can be included
    one in another by calling `include()` and `find_package()`, or indirectly with
    `add_subdirectory()`.
  prefs: []
  type: TYPE_NORMAL
- en: CMake doesn't enforce consistent naming for these, but they usually have a `.cmake`
    extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very important naming exception is a file called `CMakeLists.txt`, which is
    the first file to be executed in the configuration step, and is required at the
    top of the source tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As CMake walks the source tree and includes different listfiles, following
    variables are set: `CMAKE_CURRENT_LIST_DIR`, `CMAKE_CURRENT_LIST_FILE`, `CMAKE_PARENT_LIST_FILE`,
    `CMAKE_CURRENT_LIST_LINE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMakeLists.txt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CMake projects are configured with `CMakeLists.txt` listfiles. You are required
    to provide at least one in the root of the source tree. Such top-level file is
    first to be executed by CMake configure step and should contain at least two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake_minimum_required(VERSION <x.xx>)` which sets an expected version of
    CMake (and implicitly tells CMake what policies to apply with regards to legacy
    behaviors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project(<name> <OPTIONS>)` to name the project (available later in `PROJECT_NAME`
    variable), and specify options to configure it (we''ll talk this more in the next
    chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As your software grows - you might want to partition it into smaller units
    that can be configured and reasoned about separately. CMake supports that with
    the notion of subdirectories, and their own `CMakeLists.txt` files. Your project
    structure might look similar to this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A very simple `CMakeLists.txt` can then be used to bring it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: CMakeLists.txt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Main aspects of the project are covered in the top-level file: managing dependencies,
    stating requirements, environment detection and whatnot. In this file we''ll also
    have an `add_subdirectory(api)` command to include another `CMakeListst.txt` from
    the `api` directory to perform steps specific to API part of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: CMakeCache.txt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CACHE variables will be generated from `listfiles` and stored in `CMakeCache.txt`
    when the configure stage is run for the first time. This file resides in root
    of the build tree, and has a fairly simple format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from comments in the heading - this format is pretty self-explanatory.
    Cache entries in the `EXTERNAL` section are meant for users to modify while the
    `INTERNAL` section is managed by CMake and it's not recommended to change them
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key takeaways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage this file manually, by calling `cmake` (see *Options: Cache*
    in *Mastering the Command Line* section), or through `ccmake`/`cmake-gui`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can reset the project to default configuration by deleting this file - it
    will be regenerated from listfiles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache variables can be read and written from the listfiles. Sometimes variable
    reference evaluation is a bit complicated - more on that in the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package Config-files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Big part of the CMake ecosystem are external packages that projects can depend
    on. They allow developers to use libraries and tools in a seamless, cross-platform
    way. Packages which support CMake should provide a configuration file, so CMake
    knows how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be learning to write those files in *Chapter 11*. Meanwhile here''s
    a few interesting details:'
  prefs: []
  type: TYPE_NORMAL
- en: Config-files contain information on how to use the library binaries, headers
    and helper tools. Sometimes they expose CMake macros to use in your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `find_package()` command to include packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake files describing packages are named `<PackageName>-config.cmake` and `<PackageName>Config.cmake`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using packages, you can specify which version of the package you need.
    CMake will check that in the associated `<Config>Version.cmake` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Config-files are provided by package vendors supporting the CMake ecosystem.
    If a vendor doesn't provide such a config file, it can be replaced with a Find-module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake provides a package registry to store packages system-wide and per user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cmake_install.cmake, CTestTestfile.cmake, CPackConfig.cmake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These files are generated in the build tree by `cmake` executable in the generation
    step. As such - they shouldn't be edited manually. CMake uses them as a configuration
    for `cmake` install action, CTest and CPack. If you're doing an in-source build
    (not recommended), it's probably a good idea to add them to VCS ignore file.
  prefs: []
  type: TYPE_NORMAL
- en: CMakePresets.json, CMakeUserPresets.json
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuration of the projects can become quite a busy task when we require to
    be specific about things like cache variables, chosen generators, path of build
    tree and so on. Especially when we have more than one way of building our project.
    This is where the presets come in.
  prefs: []
  type: TYPE_NORMAL
- en: Users can choose presets through GUI or use the command line to `--list-presets`
    and select a preset for buildsystem with `--preset=<preset>` option. You'll find
    more details in the *Mastering the Command Line* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Presets are stored in the same JSON format in two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMakePresets.json` meant for project authors to provide official presets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMakeUserPresets.json` dedicated for users who want to customize project configuration
    to their liking (add it to your VCS ignore file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presets are project files, so their explanation belongs here. But they are not
    required in projects and they only become useful when we have completed the initial
    setup, so feel free to skip to the next section and return here later if needed.
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/02-presets/CMakePresets.json
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`CmakePresets.json` specifies following root fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`version` - required, always `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmakeMinimumRequired` - optional, specifies CMake version, object with three
    fields: `major`, `minor`, `patch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vendor` - optional map of vendor-specific options external tools like IDEs,
    keyed with vendor domain and slash separated path. CMake virtually ignores this
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configurePresets` - optional array of available presets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add two presets to our `configurePresets` array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'chapter-01/02-presets/CMakePresets.json : my-preset'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This file supports tree-like structure, where children presets inherit properties
    from multiple parent presets. This means we can create a copy of above preset,
    and override only the fields we need. Here''s what a child-preset might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'chapter-01/02-presets/CMakePresets.json : my-preset-multi'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CMake documentation labels only few fields as explicitly required. However,
    there are some other fields labeled as optional which must be provided either
    in the preset, or inherited from its parent.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Presets are defined as maps with following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` - **required** string identifying the preset. It has to be machine-friendly
    and unique across both files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hidden` - optional boolean hiding preset from GUI and command-line list. Such
    a preset can be a parent of another and doesn''t need to provide anything but
    its name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`displayName` - optional string with human-friendly name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` - optional string describing the preset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inherits` - optional string or array of preset names to inherit from. Values
    from earlier presets will be preferred in case of conflicts, and every preset
    is free to override any inherited field. Also - `CMakeUserPresets.json` can inherit
    from project presets but not the other way around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vendor` - optional map of vendor-specific values, follows the same convention
    as root-level `vendor` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generator` - **required or inherited** string specifying generator to use
    for the preset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`architecture`, `toolset` - optional fields configuring generators that support
    these. Each field can simply be a string or an object with `value` and `strategy`
    fields, where `strategy` is either `set` or `external`. Strategy configured to
    `set` will set the value and produce error if generator doesn''t support this
    field. Configuring `external` means that the field value is set for an external
    IDE and CMake should ignore it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binaryDir` - **required or inherited** string providing path to the build
    tree directory (absolute or relative to the source tree). Supports macro expansion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cacheVariables` - optional map of cache variables, where keys denote variable
    names. Accepted values are: `null`, `"TRUE"`, `"FALSE"`, a string-value or an
    object with optional `type` and required `value` fields. `value` can be a string
    value, `"TRUE"` or `"FALSE"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache variables are inherited with union operation unless value is specified
    as `null` - then it remains unset. String-values support macro expansion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`environment` - optional map of environment variables, where keys denote variable
    names. Accepted values are: `null` or a string-value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables are inherited with union operation unless value is specified
    as `null` - then it remains unset. String-values support macro expansion, and
    variables may reference each other in any order, as long as there is no cyclic
    reference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Following macros are recognized and evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${sourceDir}` - path to the source tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${sourceParentDir}` - path to the source tree''s parent directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${sourceDirName}` - the last filename component of `${sourceDir}` i.e., for
    `/home/rafal/project` it would be `project`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${presetName}` - value of preset''s name field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${generator}` - value of preset''s generator field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${dollar}` - a literal dollar sign ($)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$env{<variable-name>}` - environment variable macro. It will return the value
    of variable from the preset if defined, otherwise - the value from the parent
    environment. Remember that variable names in presets are case-sensitive (unlike
    in Windows environment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$penv{<variable-name>}` - just like `$env`, but always returns values from
    the parent environment. This allows to resolve issues with circular-references
    that are not allowed in the environment variables of the preset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$vendor{<macro-name>}` - Allows for vendors to insert their own macros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignoring files in Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many Version Control Systems, one of the most popular out there is
    Git. Whenever we start a new project it is good to make sure that we only check
    in to the repository files that need to be there. Project hygiene is easier to
    maintain if we just add some generated, user and temporary files to the `.gitignore`
    file. This way - git knows to automatically skip them when building new commits.
    Here''s the file I use in my projects:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/01-hello/.gitignore
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using above file in your projects will allow for more flexibility for you, other
    contributors and users.
  prefs: []
  type: TYPE_NORMAL
- en: Unknown territory of project files is now charted. With this map you'll soon
    be able to write your own listfiles, configure cache, presets and more. Before
    sail on the open seas of project writing - let's see what other kinds of self-contained
    units you can create with CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Scripts and Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Work with CMake is primarily focused on projects that get built, production
    of artifacts that get consumed by other systems: CI/CD pipelines, test platforms
    and deployed to machines or artifact repositories. There are however two other
    concepts that CMake enables you to create with its language: scripts and modules.
    Let''s take a closer look.'
  prefs: []
  type: TYPE_NORMAL
- en: Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To configure project building CMake offers a platform-agnostic programming language.
    It comes with many useful commands. You can use this tool to write scripts that
    come with your project or are completely independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it as a consistent way to do cross-platform work: instead of using
    bash scripts on Linux and batch or powershell scripts on Windows - you can have
    one version. Sure, you could bring in external tools like python, perl or ruby
    scripts, but this is yet another dependency and increased complexity for your
    C/C++ projects. Yes, sometimes this will be the only thing that can get the job
    done, but more often than not we can get away with something much simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know from the *Mastering the Command Line* section that we can execute
    scripts with `-P` option: `cmake -P script.cmake`, but what are the actual requirements
    for the script file provided? Not that many: script can be as complex as you like
    or an empty file, it is however recommended to call `cmake_minimum_required()`
    command at the beginning of the script to give CMake hint which policies it should
    apply to commands with legacy behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/03-script/script.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When running scripts CMake won''t execute any of the usual stages (configuration,
    generation), and it won''t use cache. Since there is no concept of source/build
    tree in scripts - variables that usually hold references to these paths will contain
    current working directory instead: `CMAKE_BINARY_DIR`, `CMAKE_SOURCE_DIR`, `CMAKE_CURRENT_BINARY_DIR`
    and `CMAKE_CURRENT_SOURCE_DIR`.'
  prefs: []
  type: TYPE_NORMAL
- en: Happy scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Utility Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CMake projects can use external modules to enhance their functionality. Modules
    are written in CMake language and contain macro definitions, variables and commands
    which perform all kinds of functions. They range from quite complex scripts (`CPack`
    and `CTest` also provide their modules!) to fairly simple ones, like `AddFileDependencies`
    or `TestBigEndian`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake distribution comes packed with almost 90 different utility modules. If
    that''s not enough - you can download more from the Internet by browsing curated
    lists like this one: [https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake)
    or write a module from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a utility module we need to call an `include(<MODULE>)` command. Here''s
    a simple project showing that in action:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/04-module/CMakeLists.txt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll learn what modules are available as they become relevant to the subject
    at hand. If you''re curious - a full list of bundled modules can be found here:
    [https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Find-Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the section about *Package Config-files* I have mentioned that CMake has
    a mechanism to find files belonging to external dependencies which don't support
    CMake and don't provide a CMake config file (or didn't). That's what the find-modules
    are for. CMake provides over 150 modules locating different packages in the system.
    As was the case with utility modules - there's plenty more find-modules available
    online and an option to write your own as a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: You can use them by calling `find_package()` command and providing the name
    of the package in question. Such a find-module will then play a little game of
    hide-and-seek and check all known locations of the software it is looking for.
    Then it defines variables (specified that module's manual) which allow building
    against that dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `FindCURL` module is searching for a popular *Client URL*
    library and defines following variables: `CURL_FOUND`, `CURL_INCLUDE_DIRS`, `CURL_LIBRARIES`,
    `CURL_VERSION_STRING`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 7* covers find-modules in depth.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you understand what CMake is and how it works: what are the key components
    of CMake tool family, and how to install them on a variety of systems. Like a
    true power user, you know all the ways of running CMake through the command line:
    buildsystem generation, building a project, installing, running scripts, command
    line tools and printing help. You are aware of CTest, CPack and GUI applications.
    This will help you create projects with the right perspective: for users and other
    developers. You also learned what makes up a project: directories, listfiles,
    configs, presets and helper files and what to ignore in your VCS. Finally - you
    took a sneak-peak at other non-project files: standalone scripts and modules.'
  prefs: []
  type: TYPE_NORMAL
- en: Next up is a deep dive into CMake's programming language. It will allow you
    to write your own listfiles and open the door to your first scripts, projects
    and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Official CMake webpage with the documentation: [https://cmake.org/](https://cmake.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single-Configuration generators: [https://cgold.readthedocs.io/en/latest/glossary/single-config.html](https://cgold.readthedocs.io/en/latest/glossary/single-config.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Separation of stages in CMake GUI: [https://stackoverflow.com/questions/39401003/why-there-are-two-buttons-in-gui-configure-and-generate-when-cli-does-all-in-one](https://stackoverflow.com/questions/39401003/why-there-are-two-buttons-in-gui-configure-and-generate-when-cli-does-all-in-one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
