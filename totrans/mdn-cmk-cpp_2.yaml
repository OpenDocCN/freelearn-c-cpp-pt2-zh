- en: '*Chapter 1*: First Steps with CMake'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is something magical about turning source code into a working application.
    It is not only the effect itself, that is, a working mechanism that we devise
    and bring to life, but the very process or act of exercising the idea into existence.
  prefs: []
  type: TYPE_NORMAL
- en: 'As programmers, we work in the following loop: design, code, and test. We invent
    changes, we phrase them in a language that the compiler understands, and we check
    whether they work as intended. To create a proper, high-quality application from
    our source code, we need to meticulously execute repetitive, error-prone tasks:
    invoking the correct commands, checking the syntax, linking binary files, running
    tests, reporting issues, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: It takes great effort to remember each step every single time. Instead, we want
    to stay focused on the actual coding and delegate everything else to automated
    tooling. Ideally, this process would start with a single button, right after we
    have changed our code. It would be smart, fast, extensible, and work in the same
    way across different OSs and environments. It would be supported by multiple **Integrated
    Development Environments** (**IDEs**) but also by **Continuous Integration** (**CI**)
    pipelines that test our software after a change is submitted to a shared repository.
  prefs: []
  type: TYPE_NORMAL
- en: CMake is the answer to many such needs; however, it requires a bit of work to
    configure and use correctly. This is not because CMake is unnecessarily complex
    but because the subject that we're dealing with here is. Don't worry. We'll undergo
    this whole learning process very methodically; before you know it, you will have
    become a building guru.
  prefs: []
  type: TYPE_NORMAL
- en: I know you're eager to rush off to start writing your own CMake projects, and
    I applaud your attitude. Since your projects will be primarily for users (yourself
    included), it's important for you to understand that perspective as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start with just that: becoming a CMake power user. We''ll go through
    a few basics: what this tool is, how it works in principle, and how to install
    it. Then, we''ll do a deep dive on the command line and modes of operation. Finally,
    we''ll wrap up with the purposes of different files in a project, and we''ll explain
    how to use CMake without creating a project at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing CMake on different platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the project files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering scripts and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter01](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: 'To build examples provided in this book always use recommended commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compilation of C++ source code appears to be a fairly straightforward process.
    Let''s take a small program, such as a classic `hello.cpp` application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/01-hello/hello.cpp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we need to do to get an executable is to run a single command. We
    call the compiler with the filename as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code is correct, so the compiler will silently produce an executable binary
    file that our machine can understand. We can run it by calling its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, as our projects grow, you will quickly understand that keeping everything
    in a single file is simply not possible. Clean code practices recommend that files
    should be kept small and in well-organized structures. The manual compilation
    of every file can be a tiresome and fragile process. There must be a better way.
  prefs: []
  type: TYPE_NORMAL
- en: What is CMake?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we automate building by writing a script that goes through our project
    tree and compiles everything. To avoid any unnecessary compilations, our script
    will detect whether the source has been modified since the last time we ran it
    (the script). Now, we'd like a convenient way to manage arguments that are passed
    to the compiler for each file – preferably, we'd like to do that based on configurable
    criteria. Additionally, our script should know how to link all of the compiled
    files in a binary or, even better, build whole solutions that can be reused and
    incorporated as modules in bigger projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more features we will add the higher the chance that we will get to a full-fledged
    solution. Building software is a very versatile process and can span multiple
    different aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling executables and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing some more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would take a very long time to come up with a truly modular and powerful
    C++ building application that is fit for every purpose. And it did. Bill Hoffman
    at Kitware implemented the first versions of CMake over 20 years ago. As you might
    have already guessed, it was very successful. It now has a lot of features and
    support from the community. Today, CMake is being actively developed and has become
    the industry standard for C and C++ programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem of building code in an automated way is much older than CMake,
    so naturally, there are plenty of options out there: Make, Autotools, SCons, Ninja,
    Premake, and more. But why does CMake have the upper hand?'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of things about CMake that I find (granted, subjectively)
    important:'
  prefs: []
  type: TYPE_NORMAL
- en: It stays focused on supporting modern compilers and toolchains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake is truly cross-platform – it supports building for Windows, Linux, macOS,
    and Cygwin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It generates project files for popular IDEs: Microsoft Visual Studio, Xcode,
    and Eclipse CDT. Additionally, it is a project model for others such as CLion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake operates on just the right level of abstraction – it allows you to group
    files in reusable targets and projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are tons of projects that are built with CMake and offer an easy way to
    include them in your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake views testing, packaging, and installing as an inherent part of the build
    process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old, unused features get deprecated to keep CMake lean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake provides a unified, streamlined experience across the board. It doesn't
    matter if you're building your software in an IDE or directly from the command
    line; what's really important is it takes care of post-build stages as well. Your
    **Continous Integration/Continous Deployment** (**CI/CD**) pipeline can easily
    use the same CMake configuration and build projects using a single standard even
    if all of the preceding environments differ.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be under the impression that CMake is a tool that reads source code
    on one end and produces binaries on the other – while that's true in principle,
    it's not the full picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake can''t build anything on its own – it relies on other tools in the system
    to perform the actual compilation, linking, and other tasks. You can think of
    it as the orchestrator of your building process: it knows what steps need to be
    done, what the end goal is, and how to find the right workers and materials for
    the job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This process has three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This stage is about reading project details stored in a directory, called the
    **source tree**, and preparing an output directory or **build tree** for the generation
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: CMake starts by creating an empty build tree and collecting all of the details
    about the environment it is working in, for example, the architecture, the available
    compilers, the linkers, and the archivers. Additionally, it checks whether a simple
    test program can be compiled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `CMakeLists.txt` project configuration file is parsed and executed
    (yes, CMake projects are configured with CMake's coding language). This file is
    the bare minimum of a CMake project (source files can be added later). It tells
    CMake about the project structure, its targets, and its dependencies (libraries
    and other CMake packages). During this process, CMake stores collected information
    in the build tree such as system details, project configurations, logs, and temp
    files, which are used for the next step. Specifically, a `CMakeCache.txt` file
    is created to store more stable variables (such as paths to compilers and other
    tools) and save time during the next configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The generation stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After reading the project configuration, CMake will generate a **buildsystem**
    for the exact environment it is working in. Buildsystems are simply cut-to-size
    configuration files for other build tools (for example, Makefiles for GNU Make
    or Ninja and IDE project files for Visual Studio). During this stage, CMake can
    still apply some final touches to the build configuration by evaluating **generator
    expressions**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The generation stage is executed automatically after the configuration stage.
    For this reason, this book and other resources often refer to both of these stages
    when mentioning "configuration" or "generation" of a buildsystem. To explicitly
    run just the configuration stage, you can use the `cmake-gui` utility.
  prefs: []
  type: TYPE_NORMAL
- en: The building stage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To produce the final artifacts specified in our project, we have to run the
    appropriate **build tool**. This can be invoked directly, through an IDE, or using
    the CMake command. In turn, these build tools will execute steps to produce **targets**
    with compilers, linkers, static and dynamic analysis tools, test frameworks, reporting
    tools, and anything else you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of this solution lies in the ability to produce buildsystems on
    demand for every platform with a single configuration (that is, the same project
    files):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The stages of CMake'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B17205.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – The stages of CMake
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember our `hello.cpp` application from the *Understanding the basics*
    section? CMake makes it really easy for you to build it. All we need is the following
    `CMakeLists.txt` file next to our source and two simple commands, `cmake -B buildtree`
    and `cmake --build buildtree`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'chapter01/01-hello/CMakeLists.txt: Hello world in the CMake language'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output from the Dockerized Linux system (note that we''ll discuss
    Docker in the *Installing CMake on different platforms* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left is to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have generated a buildsystem that is stored in the `buildtree` directory.
    Following this, we executed the build stage and produced a final binary that we
    were able to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know what the end result looks like, I''m sure you will be full of
    questions: what are the prerequisites to this process? What do these commands
    mean? Why do we need two of them? How do I write my own project files? Do not
    worry – these questions will be answered in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Help
  prefs: []
  type: TYPE_NORMAL
- en: This book will provide you with the most important information that is relevant
    to the current version of CMake (at the time of writing, this is 3.20). To provide
    you with the best advice, I have explicitly avoided any deprecated and no longer
    recommended features. I highly recommend using, at the very least, version 3.15,
    which is considered "the Modern CMake." If you require more information, you can
    find the latest, complete documentation online at [https://cmake.org/cmake/help/](https://cmake.org/cmake/help/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing CMake on different platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake is a cross-platform, open-source software written in C++. That means you
    can, of course, compile it yourself; however, the most likely scenario is that
    you won't have to. This is because precompiled binaries are available for you
    to download from the official web page at [https://cmake.org/download/](https://cmake.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: Unix-based systems provide ready-to-install packages directly from the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that CMake doesn't come with compilers. If your system doesn't have
    them installed yet, you'll need to provide them before using CMake. Make sure
    to add the paths to their executables to the `PATH` environment variable so that
    CMake can find them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid solving tooling and dependency problems while learning from this book,
    I recommend choosing the first installation method: Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through different environments on which CMake can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker ([https://www.docker.com/](https://www.docker.com/)) is a cross-platform
    tool that provides OS-level virtualization, allowing applications to be shipped
    in complete packages, called containers. These are self-sufficient bundles that
    contain a piece of software with all of its libraries, dependencies, and tools
    required to run it. Docker executes its containers in lightweight environments
    that are isolated one from another.
  prefs: []
  type: TYPE_NORMAL
- en: This concept makes it extremely convenient to share whole toolchains, which
    are necessary for a given process, configured and ready to go. I can't stress
    enough how easy things become when you don't need to worry about minuscule environmental
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker platform has a public repository of container images, [https://registry.hub.docker.com/](https://registry.hub.docker.com/),
    that provides millions of ready-to-use images.
  prefs: []
  type: TYPE_NORMAL
- en: 'For your convenience, I have published two Docker repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`swidzinski/cmake:toolchain`: This contains the curated tools and dependencies
    that are necessary to build with CMake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swidzinski/cmake:examples`: This contains the preceding toolchain and all
    of the projects and examples from this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is for readers who simply want a clean-slate image ready to
    build their own projects, and the second option is for hands-on practice with
    examples as we go through the chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install Docker by following the instructions from its official documentation
    (please refer to [docs.docker.com/get-docker](http://docs.docker.com/get-docker)).
    Then, execute the following commands in your Terminal to download the image and
    start the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that all of the examples are available in the directories matching this
    format:`/root/examples/``examples/chapter-<N>/<M>-<title>`.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing in Windows is straightforward – simply download the version for 32
    or 64 bits. You can pick a portable ZIP or MSI package for Windows Installer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the ZIP package, you will have to add the CMake bin directory to the `PATH`
    environment variable so that you can use it in any directory without any such
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer convenience, simply use the MSI installer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – The installation wizard can set up the PATH environment variable
    for you'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B17205.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – The installation wizard can set up the PATH environment variable
    for you
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, this is open-source software, so it is possible to build
    CMake yourself. However, first, you will have to get a binary copy of CMake on
    your system. So, why use other build tools if you have your own, right? This scenario
    is used by CMake contributors to generate newer versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, we also require a build tool that can finalize the build process
    started by CMake. A popular choice here is Visual Studio, for which the Community
    Edition is available for free from Microsoft''s website: [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).'
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting CMake on Linux is the same as getting any other popular package. Simply
    use your package manager from the command line. Packages are usually kept up to
    date with fairly recent versions. However, if you are after the latest version,
    you can download the installation script from the website:'
  prefs: []
  type: TYPE_NORMAL
- en: The script for Linux x86_64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The script for Linux aarch64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The package for Debian/Ubuntu
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The package for Red Hat
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This platform is also strongly supported by CMake developers. The most popular
    choice of installation is through MacPorts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Building from the source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If all else fails – or if you''re on a special platform – download the source
    from the official website and compile it yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Building from source is relatively slow and requires more steps. However, by
    doing it this way, you''re guaranteed to use the latest version of CMake. This
    is especially apparent when compared to packages that are available for Linux:
    the older the version of the system, the fewer updates it gets.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our CMake readily installed, let's learn how to use it!
  prefs: []
  type: TYPE_NORMAL
- en: Mastering the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of this book will teach you how to prepare CMake projects for your
    users. To cater to their needs, we need to thoroughly understand how users interact
    with CMake in different scenarios. This will allow you to test your project files
    and ensure they're working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake is a family of tools and consists of five executables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake`: This is the main executable that configures, generates, and builds
    projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctest`: This is the test driver program used to run and report test results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cpack`: This is the packaging program used to generate installers and source
    packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake-gui`: This is the graphical wrapper around `cmake`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ccmake`: This is the console-based GUI wrapper around `cmake`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This binary provides a few modes of operation (also called actions):'
  prefs: []
  type: TYPE_NORMAL
- en: Generating a project buildsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a command-line tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a project buildsystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the first step required to build our project. Here are a few options
    in terms of how the CMake build action can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the generation mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll discuss these options in the upcoming sections. Right now, let''s focus
    on choosing the right form of command. One important feature of CMake is the support
    for out-of-source builds or the production of artifacts in a separate directory.
    In contrast to tools such as GNU Make, this ensures the source directory is kept
    clean from any build-related files and avoids polluting our `-S` option followed
    by path to the directory of the produced buildsystem specified with `-B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will generate a buildsystem in the `./build` directory
    (or create it if it's missing) from the source in the `./project` directory.
  prefs: []
  type: TYPE_NORMAL
- en: We can skip one of the arguments and `cmake` will "guess" that we intended to
    use the current directory for it. However, watch out. Skipping both will get you
    an in-source build, and that is messy.
  prefs: []
  type: TYPE_NORMAL
- en: Not Recommended
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Build in the current directory, but take the source from one directory up (note
    that `-S` is optional):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Build in the `./build` directory, and use a source from the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Options for generators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed earlier, you can specify a few options during the generation stage.
    Selecting and configuring a generator decides which build tool from our system
    will be used for building, what build files will look like, and what the structure
    of the build tree will be.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, should you care? Luckily, the answer is often "no." CMake does support
    multiple native buildsystems on many platforms; however, unless you have a few
    of them installed at the same time, CMake will correctly select it for you. This
    can be overridden by the `CMAKE_GENERATOR` environment variable or by specifying
    the generator directly on the command line, such as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Some generators (such as Visual Studio) support a more in-depth specification
    of a toolset (compiler) and platform (compiler or SDK). Additionally, these have
    respective environment variables that override the default values: `CMAKE_GENERATOR_TOOLSET`
    and `CMAKE_GENERATOR_PLATFORM`. We can specify them directly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Windows users usually want to generate a buildsystem for their favorite IDE.
    On Linux and macOS, it's very common to use Unix Makefiles or Ninja generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check which generators are available on your system, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `help` printout, you should observe a full list like this
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of generators available on Windows 10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Options for caching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CMake queries the system for all kinds of information during the configuration
    stage. This information is cached in `CMakeCache.txt` in the build tree directory.
    There are a few options that allow you to manage that file more conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that is at our disposal is the ability to *prepopulate cached
    information*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can provide a path to the CMake script, which (only) contains a list of `set()`
    commands to specify variables that will be used to initialize an empty build tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **initialization and modification** of existing cache variables can be
    done in another way (for instance, when creating a file is a bit much to only
    set a few variables). You can simply set them in a command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `:<type>` section is optional (it is used by GUIs); you can use `BOOL`,
    `FILEPATH`, `PATH`, `STRING`, or `INTERNAL`. If you omit the type, it will be
    set to the type of an already existing variable; otherwise, it will be set to
    `UNINITIALIZED`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One particularly important variable contains the type of the build: for example,
    debug and release. Many CMake projects will read it on numerous occasions to decide
    things such as the verbosity of messages, the presence of debugging information,
    and the level of optimization for created artifacts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For single-configuration generators (such as Make and Ninja), you''ll need
    to specify it during the configuration phase with the `CMAKE_BUILD_TYPE` variable
    and generate a separate build tree for each type of config: `Debug`, `Release`,
    `MinSizeRel`, or `RelWithDebInfo`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that multi-configuration generators are configured during the build stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can `-L` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Such a list will contain cache variables that aren't marked as `ADVANCED`. We
    can change that by adding the `A` modifier. To print help messages with variables
    - add the `H` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, custom variables that are added manually with the `-D` option
    won't be visible unless you specify one of the supported types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **removal** of one or more variables can be done with the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, the globbing expression supports the `*` wildcard and any `?` character
    symbols. Be careful when using these, as you might break things.
  prefs: []
  type: TYPE_NORMAL
- en: Both of the `-U` and `-D` options can be repeated multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Options for debugging and tracing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'CMake can be run with a multitude of options that allow you to peek under the
    hood. To get general information about variables, commands, macros, and other
    settings, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The optional file argument allows you to store the output in a file. Running
    it in the build tree directory will print additional information about the cache
    variables and build messages from the log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our projects, we''ll be using `message()` commands to report details of
    the build process. CMake filters the log output of these based on the current
    log level (by default, this is `STATUS`). The following line specifies the log
    level that we''re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `level` can be any of the following: `ERROR`, `WARNING`, `NOTICE`, `STATUS`,
    `VERBOSE`, `DEBUG`, or `TRACE`. You can specify this setting permanently in the
    `CMAKE_MESSAGE_LOG_LEVEL` cache variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting option allows you to `message()` call. To debug very complex
    projects, the `CMAKE_MESSAGE_CONTEXT` variable can be used like a stack. Whenever
    your code enters a specific context, you can add a descriptive name to the stack
    and remove it when leaving. By doing this, our messages will be decorated with
    the current `CMAKE_MESSAGE_CONTEXT` variable like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The option to enable this kind of log output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We'll discuss logging in more detail in [*Chapter 2*](B17205_02_Final_JC_ePub.xhtml#_idTextAnchor051),
    *The CMake Language*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all else fails – and we need to use the big guns – there is always **trace
    mode**. This will print every command with the filename and exact line number
    it is called from alongside its arguments. You can enable it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Options for presets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you might have gathered, there are many, many options that users can specify
    to generate a build tree from your project. When dealing with the build tree path,
    generator, cache, and environmental variable, it's easy to get confused or miss
    something. Developers can simplify how users interact with their projects and
    provide a `CMakePresets.json` file that specifies some defaults. To learn more,
    please refer to the *Navigating the project files* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all of the available presets, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use one of the available presets as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'These values override the system defaults and the environment. However, at
    the same time, they can be overridden with any arguments that are explicitly passed
    on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – How presets override CMakeCache.txt and the system environment
    variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B17205.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – How presets override CMakeCache.txt and the system environment
    variables
  prefs: []
  type: TYPE_NORMAL
- en: Building a project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After generating our build tree, we''re ready for the next stage: *running
    the builder tool*. Not only does CMake know how to generate input files for many
    different builders, but it can also run them for you with arguments that are specific
    to our project.'
  prefs: []
  type: TYPE_NORMAL
- en: Not Recommended
  prefs: []
  type: TYPE_NORMAL
- en: 'Many online sources recommend running GNU Make directly after the generation
    stage: `make`. This is a default generator for Linux and macOS, and it usually
    works. However, we prefer the method described in this section, as it is generator-independent
    and is supported across all platforms. As a result, we don''t need to worry about
    the exact environment of every user of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the build mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the majority of these cases, it is enough to simply provide the bare minimum
    to get a successful build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: CMake needs to know where the build tree is that we generated. This is the same
    path that we passed with the `-B` argument in the generation stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'By providing a few options, CMake allows you to specify key build parameters
    that work for every builder. If you need to provide special arguments to your
    chosen, native builder, pass them at the end of the command after the `--` token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Options for parallel builds
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, many build tools will use multiple concurrent processes to leverage
    modern processors and compile your sources in parallel. Builders know the structure
    of project dependencies, so they can simultaneously process steps that have their
    dependencies met to save users' time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to override that setting if you''re building on a powerful machine
    (or to force a single-threaded build for debugging). Simply specify the number
    of jobs with either of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The alternative is to set it with the `CMAKE_BUILD_PARALLEL_LEVEL` environment
    variable. As usual, we can always use the preceding option to override the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Options for target
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We''ll discuss targets in the second part of the book. For now, let''s just
    say that every project is made up of one or more parts, called targets. Usually,
    we''ll want to build all of them; however, on occasion, we might be interested
    in skipping some or explicitly building a target that was deliberately excluded
    from normal builds. We can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you will observe, we can specify multiple targets by repeating the `-t` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'One target that isn''t normally built is `clean`. This will remove all artifacts
    from the build directory. You can call it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, CMake offers a convenient alias if you''d like to clean first
    and then implement a normal build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Options for multi-configuration generators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So, we already know a bit about generators: they come in different shapes and
    sizes. Some of them offer more features than others, and one of these features
    is the ability to build both `Debug` and `Release` build types in a single build
    tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Generators that support this feature include Ninja Multi-Config, Xcode, and
    Visual Studio. Every other generator is a single-configuration generator, and
    they require a separate build tree for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select `Debug`, `Release`, `MinSizeRel`, or `RelWithDebInfo` and specify it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, CMake will use `Debug` as the default.
  prefs: []
  type: TYPE_NORMAL
- en: Options for debugging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When things go bad, the first thing we should do is check the output messages.
    However, veteran developers know that printing all the details all of the time
    is confusing, so they often hide them by default. When we need to peek under the
    hood, we can ask for far more detailed logs by telling CMake to be verbose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The same effect can be achieved by setting the `CMAKE_VERBOSE_MAKEFILE` cached
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When artifacts are built, users can install them on the system. Usually, this
    means copying files into the correct directories, installing libraries, or running
    some custom installation logic from a CMake script.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the installation mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As with other modes of operation, CMake requires a path to a generated build
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Options for multi-configuration generators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just like in the build stage, we can specify which build type we want to use
    for our installation (for more details, please refer to the *Building a project*
    section). The available types include `Debug`, `Release`, `MinSizeRel`, and `RelWithDebInfo`.
    The signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Options for components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a developer, you might choose to split your project into components that
    can be installed independently. We'll discuss the concept of components in further
    detail in [*Chapter 11*](B17205_11_Final_JC_ePub.xhtml#_idTextAnchor217), *Installing
    and Packaging*. For now, let's just assume they represent different parts of the
    solution. This might be something like `application`, `docs`, and `extra-tools`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a single component, use the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Options for permissions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If installation is carried on a Unix-like platform, you can specify default
    permissions for the installed directories, with the following option, using the
    format of `u=rwx,g=rx,o=rx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Options for the installation directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can prepend the installation path specified in the project configuration
    with a prefix of our choice (for example, when we have limited write access to
    some directories). The `/usr/local` path that is prefixed with `/home/user` becomes
    `/home/user/usr/local`. The signature for this option is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that this won't work on Windows, as paths on this platform usually start
    with the drive letter.
  prefs: []
  type: TYPE_NORMAL
- en: Options for debugging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Similarly, to the build stage, we can also choose to view a detailed output
    of the installation stage. To do this, use any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The same effect can be achieved if the `VERBOSE` environment variable is set.
  prefs: []
  type: TYPE_NORMAL
- en: Running a script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CMake projects are configured using CMake's custom language. It's cross-platform,
    quite powerful, and already present. So, why not make it available for other tasks?
    Sure enough, you can write standalone scripts (we'll get to that at the end of
    this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake can run these scripts like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of the script mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Running such a script won''t run any configurations or generate stages. Additionally,
    it won''t affect the cache. There are two ways you can pass values to this script:'
  prefs: []
  type: TYPE_NORMAL
- en: Through variables defined with the `-D` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through arguments that can be passed after a `--` token. CMake will create `CMAKE_ARGV<n>`
    variables for all arguments passed to the script (including the `--` token).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a command-line tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On rare occasions, we might need to run a single command in a platform-independent
    way – perhaps copy a file or compute a checksum. Not all platforms were created
    equal, so not all commands are available in every system, or they have a different
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake offers a mode in which to execute the most common ones in the same way
    across platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the command-line tool mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As the use of this particular mode is fairly limited, we won''t cover it in
    depth. However, if you''re interested in the details, I recommend calling `cmake
    -E` to list all the available commands. To simply get a glimpse of what''s on
    offer, CMake 3.20 supports the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`capabilities`, `cat`, `chdir`, `compare_files`, `copy`, `copy_directory`,
    `copy_if_different`, `echo`, `echo_append`, `env`, `environment`, `make_directory`,
    `md5sum`, `sha1sum`, `sha224sum`, `sha256sum`, `sha384sum`, `sha512sum`, `remove`,
    `remove_directory`, `rename`, `rm`, `server`, `sleep`, `tar`, `time`, `touch`,
    `touch_nocreate`, `create_symlink`, `create_hardlink`, `true`, and `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: If a command you'd like to use is missing, or you need a more complex behavior,
    consider wrapping it in a script and running it in `-P` mode.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It comes without surprise that CMake offers extensive help that is accessible
    through its command line.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the help mode
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: CTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automated testing is very important in order to produce and maintain high-quality
    code. That's why we devoted an entire chapter to this subject (please refer to
    [*Chapter 8*](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179), *Testing Frameworks*),
    where we do a deep dive into the usage of CTest. It is one of the available command-line
    tools, so let's briefly introduce it now.
  prefs: []
  type: TYPE_NORMAL
- en: CTest is about wrapping CMake in a higher layer of abstraction, where the building
    stage becomes just one of the stepping stones in the process of developing our
    software. Other tasks that CMake can do for us include updating, running all kinds
    of tests, reporting the state of the project to external dashboards, and running
    scripts written in the CMake language.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, CTest standardizes running tests and reporting for solutions
    built with CMake. This means that as a user, you don't need to know which testing
    framework the project is using or how to run it. CTest provides a convenient façade
    to list, filter, shuffle, retry, and timebox test runs. Additionally, it can call
    CMake for you if a build is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to run tests for a built project is to call `ctest` in the
    generated build tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: CPack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we have built and tested our amazing software, we are ready to share it
    with the world. In a rare few instances, power users are completely fine with
    the source code, and that's what they want. However, the vast majority of the
    world is using precompiled binaries because of convenience and to save time.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake doesn''t leave you stranded here; it comes with batteries included. CPack
    is built for the exact purpose of creating packages for different platforms: compressed
    archives, executable installers, wizards, NuGet packages, macOS bundles, DMG packages,
    RPMs, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CPack works in a very similar way to CMake: it is configured with the CMake
    language and has many package generators to pick from (just don''t confuse them
    with CMake buildsystem generators). We''ll go through all the specific details
    in [*Chapter 11*](B17205_11_Final_JC_ePub.xhtml#_idTextAnchor217), *Installing
    and Packaging*, as this is quite a hefty tool that is meant for the final stages
    of CMake projects.'
  prefs: []
  type: TYPE_NORMAL
- en: The CMake GUI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CMake for Windows comes with a GUI version to configure the building process
    of previously prepared projects. For Unix-like platforms, there is a version built
    with QT libraries. Ubuntu offers it in the `cmake-qt-gui` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the CMake GUI, run the `cmake-gui` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – The CMake GUI – the configuring stage for a buildsystem using
    a generator for Visual Studio 2019'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B17205.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – The CMake GUI – the configuring stage for a buildsystem using a
    generator for Visual Studio 2019
  prefs: []
  type: TYPE_NORMAL
- en: The GUI application is a convenient tool for users of your application, as the
    options found there are rather limited. It can be useful for those who aren't
    familiar with the command line and would prefer a window-based interface.
  prefs: []
  type: TYPE_NORMAL
- en: Not Recommended
  prefs: []
  type: TYPE_NORMAL
- en: I would definitely recommend GUI to end users craving convenience; however,
    as a programmer, I avoid introducing any manual, blocking steps that would require
    clicking on forms every time I build my programs. This is especially important
    for build automation in CI pipelines. These tools require headless applications
    so that the build can be fully executed without any user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: CCMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ccmake` executable is the CMake `curses` interface for Unix-like platforms
    (it's unavailable for Windows). It's not available as part of the CMake package,
    so users have to install it separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command for Debian/Ubuntu systems is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the project configuration settings can be specified interactively
    through this GUI. Brief instructions are provided at the bottom of the Terminal
    when the program is running:'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of the CCMake command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'CCMake uses the same set of options as `cmake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – The configuring stage in ccmake'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B17205.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – The configuring stage in ccmake
  prefs: []
  type: TYPE_NORMAL
- en: As with **Graphical User Interfaces** (**GUIs**), this mode is fairly limited
    and is intended to be used by less experienced users. If you're using a Unix machine,
    I recommend that you take a quick look and move on even quicker.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the basic introduction to command line of CMake. It's time to
    discover what is the structure of a typical CMake project.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the project files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake uses quite a few files to manage its projects. Let's attempt to get a
    general idea of what each file does before tinkering with the contents. It's important
    to realize, that even though a file contains CMake language commands, it's not
    certain that it's meant for developers to edit. Some files are generated to be
    used by subsequent tools, and any changes made to those files will be written
    over at some stage. Other files are meant for advanced users to adjust your project
    to their individual needs. Finally, there are some temporary files that provide
    valuable information in specific contexts. This section will also specify which
    of them should be in the *ignore file* of your version control system.
  prefs: []
  type: TYPE_NORMAL
- en: The source tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the directory where your project will live (it is also called the **project
    root**). It contains all of the C++ sources and CMake project files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key takeaways of this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: It is required that you provide a `CMakeLists.txt` configuration file in its
    top directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be managed with a VCS such as `git`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path to this directory is given by the user with a `-S` argument of the
    `cmake` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid hardcoding any absolute paths to the source tree in your CMake code –
    users of your software can store the project under a different path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMake uses this directory to store everything that gets generated during the
    build: the artifacts of the project, the transient configuration, the cache, the
    build logs, and anything that your native build tool will create. Alternative
    names for this directory include **build root** and **binary tree**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key takeaways of this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Your binary files will be created here, such as executables and libraries, along
    with *object files* and archives used for final linking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't add this directory to your VCS – it's specific to your system. If you
    decide to put it inside the source tree, make sure to add it to the VCS ignore
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake recommends **out-of-source builds** or builds that produce artifacts in
    a directory that is separate from all source files. This way, we can avoid polluting
    our project's source tree with temporary, system-specific files (or **in-source
    builds**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is specified with `-B` or as a last argument to the `cmake` command if you
    have provided a path to the source, for example, `cmake -S ../project ./`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's recommended that your projects include an installation stage that allows
    you to put the final artifacts in the correct place in the system, so all temporary
    files used for building can be removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listfiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Files that contain the CMake language are called listfiles and can be included
    one in another, by calling `include()` and `find_package()`, or indirectly with
    `add_subdirectory()`:'
  prefs: []
  type: TYPE_NORMAL
- en: CMake doesn't enforce consistent naming for these files, but usually, they have
    a `.cmake` extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very important naming exception is a file called `CMakeLists.txt`, which is
    the first file to be executed in the configuration stage. It is required at the
    top of the source tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As CMake walks the source tree and includes different listfiles, the following
    variables are set: `CMAKE_CURRENT_LIST_DIR`, `CMAKE_CURRENT_LIST_FILE`, `CMAKE_PARENT_LIST_FILE`,
    and `CMAKE_CURRENT_LIST_LINE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMakeLists.txt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMake projects are configured with `CMakeLists.txt` listfiles. You are required
    to provide at least one in the root of the source tree. Such a top-level file
    is the first to be executed in the configuration stage, and it should contain
    at least two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake_minimum_required(VERSION <x.xx>)`: Sets an expected version of CMake
    (and implicitly tells CMake what policies to apply with regard to legacy behaviors).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project(<name> <OPTIONS>)`: This is used to name the project (the provided
    name will be stored in the `PROJECT_NAME` variable) and specify the options to
    configure it (we''ll discuss this further in the [*Chapter 2*](B17205_02_Final_JC_ePub.xhtml#_idTextAnchor051),
    *The CMake Language*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As your software grows, you might want to partition it into smaller units that
    can be configured and reasoned about separately. CMake supports this through the
    notion of subdirectories and their own `CMakeLists.txt` files. Your project structure
    might look similar to the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'A very simple `CMakeLists.txt` file can then be used to bring it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The main aspects of the project are covered in the top-level file: managing
    the dependencies, stating the requirements, and detecting the environment. In
    this file, we also have an `add_subdirectory(api)` command to include another
    `CMakeListst.txt` file from the `api` directory to perform steps that are specific
    to the API part of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: CMakeCache.txt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cache variables will be generated from `listfiles` and stored in `CMakeCache.txt`
    when the configure stage is run for the first time. This file resides in the root
    of the build tree and has a fairly simple format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you can observe from comments in the heading, this format is pretty self-explanatory.
    Cache entries in the `EXTERNAL` section are meant for users to modify, while the
    `INTERNAL` section is managed by CMake. Note that it's not recommended that you
    change them manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are several key takeaways to bear in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: You can manage this file manually, by calling `cmake` (please refer to *Options
    for caching* in the *Mastering the command line* section), or through `ccmake`/`cmake-gui`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can reset the project to its default configuration by deleting this file;
    it will be regenerated from the listfiles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache variables can be read and written from the listfiles. Sometimes, variable
    reference evaluation is a bit complicated; however, we will cover that in more
    detail in [*Chapter 2*](B17205_02_Final_JC_ePub.xhtml#_idTextAnchor051), *The
    CMake Language*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Config-files for packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big part of the CMake ecosystem includes the external packages that projects
    can depend on. They allow developers to use libraries and tools in a seamless,
    cross-platform way. Packages that support CMake should provide a configuration
    file so that CMake understands how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll learn how to write those files in [*Chapter 11*](B17205_11_Final_JC_ePub.xhtml#_idTextAnchor217),
    *Installing and Packaging*. Meanwhile, here''s a few interesting details to bear
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Config-files** (original spelling) contain information regarding how to use
    the library binaries, headers, and helper tools. Sometimes, they expose CMake
    macros to use in your project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `find_package()` command to include packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake files describing packages are named `<PackageName>-config.cmake` and `<PackageName>Config.cmake`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using packages, you can specify which version of the package you need.
    CMake will check this in the associated `<Config>Version.cmake` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Config-files are provided by package vendors supporting the CMake ecosystem.
    If a vendor doesn't provide such a config-file, it can be replaced with a **Find-module**
    (original spelling).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake provides a package registry to store packages system-wide and for each
    user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cmake_install.cmake, CTestTestfile.cmake, and CPackConfig.cmake files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These files are generated in the build tree by the `cmake` executable in the
    generation stage. As such, they shouldn't be edited manually. CMake uses them
    as a configuration for the `cmake` install action, CTest, and CPack. If you're
    implementing an in-source build (not recommended), it's probably a good idea to
    add them to the VCS ignore file.
  prefs: []
  type: TYPE_NORMAL
- en: CMakePresets.json and CMakeUserPresets.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The configuration of the projects can become a relatively busy task when we
    need to be specific about things such as cache variables, chosen generators, the
    path of the build tree, and more – especially when we have more than one way of
    building our project. This is where the presets come in.
  prefs: []
  type: TYPE_NORMAL
- en: Users can choose presets through the GUI or use the command line to `--list-presets`
    and select a preset for the buildsystem with the `--preset=<preset>` option. You'll
    find more details in the *Mastering the command line* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Presets are stored in the same JSON format in two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMakePresets.json`: This is meant for project authors to provide official
    presets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMakeUserPresets.json`: This is dedicated to users who want to customize the
    project configuration to their liking (you can add it to your VCS ignore file).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Presets are project files, so their explanation belongs here. However, they
    are not required in projects, and they only become useful when we have completed
    the initial setup. So, feel free to skip to the next section and return here later,
    if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/02-presets/CMakePresets.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`CMakePresets.json` specifies the following root fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Version`: This is required, and it is always `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmakeMinimumRequired`: This is optional. It specifies the CMake version in
    form of a hash with three fields: `major`, `minor`, and `patch`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vendor`: An IDE can use this optional field to store its metadata. It''s a
    map keyed with a vendor domain and slash-separated path. CMake virtually ignores
    this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configurePresets`: This is an optional array of available presets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add two presets to our `configurePresets` array:'
  prefs: []
  type: TYPE_NORMAL
- en: 'chapter-01/02-presets/CMakePresets.json : my-preset'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This file supports a tree-like structure, where children presets inherit properties
    from multiple parent presets. This means that we can create a copy of the preceding
    preset and only override the fields we need. Here''s an example of what a child
    preset might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'chapter-01/02-presets/CMakePresets.json : my-preset-multi'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The CMake documentation only labels a few fields as explicitly required. However,
    there are some other fields that are labeled as optional, which must be provided
    either in the preset or inherited from its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Presets are defined as maps with the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is a required string that identifies the preset. It has to be
    machine-friendly and unique across both files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hidden`: This is an optional Boolean hiding the preset from the GUI and command-line
    list. Such a preset can be a parent of another and isn''t required to provide
    anything but its name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`displayName`: This is an optional string with a human-friendly name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This is an optional string describing the preset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Inherits`: This is an optional string or array of preset names to inherit
    from. Values from earlier presets will be preferred in the case of conflicts,
    and every preset is free to override any inherited field. Additionally, `CMakeUserPresets.json`
    can inherit from project presets but not the other way around.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vendor`: This is an optional map of vendor-specific values. It follows the
    same convention as a root-level `vendor` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Generator`: This is a *required or inherited* string that specifies a generator
    to use for the preset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`architecture` and `toolset`: These are optional fields for configuring generators
    that support these options (mentioned in the *Generating a project buildsystem*
    section). Each field can simply be a string or a hash with `value` and `strategy`
    fields, where `strategy` is either `set` or `external`. The `strategy` field,
    configured to `set`, will set the value and produce an error if the generator
    doesn''t support this field. Configuring `external` means that the field value
    is set for an external IDE, and CMake should ignore it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binaryDir`: This is a *required or inherited* string that provides a path
    to the build tree directory (which is absolute or relative to the source tree).
    It supports macro expansion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cacheVariables`: This is an optional map of cache variables where keys denote
    variable names. Accepted values include `null`, `"TRUE"`, `"FALSE"`, a string
    value, or a hash with an optional `type` field and a required `value` field. `value`
    can be a string value of either `"TRUE"` or `"FALSE"`. Cache variables are inherited
    with a union operation unless the value is specified as `null` – then, it remains
    unset. String values support macro expansion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Environment`: This is an optional map of environment variables where keys
    denote variable names. Accepted values include `null` or string values. Environment
    variables are inherited with a union operation unless the value is specified as
    `null` – then, it remains unset. String values support macro expansion, and variables
    might reference each other in any order, as long as there is no cyclic reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following macros are recognized and evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${sourceDir}`: This is the path to the source tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${sourceParentDir}`: This is the path to the source tree''s parent directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${sourceDirName}`: This is the last filename component of `${sourceDir}`.
    For example, for `/home/rafal/project`, it would be `project`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${presetName}`: This is the value of the preset''s name field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${generator}`: This is the value of the preset''s generator field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${dollar}`: This is a literal dollar sign ($).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$env{<variable-name>}`: This is an environment variable macro. It will return
    the value of the variable from the preset if defined; otherwise, it will return
    the value from the parent environment. Remember that variable names in presets
    are case-sensitive (unlike in Windows environments).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$penv{<variable-name>}`: This option is just like `$env` but always returns
    values from the parent environment. This allows you to resolve issues with circular
    references that are not allowed in the environment variables of the preset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$vendor{<macro-name>}`: This enables vendors to insert their own macros.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignoring files in Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many VCSs; one of the most popular types out there is Git. Whenever
    we start a new project, it is good to make sure that we only check in to the repository
    files that need to be there. Project hygiene is easier to maintain if we just
    add generated, user, or temporary files to the `.gitignore` file. In this way,
    Git knows to automatically skip them when building new commits. Here''s the file
    that I use in my projects:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/01-hello/.gitignore
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding file in your projects will allow for more flexibility for
    you and other contributors and users.
  prefs: []
  type: TYPE_NORMAL
- en: The unknown territory of project files has now been charted. With this map,
    you'll soon be able to write your own listfiles, configure the cache, prepare
    presets, and more. Before you sail on the open sea of project writing, let's take
    a look at what other kinds of self-contained units you can create with CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering scripts and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Work with CMake is primarily focused on projects that get built and the production
    of artifacts that get consumed by other systems, such as CI/CD pipelines and test
    platforms, or deployed to machines or artifact repositories. However, there are
    two other concepts of CMake that enable you to create with its language: scripts
    and modules. Let''s take a closer look.'
  prefs: []
  type: TYPE_NORMAL
- en: Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To configure project building, CMake offers a platform-agnostic programming
    language. This comes with many useful commands. You can use this tool to write
    scripts that come with your project or are completely independent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it as a consistent way to do cross-platform work: instead of using
    bash scripts on Linux and batch or PowerShell scripts on Windows, you can have
    one version. Sure, you could bring in external tools such as Python, Perl, or
    Ruby scripts, but this is yet another dependency and will increase the complexity
    of your C/C++ projects. Yes, sometimes, this will be the only thing that can get
    the job done, but more often than not, we can get away with something far simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already learned from the *Mastering the command line* section that
    we can execute scripts using the `-P` option: `cmake -P script.cmake`. But what
    are the actual requirements for the script file provided? Not that many: a script
    can be as complex as you like or an empty file. However, it is recommended that
    you call the `cmake_minimum_required()` command at the beginning of the script.
    This command tells CMake which policies should be applied to subsequent commands
    in this project (more details in [*Chapter 3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078),
    *Setting Up Your First CMake Project*).'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/03-script/script.cmake
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When running scripts, CMake won''t execute any of the usual stages (such as
    configuration or generation), and it won''t use the cache. Since there is no concept
    of a source/build tree in scripts, variables that usually hold references to these
    paths will contain the current working directory instead: `CMAKE_BINARY_DIR`,
    `CMAKE_SOURCE_DIR`, `CMAKE_CURRENT_BINARY_DIR`, and `CMAKE_CURRENT_SOURCE_DIR`.'
  prefs: []
  type: TYPE_NORMAL
- en: Happy scripting!
  prefs: []
  type: TYPE_NORMAL
- en: Utility modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CMake projects can use external modules to enhance their functionality. Modules
    are written in the CMake language and contain macro definitions, variables, and
    commands that perform all kinds of functions. They range from quite complex scripts
    (`CPack` and `CTest` also provide modules!) to fairly simple ones, such as `AddFileDependencies`
    or `TestBigEndian`.
  prefs: []
  type: TYPE_NORMAL
- en: The CMake distribution comes packed with almost 90 different utility modules.
    If that's not enough, you can download more from the internet by browsing curated
    lists, such as the one found at [https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake),
    or write a module from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a utility module, we need to call an `include(<MODULE>)` command. Here''s
    a simple project showing this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-01/04-module/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We'll learn what modules are available as they become relevant to the subject
    at hand. If you're curious, a full list of bundled modules can be found at [https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: Find-modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *The Config-files for packages* section, I mentioned that CMake has a
    mechanism that allows it to find files belonging to external dependencies that
    don't support CMake and don't provide a CMake config-file (or haven't). That's
    what find-modules are for. CMake provides over 150 modules that are able to locate
    different packages in the system. As was the case with utility modules, there
    are plenty more find-modules available online and another option is to write your
    own as a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: You can use them by calling the `find_package()` command and providing the name
    of the package in question. Such a find-module will then play a little game of
    hide and seek and check all known locations of the software it is looking for.
    Following this, it defines variables (as specified in that module's manual) that
    allow you to build against that dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `FindCURL` module searches for a popular *Client URL* library
    and defines the following variables: `CURL_FOUND`, `CURL_INCLUDE_DIRS`, `CURL_LIBRARIES`,
    and `CURL_VERSION_STRING`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover find-modules in more depth in [*Chapter 7*](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162),
    *Managing Dependencies with CMake*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you understand what CMake is and how it works; you learned the key components
    of the CMake tool family and how to install them on a variety of systems. Like
    a true power user, you know all the ways in which to run CMake through the command
    line: buildsystem generation, building a project, installing, running scripts,
    command-line tools, and printing help. You are aware of the CTest, CPack, and
    GUI applications. This will help you to create projects, with the right perspective,
    for users and other developers. Additionally, you learned what makes up a project:
    directories, listfiles, configs, presets, and helper files, along with what to
    ignore in your VCS. Finally, you took a sneak peek at other non-project files:
    standalone scripts and modules.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a deep dive into CMake's programming language.
    This will allow you to write your own listfiles and open the door to your first
    script, project, and module.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official CMake web page and documentation: [https://cmake.org/](https://cmake.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Single-configuration generators: [https://cgold.readthedocs.io/en/latest/glossary/single-config.html](https://cgold.readthedocs.io/en/latest/glossary/single-config.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The separation of stages in the CMake GUI: [https://stackoverflow.com/questions/39401003/why-there-are-two-buttons-in-gui-configure-and-generate-when-cli-does-all-in-one](https://stackoverflow.com/questions/39401003/why-there-are-two-buttons-in-gui-configure-and-generate-when-cli-does-all-in-one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
