- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Your Professional Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gathered all the necessary knowledge to build professional projects,
    including structuring, building, dependency management, testing, analyzing, installing,
    and packaging. Now, it’s time to apply these skills by creating a coherent, professional
    project. It’s important to understand that even trivial programs benefit from
    automated quality checks and a seamless process that transforms raw code into
    a complete solution. It’s true that implementing these checks and processes is
    a significant investment, as it requires many steps to set up everything correctly.
    This is especially true when adding these mechanisms to existing code bases, which
    are often large and complex. That’s why it’s beneficial to use CMake from the
    start and establish all the necessary processes early on. It’s easier to configure
    and more efficient, as such quality controls and build automation will eventually
    need to be integrated into long-term projects anyway.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop a new solution that is as small as possible,
    while making the most of the CMake practices we discussed in the book so far.
    To keep it simple, we will implement only a single practical function – adding
    two numbers. Such basic business code will allow us to focus on the build-related
    aspects of the project we learned in previous chapters. To tackle a more challenging
    problem related to building, this project will include both a library and an executable.
    The library will handle the internal business logic and be available as a CMake
    package for other projects. The executable, intended for end users, will provide
    a user interface demonstrating the library’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum that up, in this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning our work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and managing dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and program analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and packaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing the documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch15](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch15).
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the examples provided in this book, always use the recommended commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to replace the placeholders `<build tree>` and `<source tree>` with
    appropriate paths. As a reminder: the **build tree** is the path to the target/output
    directory, and the **source tree** is the path at which your source code is located.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is compiled with GCC to provide compatibility between code coverage
    instrumentation with the `lcov` tool used to collect the results. If you want
    to compile with `llvm` or another toolchain, be sure to adapt the coverage processing
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run tests, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or simply execute it from the build tree directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this chapter, the tests will be outputted to the `test` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: Planning our work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The software we’ll be building in this chapter isn’t meant to be extremely complex
    – we’ll create a simple calculator that adds two numbers together (*Figure 15.1*).
    It will be a console application with a text user interface, utilizing a third-party
    library and a separate calculation library that could be used in other projects.
    Although this project may not have significant practical applications, its simplicity
    is perfect for demonstrating the application of various techniques discussed throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: The text user interface of our project executed in a terminal
    with mouse support'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, projects either generate a user-facing executable or a library for
    developers. It’s less common for projects to produce both, though it does happen.
    For instance, some applications come with standalone SDKs or libraries to help
    develop plugins. Another example is a library bundled with usage examples. Our
    project falls into the latter category, showcasing the library’s functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start planning by reviewing the chapter list, recalling the contents
    of each chapter, and selecting the techniques and tools described that we’ll use
    to build our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 1*, *First Steps with CMake*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter provided basic details about CMake, including installation and
    command-line usage for building projects. It also covered essential information
    about project files, such as their roles, typical naming conventions, and peculiarities.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 2*, *The CMake Language*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We introduced the necessary tools for writing correct CMake listfiles and scripts,
    covering code basics like comments, command invocations, and arguments. We explained
    variables, lists, and control structures, introducing several useful commands.
    This foundation will be crucial throughout our project.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Using CMake in Popular IDEs*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed three IDEs – CLion, VS Code, and Visual Studio IDE – highlighting
    their strengths. In our final project, choosing an IDE (or not) is up to you.
    Once decided, you can start this project in a Dev container to enjoy a fully prepared
    environment with just a few steps to build a Docker image (or just get it from
    the Docker Hub). Running the image in a container ensures that the development
    environment mirrors production.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Setting Up Your First CMake Project*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the project is crucial as it determines the CMake policies that
    will be in effect, naming, versioning, and programming language. We’ll use this
    chapter to influence the fundamental behavior of the build process.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also follow established project partitioning and structuring to determine
    the layout of directories and files, and utilize system discovery variables to
    adapt to different build environments. Toolchain configuration is another critical
    aspect that allows us to mandate a specific C++ version and the standards supported
    by the compiler. Following the chapter’s advice, we will disable in-source builds
    to maintain a clean workspace.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 5*, *Working with Targets*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we learned how every modern CMake project makes extensive use of targets.
    We’ll, of course, apply targets as well to define a few libraries and executables
    (both for test and production) that will keep the project organized and ensure
    we comply with the principle of **DRY** (**Don’t Repeat Yourself**). The acquired
    knowledge of target properties and transitive usage requirements (propagated properties)
    will allow us to keep the configuration close to target definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 6*, *Using Generator Expressions*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator expressions are heavily used throughout our project. We’ll aim to
    keep these expressions as straightforward as possible. The project will incorporate
    custom commands to generate files for Valgrind and coverage reports. Additionally,
    we’ll employ target hooks, specifically `PRE_BUILD`, to clean up the `.gcda` files
    that are produced by the coverage instrumentation process.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 7*, *Compiling C++ Sources with CMake*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s no C++ project without compilation. The basics are quite simple, but
    CMake allows us to tweak this process in so many ways: extend the sources of a
    target, configure the optimizer, and provide debugging information. For this project,
    the default compilation flags will do just fine, but we’ll go ahead and play a
    bit with the preprocessor:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll store build metadata (the project version, build time, and the Git commit
    SHA) in the compiled executable and show it to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll enable the precompilation of headers. It’s not really a necessity in such
    a small project, but it will help us practice this concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity builds won’t be necessary – this project won’t be big enough to make adding
    them worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Linking Executables and Libraries*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will obtain general information on linking, useful in any project by default.
    Additionally, since this project includes a library, we will explicitly reference
    some specific building instructions for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Static libraries for testing and development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared libraries for release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter also outlines how to isolate the `main()` function for testing
    purposes, a practice we will adopt.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 9*, *Managing Dependencies in CMake*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enhance the project’s appeal, we will introduce an external dependency:
    a text-based UI library. *Chapter 9* explores various methods for managing dependencies.
    The choice will be simple: the `FetchContent` utility module is generally recommended
    and most convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 10*, *Using C++20 Modules*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we have explored the use of C++20 modules and the environment requirements
    to support this feature (CMake 3.28, latest compilers), its wide support is still
    lacking. To ensure the project’s accessibility, we will not incorporate modules
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 11*, *Testing Frameworks*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing proper automated tests is imperative to ensuring the quality of
    our solution remains consistent over time. We will integrate CTest and organize
    our project to facilitate testing, applying the `main()` function separation mentioned
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter discusses two testing frameworks: Catch2 and GTest with GMock;
    we will use the latter. To obtain detailed information on our coverage, we will
    generate HTML reports with LCOV.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 12*, *Program Analysis Tools*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For static analysis, we can select from a range of tools: Clang-Tidy, Cpplint,
    Cppcheck, include-what-you-use, and link-what-you-use. We will opt for Cppcheck,
    as Clang-Tidy is less compatible with precompiled headers built using GCC.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis will be conducted using Valgrind’s Memcheck tool, complemented
    by the Memcheck-cover wrapper to produce HTML reports. Additionally, our source
    code will be automatically formatted during the build process with ClangFormat.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 13*, *Generating Documentation:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing documentation is essential when offering a library as part of our
    project. CMake facilitates the automation of documentation generation using `Doxygen`.
    We will adopt this approach in a refreshed design by incorporating the `doxygen-awesome-css`
    theme.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 14*, *Installing and Packaging*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we’ll configure the installation and packaging of our solution and
    prepare files to form the package as described, along with target definitions.
    We’ll install that and the artifacts from build targets to appropriate directories
    by including the `GNUInstallDirs` module. We will additionally configure a few
    components to modularize the solution and prepare it for use with CPack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Professional projects also come with a few text files: `README`, `LICENSE`,
    `INSTALL`, and so on. We will briefly cover these at the end of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: To make things simpler, we won’t implement custom logic that checks whether
    all the required utilities and dependencies are available. We’ll rely on CMake
    to show its diagnostics and tell users what’s missing. If your projects get significant
    traction, you might want to consider adding these mechanisms to improve the user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Having formed a clear plan, let’s discuss how to actually structure the project,
    both in terms of logical targets and directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: Project layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build any project, we should start with a clear understanding of what logical
    targets are going to be created within it. In this case, we’ll follow the structure
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: A structure of logical targets'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the structure by following the build order. First, we compile
    `calc_obj`, an **object library**. For a refresher on object libraries, please
    check *Chapter 5*, *Working with Targets*. We should then turn our attention to
    **static** **libraries** and **shared libraries**.
  prefs: []
  type: TYPE_NORMAL
- en: Shared libraries versus static libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 8*, *Linking Executables and Libraries*, we introduced both shared
    and static libraries. We noted that shared libraries can reduce overall memory
    usage when multiple programs use the same library. Also, it’s common for users
    to already have popular libraries installed or to know how to install them quickly.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, **shared libraries** are separate files that must be placed
    in specific paths for the dynamic linker to locate them. In contrast, **static
    libraries** are embedded directly into the executable file, which leads to faster
    usage as there are no additional steps required to locate the code in memory.
  prefs: []
  type: TYPE_NORMAL
- en: As library authors, we can decide whether we’re providing a static or a shared
    version of the library, or we can simply ship both versions and leave this decision
    to the programmer using our library in their project. Since we’re exercising our
    knowledge, we will deliver two versions.
  prefs: []
  type: TYPE_NORMAL
- en: The `calc_test` target, which includes unit tests to verify the library’s core
    functionality, will utilize the static library. Although we are building both
    types of libraries from the same *object files*, testing with either library type
    is acceptable since their functionalities should be identical. The console app
    associated with `calc_console_static` target will use the shared library. This
    target also links against an external dependency, the Functional Terminal (X)
    User Interface (FTXUI) library by Arthur Sonzogni (there is a link to the GitHub
    project in the *Further reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two targets, `calc_console` and `calc_console_test`, are designed
    to tackle a common issue in testing executables: the clash of multiple entry points
    provided by both the test frameworks and the executables. To circumvent this,
    we have intentionally isolated the `main()` function into a bootstrap target,
    `calc_console`, which merely invokes the primary function from `calc_console_static`.'
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of the necessary targets and their interrelations, our
    next step is to organize the project’s structure with appropriate files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Project file structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project consists of two key elements: the `calc` libraries and the `calc_console`
    executable. To organize our project effectively, we will employ the following
    directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src` contains sources for all released targets and library header files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test` contains tests for the above libraries and executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake` contains utility modules and helper files used by CMake to build and
    install the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*root directory* contains top-level configuration and documentation files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This structure (shown in *Figure 15.3*) ensures a clear separation of concerns,
    facilitating easier navigation and maintenance of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: The directory structure of the project'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full list of files in each of the four main directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Root directory** | `./test` |'
  prefs: []
  type: TYPE_TB
- en: '| `CHANGELOG` | `CMakeLists.txt` |'
  prefs: []
  type: TYPE_TB
- en: '| **CMakeLists.txt** | **calc/CMakeLists.txt** |'
  prefs: []
  type: TYPE_TB
- en: '| `INSTALL``LICENSE``README.md` | `calc/calc_test.cpp``calc_console/CMakeLists.txt``calc_console/tui_test.cpp`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `./src` | `./cmake` |'
  prefs: []
  type: TYPE_TB
- en: '| `CMakeLists.txt``calc/CMakeLists.txt``calc/CalcConfig.cmake``calc/basic.cpp``calc/include/calc/basic.h``calc_console/CMakeLists.txt``calc_console/bootstrap.cpp``calc_console/include/tui.h``calc_console/tui.cpp`
    | `BuildInfo.cmake``Coverage.cmake``CppCheck.cmake``Doxygen.cmake``Format.cmake``GetFTXUI.cmake``Packaging.cmake``Memcheck.cmake``NoInSourceBuilds.cmake``Testing.cmake``buildinfo.h.in``doxygen_extra_headers`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 15.1: File structure of the project'
  prefs: []
  type: TYPE_NORMAL
- en: While it may appear that CMake introduces considerable overhead, with the `cmake`
    directory initially containing more content than the actual business code, this
    dynamic will shift as the project expands in functionality. The initial effort
    to establish a clean and organized project structure is substantial, but rest
    assured, this investment will yield significant benefits in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll go through all the files mentioned in *Table 15.1* throughout the chapter
    and see in detail what they do and what role they play in the project. This will
    happen in four steps: building, testing, installing, and providing documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Building and managing dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All build processes follow the same procedure. We begin with the top-level listfile
    and progress downward through the project’s source tree. *Figure 15.4* illustrates
    the project files involved in the build process, with numbers in parentheses indicating
    the order of CMake script execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Files used in the build stage'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level `CMakeLists.txt` (1) listfile configures the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We start by specifying essential project details and setting the path to the
    CMake utility modules (the `cmake` directory in our project). We then prevent
    in-source builds using a custom module. Following that, we enable testing with
    the `CTest` module (built into CMake). This should be done at the project’s root
    level because this command creates the `CTestTestfile.cmake` file in the binary
    tree relative to its location in the source tree. Placing it elsewhere would prevent
    `ctest` from finding it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we include two key directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src`, containing the project source (to be named `bin` in the build tree)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`, containing all the testing utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we include the `Packaging` module, details of which will be discussed
    in the *Installing and packaging* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the `NoInSourceBuilds` utility module to understand its function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/NoInSourceBuilds.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here, we check if the user has provided a separate destination
    directory for generated files using the `cmake` command. It must differ from the
    project’s source tree path. If not, we instruct the user on how to specify it
    and how to clean up the repository if they made a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our top-level listfile then includes the `src` subdirectory, instructing CMake
    to process the listfile within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This file is straightforward – it includes all the modules from the `./cmake`
    directory we will be using and directs CMake to the nested directories to execute
    the listfiles found there.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s examine the listfile for the `calc` library. It’s somewhat complex,
    so we’ll break it down and discuss it in sections.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Calc library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The listfile in the `calc` directory configures various aspects of this library
    but, for now, we’ll focus only on the building:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We define three targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`calc_obj`, an *object library* compiling the `basic.cpp` implementation file.
    Its `basic.h` header file is included using the `FILE_SET` keyword in the `target_sources()`
    command. This implicitly configures appropriate include directories to be exported
    correctly for both building and installation modes. By creating an *object library*,
    we prevent redundant compilation for the two library versions, but it’s essential
    to enable `POSITION_INDEPENDENT_CODE` so that the shared library can depend on
    this target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calc_shared`, a shared library that depends on `calc_obj`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calc_static`, a static library that also depends on `calc_obj`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For context, here’s the C++ header for the basic library. This header file
    simply declares two functions within the `Calc` namespace, which helps avoid name
    collisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/include/calc/basic.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation file is straightforward as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/basic.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This wraps up the explanation of files in the `src/calc` directory. Next up
    is the `src/calc_console` and building the executable of the console calculator
    using this library.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Calc console executable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `calc_console` directory contains several files: a listfile, two implementation
    files (the business logic and a bootstrap file), and a header file. The listfile
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Though the listfile appears complex, as seasoned CMake users, we can now easily
    decipher its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the `calc_console_static` target, containing the business code without
    the `main()` function to allow linking with GTest, which has its own entry point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the *include directories*. We could add headers individually with
    `FILE_SET`, but since they are internal, we simplify this step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement header precompilation, here demonstrated with just the `<string>`
    header as an example, though larger projects might include many more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include a custom CMake module to fetch the FTXUI dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the business code with the shared `calc_shared` library and the FTXUI components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a custom module to generate build information and embed it into the artifact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Outline additional steps for this target: coverage instrumentation, testing,
    program analysis, and documentation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and link the `calc_console` bootstrap executable, establishing the entry
    point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Outline the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will explore testing, documentation, and installation processes in their
    respective sections later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re including the `GetFTXUI` utility module rather than looking for `config-module`
    in the system because it’s not very likely that most users have it installed.
    We’ll just fetch and build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/GetFTXUI.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’re using the recommended `FetchContent` method, described in detail in *Chapter
    9*, *Managing Dependencies in CMake*. The only unusual addition is the calls of
    the `option()` command, which lets us bypass the lengthy build steps for FTXUI
    and prevents its installation steps from affecting this project’s installation
    process. For more details, refer to the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listfile for the `calc_console` directory includes another custom utility
    module that is build-related: `BuildInfo`. This module will capture three pieces
    of information to be displayed in the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: The current Git commit SHA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build timestamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project version specified in the top-level listfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we learned in *Chapter 7*, *Compiling C++ Sources with CMake*, CMake can
    capture build-time values and pass them to C++ code via template files, for example,
    with a struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/buildinfo.h.in**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To fill that structure during the configuration stage, we’ll use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/BuildInfo.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After including the module, we have set variables to capture the desired information
    and use `configure_file()` to generate `buildinfo.h`. The final step was to invoke
    the `BuildInfo` function to include the generated file’s directory in the target’s
    `include` directories.
  prefs: []
  type: TYPE_NORMAL
- en: The produced header file can be then shared with multiple different consumers
    if needed. In such a case, you’ll probably want to add `include_guard(GLOBAL)`
    at the top of the listfile to avoid running the `git` command for every target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before looking into the implementation of the console calculator, I’d like
    to emphasize that you don’t need to deeply understand the intricacies of the `tui.cpp`
    file or the FXTUI library, as this isn’t essential for our purposes. Instead,
    let’s focus on the highlighted parts of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc_console/tui.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code provides the `getTui()` function, which returns a `ftxui::Component`,
    an object that encapsulates interactive UI elements like labels, text fields,
    separators, and a border. For those curious about the detailed workings of these
    elements, further materials are available in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, the *include directives* link to the headers from the `calc_obj`
    target and the `BuildInfo` module. The interaction begins with the lambda function,
    invoking `Calc::Sum`, and displaying the result using the `text()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The values from the `buildinfo.h` collected at build time are used in a similar
    way and will be shown to the user at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside `tui.cpp`, there’s a header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc_console/include/tui.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This header is used by the bootstrap file in the `calc_console` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc_console/bootstrap.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This brief code initializes an interactive console screen with FTXUI, displaying
    the `Component` object from `getTui()` and handling keyboard inputs in a loop.
    With all files in the `src` directory addressed, we can now progress to testing
    and analyzing the program.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and program analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Program analysis and testing are essential components that work together to
    ensure the quality of our solutions. For instance, using Valgrind is more effective
    when running test code (because of its consistency and coverage). Therefore, we
    will configure testing and program analysis in the same place. *Figure 15.5* illustrates
    the execution flow and files needed to set them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: Files used to enable testing and program analysis'
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers in parentheses represent the sequence in which listfiles are processed.
    Start from the top-level listfile and add the `src` and `test` directories:'
  prefs: []
  type: TYPE_NORMAL
- en: In `src`, include `Coverage`, `Format`, and `CppCheck` modules, and add the
    `src/calc` and `src/calc_console` directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `src/calc`, define targets and configure them with included modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `src/calc_console`, define targets and configure them with included modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `test`, include `Testing` (which includes `Memcheck`) and add the `test/calc`
    and `test/calc_console` directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `test/calc`, define test targets and configure them with included modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In t`est/calc_console`, define test targets and configure them with included
    modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine the listfile for the `test` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/test/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this level, the `Testing` utility module is included to provide functionality
    for both target groups (from the `calc` and `calc_console` directories):'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Testing.cmake (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We enabled testing and included the `FetchContent` module to obtain GTest and
    GMock. Although GMock isn’t used in this project, it’s included with GTest in
    the same repository, so we configure it as well. The key configuration step is
    preventing the installation of these frameworks from affecting our project’s installation
    by using the `option()` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file, we define an `AddTests()` function to facilitate comprehensive
    testing of business targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Testing.cmake (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we include the necessary modules: `GoogleTest` is bundled with CMake,
    and `Coverage` and `Memcheck` are custom utility modules included in the project.
    The `AddTests` macro is then provided to prepare a target for testing, applying
    coverage instrumentation, and memory checking. The `AddCoverage()` and `AddMemcheck()`
    functions are defined in their respective utility modules. Now, we can proceed
    to implement them.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Coverage module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding coverage across various targets involves several steps. The `Coverage`
    module provides a function that defines the coverage target for a specified target:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Coverage.cmake (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation differs slightly from the one introduced in *Chapter 11*,
    *Testing Frameworks*, as it now includes the target name in the output path to
    prevent name conflicts. Next, we need a function to clear previous coverage results:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Coverage.cmake (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we have a function to prepare a target for coverage analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Coverage.cmake (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `InstrumentForCoverage()` function is applied to `src/calc` and `src/calc_console`,
    enabling the generation of the coverage data files when targets `calc_obj` and
    `calc_console_static` are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate reports for both test targets, execute the following `cmake` commands
    after configuring the project with the `Debug` build type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we want to perform dynamic program analysis on multiple targets we defined,
    so to apply the Memcheck module, introduced in *Chapter 12*, *Program Analysis
    Tools*, we need to tweak it slightly to scan more than one target.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Memcheck module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generation of Valgrind memory management reports is initiated by `AddTests()`.
    We begin the Memcheck module with its initial setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Memcheck.cmake (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is already familiar to us. Now, let’s examine the function that creates
    the necessary targets for generating reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Memcheck.cmake (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We slightly improved the `AddMemcheck()` function from *Chapter 12* to handle
    multiple targets. We made the `REPORT_PATH` variable target-specific.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate Memcheck reports, use the following commands (note that generating
    reports is more effective when using the `Debug` build type for configuration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Okay, we defined our `Coverage` and `Memcheck` modules (they are used in the
    `Testing` module), so let’s see how the actual test targets are configured.
  prefs: []
  type: TYPE_NORMAL
- en: Applying testing scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement testing, we’ll follow this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Write unit tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define and configure executable targets for tests with `AddTests()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instrument the **Software Under Test** (**SUT**) to enable coverage collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that coverage data is cleared between the builds to prevent segmentation
    faults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start with the unit tests we have to write. To keep things brief, we’ll
    provide the simplest (and perhaps a bit incomplete) unit tests possible. First,
    test the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/test/calc/basic_test.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow with the tests for the console – for this purpose, we’ll use the FXTUI
    library. Again, understanding the source code completely isn’t necessary; these
    tests are for illustrative purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/test/calc_console/tui_test.cpp**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This test renders the UI to a static `Screen` object and checks if the string
    output contains the expected sum. Not really a great test, but at least it’s a
    short one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s configure our tests with two nested listfiles. First, for the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/test/calc/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And then for the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/test/calc_console/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These configurations enable CTest to execute the tests. We also need to prepare
    the business logic targets for coverage analysis and ensure that the coverage
    data is refreshed between builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the necessary instructions to the `calc` library target:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Instrumentation is added to the `calc_obj` with the extra `--coverage` flag,
    but `CleanCoverage()` is called for the `calc_static` target. Normally, you’d
    apply it on the `calc_obj` for consistency, but we’re using the `PRE_BUILD` keyword
    in `CleanCoverage()`, and CMake doesn’t allow `PRE_BUILD`, `PRE_LINK`, or `POST_BUILD`
    hooks to the object libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll instrument and clean the console target as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With these steps, CTest is now set up to run our tests and collect coverage.
    Next, we’ll add instructions for enabling static analysis, as we want our project
    to be of high quality during the first build and all of the subsequent builds.
  prefs: []
  type: TYPE_NORMAL
- en: Adding static analysis tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re nearing the completion of configuring quality assurance for our targets.
    The final step involves enabling automatic formatting and integrating `CppCheck`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We face a minor issue here: `calc_obj` cannot have a `PRE_BUILD` hook, so we
    apply formatting to `calc_static` instead. We also make sure that the `calc_console_static`
    target is formatted and checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.cmake (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to define the `Format` and `CppCheck` functions. Starting with
    `Format()`, we’re borrowing the code described in *Chapter 12*, *Program Analysis
    Tools*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Format.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate `CppCheck` with our sources, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/CppCheck.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is simple and convenient. You may see some resemblance to the Clang-Tidy
    module (from *Chapter 12*, *Program Analysis Tools*) showcasing CMake’s consistency
    in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments for `cppcheck` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--enable=warning`: Activates warning messages. To enable additional checks,
    refer to the Cppcheck manual (see the *Further reading* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--error-exitcode=1`: Sets the error code returned when `cppcheck` detects
    an issue. This can be any number from `1` to `255` (as `0` indicates success),
    although some numbers can be reserved by the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all files in the `src` and `test` directories created, our solution is
    now buildable and fully tested. We can proceed to the installation and packaging
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 15.6* shows where we’ll configure our project for installation and
    packaging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_15_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: File configuring installation and packaging'
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level listfile includes the `Packaging` utility module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Packaging` module details the package configuration for the project, which
    we will explore in the *Packaging with CPack* section. Our focus now is on installing
    three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Calc library artifacts: static and shared libraries, header files, and
    target export files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package definition config file for the Calc library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Calc console executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything is planned, so it’s time to configure the installation of the library.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of the library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the library, we start by defining logical targets and their artifact
    destinations, utilizing the `GNUInstallDirs` module’s default values to avoid
    manual path specification. Artifacts will be grouped into components. The default
    installation will install all files, but you may choose to only install the `runtime`
    component and skip the `development` artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For UNIX systems, we also configure post-installation registration of the shared
    library with `ldconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable reusability in other CMake projects, we’ll package the library by
    generating and installing a target export file and a config file that references
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity, the `CalcConfig.cmake` file is kept minimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/CalcConfig.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This file is located in `src/calc` since it only includes the library targets.
    If there were target definitions from other directories, like `calc_console`,
    you would typically place `CalcConfig.cmake` in the top-level or `src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the library is prepared to be installed with the `cmake --install` command
    after building the project. However, we still need to configure the installation
    of the executable.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of the executable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We, of course, want our users to be able to enjoy the executable in their system,
    so we will install it with CMake. Preparing the installation of the binary executable
    is straightforward; to achieve it, we only need to include `GNUInstallDirs` and
    use a single `install()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With that, the executable is set to be installed. Now, let’s proceed to packaging.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging with CPack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could go wild and configure a vast multitude of supported package types;
    for this project, however, a basic configuration will be enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Packaging.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a minimal setup works well for standard archives, such as ZIP files. To
    test the installation and packaging processes after building the project, use
    the following command within the build tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the installation and packaging; the next order of business is
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final touch to a professional project is the documentation. Undocumented
    projects are very difficult to navigate and understand when working in teams and
    when shared with external audiences. I would even go as far as saying that programmers
    often read their own documentation after stepping away from a specific file to
    understand what is happening inside.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is also important for legal and compliance reasons and to inform
    the users how to act with the software. If time permits, we should invest in setting
    up documentation for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Documentation usually falls into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Technical documentation (covering interfaces, designs, classes, and files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General documentation (encompassing all other non-technical documents)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw in *Chapter 13*, *Generating Documentation*, much of the technical
    documentation can be automatically generated with CMake using `Doxygen`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the technical documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While some projects generate documentation during the build phase and include
    it in the package, we’ve chosen not to do so for this project. However, there
    could be valid reasons to opt otherwise, like if the documentation needs to be
    hosted online.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15.7* provides an overview of the documentation generation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_15_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: Files used to generate documentation'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate documentation, we’ll create another CMake utility module, `Doxygen`.
    Start by using the `Doxygen` `find-module` and download the `doxygen-awesome-css`
    project for themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Doxygen.cmake (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll need a function to create targets that generate documentation.
    We’ll adapt the code introduced in *Chapter 13*, *Generating Documentation*, to
    support multiple targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/cmake/Doxygen.cmake (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this function by calling it for the library target:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the console executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/src/calc_console/CMakeLists.txt (fragment**)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This setup adds two targets to the project: `doxygen-calc` and `doxygen-calc_console`,
    allowing for the on-demand generation of technical documentation. Now, let’s consider
    what other documents should be included.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing non-technical documents for a professional project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Professional projects should include a set of non-technical documents stored
    in the top-level directory, essential for comprehensive understanding and legal
    clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`README`: Provides a general description of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LICENSE`: Details the legal parameters regarding the project’s use and distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additional documents you might consider include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSTALL`: Offers step-by-step installation instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHANGELOG`: Presents significant changes across versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTHORS`: Lists contributors and their contact information if the project
    has multiple contributors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUGS`: Advises on known issues and details on reporting new ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CMake doesn’t directly interact with these files, as they don’t involve automated
    processing or scripting. Yet, their presence is vital for a well-documented C++
    project. Here’s a minimal example of each document:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/README.md**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is short and maybe a little silly. Note the `.md` extension – it stands
    for *Markdown*, which is a text-based formatting language that is easily readable.
    Websites such as GitHub and many text editors will render these files with rich
    formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `INSTALL` file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/INSTALL**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LICENSE` file is a bit tricky, as it requires some expertise in copyright
    law (and otherwise). Instead of writing all the clauses by ourselves, we can do
    what many other projects do and use a readily available software license. For
    this project, we’ll go with the MIT License, which is extremely permissive. Check
    the *Further reading* section for some useful references:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/LICENSE**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we have the `CHANGELOG`. As suggested earlier, it’s good to keep track
    of changes in a file so that developers using your project can easily find out
    which version supports the features they need. For example, it might be useful
    to say that a multiplication feature was added to the library in version 0.8.2\.
    Something as simple as the following is already helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch15/01-full-project/CHANGELOG**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: With these documents, the project not only gains an operational structure but
    also communicates its usage, changes, and legal considerations effectively, ensuring
    users and contributors have all the necessary information at their disposal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we put together a professional project based on everything
    we’ve learned so far. Let’s do a quick recap.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started by laying out the project and discussing what files will live in
    which directory. Based on previous experience and the desire to practice more
    advanced scenarios, we delineated a main application for the users and a library
    that another developer might use. This shaped the structure of directories and
    relations between the CMake targets we want to build. We then followed with the
    configuration of individual targets for the build: we provided the source code
    for the library, defined its targets, and set it up for consumption with position-independent
    code parameters. The user-facing application also had its executable target defined,
    provided with source code, and configured its dependency: the FTXUI library.'
  prefs: []
  type: TYPE_NORMAL
- en: Armed with artifacts to build, we continued to enhance our project with tests
    and quality assurance. We added the coverage module to produce coverage reports,
    Memcheck to verify the solution with Valgrind during the runtime, and `CppCheck`
    to execute static analysis as well.
  prefs: []
  type: TYPE_NORMAL
- en: Such a project was now ready to be installed, so we created appropriate installation
    entries for the library and the executable using the techniques learned so far,
    and we prepared a package configuration for CPack. The final task was to ensure
    that the project was correctly documented, so we set up automatic documentation
    generation with Doxygen and wrote a few basic documents that take care of less
    technical aspects of the software distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This led us to the completion of the project configuration and we can now easily
    build it and install it with just a few precisely used CMake commands. But what
    if we could just use one simple command to complete the entire process? Let’s
    discover how in the final chapter: *Chapter 16*, *Writing CMake Presets*.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Building both a static library and a shared library: [https://stackoverflow.com/q/2152077](https://stackoverflow.com/q/2152077)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A FXTUI library project:[https://github.com/ArthurSonzogni/FTXUI](https://github.com/ArthurSonzogni/FTXUI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation of the `option()` command:[https://cmake.org/cmake/help/latest/command/option.html](https://cmake.org/cmake/help/latest/command/option.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing for release (of open source software) by Google:[https://opensource.google/docs/releasing/preparing/](https://opensource.google/docs/releasing/preparing/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why we can’t use Clang-Tidy for GCC-precompiled headers:[https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104](https://gitlab.kitware.com/cmake/cmake/-/issues/22081#note_943104)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cppcheck manual:[https://cppcheck.sourceforge.io/manual.pdf](https://cppcheck.sourceforge.io/manual.pdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a README:[https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/](https://www.freecodecamp.org/news/how-to-write-a-good-readme-file/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creative Commons licenses for GitHub projects:[https://github.com/santisoler/cc-licenses](https://github.com/santisoler/cc-licenses)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly used project licenses recognized by GitHub:[https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/licensing-a-repository)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave a review!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enjoyed this book? Help readers like you by leaving an Amazon review. Scan the
    QR code below to get a free eBook of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Review_Copy.png)'
  prefs: []
  type: TYPE_IMG
