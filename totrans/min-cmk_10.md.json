["```cpp\ncmake --preset <preset-name>\ncmake --build <build-folder> --target install\n```", "```cpp\nExternalProject_Add(\n  mc-array\n  SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../lib/array\n  BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/mc-array-build/${build_type_dir}\n  INSTALL_DIR ${CMAKE_CURRENT_SOURCE_DIR}/install\n  CMAKE_ARGS ${build_type_arg} -DCMAKE_INSTALL_PREFIX=<INSTALL_DIR>\n  CMAKE_CACHE_ARGS -DCMAKE_DEBUG_POSTFIX:STRING=d)\n```", "```cpp\nSOURCE_DIR URL or GIT_REPOSITORY link. If we did, for some reason, want to refer to an older version of one of the libraries at a specific moment in the Git history of our project, we could use this approach:\n\n```", "```cpp\n\n\t\t\tWe did the same thing in [*Chapter 3*](B21152_03.xhtml#_idTextAnchor065), *Using FetchContent with External Dependencies*, when using `FetchContent`. The preceding command will clone the entire repository into the build folder of our third-party `CMakeList.txt` file, and then treat the `ch8/part-1/lib/array` directory as the root of the repository (at least as far as `ExternalProject_Add` is concerned). It’s not often needed but can be useful if a repository holds more than one CMake project.\n\t\t\tWhile we’re making changes to `third-party/CMakeLists.txt`, we’ll also make one small improvement to how we handle our bgfx dependency. When bgfx was first introduced in [*Chapter 6*](B21152_06.xhtml#_idTextAnchor152), *Installing Dependencies and ExternalProject_Add* (see `ch6/part-4`), we wound up needing to clone the repository twice, once for the static version of the library (needed to build the tools), and again for the shared version of the library that our application linked against. The good news is there’s a handy technique we can apply to download the library once. The following is an extract of the changes with the differences highlighted:\n\n```", "```cpp\n\n\t\t\tThe first `ExternalProject_Add` call is the same as before; we let it know the repository and specific `GIT_TAG` to download. However, in the second version, instead of repeating those lines, we first call `ExternalProject_Get_Property`, passing the `bgfxt` target and the `SOURCE_DIR` property. `SOURCE_DIR` will be populated with the location of the `bgfxt` source code once it’s downloaded, and in the second command, we point the `bgfx` target to reference that source code location. As the code is identical and it’s just how we’re building it that’s different, this saves a bit of time and network bandwidth downloading the same files all over again.\n\t\t\tYou might have noticed that we’re using `URL \"file://${SOURCE_DIR}\"` as opposed to `SOURCE_DIR ${SOURCE_DIR}`. This is because if we tried to use `SOURCE_DIR`, the `ExternalProject_Add` command would fail at configure time because `SOURCE_DIR` is expected to already be present when we configure. As this isn’t the case with our dependency (the source for `bgfxt` will only be downloaded and made available at build time), we can use the `URL` option with a local file path shown by `file://`, which will cause the file path to instead be resolved at build time.\n\t\t\tWith the addition of the three new `ExternalProject_Add` calls referencing our libraries, when building our project, we only need to visit two directories, as opposed to the earlier five. We can navigate to `ch8/part-1/third-party` and run the following CMake commands:\n\n```", "```cpp\n\n\t\t\tThis will download, build, and install all our dependencies at once. We then only need to navigate to `ch8/part-1/app` and run the following:\n\n```", "```cpp\n\n\t\t\tThis will build and link our application. We’ve also tidied up our `CMakePresets.json` file to have `CMAKE_PREFIX_PATH` only refer to `${sourceDir}/../third-party/install`, as opposed to the numerous install folders we had for each of our internal dependencies in the last chapter.\n\t\t\tFinally, to launch the application, we first need to compile our shaders and then launch the application from our application root directory (`ch8/part-1/app`):\n\n```", "```cpp\n\n\t\t\tThis is a substantial improvement from before, but we can do better. The main build is still split across two stages (dependencies and application), and we still have the annoying issue of needing to remember to compile the shaders (an easy step to overlook). We want to achieve the holy grail of one command to bootstrap everything. Let’s start by seeing how we can solve the first problem by reducing our build steps from two to one.\n\t\t\tConfiguring a super build\n\t\t\tFor those unfamiliar with the term **super build**, it is a pattern to bundle external dependencies and the local build together in one step. Behind the scenes, things are still being built separately, but from the user’s perspective, everything happens at once.\n\t\t\tSuper builds are great for getting up and running with a project quickly. They essentially automate all the configuration and dependency management for you. One other useful quality about them is they’re opt-in. If you want to build the dependencies yourself and install them in a custom location, letting the application explicitly know where to find them, that’s still possible, and the super build won’t get in the way.\n\t\t\tSuper builds provide the best of both worlds. They are a singular way to simply build a project, and they can also be easily disabled, allowing you to configure your dependencies as you see fit.\n\t\t\tIntegrating super build support\n\t\t\tWe’re going to walk through the changes necessary to add super build support by reviewing `ch8/part-2`. All changes are confined to the `app` subfolder.\n\t\t\tTo begin with, to have our app feel a bit more like a real CMake project (where our CMake project is the root folder), we’re going to move the `third-party` folder inside `app`. The structure now looks like this:\n\n```", "```cpp\n\n\t\t\tThis is compared to how it was before:\n\n```", "```cpp\n\n\t\t\tThis is more representative of a real CMake project and will make enabling and disabling super builds a bit easier.\n\t\t\tWe’ll start by looking at the changes in `ch8/part-2/app/CMakeLists.txt`. The first and only changes are right at the top of the file:\n\n```", "```cpp\n\n\t\t\tThe first change is simply the addition of a new CMake option to enable or disable super builds. It’s defaulted to `OFF` for now, but it’s easy to change, and we, of course, have some new CMake presets we’ll cover later in this section, which provide a few different permutations people might want to use.\n\t\t\tNext comes the new functionality that only runs if super builds are enabled. It’s worth emphasizing that everything in our application’s `CMakeLists.txt` file stays exactly the same as before. We can easily revert to the earlier way of building if we wish to by simply setting `SUPERBUILD` to `OFF`. Even using both at the same time is easy and convenient (we’ll get into how to do this a bit later).\n\t\t\tInside the super build condition, we call `add_subdirectory` on the `third-party` folder (this was one of the reasons we moved it inside the `app` folder to make composing our `CMakeLists.txt` scripts a little easier). In this instance, we could have used `include` instead of `add_subdirectory`. However, the advantage of `add_subdirectory`, in this case, is that when CMake is processing the file, it will process it where it currently lives in the folder structure. This means that `${CMAKE_CURRENT_SOURCE_DIR}` will refer to `path/to/ch8/part-2/app/third-party`, not `path/to/ch8/part-2/app`.\n\t\t\tIf we’d instead used `include` and referred to the `CMakeLists.txt` file explicitly (`include(third-party/CMakeLists.txt)`), this would have the effect of copying the contents of the file directly to where the `include` call is (we’re effectively substituting the `include` call with the contents of the file). The issue with this is that `${CMAKE_CURRENT_SOURCE_DIR}`, which is used inside `ch8/part-2/app/third-party/CMakeLists.txt`, will refer to `ch8/part-2/app` instead of `ch8/part-2/app/third-party`. This means that the behavior of our third-party `ExternalProject_Add` commands will differ when called as part of a super build instead of when being invoked directly from the `third-party` folder. In this instance, the relative paths we’re using to refer to our internal library files will not resolve correctly and the location of the third-party install folder will be in `app` instead of `app/third-party`. We want to avoid this, so `add_subdirectory` is a better choice in this instance.\n\t\t\tLet’s now follow the execution flow CMake will take and look at the changes made to our third-party `CMakeLists.txt` file found in `ch8/part-2/app/third-party`. The convenient thing is that we’ve kept the ability to build the third-party dependencies separately if we want to. Things will work just as they did before when we’re not using a super build.\n\t\t\tThe first change is to configure where the third-party build artifacts should go depending on whether we’re using a super build or not. If we’re using a super build, we want to use a separate build folder to store all the third-party dependency files. The reason for this is to keep the same separation we had before when building our third-party dependencies separately. If we don’t do this, our third-party build artifacts will be added to the same build folder as our main application. This means that if we want to remove our application build folder and rebuild, we need to build all our third-party dependencies again.\n\t\t\tOne way to achieve this is with the following check:\n\n```", "```cpp\n\n\t\t\tWhen using a super build, the build files will be added to `third-party/build` (`CMAKE_CURRENT_SOURCE_DIR` will refer to the folder that the current `CMakeLists.txt` file is being processed in). The one downside to this approach is that we’ve hard-coded where the third-party build folder is, and it cannot be modified by users (they could still build the third-party libraries separately and specify `CMAKE_CURRENT_BINARY_DIR` using `-B`, but not as part of a super build).\n\t\t\tTo make things more flexible, we can provide a CMake cache variable with a reasonable default that users can override:\n\n```", "```cpp\n\n\t\t\tHere, we introduce `THIRD_PARTY_BINARY_DIR`, which we default to `app/build-third-party` (we could have stuck with `third-party/build`, but this way, our app and third-party build folders will stay closer together to make clean-up easier). We also ensure to handle if a user provides a relative path by using `if(NOT IS_ABSOLUTE ${THIRD_PARTY_BINARY_DIR})`. In this case we append the path provided to `CMAKE_SOURCE_DIR` (which, in our case, will be the `app` folder). This check also treats paths beginning with `~/` on macOS and Linux as absolute paths. It’s a little more code, but the increased flexibility can be incredibly useful for our users.\n\t\t\tThe extra check of `AND NOT PROJECT_IS_TOP_LEVEL` is to guard against someone accidentally setting `SUPERBUILD` to `ON` when building the third-party dependencies separately as their own project. `SUPERBUILD` will have no effect if this is the case. `PROJECT_IS_TOP_LEVEL` can be used to check whether the preceding call to `project` was from the top-level `CMakeList.txt` file or not (for more information, please see [https://cmake.org/cmake/help/latest/variable/PROJECT_IS_TOP_LEVEL.html](https://cmake.org/cmake/help/latest/variable/PROJECT_IS_TOP_LEVEL.html)). \n\t\t\tBy introducing the `PREFIX_DIR` variable, we can later pass this to `PREFIX` in the `ExternalProject_Add` command, along with the dependency name, to ensure that the build files wind up in `app/build-third-party/<dep>` instead of `app/build`. When building normally, `CMAKE_CURRENT_BINARY_DIR` will resolve to whatever the user sets as their build folder as part of the third-party CMake configure command.\n\t\t\tWe use `PREFIX_DIR` in the `ExternalProject_Add` command like so:\n\n```", "```cpp\n\n\t\t\tThe `PREFIX` argument to `ExternalProject_Add` sets the root directory for the dependency. We use the new `PREFIX_DIR` variable, along with the external project name. This ensures that all dependencies we’re building are isolated from one another, avoiding any risk of file naming collisions when downloading and building them. It also makes it easier to rebuild a specific dependency by deleting one of the subfolders and then running the CMake configure and build commands again. Lastly, we will also update `BINARY_DIR` to refer to `PREFIX_DIR` instead of `CMAKE_CURRENT_BINARY_DIR` to handle whether we’re building things as a super build or not.\n\t\t\tEach dependency has the same changes applied; there’s only one more change at the end of the file, also wrapped inside a super build check. The change is yet another call to `ExternalProject_Add`, only this time with a bit of a twist: we’re calling it with the source directory of our top-level CMake project:\n\n```", "```cpp\n\n\t\t\tWe start by naming the external project the same as the CMake project currently being processed, with `_superbuild` appended to differentiate them (`CMAKE_PROJECT_NAME` refers to the top-level CMake project). We then ensure that the project depends on all our third-party dependencies using the `DEPENDS` argument so it will only be built when they all are ready. `SOURCE_DIR` is where we set `ExternalProject_Add` to look for our root `CMakeLists.txt` file (`CMAKE_SOURCE_DIR` refers to the top level of the current CMake source tree, which is usually synonymous with the folder containing our root `CMakeLists.txt` file). We also let it know where to find the third-party dependencies with `CMAKE_PREFIX_PATH`.\n\t\t\tWe next pass through the `SUPERBUILD` option, only this time, we’re explicitly setting it to `OFF`. The key insight to this approach is realizing that we’re calling our root `CMakeLists.txt` script recursively. The second time through, as `SUPERBUILD` is `OFF`, we’ll process the file as normal after waiting for all our dependencies to become available (this is what `DEPENDS` guarantees). Finally, we need to disable the `INSTALL_COMMAND` option, as our application doesn’t currently provide an install target (we haven’t added any install functionality), so we just set it to an empty string.\n\t\t\tLooping back to the top-level `CMakeLists.txt` file in `ch8/part-2/app`, after the call to `add_subdirectory`, we simply `return` and finish processing (remember, we will have processed this file in its entirety in the `ExternalProject_Add` command with `SUPERBUILD` set to `OFF`).\n\t\t\tThose are all the changes we need to support super builds. To make enabling them a bit easier, we’ve also added a new CMake configure preset called `multi-ninja-super`. It uses a new hidden configure preset called `super`, as shown here, with `SUPERBUILD` set to `ON`:\n\n```", "```cpp\n\n\t\t\tThe new preset we added then inherits `super` as well as `multi-ninja`:\n\n```", "```cpp\n\n\t\t\tTo take advantage of this, from `ch8/part-2/app`, run the following commands:\n\n```", "```cpp\n\n\t\t\tTaking it one step further, we can also add a build preset that uses the new configure preset, and finally a workflow preset that uses them both together:\n\n```", "```cpp\n\n\t\t\tThis allows us to configure and build everything in one command:\n\n```", "```cpp\n\n\t\t\tNinja and super builds on Windows\n\t\t\tIt is possible, if you are using super builds on Windows, that after the first build, you may hit the `ninja: error: failed recompaction: Permission denied` error. This appears to be a Windows-specific issue with Ninja related to file paths. Running the same CMake command again will resolve the error. However, if the issue persists, it may be worth experimenting with other generators on Windows such as Visual Studio.\n\t\t\tOne last reminder is that, by default, this will build in a debug configuration (`Debug`), which we might not want, so adding `\"configuration\": \"Release\"` to our build preset is likely a good idea (see `ch8/part-2/app/CMakePreset.json` for a full example).\n\t\t\tWe can then run our app as usual from the project root directory (`ch8/part-2/app`) with the following command (not forgetting to first build the shaders):\n\n```", "```cpp\n\n\t\t\tEarlier in the section, we briefly touched on the fact that super builds and regular builds can coexist seamlessly. For example, we can configure our existing `multi-ninja` preset after configuring and building the super build, as we know all third-party dependencies are now downloaded and installed (`multi-ninja` still has `CMAKE_PREFIX_PATH` set to `app/third-party/install`). This can be quite useful as configuring `multi-ninja-super` again and then building the application will trigger a check of all dependencies. This is usually quite fast, but if the dependencies are stable and aren’t changing often, creating a separate non-super build folder for active development will avoid this. You essentially have two build folders underneath `build`:\n\n```", "```cpp\n\n\t\t\tWe get these two build folders thanks to our use of CMake presets and the `binaryDir` property, which lets us use the current preset name (`${sourceDir}/build/${presetName}`). [*Chapter 5*](B21152_05.xhtml#_idTextAnchor141), *Streamlining CMake Configuration*, contains more information about this topic for reference.\n\t\t\tOne final gotcha to mention is that when using a multi-config generator, changing the config passed to the build command will only trigger the application to rebuild in the new configuration, not all the dependencies. To ensure that all dependencies are rebuilt, it is necessary to configure before running the build command (`cmake --``build <build-folder>`).\n\t\t\tFor example, this might look as follows:\n\n```", "```cpp\n\n\t\t\tUsing a single config generator behaves the same. It’s just something to be aware of, as normally, changing the `--config` option passed to the CMake build command with multi-config generators will rebuild everything in the new configuration (this is, unfortunately, one downside of using the super build pattern, but it’s a fairly minor one given the benefits it brings).\n\t\t\tThe last thing to be aware of with super builds is clean-up. Before, we only needed to delete the build folder to remove all build artifacts, but now, because we’ve split things, there are two folders (three, if you count the install folder) to delete. For completeness, to get back to a clean state, remember to delete the following folders (default locations listed here):\n\n```", "```cpp\n\n\t\t\tWith super builds, we can now run a single CMake command and have our project downloaded and built in one step. This is a substantial improvement on what we had before, but there’s one last issue to address: automating the shader compilation step. We’ll look at how to achieve this in the next section.\n\t\t\tAutomating scripts with CMake\n\t\t\tWe’ve removed a lot of manual steps that we were dealing with at the start of the chapter, but one remains. This is the requirement to build the shaders needed by bgfx to transform and color our geometry. Up until now, we’ve been relying on running custom `.bat`/`.sh` scripts from the `app` folder before running our *Game of Life* application, but there’s a better possibility. In this section, we’ll show how to make this process part of the build itself, and use CMake to achieve a cross-platform solution without the need for OS-specific scripts.\n\t\t\tTo start with, we’re going to do away with our existing `.bat`/`.sh` scripts and replace them with `.cmake` files. We’ll pick macOS as the first platform to update; the file will be called `compile-shader-macos.cmake`, and will live under a new `cmake` folder in the `app` directory (equivalent files for Windows and Linux will differ in the exact same way as the existing scripts).\n\t\t\tWe’re eventually going to invoke these scripts from our top-level `CMakeLists.txt` file. However, before we do, it’s useful to introduce a CMake operation we haven’t covered so far, and that is the ability to run a CMake script from the command line using `cmake –P` (see [https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-script](https://cmake.org/cmake/help/latest/manual/cmake.1.html#run-a-script) for more details). As a quick example, we can create a file called `hello-world.cmake` and add a simple `message` command to output `Hello, world!`:\n\n```", "```cpp\n\n\t\t\tIf we invoke it from the command line by running `cmake -P hello-world.cmake`, we’ll see the following output:\n\n```", "```cpp\n\n\t\t\t(If we include `hello-world.cmake` in a `CMakeLists.txt` file, it will run at configure time and `Hello, World!` will be printed then).\n\t\t\tThe CMake functionality to invoke a script also supports first providing CMake variables from the command line using the familiar `-D` argument introduced in [*Chapter 2*](B21152_02.xhtml#_idTextAnchor032), *Hello, CMake!* (importantly appearing before `-P`):\n\n```", "```cpp\n\n\t\t\tWe’ll use this in our shader script example a little later to help control the output when invoking the command.\n\t\t\tCMake provides a wealth of useful modules and functions to support file and path manipulation. We’re going to take advantage of them as we craft a CMake script to build our shaders. It’s important to ensure that we have a consistent working directory when invoking `compile-shader-<platform>.cmake`. There are some subtle differences when running from a top-level CMake project and invoking the script using `-P` directly. For example, if we decided to use `CMAKE_SOURCE_DIR` when specifying our paths, this would work correctly when running from the top-level `CMakeLists.txt` file, and when invoking `compile-shader-<platform>.cmake` from the app folder (e.g., `cmake -P cmake/compile-shader-macos.cmake`), but would fail if a user tried to run it from the nested `cmake` folder itself. This is because `CMAKE_SOURCE_DIR` will default to the folder holding the top-level `CMakeLists.txt` file when part of a CMake configure step, and to the folder CMake was invoked from when running `cmake -P path/to/cmake-script.cmake` (this is the same problem we had with the `.``sh`/`.bat` scripts).\n\t\t\tTo account for these differences, we’re going to use a CMake path-related function to ensure that our script’s working directory is always set to the `app` folder. The function we’re going to use is called `cmake_path`. Added in CMake `3.20`, `cmake_path` provides utilities to manipulate paths, decoupled from the filesystem itself (to learn more about `cmake_path`, see [https://cmake.org/cmake/help/latest/command/cmake_path.html](https://cmake.org/cmake/help/latest/command/cmake_path.html)). In our case, we’d like to find the directory containing our `compile-shader-<platform>.cmake` file. This can be performed with the following command:\n\n```", "```cpp\n\n\t\t\tIn the preceding command, we can see the following arguments:\n\n\t\t\t\t*   The first argument, `GET`, describes the type of operation we’d like to perform.\n\t\t\t\t*   The next argument, `CMAKE_SCRIPT_MODE_FILE` ([https://cmake.org/cmake/help/latest/variable/CMAKE_SCRIPT_MODE_FILE.html](https://cmake.org/cmake/help/latest/variable/CMAKE_SCRIPT_MODE_FILE.html)), holds the full path to the current script being processed. It’s important to note that this variable is only set when using `cmake -P` to execute the script. It will not be populated when using `include`. A check for this variable can be included at the top of the script and a warning issued if a user incorrectly tries to include it (see `ch8/part-3/app/cmake/compile-shader-<platform>.cmake` for an example).\n\t\t\t\t*   The following argument, `PARENT_PATH`, is the component to retrieve from the preceding path. In this case, we are requesting the parent path of the current script file (essentially, the directory it is in). To see what other components are available, please see [https://cmake.org/cmake/help/latest/command/cmake_path.html#decomposition](https://cmake.org/cmake/help/latest/command/cmake_path.html#decomposition).\n\t\t\t\t*   The final argument, `COMPILE_SHADER_DIR`, is the variable to populate the result with.\n\n\t\t\tNow we have this directory, we just need to go one level up to reach the `app` folder. We can achieve this using the same command, only substituting the first argument with the variable we populated in the preceding command.\n\n```", "```cpp\n\n\t\t\tWe now have a consistent and portable way to automatically retrieve the `app` folder. We can use the `COMPILE_SHADER_WORKING_DIR` variable in the following CMake script commands.\n\t\t\tCMake provides another useful utility called `file` that can be used for a wide array of file and path manipulations (as opposed to `cmake_path`, this command does interact with the filesystem). In our simple case, we just need to create a new folder (the `build` folder in the `app/shader` directory), which can be achieved with the following `file` command:\n\n```", "```cpp\n\n\t\t\tThe first argument is the operation to perform, and the second is where to do it. This ensures that we now have an output directory to hold our compiled shader files. To learn more about the `file` command, see [https://cmake.org/cmake/help/latest/command/file.html](https://cmake.org/cmake/help/latest/command/file.html).\n\t\t\tWe’re next going to make use of a CMake command called `execute_process`, which allows us to run child processes from within a CMake script. In this case, we’re going to replicate the contents of our `compile_shader_macos.sh` file inside the `execute_process` command. The following is an example of what this looks like:\n\n```", "```cpp\n\n\t\t\tWe first call `execute_process`, and then pass the `COMMAND` argument. What follows are the same instructions we would pass at the command line, which were previously invoked from our `.sh` script. We then pass one more argument, `WORKING_DIRECTORY`, to specify where the listed commands should be run relative to (this is populated by the variable we created earlier referring to the `app` directory, regardless of whether the script is being run using `cmake -P` or whether it is being invoked from a `CMakeLists.txt` file). We can now build our shaders using `cmake -P path/to/app/cmake/compile-shader-macos.cmake` from any folder of our choosing (to understand what else `execute_process` can do, see [https://cmake.org/cmake/help/latest/command/execute_process.html](https://cmake.org/cmake/help/latest/command/execute_process.html)).\n\t\t\tBefore we look at invoking our new scripts from `CMakeLists.txt` as part of the main build, there’s a small improvement we can make to our new `compile-shader-macos.cmake` file. Up until now, we’ve been passing the `--verbose` flag to the *bgfx* `shaderc` program to show the full output of compiling our shaders. This can sometimes be useful, but it’s unlikely that we want to see this as part of the main build every time we either configure or build using CMake. Even with the `--verbose` argument removed, the output is still generated when invoking `shaderc`, which, in the default case, we might want to hide.\n\t\t\tTo work around this, let’s introduce a new CMake variable called `USE_VERBOSE_SHADER_OUTPUT` to our `compile-shader-<platform>.cmake` scripts. This will default to `OFF` and will control two internal CMake variables. The first is `VERBOSE_SHADER_OUTPUT`, which will substitute the direct reference to `--verbose`:\n\n```", "```cpp\n\n\t\t\tWhen we invoke `cmake -P cmake/compile-shader-<platform>.cmake`, we now won’t, by default, see the full output from `shaderc`, but we can easily enable it again by setting `VERBOSE_SHADER_OUTPUT` to `ON`:\n\n```", "```cpp\nif(USE_VERBOSE_SHADER_OUTPUT)\n  set(VERBOSE_SHADER_OUTPUT --verbose)\nelse()\n  set(QUIET_SHADER_OUTPUT ERROR_QUIET OUTPUT_QUIET)\nendif()\nexecute_process(\n  COMMAND\n  ...\n  ${VERBOSE_SHADER_OUTPUT}\n  ${QUIET_SHADER_OUTPUT}\n  WORKING_DIRECTORY ${COMPILE_SHADER_WORKING_DIR})\n```", "```cpp\nif(WIN32)\n  set(COMPILE_SHADER_SCRIPT\n      ${CMAKE_SOURCE_DIR}/cmake/compile-shader-windows.cmake)\nelseif(LINUX)\n  set(COMPILE_SHADER_SCRIPT\n      ${CMAKE_SOURCE_DIR}/cmake/compile-shader-linux.cmake)\nelseif(APPLE)\n  set(COMPILE_SHADER_SCRIPT\n      ${CMAKE_SOURCE_DIR}/cmake/compile-shader-macos.cmake)\nendif()\n```", "```cpp\ninclude(${COMPILE_SHADER_SCRIPT})\n```", "```cpp\nif(CMAKE_SCRIPT_MODE_FILE AND NOT CMAKE_PARENT_LIST_FILE)\n  # existing approach\nelse()\n  set(COMPILE_SHADER_WORKING_DIR ${CMAKE_SOURCE_DIR})\nendif()\n```", "```cpp\nadd_custom_command(\n  TARGET ${PROJECT_NAME}\n  POST_BUILD\n  COMMAND ${CMAKE_COMMAND} -P ${COMPILE_SHADER_SCRIPT}\n  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n  VERBATIM)\n```", "```cpp\ncmake --workflow --preset multi-ninja-super\n```", "```cpp\n./build/multi-ninja-super/Release/minimal-cmake_game-of-life_window\n```", "```cpp\nif(NOT CMAKE_SCRIPT_MODE_FILE)\n  message(\n    WARNING\n      \"This script cannot be included, it must be executed using `cmake -P`\")\n  return()\nendif()\n```", "```cpp\noption(\n  MC_GOL_SHARED\n  \"Enable shared library for Game of Life\" OFF)\noption(\n  MC_DRAW_SHARED \"Enable shared library for Draw\" OFF)\n```", "```cpp\nExternalProject_Add(\n  mc-draw\n  ...\n  CMAKE_ARGS ... -DMC_DRAW_SHARED=${MC_DRAW_SHARED}\n  ...)\n```", "```cpp\noption(\n  USE_VERBOSE_SHADER_OUTPUT \n  \"Show output from shader compilation\" OFF)\n...\nadd_custom_command(\n  TARGET ${PROJECT_NAME}\n  POST_BUILD\n  COMMAND\n    ${CMAKE_COMMAND} -D USE_VERBOSE_SHADER_OUTPUT=${USE_VERBOSE_SHADER_OUTPUT}\n    -P ${COMPILE_SHADER_SCRIPT}\n  WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}\n  VERBATIM)\n```", "```cpp\n\"CMAKE_INSTALL_PREFIX\": \"${sourceDir}/install\"\n```", "```cpp\ninstall(\n  TARGETS ${PROJECT_NAME}\n  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n```", "```cpp\ninstall(\n  FILES\n    $<TARGET_FILE:SDL2::SDL2>\n    ...\n```", "```cpp\n$<$<STREQUAL:$<TARGET_PROPERTY:minimal-cmake::line,TYPE is equal to SHARED_LIBRARY, then substitute the path to the shared library, otherwise, do nothing (the expression will evaluate to an empty string).\n\t\t\tSticking with the dynamic libraries, there’s another minor change we need to make. If you recall [*Chapter 4*](B21152_04.xhtml#_idTextAnchor086), *Creating Libraries for FetchContent*, we discussed the topic of making libraries relocatable on macOS and Linux by changing the `RPATH` variable of the executable. We achieved this by using `set_target_properties` to update the `BUILD_RPATH` property of the executable. To ensure things work correctly for both build and install targets, we need to update this command slightly. The changes are shown here:\n\n```", "```cpp\n$<TARGET_FILE:SDL2::SDL2>\n$<$<PLATFORM_ID:Linux>:$<TARGET_SONAME_FILE:SDL2::SDL2>>\n```", "```cpp\ninstall(DIRECTORY ${CMAKE_SOURCE_DIR}/shader/build\n        DESTINATION ${CMAKE_INSTALL_BINDIR}/shader)\n```", "```cpp\ncmake --build build/multi-ninja-super\n```", "```cpp\ncmake --install build/multi-ninja-super\n```", "```cpp\n\n```", "```cpp\n\n```"]