["```cpp\nShaders not found. Have you built them using compile-shader-<platform>.sh/bat script?\n```", "```cpp\n├── minimal-cmake_game-of-life_window\n└── shader\n      ├── fs_vertcol.bin\n      └── vs_vertcol.bin\n```", "```cpp\nadd_custom_command(\n  TARGET ${PROJECT_NAME}\n  POST_BUILD\n  ...\n  COMMAND\n    ${CMAKE_COMMAND} -E copy_directory\n      ${CMAKE_SOURCE_DIR}/shader/build\n    $<TARGET_FILE_DIR:${PROJECT_NAME}>/shader\n  VERBATIM)\n```", "```cpp\ninstall(\n  DIRECTORY ${CMAKE_SOURCE_DIR}/shader/build/\n  DESTINATION ${CMAKE_INSTALL_BINDIR}/shader\n  FILES_MATCHING\n  bin files, we will use the install DIRECTORY option, FILES_MATCHING, with the PATTERN match kind (this uses a glob matching pattern; for more complex cases, it’s possible to use REGEX and provide a regular expression instead). Note that we also added a trailing forward slash at the end of build on the first line to ensure that we only copy the folder’s contents, not the folder itself.\n\t\t\tThese are the only changes we need to make to our `CMakeLists.txt` file; let’s now turn our attention to `main.cpp`. The change we need to make to this is small and self-contained, as shown in the following snippet:\n\n```", "```cpp\n\n\t\t\tWe first call `SDL_GetBasePath()` to get the path to where our executable is running, and then we use the `std::string` C++ type for convenience to build a path to the file we want to load (there is undoubtedly a faster and more efficient method, using C++17’s filesystem library and/or `std::string_view`, but this is intended as a quick, simple example). Once we have the full path to our file, we can pass it to our existing `read_file` function, and when we’ve finished using it, we need to clean up `base_path` using `SDL_free`, as we’re responsible for managing its lifetime.\n\t\t\tWith these changes applied, it’s now possible to launch our application from Finder on macOS, GNOME on Linux (the default Ubuntu desktop), and through File Explorer on Windows. With the relative loading of assets out of the way, we now have everything we need to start adding CPack support to our application.\n\t\t\tIntegrating CPack\n\t\t\tIntegrating CPack is deceptively simple; the majority of the work comes from the `install` commands we’ve already covered. The process involves setting several CPack-related variables (beginning with the `CPACK_` prefix) to project-specific values, and then adding `include(CPack)` at the very end of our `CMakeLists.txt` file. In fact, with the current state of our `CMakeLists.txt` file from `ch10/part-1/app`, it’s possible to just add `include(CPack)` at the end, and then running `cpack` will do something useful.\n\t\t\tOne quick reminder is that CPack will default to installing a `Release` build, so ensure that you’ve built the `Release` configuration of the application; otherwise, invoking `cpack` will produce an error resembling the following:\n\n```", "```cpp\n\n\t\t\tTo invoke `cpack` directly, you need to tell it where to find a newly generated file called `CPackConfig.cmake`. This file gets created after running a CMake configure step when the `include(CPack)` command is added to our `CMakeLists.txt` file. `CPackConfig.cmake` will appear at the root of the build folder; it’s also usually sensible to provide a directory for the packaged files to be added to (similarly to how we provide a build folder for CMake to store our build files).\n\t\t\tThe following is an example of invoking CPack after we’ve configured and built our project (e.g., by running `cmake --workflow --``preset multi-ninja-super`):\n\n```", "```cpp\nset(CPACK_PACKAGE_NAME \"minimal-cmake_game-of-life\")\n```", "```cpp\nset(\n  CPACK_PACKAGE_EXECUTABLES\n  PROJECT_NAME) and the second is a friendly name for the application once the package has been installed by a user (this makes sure things such as the Start Menu icon on Windows has this name).\n\t\t\tThat’s it for the common variables; we could specify other properties about the project, such as the version, description, and vendor, but we’ll skip those for now. Next, we’re going to look at our Windows NSIS installer and what other variables are needed.\n\t\t\tThe CPack Windows NSIS package\n\t\t\tTo create something that resembles a traditional Windows installer for our application, we’re going to use the NSIS package. If you don’t already have this installed, you can download it from [https://nsis.sourceforge.io/Download](https://nsis.sourceforge.io/Download) (the examples in this book were tested with NSIS `3.10`). Once this is installed, specifying the NSIS generator in CPack should work (if you don’t have it installed, you’ll get an error that CPack can’t find NSIS).\n\t\t\tThe NSIS installer should more or less work out of the box with our current setup; all we need to do is run the following command (the exact build folder shown here, `build/multi-ninja`, may differ in your case):\n\n```", "```cpp\nset(CPACK_NSIS_PACKAGE_NAME \"Minimal CMake - Game of Life\")\nset(CPACK_NSIS_MANIFEST_DPI_AWARE true)\n```", "```cpp\nset(\n  CPACK_NSIS_MUI_ICON\n  \"${CMAKE_SOURCE_DIR}/packaging/windows/mc_icon.ico\")\n```", "```cpp\nIDI_ICON1 ICON \"mc_icon.ico\"\n```", "```cpp\ntarget_sources(\n  ${PROJECT_NAME} PRIVATE packaging/windows/icon.rc)\n```", "```cpp\nset_target_properties(\n  ${PROJECT_NAME} PROPERTIES WIN32_EXECUTABLE\n  if(WIN32) block to ensure that we only set these values on Windows (see ch10/part-2/app/CMakeLists.txt for the complete example). Here’s another quick reminder that using Visual Studio Code’s part-<n>/ folders for each chapter).\n\t\t\tThe last (and optional) change we can make to our `CMakeLists.txt` file is to add a desktop shortcut for our application. This can be achieved by using `CPACK_NSIS_EXTRA_INSTALL_COMMANDS` and `CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS`. The following snippet shows how this is done:\n\n```", "```cpp\n\n\t\t\tWe use the `CreateShortCut` command to create a shortcut on the user’s desktop, named `Minimal CMake - Game of Life.lnk`, and link it to the name of the executable in its install location.\n\t\t\tThe abundance of backslashes unfortunately isn’t a typo; they are needed to escape the backslash character at multiple stages. To represent a literal backslash in CMake, it must be escaped by using a backslash character (`\\`), and NSIS also expects the path it uses to be separated by backslashes, and they too need to be escaped. The processing of the path reduces the backslashes from 4 to 2, and finally to 1 (by the time NSIS sees the path). This is a bit ugly and confusing, but unfortunately, there isn’t much we can do about it.\n\t\t\tWith that final change, we’re done crafting our Windows installer. There’s more we can add, but this should give you a solid base to work from when building your own installers in the future.\n\t\t\t![Figure 10.1: The Windows NSIS installer](img/B21152_10_1.jpg)\n\n\t\t\tFigure 10.1: The Windows NSIS installer\n\t\t\tTo package our application on Windows using the NSIS installer, use the following command from `ch10/part-2/app` (remembering to have first configured and built a `Release` configuration of the application):\n\n```", "```cpp\n\n\t\t\tThis will create an executable installer, and running it will install *Minimal CMake – Game of Life* in your `Program Files` directory, like any other application you might install (a quick note that administrator privileges are required to install to `Program Files`). An uninstaller is also generated, which makes it easy to remove the application and associated shortcuts in the future.\n\t\t\tThe CPack macOS bundle package\n\t\t\tWe are now going to look at the commands needed to package an application bundle on macOS. In this section, we’re going to show how to use the `Bundle` generator. There is another approach we’ll touch on later in the chapter that shows how to build a macOS bundle directly (this works a little differently from how we’ve configured things so far and differs significantly from other platforms, so using it will depend on your exact situation and preference).\n\t\t\tThe good news is that the `CMakeLists.txt` changes are confined to a single block, as shown here:\n\n```", "```cpp\n\n\t\t\tWe’ll walk through each line to understand what it’s doing and why it’s needed:\n\n\t\t\t\t*   The first line (`CPACK_BUNDLE_NAME`) simply sets the name of the application bundle. This is the name that will appear inside the bundle when it’s opened and dragged to the application folder.\n\t\t\t\t*   The second line (`CPACK_BUNDLE_PLIST`) refers to an information property list (`info.plist` for short) that is used to store metadata about the application. This is the mechanism used by macOS and iOS to store configuration information for applications (to learn more about information property lists, go to [https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html)). There’s a lot of properties that can be added to this file, but for our purposes, we only need one for the time being, and that’s the `CFBundleIconFile` property. This will refer to the icon file in the bundle, which will share the name of the bundle (this is different from the name of the icon file (`gol.icns`) before packaging; the `.icns` file is renamed to match the value of `CPACK_BUNDLE_NAME` inside the bundle). The `info.plist` file will be added to the `Contents` folder of the bundle.\n\t\t\t\t*   The third variable (`CPACK_BUNDLE_ICON`) refers to the icon file to use for the bundle. The file we’re using here is `gol.icns`, which was generated by running the `generate-icons.sh` script in the packaging folder. It internally uses `sips` ([https://ss64.com/mac/sips.html](https://ss64.com/mac/sips.html)) on macOS to generate icons of increasing size (all power of 2 dimensions) from a source image (for things to work, ensure that the source image you use is 1,024 x 1,024 pixels in size), and then it uses `iconutil` ([https://www.unix.com/man-page/osx/1/iconutil/](https://www.unix.com/man-page/osx/1/iconutil/)) to create the `.icns` file for CPack (and our `info.plist` file) to refer to. With these changes, we’ll get an icon for our bundle and application after it’s installed.\n\t\t\t\t*   The last variable (`CPACK_BUNDLE_STARTUP_COMMAND`) holds a path to a small helper startup script to ensure that we can launch our application from the bundle. This file will be copied to `Contents/MacOS` inside the bundle.\n\n\t\t\tThe content of the file it refers to (`bundle-run.sh`) is as follows:\n\n```", "```cpp\n\n\t\t\tThe first line changes the directory to the location of the script that’s currently running (so we’ll end up in the bundle’s `Contents/MacOS` folder), and the second line launches our executable (all resources will then load relative to it). It’s a little unconventional but works well when dealing with a cross-platform `CMakeLists.txt` file.\n\t\t\tTo package our application on macOS using the bundle generator, navigate to `ch10/part2/app`, and then run the following command (again, remember to build the application in the `Release` configuration first):\n\n```", "```cpp\ninstall(\n  FILES ${CMAKE_SOURCE_DIR}/packaging/linux/mc-gol.desktop\n  DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/applications)\ninstall(\n  FILES packaging/linux/mc-gol-logo.png\n  DESTINATION ${CMAKE_INSTALL_DATAROOTDIR}/icons)\nendif()\n```", "```cpp\n[Desktop Entry]\nName=Minimal CMake - Game of Life\nComment=Interactive Game of Life simulation\nExec=minimal-cmake_game-of-life_window\nIcon=mc-gol-logo\nTerminal=false\nType=Application\nCategories=Development\n```", "```cpp\nset(CPACK_DEBIAN_PACKAGE_MAINTAINER \"<maintainer-email>\")\n```", "```cpp\ncpack --config build/multi-ninja/CPackConfig.cmake -G .deb file in the package folder. To install the package to the system, use the following command:\n\n```", "```cpp\n\n\t\t\tThis will install the package and make it available in your path; it can be launched by typing `minimal-cmake_game-of-life_window` from the terminal (try changing the directory to your `$HOME`*/*`~` folder and launching it), or by navigating to `Minimal CMake – Game` `of Life`.\n\t\t\t![Figure 10.3: The installed icon on Linux (Ubuntu)](img/B21152_10_3.jpg)\n\n\t\t\tFigure 10.3: The installed icon on Linux (Ubuntu)\n\t\t\tThe last important detail to cover is if we wish to uninstall an application from our system, we can do this by running the inverse of the `dpkg -i` command, which takes the following form:\n\n```", "```cpp\n\n\t\t\tThis will remove the executable, libraries, icons, and `.desktop` file from the system and restore it to the state it was before the package was installed.\n\t\t\tThat covers creating three separate package generators on three separate platforms. There are, of course, many more, and the packages we did create can continue to be improved and refined, but this should hopefully give a taste of how to use CPack and some of the details to be aware of.\n\t\t\tIn the next section, we’re going to spend a bit of time on a macOS-specific topic, relating to CMake’s built-in support for application bundles.\n\t\t\tBuilding a macOS bundle\n\t\t\tWhen looking at macOS in *The CPack macOS bundle package* section earlier, we used the CPack generator `Bundle` type to package our application’s build artifacts in a macOS bundle. There is, however, an interesting alternative that is worth briefly mentioning.\n\t\t\tCMake provides an option to directly build an application as a macOS bundle. The setting is called `MACOSX_BUNDLE`, and it can be passed directly to `add_executable` or set separately with `set_target_properties`, as shown here:\n\n```", "```cpp\n$<$<PLATFORM_ID:Darwin>:@loader_path;.dylib files relative to its location, without the files needing to be in the same folder. We also used an add_custom_target command to create the Frameworks folder for us before we tried to copy any files there:\n\n```", "```cpp\n\n\t\t\tWe use `add_dependencies` to ensure that this happens before our main executable is built (`${PROJECT_NAME}` will depend on the `create_frameworks_directory` target, ensuring that `create_frameworks_directory` happens first).\n\t\t\tWe can forgo a lot of our install commands in the case of a macOS bundle because it handles copying all the files to the correct location internally; for the install step, we just need to install `BUNDLE`:\n\n```", "```cpp\nset_source_files_properties(\n  shader/build/vs_vertcol.bin shader/build/fs_vertcol.bin\n  PROPERTIES MACOSX_PACKAGE_LOCATION \"Resources/shader\")\nset_source_files_properties(\n  packaging/macos/gol.icns\n  PROPERTIES MACOSX_PACKAGE_LOCATION target_sources command:\n\n```", "```cpp\nset_target_properties(\n  ${PROJECT_NAME}\n  PROPERTIES OUTPUT_NAME \"Minimal CMake - Game of Life\"\n    MACOSX_BUNDLE_BUNDLE_NAME\n      \"Minimal CMake - Game of Life\"\n    MACOSX_BUNDLE_GUI_IDENTIFIER\n      \"com.minimal-cmake.game-of-life\"\n    MACOSX_BUNDLE_ICON_FILE \"gol.icns\"\n  ...)\n```", "```cpp\ncpack --config build/multi-ninja/CPackConfig.cmake \\\n  -B package -G CPACK_DMG_... variables. As mentioned earlier, when discussing the Bundle generator, these values can be used to further customize the macOS disk image (for example, CPACK_DMG_DS_STORE can be used to refer to a customized .DS_Store file to provide a custom layout; for more information, see https://cmake.org/cmake/help/latest/cpack_gen/dmg.html and ch10/part-4/app as an example). It’s worth highlighting that the previous Bundle generator we used inherits from DragNDrop, which is why the CPACK_DMG_... settings can also be used to customize the .dmg file when using the Bundle generator.\n\t\t\tWhen building macOS applications that are going to be installed and launched through Finder, using the `MACOSX_BUNDLE` approach is incredibly useful and a sensible option to take. However, it does make maintaining a cross-platform application a little more complicated, as things behave quite differently between platforms. Whether you choose to use it or not will depend on your specific use case. Hopefully, showing how both approaches can be used is useful (`ch10/part-3/app` contains a full example for reference). For the remaining part of this chapter, we’ll switch back to the approach shown in `part-2` to help keep things more consistent across Windows, macOS, and Linux.\n\t\t\tAdding CPack presets\n\t\t\tBefore closing out this chapter, it’s worth covering one more useful topic when it comes to CPack, and that’s its support for CMake presets. CMake provides the package presets (`packagePresets`) field in `CMakePresets.json`, and various CPack options can be set there, instead of from the command line or inside our `CMakeLists.txt` file.\n\t\t\tThe upshot of this is that we don’t have to write the following on macOS:\n\n```", "```cpp\n\n\t\t\tWe can instead write this:\n\n```", "```cpp\n\n\t\t\tThis will use the preconfigured options we’ve set for macOS; an example listing is shown here:\n\n```", "```cpp\n\n\t\t\tWe start with a base preset that can be shared across multiple package presets (one for each platform), and then we set the package directory to `${sourceDir}/package` so that we can omit `-B package` from the command line. We must also provide `configurePreset` so that CPack knows which build folder to use (this is because the build folder is specified by the configure preset). We then provide our actual preset; the preceding example is for macOS, but presets are added for each platform in `ch10/part-4/app/CMakePresets.json`. By using the `condition` property, we ensure that this preset only appears when running on macOS, and we also provide the explicit generator to use (in this case, `Bundle`).\n\t\t\tThe other useful thing about package presets is that they can be included in workflow presets, making it possible to configure, build, test, and package all with one command.\n\t\t\tAs CPack requires the `Release` configuration to be compiled (`-DCMAKE_BUILD_TYPE=Release` when configuring with a single-config generator, or `--config Release` when building with a multi-config generator), we skip the testing preset in the packaging workflow, as we explicitly build it in a `Debug` configuration (see the `multi-ninja-super-test` build preset in `ch10/part-4/app/CMakePresets.json`).\n\t\t\tThe following is an example of the workflow preset for Linux:\n\n```", "```cpp\n\n\t\t\tThis can be invoked by using the following command (run from `ch10/part-4/app`):\n\n```", "```cpp\n\n\t\t\tAt the time of writing, workflow presets do not currently support the `condition` property we used for other presets. This means that it’s not possible to hide the workflow presets for other platforms, but they will fail to run, as we’ve specified which package preset is allowed on which platform already. It is possible that workflow presets will be updated in the future to inherit `condition` properties from the steps they use; however, there is no timeframe for when this may happen. This topic is an ongoing area of discussion within the CMake community.\n\t\t\tOther uses for CPack\n\t\t\tIn addition to the main packaging and installer logic we’ve covered so far in this chapter, there are a couple more uses for CPack that are worth mentioning briefly. The first is the ability to use a standard archive format (such as `.zip`, `.7z`, or `.tar.gz`) to create a snapshot of an application at a certain point in time. It might be useful to do this to share a work-in-progress build with someone before sending them a full installer (running the application from the extracted folder will work and will not affect the wider system). It can also be useful to keep an archive of builds for milestones or releases you can then go back to easily in the future (this is commonly done in the *Tags and Releases* section of projects on GitHub. A good example is a tool such as `ripgrep` ([https://github.com/BurntSushi/ripgrep/releases](https://github.com/BurntSushi/ripgrep/releases)). For a full list of archive formats (and other package generators), run `cpack --help`.\n\t\t\tThere is also one more file generated by CPack that we haven’t covered yet, and that’s `CPackSourceConfig.cmake`. By providing this file to the `cpack` `--config` argument, it’s possible to create an archive of the source directory itself, not the built artifacts. We must do a little bit of work to tell CPack which files not to include, which we achieve by setting the `CPACK_SOURCE_IGNORE_FILES` variable before invoking the `include(CPack)` command.\n\t\t\tThe following is an example from `ch10/part-5/app/CMakeLists.txt`:\n\n```", "```cpp\n\n\t\t\tThe `CPACK_SOURCE_IGNORE_FILES` variable uses regular expressions to match against the different file and folder paths to discount.\n\t\t\tWith this change, we can then run the following command to create a snapshot of the source directory if we wish:\n\n```", "```cpp\n\n\t\t\tInstead of providing `CPackConfig.cmake` as we did earlier in the chapter, we pass `CPackSourceConfig.cmake`, as well as a package generator (`-G`) to use and a folder (`-B`) to add the archived file to. We could also configure a CMake preset to handle this by using the `configFile` entry to specify the source config file. The following is one way to do this (we’re using `ZIP` instead of `TGZ` as the package generator in this example):\n\n```", "```cpp\n\n\t\t\tReview `ch10/part-5/app/CMakePresets.json` to see this in context. It’s then possible to use `cpack --preset source` to create a source package.\n\t\t\tSummary\n\t\t\tYou made it! Packaging was the last hurdle on our CMake journey. Making your application shareable with others is a significant achievement, and you now have everything you need to create a cross-platform application that’s easy to build and distribute. This is no small feat, and although there’s of course still plenty more to learn, you’re standing on a solid foundation and have the tools available to build your own applications from scratch.\n\t\t\tIn this chapter, we got to know CPack and how it integrates with our existing CMake scripts. We first learned how to handle loading files relative to our executable, an important detail to make sure that running our application from any location works reliably. We then took a tour of CPack, seeing how to provide packaging support for Windows, macOS, and Linux. This is essential for providing a familiar means for users to install your application, matching what they’ve come to expect from existing conventions on their platform. We then took a small detour to discuss building macOS bundles with CMake and the various improvements and trade-offs in doing so. We then looked at how to simplify CPack usage by taking advantage of CMake presets to configure and automate the packaging step, another key factor in keeping our projects clean and maintainable. We concluded by looking at some other uses of CPack, as well as how to package our project’s source and its build artifacts.\n\t\t\tWe’ve now covered all the main topics to get you up and running with CMake. In the final chapter, we’re going to cover useful tools available in the CMake ecosystem to make day-to-day development faster and easier. We’ll also touch on where to go next and introduce some topics we weren’t able to cover in detail in this book.\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```"]