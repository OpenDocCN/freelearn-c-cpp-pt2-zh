["```cpp\n.\n├── CMakeLists.txt\n├── ...\n└── tests\n    ├── CMakeLists.txt\n    └── tests.cpp\n```", "```cpp\noption(MC_ARRAY_BUILD_TESTING \"Enable testing\" OFF)\n```", "```cpp\ninclude(CTest)\n```", "```cpp\nadd_executable(dynamic-array-test)\ntarget_sources(\n  dynamic-array-test PRIVATE src/array.test.c)\n```", "```cpp\n.\n├── CMakeLists.txt\n└── src\n    ├── array.c\n    └── .test being inserted between the file name and extension. For unit tests, this is a common approach and has the big advantage of making the test code easy to find. It’s well understood that tests provide an incredibly valuable form of documentation, containing lots of examples of how to use a particular type. By keeping both implementation and test code together, it makes maintaining and understanding the code easier. Another benefit of tests as documentation is that tests are more likely to be kept up to date as code changes because not doing so will result in the tests failing or not compiling (that’s as long as you’re building and running them regularly, of course).\n\t\t\tThe previously outlined approach is recommended for unit tests when there’s a one-to-one mapping between the tests and the type but is less applicable for higher-level integration tests. In those cases, maintaining a dedicated testing folder is usually advisable (either at the project root or split across directories grouped by functionality). Whatever you decide, the most important thing is having any tests at all, wherever they may be.\n\t\t\tWe then link our new test application against both `unity` and our `dynamic-array` library and set the target compile features we care about:\n\n```", "```cpp\n\n\t\t\tThe last and most relevant command for this section is `add_test`:\n\n```", "```cpp\n\n\t\t\tThis registers our new `dynamic-array-test` executable with CTest so it can invoke it and report the outcome (this essentially means we can use `ctest` to run it). The first argument, `NAME`, allows us to provide a name for the test; this is what will be displayed in the output when running `ctest`. The next argument, `COMMAND`, is the test to run. In our case, this is an executable target, so we pass the target name of our test executable directly, but as we’ll see later, this can be one of many different commands.\n\t\t\tVery briefly, one command we haven’t included is `enable_testing()`. You may spot this in other examples, but it is technically redundant as `enable_testing()` is called automatically by the `include(CTest)` command (there are some cases where it is required however, for example when splitting tests across different files and using `add_subdirectory`, see [*Chapter 11*](B21152_11.xhtml#_idTextAnchor228)*, Supporting Tools and Next Steps* for an example). To see the complete example, please refer to `ch9/part-1/lib/array/CMakeLists.txt`. It’s encouraged to use the Visual Studio Code `ch8/part-5/lib/array/CMakeLists.txt` to more easily see the differences.\n\t\t\tRunning the tests\n\t\t\tWe now have everything we need to build and run our tests. Navigate to `ch9/part-1/lib/array` and run the following commands:\n\n```", "```cpp\n\n\t\t\tThe first two commands we’ve seen many times before in one form or another; these will configure and build our application and tests (we’ve updated `CMakePresets.json` to include a new `\"test\"` preset with `MC_ARRAY_BUILD_TESTING` set to `ON`).\n\t\t\tWith those out of the way, let’s briefly walk through the `ctest` command. The first argument is `--test-dir`, which we use to specify the build directory containing the tests (this saves having to `cd` into the `build` folder and run `ctest`). The next argument, `-C` (short for `--build-config`), allows us to specify the configuration to test. This is needed because we’re using the `\"Ninja Multi-Config\"` generator; if we’d used a single config generator, the `build` folder would already have a build type defined through `CMAKE_BUILD_TYPE` and the `-C` argument could be omitted.\n\t\t\tRunning the preceding command produces the following output:\n\n```", "```cpp\n\n\t\t\tIt’s worth briefly mentioning if we omitted `include(CTest)` and `add_test(...)` in our `CMakeLists.txt` file, we’d lose the ability to use `ctest`, but we’d still be able to run our compiled test executable, like so:\n\n```", "```cpp\n\n\t\t\tFor simple use cases, this might be sufficient, but the more consistent `ctest` interface makes test commands portable across different platforms. `ctest` begins to really shine when we want to combine running several different kinds of tests into a single command.\n\t\t\tOne other useful argument that can be passed to `ctest` is the `--verbose` option. This will display additional output from the tests (in the following case, the output will match running the test executable directly):\n\n```", "```cpp\nctest --test-dir build -C Debug ctest command has a bewildering number of options, not all of which we can cover here. To learn more about the different arguments and configuration options, please consult https://cmake.org/cmake/help/latest/manual/ctest.1.html for more information.\n\t\t\tWe’ve covered how to add unit tests to some of our existing libraries and have seen how to invoke them using CTest. Next, we’re moving to the other end of the spectrum and will see an example of adding end-to-end tests for our *Game of* *Life* application.\n\t\t\tAdding end-to-end tests to an application\n\t\t\tCreating end-to-end tests for an application can be a challenge, and usually relies on an external tool or scripting language to send commands to the application to drive it. To support this, in our *Game of Life* application, we’re going to add one last library that will not only enhance our application but also make it testable end to end.\n\t\t\tThe library in question is called **Dear ImGui** ([https://github.com/ocornut/imgui](https://github.com/ocornut/imgui)), an open source (MIT licensed) immediate mode **graphical user interface** (**GUI**), originally designed for use in games, but now used across a wide variety of applications.\n\t\t\tImmediate versus retained UI\n\t\t\tThere are two main styles of UI libraries, often referred to as retained mode and immediate mode. A **retained mode** UI tends to require its widgets to be created and managed explicitly. A popular example of this is the Qt (pronounced *cute*) UI library. **Immediate mode** libraries do not require widgets to be created; instead, simply calling a function will display a UI element. There are pros and cons to each approach. Retained mode tends to be favored for UI-heavy applications, while immediate mode is preferred for graphical overlays for games or developer tools (though there are exceptions to both). We’ve opted for Dear ImGui due to its ease of use and simple integration with SDL 2.\n\t\t\tIntegrating a UI library\n\t\t\tBefore we look at how we go about creating end-to-end tests for our application, we’re first going to add Dear ImGui to our project. The initial integration is shown in `ch9/part-2`. Dear ImGui, like `bgfx`, does not natively support CMake, however, because Dear ImGui is a relatively small library, it’s easy to add a CMake wrapper around it.\n\t\t\tThe repository we’ll use is [https://github.com/pr0g/imgui.cmake](https://github.com/pr0g/imgui.cmake), which takes a very similar approach to the `bgfx` CMake repository we saw in [*Chapter 6*](B21152_06.xhtml#_idTextAnchor152), *Installing Dependencies and ExternalProject_Add*. The main Dear ImGui repository is embedded as a Git submodule, and a `CMakeLists.txt` file is added at the root of the repository to aggregate the source files and produce a library using CMake (this makes integrating with `FetchContent` or `ExternalProject_Add` possible).\n\t\t\tWe add Dear ImGui as a new third-party dependency in `ch9/part-2/third-party/CMakeLists.txt` and update our super build project and main `CMakeLists.txt` file accordingly to link against the new dependency.\n\t\t\tOne other important change we’re going to make is to finally switch our application from using C to C++. This is to prepare it for being able to integrate the Dear ImGui Test Engine. Dear ImGui is written in C++, but C bindings do exist for it (see [https://github.com/cimgui/cimgui](https://github.com/cimgui/cimgui) for an example, which also comes with CMake support). They do not yet unfortunately exist for the testing library, so upgrading to C++ is a necessary step. The changes are minimal though, and as we’ve chosen to use C++ 20, we get to take advantage of designated initializers, which we’d been using in C (essentially a convenient way to initialize structs) with only a minor change in syntax.\n\t\t\tThere are a few small additions we need before we can integrate Dear ImGui (see `ch9/part-2/app/imgui`). The first is a render backend (as we’re using `bgfx`, we need it to implement a handful of functions required by Dear ImGui), and the second is a platform backend (in this case, we use the SDL 2 platform backend provided by the Dear ImGui repository available from [https://github.com/ocornut/imgui/tree/master/backends](https://github.com/ocornut/imgui/tree/master/backends)).\n\t\t\tWith these changes added, we can now add our Dear ImGui code. We’re going to add a few simple options to make interacting with our *Game of Life* application a bit easier. The changes include a simulation time control to adjust the amount of time between each update, the ability to pause and resume the simulation, to step the simulation a frame at a time when it’s paused, to clear the board, and to return the board to its original state. The results are shown in *Figure 9**.1*.\n\t\t\t![Figure 9.1: Game of Life with Dear ImGui controls](img/B21152_09_1.jpg)\n\n\t\t\tFigure 9.1: Game of Life with Dear ImGui controls\n\t\t\tAs a quick reminder, to configure and build the example shown previously, navigate to `ch9/part-2/app` and use the following command:\n\n```", "```cpp\n\n\t\t\tThe application can then be launched by running the executable produced (again from the same directory):\n\n```", "```cpp\n\n\t\t\tDear ImGui is incredibly powerful and comes with an enormous amount of functionality; our simple example is only scratching the surface. To see what else you can do with Dear ImGui, try adding a call to `ImGui::ShowDemoWindow()` right after `ImGui::NewFrame()` to see more of what it’s capable of.\n\t\t\tIntegrating end-to-end tests using Dear ImGui\n\t\t\tWith Dear ImGui integrated, we can now look at bringing in the Dear ImGui Test Engine (available from [https://github.com/ocornut/imgui_test_engine](https://github.com/ocornut/imgui_test_engine)). The Dear ImGui Test Engine has a slightly more restrictive license and requires obtaining a paid license in certain cases (see the `LICENSE.txt` file for more details). However, for derivative software released under an open source license (such as this book’s accompanying source code), it is free to use.\n\t\t\tTurning our attention to `ch9/part-3/app`, we’re first going to upgrade our third-party dependency from `imgui.cmake` to `imgui-test-engine.cmake` (see [https://github.com/pr0g/imgui-test-engine.cmake](https://github.com/pr0g/imgui-test-engine.cmake) for reference; it follows the same pattern as the previous `imgui.cmake` library). The `imgui-test-engine.cmake` library publicly depends on `imgui.cmake` (`imgui.cmake` is a transitive dependency), so we can make this small change to our `CMakeLists.txt` files, and things will continue working as they did before.\n\t\t\tThe Dear ImGui Test Engine requires us to make changes to our source code to integrate it, and we only want this code to be compiled and executed when in test mode. To facilitate this, we can use a CMake `option` to determine whether we’re building a testable version of our application or a regular one. At the top of `ch9/part-3/app/CMakeLists.txt`, we have the following line:\n\n```", "```cpp\n\n\t\t\tThis is defaulted to `OFF`, but if a user passes `-DMC_GOL_APP_BUILD_TESTING=ON` when configuring (or adds or updates a CMake preset with this setting), tests will be enabled. The test target itself is wrapped in `if (MC_GOL_APP_BUILD_TESTING)` just as we did when adding tests to our libraries earlier in the chapter.\n\t\t\tBecause we’re testing an application, and not a library, we can’t add a new test target and link against our application as linking against executables isn’t allowed. We must recompile the application again, only with our testing code turned on. To avoid a lot of repeated code in our `app/CMakeLists.txt` file, we’ve introduced a new `INTERFACE` target called `${PROJECT_NAME}-common`. An `INTERFACE` target allows you to specify usage requirements including source files, compile definitions, libraries, and more. The target won’t be built itself but can be used by other targets (in our case, our normal application and test application), simply by calling `target_link_libraries` with the new `${``PROJECT_NAME}-common` target.\n\t\t\tA snippet from `ch9/part-3/app/CMakeLists.txt` using this approach is shown here:\n\n```", "```cpp\nfunction(set_common_target_properties TARGET_NAME)\n  set_target_properties(\n    ${TARGET_NAME}\n    …\nendfunction()\nset_common_target_properties(CMakeLists.txt file, when defining the new test target, we set the MC_GOL_APP_BUILD_TESTING compile definition (this matches the CMake option for consistency but needn’t be the same):\n\n```", "```cpp\n#ifdef MC_GOL_APP_BUILD_TESTING\n  // register tests\n  RegisterGolTests(engine, board);\n  // queue tests\n  ImGuiTestEngine_QueueTests(\n    engine, ImGuiTestGroup_Tests, \"gol-tests\",\n    ImGuiTestRunFlags_RunFromGui);\n#endif\n```", "```cpp\ntarget_sources(\n  MC_GOL_APP_BUILD_TESTING again to wrap a call to ImGuiTestEngine_IsTestQueueEmpty(engine) to check when all tests have finished running. When this happens, we ensure the total number of tests run is equal to the total number of successful tests, and then terminate the application, returning either 0 for success or 1 for failure.\n\t\t\tThe tests themselves, residing in `gol-tests.cpp`, allow us to script interactions with Dear ImGui, and because Dear ImGui interfaces with SDL 2, it can simulate mouse movements and clicks our application can respond to. To achieve this, a small change is needed to our input handling in `main.cpp`; we need to switch to using Dear ImGui instead of SDL 2 directly.\n\t\t\tFor example, the check to see if the left mouse button has been clicked goes from the following:\n\n```", "```cpp\n\n\t\t\tTo instead, look like this:\n\n```", "```cpp\n\n\t\t\tInside `RegisterGolTests`, we then can write a full end-to-end test to move the mouse, issue a click, and check the state of the *Game of* *Life* board:\n\n```", "```cpp\n\n\t\t\tIt’s not necessary to understand every line, but the important detail is we can now test our application as if we were a user, which can be incredibly useful for thorny kinds of test cases we’d like to cover.\n\t\t\tOne other quick thing to mention is the Dear ImGui Test Engine also provides an interactive UI option to selectively run tests and view their output. To enable this, and stop tests from being automatically queued, pass `-D MC_GOL_APP_INTERACTIVE_TESTING=ON` when configuring the project. A CMake preset with this setting enabled has also been added called `multi-ninja-test-interactive` (see `ch9/part-3/app/main.cpp` for the full implementation).\n\t\t\tIntegrating end-to-end tests with CTest\n\t\t\tReturning to our application’s `CMakeLists.txt` file, we can now see how we can integrate the preceding test application with CTest. All that’s needed (other than the obligatory call to `include(CTest)`), is the familiar `add_test` command:\n\n```", "```cpp\ncmake --preset multi-ninja-super-test\ncmake --build build/multi-ninja-super-test\nctest --test-dir build/multi-ninja-super-test -C Debug\n```", "```cpp\n{\n  \"name\": \"multi-ninja-super-test\",\n  \"configurePreset\": \"multi-ninja-super-test\",\n  \"configuration\": \"Debug\"\n}\n```", "```cpp\ncmake --workflow --preset multi-ninja-super-test\n```", "```cpp\nif(MC_GOL_APP_BUILD_TESTING)\n  ExternalProject_Add(\n    Catch2\n    GIT_REPOSITORY https://github.com/catchorg/Catch2.git\n    GIT_TAG v3.6.0\n    ...\nendif()\nif(SUPERBUILD AND NOT PROJECT_IS_TOP_LEVEL)\n  if(MC_GOL_APP_BUILD_TESTING)\n    set(TEST_DEPENDENCIES Catch2)\n  endif()\n  ExternalProject_Add(\n    ${CMAKE_PROJECT_NAME}_superbuild\n    DEPENDS\n      SDL2 bgfx imgui-test-engine.cmake\n      mc-gol mc-draw ${TEST_DEPENDENCIES}\n    ...\nendif()\n```", "```cpp\nfind_package(Catch2 REQUIRED CONFIG)\n```", "```cpp\nadd_executable(${PROJECT_NAME}-unit-test)\ntarget_sources(\n  ${PROJECT_NAME}-unit-test PRIVATE\n    src/viewport/screen.cpp\n    src/viewport/screen.test.cpp)\ntarget_link_libraries(\n  ${PROJECT_NAME}-unit-test\n    Catch2::Catch2WithMain as-c-math)\ntarget_compile_features(\n  ${PROJECT_NAME}-unit-test PRIVATE cxx_std_20)\n```", "```cpp\nadd_test(\n  NAME \"game of life unit tests\"\n  COMMAND ${PROJECT_NAME}-unit-test)\n```", "```cpp\necho %ERRORLEVEL%\n```", "```cpp\necho $?\n```", "```cpp\n> .../minimal-cmake_game-of-life_window-unit-test.exe\n> echo $?\n2\n```", "```cpp\nset_tests_properties(\n  \"game of life unit tests\"\n  PROPERTIES \"All tests passed\" when no failures occur, which CTest checks for; it will report success if it detects it. This is a somewhat contrived example but can be useful in different situations where an exit code may not be available. See https://cmake.org/cmake/help/latest/prop_test/PASS_REGULAR_EXPRESSION.html for more information.\n\t\t\tCMake script tests\n\t\t\tThe last kind of test we’ll cover is using CMake itself to run a CMake script file (like the CMake scripts we created to compile our shaders). We’re going to add a simple test to verify that the shaders required for the application to run have been compiled successfully. To achieve this, we create a new CMake script called `shaders-compiled.cmake` and add it to our `tests` directory. All it does is check for the existence of our shader files; a snippet is shown here:\n\n```", "```cpp\n\n\t\t\tIt’s not a particularly granular test, but if it fails, it is a useful early warning that the overall build is not functioning correctly and gives us a useful indicator of where to look.\n\t\t\tWe can run this file directly by running `cmake -P tests/shaders-compiled.cmake` from `ch9/part-4/app`. When the `message(FATAL_ERROR ...` command is met, CMake will cease processing and return a non-zero error code (we can again verify this using `echo $?` or equivalent).\n\t\t\tTo run this test as part of our top-level project, we can add the following to the testing section of our `CMakeLists.txt` file in `ch9/part-4/app`:\n\n```", "```cpp\n\n\t\t\tThis runs the file just as we did from the command line, and by providing a variable for `WORKING_DIRECTORY`, we ensure the test runs from `CMAKE_SOURCE_DIR` rather than the `build` folder so the relative paths to our shader files resolve correctly.\n\t\t\tOne final tip is that now that we have multiple tests to run, when working on a particular test, it can be useful to skip the others. In this situation, the `--tests-regex` (`-R` for short) command-line option can be used to select only the tests we want to run. For example, to only run the unit tests for our application, we could use the following command:\n\n```", "```cpp\n\n\t\t\tCMake also offers the ability to associate tests with specific labels. A pattern matching one or more of the labels can be passed to `ctest` to then have it only run the tests with that particular label. This can be achieved using `set_tests_properties`:\n\n```", "```cpp\nctest --test-dir build/multi-ninja-super-test --label-exclude (-LE) to do the opposite, and not run any tests that match the label (in the preceding example, using -LE slow would run all tests that are not labeled slow).\n\t\t\tThere are many more command-line arguments available for `ctest`, which are worth reviewing. They can be found by visiting [https://cmake.org/cmake/help/latest/manual/ctest.1.html](https://cmake.org/cmake/help/latest/manual/ctest.1.html).\n\t\t\tUsing CDash with CTest\n\t\t\tOne last topic to cover in the context of testing is integrating with another CMake tool called CDash. **CDash** is a web-based software testing server that can be used to present the results of running CTest. CDash displays a dashboard showing which tests are passing and which are failing and can also be used to display the current code coverage, as well as any build warnings or errors.\n\t\t\tThe good news is adding CDash support to our project requires minimal effort. We’ll briefly walk through the changes required and look at adding code coverage support on macOS and Linux to be displayed from CDash.\n\t\t\tCreating a CDash project\n\t\t\tThe first step we need to take is to create an account and a new project with CDash. While it’s possible to self-host a CDash server, using the CDash service provided by Kitware is a quick and easy way to get set up. This can be achieved by visiting [https://my.cdash.org/](https://my.cdash.org/), creating an account, and then navigating to [https://my.cdash.org/user](https://my.cdash.org/user) and scrolling down to the **Administrator** section. Here, there is then a **Start a new** **project** option.\n\t\t\tWhen creating a project, there are several options to provide, including the project name, description, whether the project is private, protected, or public, and whether submissions should be authenticated or not. For *Minimal CMake*, we have created a new public project, which can be found by visiting [https://my.cdash.org/index.php?project=minimal-cmake](https://my.cdash.org/index.php?project=minimal-cmake).\n\t\t\tOnce your project has been created, the next step is to connect your local project to CDash. To do this, we add a new file to the root of our CMake project (in our case, this is `ch9/part-5/app`) called `CTestConfig.cmake`. Its contents are as follows:\n\n```", "```cpp\n\n\t\t\tThere are many more options you can set, but for our purposes, we’re simply specifying the project name, and where the build artifacts should be uploaded to. For more complex cases, it’s possible to specify nightly build times, the maximum number of warnings or errors to be detected, and memory checks. For a full list of variables, please see [https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html#variables-for-ctest](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html#variables-for-ctest).\n\t\t\tUploading test results\n\t\t\tWith the CDash project created and `CTestConfig.cmake` added to our project, we can run the following CTest command to run our tests and upload the results to CDash:\n\n```", "```cpp\ntarget_compile_options(${TARGET_NAME} PRIVATE --coverage)\ntarget_link_options(${TARGET_NAME} PRIVATE --coverage to both the compile and link options for our test targets. Internally, CMake is using a tool called gcov to generate coverage information. gcov itself is outside the scope of this book. It can be used without CMake or CTest, but fortunately for us, CTest does a nice job of providing a simple interface that wraps gcov and we can treat it as an implementation detail for now.\n\t\t\tOne last change is to limit the amount of coverage information that’s reported (to essentially ignore files we don’t care about). This can be achieved by adding a new file called `CTestCustom.cmake.in` that contains the `CTEST_CUSTOM_COVERAGE_EXCLUDE` CTest variable, which allows us to pass coverage paths to ignore to CTest:\n\n```", "```cpp\n\n\t\t\tCTest will look for this file in the CMake `build` folder (`CMAKE_BINARY_DIR`), so we need to copy the template file to the `build` folder when we run the CMake configure step. To do this, we use `configure_file`, added at the bottom of our testing block in our application’s `CMakeList.txt` file:\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```"]