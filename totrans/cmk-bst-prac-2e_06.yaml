- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging, Deploying, and Installing a CMake Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Properly packaging software is often overshadowed by the focus on writing and
    building it, yet it is often a significant factor in ensuring the success and
    longevity of any software project. Packaging serves as the bridge between the
    developer’s creation and the end user’s experience, encompassing everything from
    distribution to installation and maintenance. Well-packaged software not only
    streamlines the deployment process but also enhances user satisfaction, fosters
    reliability, and facilitates seamless updates and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that software is packaged in a manner compatible with these diverse
    environments is paramount to its usability and accessibility. Moreover, users
    span a wide spectrum of technical proficiency, ranging from seasoned professionals
    to novices. Consequently, packaging must cater to this spectrum, offering intuitive
    installation processes for less experienced users while providing advanced options
    for the technically adept. Furthermore, adherence to installation standards is
    crucial not only for user convenience but also for maintaining system integrity.
    By following established packaging norms, developers mitigate the risk of cluttering
    target systems with unnecessary files or conflicting dependencies, thus promoting
    system stability and cleanliness. In essence, packaging software is the crucial
    final step that transforms raw code into a polished, accessible product, making
    it as vital as the development process itself.
  prefs: []
  type: TYPE_NORMAL
- en: CMake has good internal support and tooling to make installing and packaging
    easy. The good side of this is that CMake leverages existing project code to do
    such things. Thus, making a project installable or packaging a project does not
    result in heavy maintenance costs. In this chapter, we’re going to learn how to
    leverage CMake’s existing abilities regarding installing and packaging for deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Making CMake targets installable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supplying configuration information for others using your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an installable package with CPack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you dive into this chapter, you should have a good grasp of targets in
    CMake (covered briefly in [*Chapter 1*](B30947_01.xhtml#_idTextAnchor015), *Kickstarting
    CMake*, and [*Chapter 3*](B30947_03.xhtml#_idTextAnchor054), *Creating a* *CMake*
    *Project*, in detail). This chapter will build on top of that knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Please obtain this chapter’s examples from this book’s GitHub repository at
    [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
    This chapter’s exemple content is available in the `chapter04/` subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: Making CMake targets installable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of CMake, there is a difference between the terms *installing*
    and *packaging* software. Installing software involves copying executable files,
    libraries, and other necessary resources to a predefined location. Packaging,
    on the other hand, involves bundling all necessary files and dependencies into
    a distributable format (such as a tarball, ZIP archive, or installer package)
    for easy distribution and installation on other systems. CMake’s packaging mechanism
    works by first installing a project in a temporary location and then packaging
    the installed files into a suitable format.
  prefs: []
  type: TYPE_NORMAL
- en: The most primitive way of supporting deployment in a project is by making it
    *installable*. On the contrary, the end user still must acquire the project’s
    source code and build it from scratch. An installable project has extra build
    system code for installing the runtime or development artifacts on the system.
    The build system will perform the install action here, given that it has proper
    instructions on how to do so. Since we’re using CMake to generate the build system
    files, CMake must generate the relevant install code. In this section, we will
    dive into the basics of how to instruct CMake to generate such code for the CMake
    targets.
  prefs: []
  type: TYPE_NORMAL
- en: The install() command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `install(...)` command is a built-in CMake command that allows you to generate
    build system instructions for installing targets, files, directories, and more.
    CMake will not generate install instructions unless it is explicitly told to do
    so. Therefore, what gets installed is always under your control. Let’s inspect
    its basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Installing CMake targets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make a CMake target installable, the `TARGETS` parameter must be specified
    with at least one argument. The command signature for this usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TARGETS` parameter denotes that `install` will accept a set of CMake targets
    to generate the installation code for. In this form, only the output artifacts
    of the target will be installed. The most common output artifacts for a target
    are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARCHIVE` (static libraries, DLL import libraries, and linker import files):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for targets marked as `FRAMEWORK` in macOS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIBRARY` (shared libraries):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for targets marked as `FRAMEWORK` in macOS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for DLLs (in Windows)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNTIME` (executables and DLLs):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for targets marked as `MACOSX_BUNDLE` in macOS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After making a target installable, CMake will generate the necessary installation
    code to install the output artifacts that will be produced for the target. To
    illustrate this, let’s make a basic executable target installable together. To
    see the `install(...)` command in action, let’s inspect the `CMakeLists.txt` file
    of `Chapter 4`, `example 1`, which can be found in the `chapter04/ex01_executable`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, an executable target called `ch4_ex01_executable` is
    being defined and its properties are being populated in the subsequent two lines.
    The last line, `install(...)`, is the line we’re interested in. It tells CMake
    to create the required install code for `ch4_ex01_executable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether `ch4_ex01_executable` can be installed, let’s build the project
    and install it via the CLI from within the root folder of `chapter 4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having to specify the `--prefix` parameter for `cmake --install`,
    you can also use the `CMAKE_INSTALL_PREFIX` variable to provide the non-default
    `install` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please specify the `--config` argument for the `cmake --build` and `cmake --install`
    commands while using CMake with multi-config generators, such as Ninja multi-config
    and Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s inspect what the `cmake --install` command did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the last line of the preceding output, we can see the *output artifact* of
    the `ch4_ex01_executable` target – that is, the `ch4_ex01_executable` binary is
    installed. Since that was the only output artifact that the `ch4_ex01_executable`
    target had, we can conclude that our target has indeed become installable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that `ch4_ex01_executable` is not directly installed in the `/tmp/install-test`
    (prefix) directory. Instead, the `install` command puts it in the `bin/` subdirectory.
    This is because CMake is smart about what kind of artifact should go where. In
    a traditional UNIX system, binaries go into `/usr/bin`, while libraries go into
    `/usr/lib`. CMake knows that the `add_executable()` command produces an executable
    binary artifact and puts it into the `/bin` subdirectory. These directories are
    provided by CMake by default, depending on the target type. The CMake module that
    provides the default installation path information is known as the `GNUInstallDirs`
    module. The `GNUInstallDirs` module defines various `CMAKE_INSTALL_` paths when
    included. The following table shows the default installation directories for the
    targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Target Type** | **GNUInstallDirs Variable** | **Built-In Default** |'
  prefs: []
  type: TYPE_TB
- en: '| RUNTIME | ${CMAKE_INSTALL_BINDIR} | bin |'
  prefs: []
  type: TYPE_TB
- en: '| LIBRARY | ${CMAKE_INSTALL_LIBDIR} | lib |'
  prefs: []
  type: TYPE_TB
- en: '| ARCHIVE | ${CMAKE_INSTALL_LIBDIR} | lib |'
  prefs: []
  type: TYPE_TB
- en: '| PRIVATE_HEADER | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
  prefs: []
  type: TYPE_TB
- en: '| PUBLIC_HEADER | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
  prefs: []
  type: TYPE_TB
- en: 'To override the built-in defaults, an additional `<TARGET_TYPE> DESTINATION`
    parameter is required in the `install(...)` command. To illustrate this, let’s
    try to change the default `RUNTIME` install directory to `qbin` instead of `bin`.
    Doing so only requires that we make a small modification to our original `install(...)`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After making this change, we can rerun the `configure`, `build`, and `install`
    commands. We can confirm that the `RUNTIME` destination has changed by inspecting
    the `cmake --install` command’s output. Different from the first time, we can
    observe that the `ch4_ex01_executable` binary is put into `qbin` instead of the
    default (`bin`) directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at another example. We will be installing a `STATIC` library
    this time. Let’s look in the `CMakeLists.txt` file of [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Example 2*, which can be found in the `chapter04/ex02_static` folder. Comments
    and the `project(...)` command have been omitted due to space reasons. Let’s start
    inspecting the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, it is a little bit different from our previous example.
    First, there is an additional `install(...)` command with the `DIRECTORY` argument.
    This is required to make the header files of the static library installable. The
    reason for this is that CMake will not install any file that is not an *output
    artifact* and the `STATIC` library target only produces a binary file as an *output
    artifact*. Header files are not considered *output artifacts* and should be installed
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The trailing slash in the `DIRECTORY` argument causes CMake to copy the folder’s
    content instead of copying the folder by name. CMake handles trailing slashes
    in the same fashion as the Linux `rsync` command.
  prefs: []
  type: TYPE_NORMAL
- en: Installing files and directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in the previous section, the things we mean to install are not always
    part of a target’s *output artifacts*. They may be runtime dependencies of the
    target, such as images, assets, resource files, scripts, and configuration files.
    CMake provides the `install(FILES...)` and `install(DIRECTORY...)` commands for
    installing any specific files or directories. Let’s begin with installing files.
  prefs: []
  type: TYPE_NORMAL
- en: Installing files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `install(FILES...)` command accepts one or more files as an argument. It
    requires an additional `TYPE` or `DESTINATION` parameter as well. Both parameters
    are used for determining the destination directory of the specified files. The
    `TYPE` parameter is used to indicate which files will use the default path for
    that file type as an installation directory. Defaults can be overridden by setting
    the relevant `GNUInstallDirs` variable. The following table shows the valid `TYPE`
    values, along with their directory mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **GNUInstallDirs Variable** | **Built-In Default** |'
  prefs: []
  type: TYPE_TB
- en: '| BIN | ${CMAKE_INSTALL_BINDIR} | bin |'
  prefs: []
  type: TYPE_TB
- en: '| SBIN | ${CMAKE_INSTALL_SBINDIR} | sbin |'
  prefs: []
  type: TYPE_TB
- en: '| LIB | ${CMAKE_INSTALL_LIBDIR} | lib |'
  prefs: []
  type: TYPE_TB
- en: '| INCLUDE | ${CMAKE_INSTALL_INCLUDEDIR} | include |'
  prefs: []
  type: TYPE_TB
- en: '| SYSCONF | ${CMAKE_INSTALL_SYSCONFDIR} | etc |'
  prefs: []
  type: TYPE_TB
- en: '| SHAREDSTATE | ${CMAKE_INSTALL_SHARESTATEDIR} | com |'
  prefs: []
  type: TYPE_TB
- en: '| LOCALSTATE | ${CMAKE_INSTALL_LOCALSTATEDIR} | var |'
  prefs: []
  type: TYPE_TB
- en: '| RUNSTATE | ${CMAKE_INSTALL_RUNSTATEDIR} | <LOCALSTATE dir>/run |'
  prefs: []
  type: TYPE_TB
- en: '| DATA | ${CMAKE_INSTALL_DATADIR} | <DATAROOT dir> |'
  prefs: []
  type: TYPE_TB
- en: '| INFO | ${CMAKE_INSTALL_INFODIR} | <DATAROOT dir>/info |'
  prefs: []
  type: TYPE_TB
- en: '| LOCALE | ${CMAKE_INSTALL_LOCALEDIR} | <DATAROOT dir>/locale |'
  prefs: []
  type: TYPE_TB
- en: '| MAN | ${CMAKE_INSTALL_MANDIR} | <DATAROOT dir>/man |'
  prefs: []
  type: TYPE_TB
- en: '| DOC | ${CMAKE_INSTALL_DOCDIR} | <DATAROOT dir>/doc |'
  prefs: []
  type: TYPE_TB
- en: If you don’t wish to use the `TYPE` parameter, you can use the `DESTINATION`
    parameter instead. It lets you provide a custom destination for the specified
    files in the `install(...)` command.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative form of `install(FILES...)` is `install(PROGRAMS...)`, which
    is the same as `install(FILES...)` except it also sets `OWNER_EXECUTE`, `GROUP_EXECUTE`,
    and `WORLD_EXECUTE` permissions for installed files. This makes sense for binaries
    or script files that must be executed by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand `install(FILES|PROGRAMS...)`, let’s look at an example. The example
    we’re going to look at is [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071)*, Example
    3* (`chapter04/ex03_file`). It essentially contains three files: `chapter04_greeter_content`,
    `chapter04_greeter.py`, and `CMakeLists.txt`. First, let’s look at its `CMakeLists.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s digest what we have seen; in the first `install(...)` command, we’re telling
    CMake to install the `chapter04_greeter_content` file in the current `CMakeLists.txt`
    directory (`chapter04/ex03_file`) in the default `BIN` directory of the system.
    In the second `install(…)` command, we’re telling CMake to install `chapter04_greeter.py`
    in the default `BIN` directory with the name `chapter04_greeter`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `RENAME` parameter is only valid for single-file `install(...)` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these `install(...)` instructions, CMake should install the `chapter04_greeter.py`
    and `chapter04_greeter_content` files in the `${CMAKE_INSTALL_PREFIX}/bin` directory.
    Let’s build and install the project via the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at what the `cmake --install` command did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output confirms that CMake generated the required installation
    code for the `chapter04_greeter_content` and `chapter04_greeter.py` files. Lastly,
    let’s check whether the `chapter04_greeter` file can be executed since we used
    the `PROGRAMS` parameter to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have concluded the `install(FILES|PROGRAMS...)` section. Let’s
    continue with installing directories.
  prefs: []
  type: TYPE_NORMAL
- en: Installing directories
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `install(DIRECTORY...)` command is useful for installing directories. The
    directory’s structure will be copied as is to the destination. Directories can
    either be installed as a whole or selectively. Let’s begin with the most basic
    directory installation example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example will install the `dir1` and `dir2` directories in the
    `${CMAKE_INSTALL_PREFIX}/var` directory, along with all of their subfolders and
    files as is. Sometimes, installing the folder’s entire content is not desirable.
    Luckily, CMake allows the `install` command to include or exclude directory content
    based on globbing patterns and regular expressions. Let’s install `dir1`, `dir2`,
    and `dir3` selectively this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used the `FILES_MATCHING` parameter to define
    criteria for file selection. `FILES_MATCHING` can be followed by either the `PATTERN`
    or `REGEX` argument. `PATTERN` allows you to define a globbing pattern, whereas
    `REGEX` allows you to define a regular expression. By default, these expressions
    are used for including files. If you want to exclude files that match the criteria,
    you can append the `EXCLUDE` argument to the pattern. Note that these filters
    are not applied to subdirectory names because of the `FILES_MATCHING` parameter.
    We also used `PATTERN` in the last `install(...)` command without `FILES_MATCHING`
    prepended, which allows us to filter subdirectories instead of files. This time,
    only the files with the `.x` extension in `dir1`, files that don’t have the `.hpp`
    extension in `dir2`, and all the content except for the `bin` folder in `dir3`
    will be installed. This example is available as [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071)*,
    Example 4* in the `chapter04/ex04_directory` folder. Let’s compile and install
    it to see whether it does the right thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `cmake --install` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`FILES_MATCHING` cannot be used after `PATTERN` or `REGEX` but it can be done
    vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see that only the files with the `.x` extension are picked
    from `dir1`. This is because of the `FILES_MATCHING PATTERN "*.x"` parameter in
    the first `install(...)` command, causing the `asset2` file to not be installed.
    Also, note that the `dir2/chapter04_hello.dat` file is installed and the `dir2/chapter04_hello.hpp`
    file is skipped. This is due to the `FILES_MATCHING PATTERN "*.hpp" EXCLUDE PATTERN
    "*"` parameters in the second `install(…)` command. Lastly, we can see that the
    `dir3/asset4` file is installed and the `dir3/bin` directory is completely skipped
    since the `PATTERN "bin" EXCLUDE` parameter is specified in the last `install(...)`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: With `install(DIRECTORY...)`, we have covered the basics of the `install(...)`
    command. Let’s continue with the `install(…)` command’s other common parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Other common parameters of the install() command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we’ve seen, the `install()` command’s first parameter indicates what to install.
    There are additional parameters that allow us to customize the installation. Let’s
    inspect some of the common parameters together.
  prefs: []
  type: TYPE_NORMAL
- en: The DESTINATION parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This parameter allows you to specify a target directory for the files specified
    in the `install(...)` command. The directory path can be relative or absolute.
    Relative paths will be relative to the `CMAKE_INSTALL_PREFIX` variable. It is
    recommended to use relative paths to make the installation *relocatable*. Also,
    it is important to use relative paths for packaging since `cpack` requires install
    paths to be relative. It is good practice to use a path that begins with the relevant
    `GNUInstallDirs` variable so that package maintainers can override the install
    destination if needed. The `DESTINATION` parameter can be used together with the
    `TARGETS`, `FILES`, `IMPORTED_RUNTIME_ARTIFACTS`, `EXPORT`, and `DIRECTORY` installation
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The PERMISSIONS parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This parameter allows you to change the installed file permissions on supported
    platforms. The available permissions are `OWNER_READ`, `OWNER_WRITE`, `OWNER_EXECUTE`,
    `GROUP_READ`, `GROUP_WRITE`, `GROUP_EXECUTE`, `WORLD_READ`, `WORLD_WRITE`, `WORLD_EXECUTE`,
    `SETUID`, and `SETGID`. The `PERMISSIONS` parameter can be used with the `TARGETS`,
    `FILES`, `IMPORTED_RUNTIME_ARTIFACTS`, `EXPORT`, and `DIRECTORY` installation
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The CONFIGURATIONS parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This allows you to limit a set of parameters to be applied when a specific build
    configuration has been specified.
  prefs: []
  type: TYPE_NORMAL
- en: The OPTIONAL parameter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This parameter makes the file to be installed optional so that installation
    does not fail when the file is not present. The `OPTIONAL` parameter can be used
    together with the `TARGETS`, `FILES`, I`MPORTED_RUNTIME_ARTIFACTS`, and `DIRECTORY`
    installation types.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to make targets, files, and directories installable.
    In the next section, we will learn how to generate configuration information so
    that we can import CMake projects directly into another CMake project.
  prefs: []
  type: TYPE_NORMAL
- en: Supplying configuration information for others using your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to make our project installable so that
    others can consume our project by installing it on their system. But sometimes,
    delivering the artifacts is not enough. For example, if you are delivering a library,
    it must also be easy to import it into a project – especially a CMake project.
    In this section, we will learn how to make this importing process easier for other
    CMake projects.
  prefs: []
  type: TYPE_NORMAL
- en: There are convenient ways of importing a library, given that the project to
    be imported has the proper configuration files. One of the prominent ways of doing
    so is by utilizing the `find_package()` method (which we will cover in [*Chapter
    5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries* *and
    Dependency Management*). If you have consumers that use CMake in their workflows,
    they will be happy if they can just write `find_package(your_project_name)` and
    start using your code. In this section, we will learn how to generate the required
    configuration files to make `find_package()` work for your project.
  prefs: []
  type: TYPE_NORMAL
- en: CMake’s preferred way of consuming dependencies is via packages. Packages convey
    dependency information for CMake-based build systems. Packages can be in the form
    of `Config-file` packages, `Find-module` packages, or `pkg-config` packages. All
    of the package types can be found and consumed via `find_package()`. In the interest
    of efficiency and adherence to best practices, our focus in this section will
    be solely on `Config-file` packages. The other methods, such as `find-modules`
    and `pkg-config` packages, are considered outdated workarounds primarily used
    in the absence of config files and are generally not recommended. Let’s delve
    into the world of `Config-file` packages to understand their benefits and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Entering the CMake package world – Config-file packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Config-file packages are based on configuration files that contain package content
    information. This information indicates the package’s content locations, so CMake
    reads this file and uses the package. Thus, discovering only the package configuration
    files is enough to consume the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of configuration files – a package configuration file and
    an optional package version file. Both files must have a specific naming convention.
    Package configuration files can be named `<ProjectName>Config.cmake` or `<projectname>-config.cmake`,
    depending on personal preference. Both notations will be picked by CMake on `find_package(ProjectName)`/`find_package(projectname)`
    calls. The content of package configuration files looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, `${PREFIX}` is the installation prefix of the project. It is a variable
    since the installation prefix can be changed based on the system’s type and can
    also be changed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Like package configuration files, package version files can be named `<ProjectName>ConfigVersion.cmake`
    or `<projectname>-config-version.cmake` as well. CMake expects package configuration
    and package version files to be present in the `find_package(...)` search paths.
    You can create these files with the help of CMake. One of the many places that
    `find_package(...)` looks while searching for packages is the `<CMAKE_PREFIX_PATH>/cmake`
    directory. We’ll be putting our `config-file` package configuration files into
    this folder throughout our examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `config-file` packages, we will need to learn about a few extra things,
    such as `CmakePackageConfigHelpers` module. To learn about these things, let’s
    start diving into an actual example. We’ll be following [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071)*,
    Example 5* to learn how to structure a CMake project to make it a `chapter04/
    ex05_config_file_package` folder. Let’s start by inspecting the `CMakeLists.txt`
    file in the `chapter04/ex05_config_file_package` directory (comments and project
    commands have been omitted in favor of space; also, note that the lines that are
    not relevant to the topic will not be mentioned):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` file is quite similar to `chapter04/ex02_static`. This
    is because it is the same example, except it supports the `config-file` package.
    The first line, `include(GNUInstallDirs)`, is used to include the `GNUInstallDirs`
    module. This provides the `CMAKE_INSTALL_INCLUDEDIR` variable, which will be used
    later. `set(ch4_ex05_lib_INSTALL_CMAKEDIR...)` is a user-defined variable for
    setting the target installation directory of the `config-file` packaging configuration
    files. It is a relative path that should be used in the `install(…)` directives,
    so it is implicitly relative to `CMAKE_INSTALL_PREFIX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `target_include_directories(...)` call is quite different than the usual
    calls. It uses `generator expressions` to distinguish between build-time `include`
    directories and install-time `include` directories since the build-time `include`
    path will not be present when the target is imported into another project. The
    following set of commands will make the target installable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`install(TARGETS...)` is a bit different than regular calls as well. It contains
    an extra `EXPORT` parameter. This `EXPORT` parameter is used to create an export
    name from the given `install(…)` targets. These targets can then be exported using
    this export name. The path that’s specified with the `INCLUDES DESTINATION` parameter
    will be used to populate the `INTERFACE_INCLUDE_DIRECTORIES` property of the exported
    target and will be automatically prefixed with the install prefix path. Here,
    the `install(DIRECTORY...)` command is used to install the target’s header files
    and is located in `${PROJECT_SOURCE_DIR}/include/`, in the `${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_INCLUDEDIR}`
    directory. The `${CMAKE_INSTALL_INCLUDEDIR}` variable is used to give consumers
    the ability to override the `include` directory for this installation. Now, let’s
    create an export file from the export name we created in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`install(EXPORT...)` is perhaps the most important piece of code in this file.
    It is the code that does the actual target exporting. It generates a CMake file
    that contains all the exported targets in the given export name. The `EXPORT`
    parameter accepts an existing export name to perform the export. It refers to
    the `ch4_ex05_lib_export` export name that we created with the previous `install(TARGETS...)`
    call. The `FILE` parameter is used to determine the export’s filename and is set
    to `ch4_ex05_lib-config.cmake`. The `NAMESPACE` parameter is used to prefix all
    the exported targets with a namespace. This allows you to connect all the exported
    targets under a common namespace and avoid collisions with packages that have
    similar target names. Lastly, the `DESTINATION` parameter determines the installation
    path of the generated export file. This is set to `${ch4_ex05_lib_INSTALL_CMAKEDIR}`
    to allow `find_package()` to discover it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since we are not providing any extras other than exported targets, the name
    of the export file is `ch4_ex05_lib-config.cmake`. It is the package configuration
    file name that’s required for this package. We’ve done this because the example
    project does not require any extra dependencies to be satisfied first and can
    be directly imported as is. If any extra action is required, it is recommended
    to have an intermediate package configuration file that satisfies those dependencies
    and includes the exported file after.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `install(EXPORT...)` command, we obtained the `ch4_ex05_lib-config.cmake`
    file. This means that our target can be consumed via `find_package(..)`. One additional
    step is required to achieve full support for `find_package(…)`, which is obtaining
    the `ch4_ex05_lib-config-version.cmake` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the last few lines, you can find the code that’s required to generate and
    install the `ch4_ex05_lib-config-version.cmake` file. With the `include(CMakePackageConfigHelpers)`
    line, the `CMakePackageConfigHelpers` module is imported. This module provides
    the `write_basic_package_version_file(…)` function. The `write_basic_package_version_file(…)`
    function is used to automatically generate package version files, depending on
    the given parameters. The first positional argument is the output’s filename.
    The `VERSION` parameter is used to specify the version of the package we’re generating
    in `major.minor.patch` form. It is opted out to allow `write_basic_package_version_file`
    to get it from the project version automatically. The `COMPATIBILITY` parameter
    allows you to specify compatibility policies, depending on the version’s value.
    `SameMajorVersion` denotes that this package is compatible with any version that
    has the same major version value of this package. The other possible values are
    `AnyNewerVersion`, `SameMinorVersion`, and `ExactVersion`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test whether this works. To test the package configuration, we must
    install the project in the regular way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cmake --install` command’s output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that our package configuration files have been successfully
    installed in the `/tmp/install-test/cmake` directory. I’ll leave inspecting the
    content of those files to you as an exercise. So, we have a consumable package
    on our hands. Let’s switch sides and try to consume our freshly baked package.
    To do that, we’ll look at the `chapter04/ex05_consumer` example. Let’s inspect
    the `CMakeLists.txt` file together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first few lines, we can see verification regarding whether the project
    is a top-level project or not. Since this example is intended to be an external
    application, it should not be part of the root example project. Thus, we can guarantee
    that we will use the targets that are exported by the package, not the root project’s
    targets. The root project also does not include the `ex05_consumer` folder. Next,
    there’s a `find_package(…)` call, where `ch4_ex05_lib` is given as a package name.
    It is also explicitly requested that the package should have a major version of
    1; `find_package(…)` must only consider `CONFIG` packages and packages specified
    in this `find_package(…)` call are required. In the subsequent lines, a regular
    executable is defined called `ch4_ex05_consumer` that’s linked against `ch4_ex05_lib`
    in the `ch4_ex05_lib` namespace (`ch4_ex05_lib::ch4_ex05_lib`). `ch4_ex05_lib::ch4_ex05_lib`
    is the actual target we have defined in our package. Let’s look at the source
    file, `src/main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple application that includes `chapter04/ex05/lib.hpp`, creates
    an instance of the `greeter` class, and calls the `greet()` function. Let’s try
    to compile and run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have installed the package using a custom prefix (`/tmp/install-test`),
    we can indicate this by setting the `CMAKE_PREFIX_PATH` variable. This causes
    `find_package(…)` to search `/tmp/install-test` for packages as well. For default
    prefix installations, this parameter setting is not required. We should see the
    infamous `Hello, world!` message if everything goes well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, our consumers can use our little **greeter** and everybody is happy. Now,
    let’s conclude this section by learning how to package with **CPack**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an installable package with CPack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how CMake can structure software projects. Although CMake
    is the star of the show, CMake has some powerful friends too. It is time to introduce
    you to CPack, the packaging tool of CMake. It is shipped with CMake installations
    by default. It allows you to leverage existing CMake code to generate platform-specific
    installations and packages. CPack is similar to CMake in concept. It is based
    on generators that generate packages instead of build system files. The following
    table shows the available CPack generator types as of version 3.21.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Generator Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 7Z | 7-zip archive |'
  prefs: []
  type: TYPE_TB
- en: '| DEB | Debian package |'
  prefs: []
  type: TYPE_TB
- en: '| External | CPack external package |'
  prefs: []
  type: TYPE_TB
- en: '| IFW | Qt Installer Framework |'
  prefs: []
  type: TYPE_TB
- en: '| NSIS | Null Soft Installer |'
  prefs: []
  type: TYPE_TB
- en: '| NSIS64 | Null Soft Installer (64-bit) |'
  prefs: []
  type: TYPE_TB
- en: '| NuGet | NuGet packages |'
  prefs: []
  type: TYPE_TB
- en: '| RPM | RPM packages |'
  prefs: []
  type: TYPE_TB
- en: '| STGZ | Self-extracting TAR gzip archive |'
  prefs: []
  type: TYPE_TB
- en: '| TBZ2 | Tar BZip2 archive |'
  prefs: []
  type: TYPE_TB
- en: '| TGZ | Tar GZip archive |'
  prefs: []
  type: TYPE_TB
- en: '| TXZ | Tar XZ archive |'
  prefs: []
  type: TYPE_TB
- en: '| TZ | Tar Compress archive |'
  prefs: []
  type: TYPE_TB
- en: '| TZST | Tar Zstandard archive |'
  prefs: []
  type: TYPE_TB
- en: '| ZIP | Zip archive |'
  prefs: []
  type: TYPE_TB
- en: 'CPack uses CMake’s installation mechanism to populate the content of the packages.
    CPack uses the configuration details that are present in the `CPackConfig.cmake`
    and `CPackSourceConfig.cmake` files to generate packages. These files can either
    be populated manually or generated automatically by CMake with the help of the
    CPack module. Using CPack on an existing CMake project is as easy as including
    the CPack module, given that the project already has proper `install(…)` commands.
    Including the CPack module will cause CMake to generate the `CPackConfig.cmake`
    and `CPackSourceConfig.cmake` files, which are the CPack configurations that are
    needed to pack the project. Also, an additional `package` target will become available
    for the build step. This step will build the project and run CPack so that it
    starts packaging. CPack can be used when the CPack configuration files have been
    populated properly, either by CMake or the user. The CPack module allows you to
    customize the packaging process. A large amount of CPack variables can be set.
    These variables are separated into two groups – common variables and generator-specific
    variables. Common variables affect all package generators, whereas generator-specific
    variables only affect a specific type of generator. We’ll be inspecting the most
    basic and prominent ones and we will mostly deal with the common variables. The
    following table shows the most common CPack variables we will use in our examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable Name** | **Description** | **Default Value** |'
  prefs: []
  type: TYPE_TB
- en: '| CPACK_PACKAGE_NAME | Package name | Project name |'
  prefs: []
  type: TYPE_TB
- en: '| CPACK_PACKAGE_VENDOR | Package vendor name | “Humanity” |'
  prefs: []
  type: TYPE_TB
- en: '| CPACK_PACKAGE_VERSION_MAJOR | Package major version | Project major version
    |'
  prefs: []
  type: TYPE_TB
- en: '| CPACK_PACKAGE_VERSION_MINOR | Package minor version | Project minor version
    |'
  prefs: []
  type: TYPE_TB
- en: '| CPACK_PACKAGE_VERSION_PATCH | Package patch version | Project patch version
    |'
  prefs: []
  type: TYPE_TB
- en: '| CPACK_GENERATOR | List of CPack generators to use | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| CPACK_THREADS | Number of threads to use when parallelism is supported |
    1 |'
  prefs: []
  type: TYPE_TB
- en: 'Any changes that must be made to the variables must be made before you include
    the CPack module. Otherwise, the defaults will be used. Let’s dive into an example
    to see CPack in action. We will be following the [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Example 6* (`chapter04/ex06_pack`) example. This example is structured as a standalone
    project and is not part of the root example project. It is a regular project with
    two subdirectories named `executable` and `library`. The `CMakeLists.txt` file
    of the `executable` directory looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` file of the `library` directory looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` files for these folders do not contain anything out of
    the ordinary. They contain regular, installable CMake targets and declare nothing
    about CPack. Let’s look at the top-level `CMakeLists.txt` file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-level `CMakeLists.txt` file is pretty much a regular, top-level `CMakeLists.txt`
    file, except for the last four lines. It sets three CPack-related variables and
    then includes the CPack module. These four lines are enough to provide basic CPack
    support. The `CPACK_PACKAGE_NAME` and `CPACK_PACKAGE_VERSION_*` variables are
    not set to let CPack deduce them from the top-level project’s name and version
    parameters. Let’s configure the project to see whether it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After configuring the project, the `CpackConfig.cmake` and `CpackConfigSource.cmake`
    files should be generated by the CPack module in the `build/CPack*` directory.
    Let’s check whether they’re present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the CPack configuration files are automatically generated.
    Let’s build this and try to package the project with CPack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--config` argument is the main input of the CPack command. The `-B` argument
    overrides the default package directory that CPack will write its artifacts to.
    Let’s look at CPack’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that CPack has used the `DEB`, `RPM`, and `TBZ2` generators
    to generate the `ch4_ex06_pack-1.0-Linux.deb`, `ch4_ex06_pack-1.0-Linux.rpm`,
    and `ch4_ex06_pack-1.0-Linux.tar.bz2` packages, respectively. Let’s try to install
    the generated Debian package in a Debian environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the packaging was correct, we should be able to invoke `ch4_ex06_executable`
    directly on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It works! As an exercise, try to install the `RPM` and `tar.bz2` packages as
    well. There are generally two approaches to handling packages. One is to create
    small packages that depend on other packages to install the dependencies and the
    other approach is to create installers that contain all the necessary libraries
    to run standalone. Typically, Linux distributions come with a package manager
    that handles these dependencies, while Windows and macOS depend on standalone
    installers by default. Although, in recent years, Chocolatey for Windows and Homebrew
    for macOS have become popular package managers that support dependent packages,
    CPack does not (yet) support them. So far, we have only looked at simple packages
    that require the user to install all the dependencies by themselves. Let’s see
    how we could build a standalone package for easy distribution on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Creating standalone installers for Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Windows does not come with a standard package manager, installers for
    software often must include all necessary libraries. One approach is to include
    premade installers in either NSIS or WIX installers, but that is not always possible,
    so let’s have a look at how to find dependent files. For this, CMake offers the
    optional `RUNTIME_DEPENDENCIES` flag for the `install` command and the `InstallRequiredSystemLibraries`
    module to find dependencies for packaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the `InstallRequiredSystemLibraries` module is included.
    The module is tailored to work in Windows. Including the module creates install
    instructions for libraries provided by the compiler such as the Visual Studio
    C++ runtime supplied by MSVC. It can be configured to include the debug versions
    of the libraries by setting the `CMAKE_INSTALL_DEBUG_LIBRARIES` variable to true,
    as done in the preceding example. There are further options available to instruct
    CMake to install additional libraries, such as the Windows MFC libraries, OpenMP,
    or the Microsoft Universal CRT libraries for app-local deployment on Windows XP
    or older Windows versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full documentation of the module can be found here: [https://cmake.org/cmake/help/latest/module/InstallRequiredSystemLibraries.html](https://cmake.org/cmake/help/latest/module/InstallRequiredSystemLibraries.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Including the compiler-provided libraries is one thing, but often software
    projects will depend on other libraries as well. If these are to be shipped in
    the same package, they can be included by using the `RUNTIME_DEPENDENCIES` option
    of the `install()` command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will try to find out any shared libraries that the target specified depends
    on. Because of the way that Windows handles DLL resolution, this will most likely
    find a lot more libraries than what is really needed. Specifically, it will most
    likely find libraries starting with *api-ms* or *ext-ms* that are there for compatibility
    reasons and that are not needed. These can be filtered out with the `PRE_EXCLUDE_REGEXES`
    option, which filters before including them. Any file paths that match these regular
    expressions will be excluded from consideration when determining runtime dependencies.
    Alternatively, the `POST_EXCLUDE_REGEXES` option can be used to filter the files
    after they have been found. This can be useful if you want to exclude files from
    a certain location. In the preceding example, this is used to exclude any DLL
    files from the 32-bit `system32` folder.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use CPack to pack our project. This is not
    an exhaustive guide. For a complete guide, the official CPack documentation provides
    a lot of information. With that, we’ve successfully reached the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the basics of making a target installable and how
    to package a project for development and consumer environments. Deployment is
    an important aspect of professional software projects, and with the help of the
    things we have covered in this chapter, you can tackle such deployment requirements
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to integrate third-party libraries into
    CMake projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How can we instruct CMake to make a CMake target installable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which files are installed when a target is installed via the `install(TARGETS)`
    command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For library targets, are header files installed by the `install(TARGETS)` command?
    Why? If not, what can be done to install them as well?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `GNUInstallDirs` CMake module provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you selectively install a directory’s content in a destination directory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we use relative paths when specifying install destination directories?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the essential files required for a `config-file` package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does exporting a target mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you make a CMake project packageable with CPack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the answers to the preceding questions:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be achieved via the `install(TARGETS <``target_name>)` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output artifacts of the specified targets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, because header files are not classified as output artifacts of a target.
    They must be installed separately via the `install(DIRECTORY)` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GNUInstallDirs` CMake module provides system-specific default paths for
    installation, such as `bin`, `lib`, and `include`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the help of the `PATTERN` and `FILES_MATCHING` parameters of the `install(DIRECTORY)`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the installation relocatable so that the user can change the installation
    directory by specifying an installation prefix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `<package-name>-config.cmake` or `<package-name>Config.cmake` file, and
    optionally the `<package-name>-config-version.cmake` or `<``package-name>ConfigVersion.cmake`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exporting a target means creating the required CMake code so that you can import
    it into another CMake project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This can be achieved by including the CPack module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
