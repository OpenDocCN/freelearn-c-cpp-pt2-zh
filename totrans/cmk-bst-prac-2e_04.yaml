- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a CMake Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should be familiar with how to use CMake and its basic concepts,
    such as the two-stage build. So far, we have only looked at how CMake is used
    with code that already exists, but the more interesting part is when it comes
    to building an application using CMake. In this chapter, you will learn how to
    build executables and libraries and how to use them together. We will have an
    in-depth look at creating different kinds of libraries and we will present some
    good practices about how to structure CMake projects. As libraries often come
    with a variety of compiler settings, we will learn how we can set them and pass
    them on to dependent libraries if necessary. Since dependencies in projects can
    get quite complicated, we will also learn how to visualize the dependencies between
    the different targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a “hello world” executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing it together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the previous chapters, all the examples have been tested with CMake
    3.21 and run on one of the following compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: GCC 9 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang 12 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSVC 19 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the examples and source code for this chapter are available in this book’s
    GitHub repository, [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition),
    in the `chapter03` subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although CMake can work with almost any file structure for a project, there
    are some good practices regarding how to organize files. The examples in this
    book follow the following common pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three folders and one file present in a minimal project structure.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build`: The folder where the `build` files and binaries are placed. When checking
    out a fresh project, the build folder is usually not yet present as it will be
    generated by CMake. It is typically named `build`, but it can have any name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include/project_name`: This folder contains all the header files that are
    publicly accessible from outside the project. Adding a subfolder that contains
    the project’s name is helpful since includes are done with `<project_name/somefile.h>`,
    making it easier to figure out which library a header file is coming from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src`: This folder contains all the source and header files that are private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMakeLists.txt`: This is the root CMake file. The `build` folder can be placed
    almost anywhere. Placing it in the project root is just very convenient. However,
    we strongly advise against choosing any non-empty folder as the `build` folder.
    In particular, putting the build/files into either `include` or `src` is considered
    a bad practice. Additional folders such as `test` or `doc` are often present for
    organizing tests and documentation pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with nested projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re nesting projects inside each other, each project should map the
    file structure above and each `CMakeLists.txt` should be written so that the sub-project
    can be built standalone. This means that each `CMakeLists.txt` file of a sub-project
    should specify `cmake_minimum_required` and, optionally, a project definition
    as well. We will cover large projects and superbuilds in depth in [*Chapter* *10*](B30947_10.xhtml#_idTextAnchor158),
    *Handling Distributed Repositories and Dependencies in* *a Super-Build*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested projects look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the folder structure is repeated inside the `subproject` folder. Sticking
    to such a folder structure and making the subproject buildable on its own makes
    it easier to move projects around. It also allows developers to only build parts
    of a project, which can come in handy for big projects where build times may get
    rather long.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the file structure covered, let’s start by creating a simple,
    standalone executable without any special dependencies. Later in this chapter,
    we will create various kinds of libraries and bring them all together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a “hello world” executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create a simple executable from a simple hello world C++ program.
    The following C++ program will print out `Welcome to CMake` `Best Practices`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To build this, we need to compile it and give the executable a name. Let’s
    see what the `CMakeLists.txt` file to build this executable looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the first line, `cmake_minimum_required(VERSION 3.21)`, we tell CMake which
    version of CMake is expected to be used and which features CMake will enable.
    Trying to build this project with a CMake version less than the one specified
    will result in an error. For this book, we are using CMake 3.21 for all the examples,
    but for compatibility reasons, you could select a lower version.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, version 3.1 would be the absolute minimum because, before
    that, the `target_sources` command is not available. It is good practice to put
    the `cmake_minimum_required` command at the top of each `CMakeLists.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the project is set up using the `project()` command. The first argument
    is the project’s name – in our case, `"hello_world_standalone"`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the version of the project is set to version 1.0\. What follows is a brief
    description and the home page’s URL. Finally, the `LANGUAGES CXX` attribute specifies
    that we are building a C++ project. Apart from the project’s name, all the arguments
    are optional.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the `add_executable(hello_world)` command creates a target called `hello_world`.
    This will also be the name of the executable file that’s created by this target.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the target has been created, adding the C++ source files to the target
    is done with `target_sources`. In this case, `hello_world` is the target name,
    as specified in `add_executable`. The `PRIVATE` definition specifies that the
    sources are only used to build this target and are not visible for any dependent
    targets. After the scope specifier, there’s a list of source files that are relative
    to the path of the current `CMakeLists.txt` file. If needed, the location of the
    currently processed `CMakeLists.txt` file can be accessed with the `CMAKE_CURRENT_SOURCE_DIR`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Sources can be added directly to the `add_executable` function or separately
    using the `target_sources` functions. Adding them with `target_sources` allows
    you to explicitly define where the sources can be used by using `PRIVATE`, `PUBLIC`,
    or `INTERFACE`. However, specifying anything other than `PRIVATE` only makes sense
    for library targets. When source files are directly added to the `add_executable`
    command, they are automatically `PRIVATE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common pattern that you often see is naming the main executable of a project
    after the project’s name by using the `PROJECT_NAME` variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While this seems to be convenient at first glance, it is not a good practice.
    The project’s name and the target carry a different semantic meaning, so they
    should be treated as separate things, so using `PROJECT_NAME` as the name for
    targets should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Executables are important and quite easy to create, but unless you’re building
    a huge monolith, libraries are a good way to modularize and distribute code. In
    the next section, we will learn how libraries are built and how to handle different
    linking methods.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a library works similarly to creating an executable, although there
    are a few additional things to consider since library targets are usually used
    by other targets, either in the same project or by other projects. Since libraries
    usually have an internal part and a publicly visible API, we must take this into
    account when adding files to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple project for a library will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, the file starts with setting `cmake_minimum_required` and the project
    information, which should be familiar to you by now.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the target for the library is created with `add_library` – in this case,
    the type of library is not determined. We could pass `STATIC` or `SHARED` instead
    to determine the linking type of the library explicitly. By omitting this, we
    allow any downstream consumers of the library to choose how to build and link
    it. Generally, static libraries are easiest to handle, but have drawbacks regarding
    compile time and modularized distribution. More information about building shared
    libraries can be found in the *Symbol visibility in shared* *libraries* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: If the type of the library is omitted, the `BUILD_SHARED_LIBS` variable determines
    whether the libraries are built as shared or static libraries by default. This
    variable should not be set unconditionally in the `CMakeLists.txt` files of a
    project; it should always be passed on by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally to just defining the library target, it is good practice to also
    define a library alias, which is done with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This creates an alias name called `ch3_hello::hello` that refers to the `hello`
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the sources for the library are added with `target_sources`. The first
    argument is the target name, followed by the sources separated by the `PRIVATE`,
    `PUBLIC`, or `INTERFACE` keyword. In practice, source files are almost always
    added with the `PRIVATE` specifier. The `PRIVATE` and `PUBLIC` keywords specify
    where the sources should be used for compiling. Specifying `PRIVATE` means that
    the sources will only be used in the `hello` target itself. If `PUBLIC` is used,
    then the sources will be added to `hello` and any target that links to `hello`.
    As we mentioned previously, this is not usually desired. The `INTERFACE` keyword
    would mean that the sources are not added to `hello` but should be added to anything
    that links against `hello`. This is usually only the case for headers and not
    for source files. Generally, anything that’s specified as `PRIVATE` for a target
    can be seen as a build requirement for the target. Sources marked as `PUBLIC`
    are build and interface requirements for a target and sources marked as `INTERFACE`
    are interface-only. Finally, the `include` directories for the library are set
    using `target_include_directories`. All the files inside the folders specified
    by this command can be accessed using `#include <file.hpp>` (with the angle brackets)
    instead of `#include ""`, although the version with the quotes may still work.
    The `include` directories follow the same semantics as the source files when it
    comes to `PRIVATE`, `PUBLIC`, and `INTERFACE`.
  prefs: []
  type: TYPE_NORMAL
- en: '`PRIVATE` includes paths that will not be included in the target property,
    `INTERFACE_INCLUDE_DIRECTORIES`. CMake will read this property when targets depend
    on the library to determine which of the `include` directories are visible to
    the dependee.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the C++ code of the library uses features that are tied to a modern version
    of C++, such as C++11/14/17/20 or C++23 (to be released soon), we must set the
    `cxx_std_17` property. Since this standard is necessary to compile the library
    itself and also to interface against the library, it is set to `PUBLIC`. Setting
    it to `PUBLIC` or `INTERFACE` is only necessary if the header files contain code
    that requires a certain standard. If only the internal code is dependent on a
    certain standard, setting it to `PRIVATE` is preferred. Generally, try to set
    the public C++ standard to the lowest that works. It is also possible to only
    enable certain features of one of the modern C++ standards, but this is rather
    uncommon.
  prefs: []
  type: TYPE_NORMAL
- en: A full list of the available compile features can be found at [https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html).
  prefs: []
  type: TYPE_NORMAL
- en: Library aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Library aliases are a way to refer to a library without creating a new build
    target, sometimes referred to as namespaces. A common pattern is to create a library
    alias in the form of `MyProject::Library` for each library that is installed from
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be used to semantically group multiple targets. They also help avoid
    clashes in naming, especially when projects contain common targets such as libraries
    named `utils`, `helpers`, and similar. It is good practice to collect all the
    targets of the same project under the same namespace. When you’re linking libraries
    from other projects, including the namespace prevents you from accidentally including
    a wrong library. It is considered good practice to create an alias with a namespace
    for all libraries to group them so that they can be referenced by their namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In addition to helping with determining the origin of a target, CMake uses namespaces
    to recognize imported targets and create better diagnostic messages, as we will
    see when we look at installing and packaging in [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Packaging, Deploying, and Installing a CMake Project*, as well as in [*Chapter
    5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries**and
    Dependency Management*, where we will cover dependency management.
  prefs: []
  type: TYPE_NORMAL
- en: Always use namespaces
  prefs: []
  type: TYPE_NORMAL
- en: As a good practice, always alias your targets with a namespace and reference
    them using the `namespace::` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, whenever you’re referencing a target from outside of your project,
    use the fully qualified name including the namespace to add them with `target_link_library`.
    While aliases are a way to semantically name the build targets used in CMake,
    they only have limited influence on what the resulting library file is actually
    called when built. But for this, CMake also offers convenient functions to control
    the naming and make sure that libraries conform to the naming conventions of the
    different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Naming libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re creating libraries using `add_library(<name>)`, the name of the
    library must be globally unique inside the project as name collisions are errors.
    By default, the actual filename of the library is constructed according to the
    conventions on the platform, such as `lib<name>.so` on Linux and `<name>.lib`
    or `<name>.dll` on Windows. The name of the file can be changed from the default
    behavior by setting the `OUTPUT_NAME` property of a target. This can be seen in
    the following example, where the name of the output file has been changed from
    `ch3_hello` to `hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Avoid names for libraries with the prefix or postfix of `lib` as CMake may append
    or prepend the appropriate string to the filename, depending on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'A frequently used naming convention for shared libraries is to add the version
    to the filename to specify the build version and API version. By specifying the
    `VERSION` and `SOVERSION` properties for a library target, CMake will create the
    necessary filenames and symbolic links when building and installing the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'On Linux, this example will result in a filename of `libhello.so.1.0.0` with
    symlinks from `libhello.so` and `libhello.so.1` pointing to the actual library
    file. The following screenshot shows the generated file and the symbolic links
    pointing to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The library file and the generated symlinks when building with
    the SOVERSION property](img/B30947_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The library file and the generated symlinks when building with
    the SOVERSION property
  prefs: []
  type: TYPE_NORMAL
- en: Another convention that’s often seen in projects is adding a different postfix
    to the filename for the various build configurations. CMake handles this by setting
    the `CMAKE_<CONFIG>_POSTFIX` global variable to or whatever the convention is
    or adding the `<CONFIG>_POSTFIX` property to the targets. If this variable is
    set, the postfix will be automatically added to non-executable targets. As with
    most global variables, they should be passed to CMake over the command line or
    as a preset rather than hardcoded in the `CMakeLists.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The postfix for debug libraries can also be set explicitly to a single target,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will result in the library file and symlinks being named `libhellod.so`
    when you’re building in the debug configuration. Since linking libraries is done
    over targets rather than filenames in CMake, picking the correct filename happens
    automatically, so we do not have to keep track manually. However, one thing to
    watch out for when linking shared libraries is symbol visibility. We’ll look at
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Symbol visibility in shared libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To link against shared libraries, the linker must know which symbols can be
    used from outside the library. These symbols can be classes, functions, types,
    and more, and the process of making them visible is called exporting.
  prefs: []
  type: TYPE_NORMAL
- en: Compilers have different ways and default behavior when specifying symbol visibility,
    which makes specifying this in a platform-independent way a bit of a hassle. It
    starts with the default visibility of the compilers; GCC and Clang assume that
    all the symbols are visible, while Visual Studio compilers, by default, hide all
    the symbols unless they’re explicitly exported. By setting `CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS`,
    the default behavior of MSVC can be changed, but this is a brute-force approach
    to the problem and can only be used if all the symbols of a library should be
    exported.
  prefs: []
  type: TYPE_NORMAL
- en: While setting all the symbols to publicly visible is an easy way to ensure that
    linking is easy, it has a few downsides.
  prefs: []
  type: TYPE_NORMAL
- en: By exporting everything, there is no way of preventing the use of internal code
    by dependent targets.
  prefs: []
  type: TYPE_NORMAL
- en: Since every symbol can be used by external code, the linker cannot discard dead
    code, so the resulting libraries tend to be bloated. This is especially true if
    the library contains templates, which tend to blow up the number of symbols considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Since every symbol is exported, the only clue about what should be considered
    hidden or internal has to come from the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the internal symbols of a library may expose things that should be
    kept hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Setting all symbols to visible
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when you’re setting all symbols to be visible in a shared library,
    especially when you’re concerned about security issues or when the size of the
    binary is important.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the default visibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change the default visibility of the symbols, set the `<LANG>_VISIBILITY_PRESET`
    property to `HIDDEN`. This property can be set either globally or for a single
    library target. `<LANG>` is substituted for the language that the library is written
    in, such as `CXX` for C++ or `C` for C. If all the symbols are hidden symbols
    to be exported, they must be marked specially in the code. The most common way
    to do this is to specify a preprocessor definition that determines whether a symbol
    is visible or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `HELLO_EXPORT` definition will contain information about whether the symbol
    will be exported when the library is compiled or whether it should be imported
    when you’re linking against the library. GCC and Clang use the `__attribute__(…)`
    keyword to determine this behavior, while on Windows, `_declspec(…)` is used.
    Writing header files that handle this in a cross-platform manner is not an easy
    task, especially if you also have to consider that libraries might be built as
    static and object libraries. Luckily, CMake provides the `generate_export_header`
    macro, which is imported by the `GenerateExportHeader` module, to make this easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the symbols for the `hello` library are set to be
    hidden by default. Then, they are individually enabled again with the use of the
    `generate_export_header` macro, which is imported by the `GenerateExportHeader`
    module. Additionally, this example sets the `VISIBILITY_INLINES_HIDDEN` property
    to `TRUE` to further reduce the export symbol table by hiding inlined class member
    functions. Setting the visibility for inlines is not strictly necessary, but it’s
    often done when the default visibility is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The call to `generate_export_header` creates a file named `export_hello.hpp`
    in the `CMAKE_CURRENT_BINARY_DIR/export/hello` directory that can be included
    in the files of the library. It is good practice to put these generated files
    in a subfolder of the build directory so that only part of the directory is added
    to the `include` path. The `include` structure of the generated files should match
    the `include` structure of the rest of the library. So, if, in this example, all
    the public header files are included by calling `#include <hello/a_public_header.h>`,
    the export header should also be placed in a folder called `hello`. The generated
    file also has to be added to the installation instructions, as explained in [*Chapter
    4*](B30947_04.xhtml#_idTextAnchor071), *Packaging, Deploying, and Installing a
    CMake Project*. Additionally, to create the export file, the necessary compiler
    flags for exporting the symbols must be set to the target.
  prefs: []
  type: TYPE_NORMAL
- en: Since the generated header file must be included in the files that declare the
    classes, functions, and types to be exported, `CMAKE_CURRENT_BINARY_DIR/export/`
    is added to `target_include_directories`. Note that this has to be `PUBLIC` so
    that dependent libraries can find the file as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more options regarding the `generate_export_header` macros, but
    what we have seen in this section covers the majority of use cases. Additional
    information about setting symbol visibility can be retrieved from the official
    CMake documentation at [https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html](https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html).
  prefs: []
  type: TYPE_NORMAL
- en: Interface or header-only libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Header-only libraries are a bit special as they are not compiled; instead, they
    export their headers so that they’re directly included in other libraries. In
    most aspects, header-only libraries work like normal libraries, but their header
    files are exposed using the `INTERFACE` keyword, rather than the `PUBLIC` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since header-only libraries do not need to be compiled, they do not add sources
    to the targets. The following code creates a minimal header-only library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is also worth noting that before CMake version `3.19`, the `INTERFACE` libraries
    could not have any `target_sources` added. Now, header-only libraries can have
    sources listed, but it is rarely used
  prefs: []
  type: TYPE_NORMAL
- en: Object libraries – for internal use only
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you may want to split off code so that parts of it can be reused
    without the need to create a full-blown library. A common practice is when you
    want to use some code in an executable and unit tests, without the need to recompile
    everything twice.
  prefs: []
  type: TYPE_NORMAL
- en: For this, CMake provides object libraries, where the sources are compiled, but
    not archived or linked. An object library is created by calling `add_library(MyLibrary
    OBJECT)`.
  prefs: []
  type: TYPE_NORMAL
- en: Since CMake 3.12, these objects can be used like normal libraries by adding
    them to `target_link_libraries` functions. Before version 3.12, object libraries
    needed to be added with a generator expression; that is, `$<TARGET_OBJECTS:MyLibrary>`.
    This expands to a list of objects during build system generation. This can still
    be done, but it is no longer recommended as it quickly becomes unmaintainable,
    especially if there are multiple object libraries in a project.
  prefs: []
  type: TYPE_NORMAL
- en: When to use object libraries
  prefs: []
  type: TYPE_NORMAL
- en: Object libraries help speed up building and modularizing code without making
    the modules public.
  prefs: []
  type: TYPE_NORMAL
- en: With object libraries, all the different types of libraries are covered. Libraries
    on their own are fun to write and maintain, but unless they are integrated into
    a bigger project, they do not do anything. So, let’s see how all the libraries
    we’ve defined so far can be used in an executable.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it together – using your libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created three different libraries – a binary library to be linked
    either statically or dynamically, an interface or header-only library, and a precompiled
    but not linked object library.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to use them in an executable in a shared project. Installing
    them as system libraries or using them as external dependencies will be covered
    in [*Chapter 5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries*
    *and* *Dependency Management*.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can either put the `add_library` calls in the same `CMakeLists.txt` file
    or we can integrate them by using `add_subdirectory`. Both are valid options and
    depend on how the project is set up, as described in the *Setting up a project*
    and *Working with nested projects* sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we’re assuming that three libraries have been defined
    with `CMakeLists.txt` files in the `hello_lib`, `hello_header_only`, and `hello_object`
    directories. These libraries can be included using the `add_subdirectory` command.
    Here, a new target called `chapter3`, which is our executable, is created. Then,
    the libraries are added to the executable by `target_link_libraries`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The target of `target_link_libraries` can either be an executable or another
    library. Again, the libraries are linked using an access specifier, which is either
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PRIVATE`: The library is used to link against, but it is not a part of the
    public interface. The linked library is only a requirement when you’re building
    the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTERFACE`: The library is not linked against, but it is part of the public
    interface. The linked library is a requirement when you’re using the target somewhere
    else. This is usually only used when you’re linking header-only libraries from
    other header-only libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUBLIC`: The library is linked against, and it is part of the public interface.
    So, the library is both a build dependency and a usage dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attention – bad practices
  prefs: []
  type: TYPE_NORMAL
- en: The following practices are actively discouraged by the authors of this book
    as they tend to create unmaintainable projects that make it hard to port between
    different build environments. However, we have included them for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of passing another target after `PUBLIC`, `PRIVATE`, or `INTERFACE`,
    you can also pass full paths to libraries or the filename of a library, such as
    `/usr/share/lib/mylib.so` or just `mylib.so`. These practices are possible but
    discouraged as they make the CMake project less portable. Additionally, it is
    possible to pass linker flags here by passing something such as `-nolibc`, though
    again, this is discouraged. If special linker flags are needed for all the targets,
    then passing them using the command line is the preferred way. If a single library
    needs special flags, then using `target_link_options` is the preferred way to
    do this, preferably in combination with the options that are set over the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at setting compiler and linker options.
  prefs: []
  type: TYPE_NORMAL
- en: Setting compiler and linker options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ compilers have lots of options regarding some of the most common flags
    to be set and it is also a common practice to set preprocessor definitions from
    the outside. In CMake, these are passed using the `target_compile_options` command.
    Changing linker behavior is done with the `target_link_options` command. Unfortunately,
    compilers and linkers may have different ways of how flags are set. For instance,
    in GCC and Clang, options are passed with a dash (`-`), while the Microsoft compiler
    takes slashes (`/`) as prefixes for its options. But by using generator expressions,
    which we covered in [*Chapter 1*](B30947_01.xhtml#_idTextAnchor015), *Kickstarting
    CMake*, this can be conveniently handled in CMake, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at the generator expression in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`$<$<CXX_COMPILER_ID:MSVC>:/SomeOption>` is a nested generator expression that
    is evaluated inside out. Generator expressions are evaluated during build system
    generation. First, `$<CXX_COMPILER_ID:MSVC>` evaluates to `true` if the C++ compiler
    equals `MSVC`. If this is the case, then the outer expression will return `/SomeOption`,
    which is then passed to the compiler. If the inner expression evaluates to `false`,
    then nothing is passed on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$<$<CXX_COMPILER_ID:GNU,Clang,AppleClang>:-fopenmp>` works similarly, but
    instead of just checking against a single value, a list containing `GNU,Clang,AppleClang`
    is passed. If `CXX_COMPILER_ID` matches either of these, the inner expression
    evaluates to `true` and `someOption` is passed to the compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing compiler or linker options as `PRIVATE` marks them as a build requirement
    for this target that is not needed for interfacing the library. If `PRIVATE` is
    substituted with `PUBLIC`, then the compile option also becomes a usage requirement
    and all the targets that depend on the original targets will use the same compiler
    options. Exposing compiler options to the dependent targets is something that
    needs to be done with caution. If a compiler option is only needed to use a target
    but not to build it, then `keyword INTERFACE` can be used. This is mostly the
    case when you’re building header-only libraries.
  prefs: []
  type: TYPE_NORMAL
- en: A special case of compiler options is preprocessor or compile definitions, which
    are passed to the underlying program. These are passed with the `target_compile_definitions`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging compiler options with compilation databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see all the compile options, you can look at the generated build files, such
    as Makefiles or Visual Studio projects. A much more convenient way is to let CMake
    export all the compile commands as a JSON compilation database.
  prefs: []
  type: TYPE_NORMAL
- en: By enabling the `CMAKE_EXPORT_COMPILE_COMMANDS` variable, a file called `compile_commands.json`
    containing the full commands for compiling is created in the `build` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling this option and running CMake will produce results similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note the addition of the manually specified `-fopenMP` flag from the previous
    example. `compile_commands.json` can be used as a build-system-agnostic way to
    load the commands. Some IDEs, such as VS Code and Clion, can interpret the JSON
    file and generate project information themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The full specifications of the compile commands database can be found at [https://clang.llvm.org/docs/JSONCompilationDatabase.html](https://clang.llvm.org/docs/JSONCompilationDatabase.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more and more tools out there that use the `compile_commands.json`
    database to figure out the exact compilation options passed on, so a lot of projects
    turn the creation on by default. Notably, most tools from LLVM, such as the `clang-tidy`
    linter or `clangd` for code completion, benefit a lot from having access to the
    compilation database. It also often comes in handy for debugging compiler options
    in case something does not work as expected: [https://clang.llvm.org/docs/JSONCompilationDatabase.html](https://clang.llvm.org/docs/JSONCompilationDatabase.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve completed this chapter, you’re ready to create applications
    and libraries with CMake and start building more complex projects than just “hello
    world.” You have learned how to link different targets together and how compiler
    and linker options can be passed to targets. We also covered object libraries
    for internal use only and discussed symbol visibility for shared libraries. Finally,
    you learned how to document these dependencies automatically so that you have
    an overview of large projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to package and install your applications
    and libraries on different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the CMake command for creating an executable target?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the CMake command for creating a library target?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you specify whether a library is statically or dynamically linked?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is special about object libraries and where do they come in handy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you specify the default symbol visibility for shared libraries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are compiler options specified for a target and how can you see the compile
    commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CMake command for creating an executable target is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`add_executable`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The CMake command for creating a library target is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`add_library`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By adding the `SHARED` or `STATIC` keyword or by setting the `BUILD_SHARED_LIBS`
    global variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object libraries are libraries that are compiled but not linked. They are useful
    for internally separating code and reducing compile time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By globally setting the `<``LANG>_VISIBILITY_PRESET` property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By calling the `target_compile_options` function. The compile options can be
    seen in the `compile_commands.json` file, which is generated if the `CMAKE_EXPORT_COMPILE_COMMANDS`
    variable is set to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
