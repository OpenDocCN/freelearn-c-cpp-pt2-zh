- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing and Packaging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our project has been built, tested, and documented. Now, it’s finally time
    to release it to our users. This chapter primarily focuses on the final two steps
    we need to take: installation and packaging. These are advanced techniques that
    build on top of everything we’ve learned so far: managing targets and their dependencies,
    transient usage requirements, generator expressions, and much more.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Installation allows our project to be discoverable and accessible system-wide.
    We will cover how to export targets for use by other projects without needing
    installation and how to install our projects for easy system-wide accessibility.
    We’ll learn how to configure our project to automatically place various artifact
    types in their appropriate directories. To handle more advanced scenarios, we’ll
    introduce low-level commands for installing files and directories, as well as
    for executing custom scripts and CMake commands.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll explore setting up reusable CMake packages that other projects
    can discover using the `find_package()` command. We’ll explain how to ensure that
    targets and their definitions are not restricted to a specific file system location.
    We’ll also discuss how to write basic and advanced **config files**, along with
    the **version files** associated with packages. Then, to make things modular,
    we’ll briefly introduce the concept of components, both in terms of CMake packages
    and the `install()` command. All this preparation will pave the way for the final
    aspect we’ll be covering in this chapter: using CPack to generate archives, installers,
    bundles, and packages that are recognized by all kinds of package managers in
    different operating systems. These packages can distribute pre-built artifacts,
    executables, and libraries. It’s the easiest way for end users to start using
    our software.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Exporting without installation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing projects on the system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging with CPack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch14](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch14).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install examples, use the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Exporting without installation
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we make the targets of project `A` available to the consuming project,
    `B`? Usually, we’d use the `find_package()` command, but that requires creating
    a package and installing it on the system. While useful, this approach involves
    some work. Sometimes, we just need a quick way to build a project and make its
    targets available for other projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'One time-saving method is to include in project `B` the main listfile of `A`,
    which already contains all the target definitions. However, this file might also
    include global configuration, CMake commands with side effects, additional dependencies,
    and perhaps unwanted targets for `B` (like unit tests). So, this is not the best
    approach. Instead, we can provide a **target export file** for the consuming project,
    `B`, to include with the `include()` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will define all targets of `A` with the correct properties set, using commands
    such as `add_library()` and `add_executable()`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'You must specify all targets to export after the `TARGETS` keyword and provide
    the destination filename after `FILE`. The other arguments are optional:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the explanation of the individual arguments:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '`NAMESPACE` is recommended to indicate that the target has been imported from
    other projects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APPEND` prevents CMake from erasing the file’s contents before writing.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPORT_LINK_INTERFACE_LIBRARIES` exports target link dependencies (including
    imported and config-specific variants).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s apply this exporting method to the `Calc` library example, which provides
    two simple methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/01-export/src/include/calc/basic.h**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to declare the `Calc` target so we have something to export:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/01-export/src/CMakeLists.txt**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, to generate the export file, we are using the `export(TARGETS)` command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/01-export/CMakeLists.txt (fragment)**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our exported target declaration file will be located in the `cmake` subdirectory
    of the build tree (following the convention for `.cmake` files). To avoid repeating
    this path later, we’re setting it in the `EXPORT_DIR` variable. Then, we call
    `export()` to generate the target declaration file, `CalcTargets.cmake`, with
    the `calc` target. For projects including this file, it will be visible as `Calc::calc`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Note that this export file isn’t *a package* yet. More importantly, all paths
    in this file are absolute and hardcoded to the build tree, making them non-relocatable
    (discussed in the *Understanding the issues with relocatable targets* section).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The `export()` command also has a shorter version using the `EXPORT` keyword:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, it requires the name of a predefined export rather than a list of exported
    targets. Such `<export>` instances are named lists of targets that are created
    by `install(TARGETS)` (we’ll cover this command in the *Installing logical targets*
    section).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a tiny example demonstrating how this shorthand is used in practice:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/01-export/CMakeLists.txt (continued)**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code works similarly to the previous example, but now it shares a single
    target list between the `export()` and `install()` commands.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Both methods of generating export files yield similar results. They include
    some boilerplate code and a few lines defining the target. With `<build-tree>`
    set to the build tree path, they’ll create a **target export file** similar to
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**<build-tree>/cmake/CalcTargets.cmake (fragment)**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Normally, we wouldn’t edit or even open this file, but it’s important to note
    that the paths will be hardcoded in it (see the highlighted lines). In its current
    form, the built project isn’t relocatable. To change that, some additional steps
    are required. In the next section, we’ll explain what relocation is and why it
    is important.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Installing projects on the system
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *First Steps with CMake*, we indicated that CMake offers a
    command-line mode for installing built projects on the system:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, `<dir>` is the path to the generated build tree (required). The `<options>`
    include:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`--config <cfg>`: This selects the build configuration for multi-configuration
    generators.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--component <comp>`: This limits the installation to the given component.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--default-directory-permissions <permissions>`: This sets the default permissions
    for the installed directories (in `<u=rwx,g=rx,o=rx>` format).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--install-prefix <prefix>`: This specifies the non-default installation path
    (stored in the `CMAKE_INSTALL_PREFIX` variable). It defaults to `/usr/local` on
    Unix-like systems and to `c:/Program Files/${PROJECT_NAME}` on Windows. Before
    CMake 3.21, you’ll have to use a less-explicit option: `--prefix <prefix>`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v, --verbose`: This increases the verbosity of the output (achievable also
    by setting the `VERBOSE` environment variable).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installations typically involve copying generated artifacts and necessary dependencies
    to a system directory. Using CMake introduces a convenient installation standard
    to all CMake projects and offers several additional benefits:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: It provides platform-specific installation paths for artifacts, depending on
    their types (by following *GNU coding standards*).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enhances the installation process by generating target export files, allowing
    direct reuse of project targets by other projects.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates discoverable packages through **config files**, wrapping the target
    export files and package-specific CMake macros and functions defined by the author.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These features are quite powerful as they save a lot of time and simplify the
    usage of projects that are prepared this way. The first step in performing a basic
    installation is copying the built artifacts to their destination directory. This
    brings us to the `install()` command and its various modes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '`install(``TARGETS)`: This installs output artifacts such as libraries and
    executables.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(FILES|PROGRAMS)`: This installs individual files and sets their permissions.
    These files don’t need to be part of any logical targets.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(DIRECTORY)`: This installs entire directories.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(SCRIPT|CODE)`: This runs a CMake script or a snippet during installation.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(EXPORT)`: This generates and installs a target export file.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(RUNTIME_DEPENDENCY_SET <set-name> [...])`: This installs runtime dependency
    sets defined in the project.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(IMPORTED_RUNTIME_ARTIFACTS <target>... [...])`: This queries imported
    targets for runtime artifacts and installs them.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding these commands to your listfile generates a `cmake_install.cmake` file
    in your build tree. While it’s possible to manually invoke this script with `cmake
    -P`, this is not recommended. The file is intended for internal use by CMake when
    `cmake --install` is executed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `install()` mode has a comprehensive set of options, with a few shared
    across modes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`DESTINATION`: This specifies the installation path. Relative paths are prepended
    with `CMAKE_INSTALL_PREFIX`, while absolute paths are used verbatim (and not supported
    by `cpack`).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PERMISSIONS`: This sets file permissions on supported platforms. The available
    values include `OWNER_READ`, `OWNER_WRITE`, `OWNER_EXECUTE`, `GROUP_READ`, `GROUP_WRITE`,
    `GROUP_EXECUTE`, `WORLD_READ`, `WORLD_WRITE`, `WORLD_EXECUTE`, `SETUID`, and `SETGID`.
    Default directory permissions created during installation time can be set with
    the `CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS` variable.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIGURATIONS`: This specifies configurations (`Debug`, `Release`). Options
    following this keyword apply only if the current build configuration is in the
    list.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONAL`: This prevents errors when the installed files don’t exist.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two shared options, `COMPONENT` and `EXCLUDE_FROM_ALL`, are used in component-specific
    installations. These will be discussed in the *Defining components* section later
    in the chapter. For now, let’s take a look at the first installation mode: `install(TARGETS)`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Installing logical targets
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Targets defined by `add_library()` and `add_executable()` can easily be installed
    with the `install(TARGETS)` command. This means copying the artifacts that have
    been produced by the buildsystem to the appropriate destination directories and
    setting suitable file permissions for them. The general signature for this mode
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After the initial mode specifier, that is, `TARGETS`, we must provide a list
    of targets we’d like to install. Here, we may optionally assign them to a **named
    export** with the `EXPORT` option, which can be used in `export(EXPORT)` and `install(EXPORT)`
    to produce a target export file. Then, we must configure the installation of output
    artifacts (grouped by type). Optionally, we can provide a list of directories
    that will be added to the target export file for each target in its `INTERFACE_INCLUDE_DIRECTORIES`
    property.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`[<output-artifact-configuration>...]` provides a list of configuration blocks.
    The full syntax of a single block is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The command mandates that every output artifact block starts with `<TYPE>`
    (this is the only required element). CMake recognizes several of them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`ARCHIVE`: Static libraries (`.a`) and DLL import libraries for Windows-based
    systems (`.lib`).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIBRARY`: Shared libraries (`.so`), but not DLLs.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNTIME`: Executables and DLLs.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBJECTS`: *Object files* from `OBJECT` libraries.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FRAMEWORK`: Static and shared libraries that have the `FRAMEWORK` property
    set (this excludes them from `ARCHIVE` and `LIBRARY`). This is macOS-specific.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUNDLE`: Executables marked with `MACOSX_BUNDLE` (also not part of `RUNTIME`).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILE_SET <set>`: Files in the `<set>` file set specified for the target. Either
    C++ header files or C++ module headers (since CMake 3.23).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUBLIC_HEADER`, `PRIVATE_HEADER`, `RESOURCE`: Files specified in the target
    properties with the same name (on Apple platforms, they should be set on the `FRAMEWORK`
    or `BUNDLE` targets).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CMake documentation claims that if you only configure one artifact type
    (for example, `LIBRARY`), only this type will be installed. For CMake version
    3.26.0, this is not true: all the artifacts will be installed as if they were
    configured with the default options. This can be solved by specifying `<TYPE>
    EXCLUDE_FROM_ALL` for all unwanted artifact types.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: A single `install(TARGETS)` command can have multiple artifact configuration
    blocks. However, be aware that you may only specify one of each type per call.
    That is, if you’d like to configure different destinations of `ARCHIVE` artifacts
    for the `Debug` and `Release` configurations, then you must make two separate
    `install(TARGETS ... ARCHIVE)` calls.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also omit the type name and specify options for all the artifacts.
    Installation would then be then performed for every file that’s produced by these
    targets, regardless of their type:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In many cases, you don’t need to provide the `DESTINATION` explicitly, thanks
    to the built-in defaults, but there are a few caveats to keep in mind when dealing
    with different platforms.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the default destination for different platforms
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When CMake installs your project’s files, it copies them into a specific directory
    in the system. Different file types belong in different directories. This directory
    is determined by the following formula:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As mentioned in the previous section, you can explicitly provide the `DESTINATION`
    component for installation, or let CMake use a built-in default based on the type
    of the artifact:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '| **Artifact type** | **Built-in default** | **Install directory variable**
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `RUNTIME` | `bin` | `CMAKE_INSTALL_BINDIR` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `LIBRARY``ARCHIVE` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `PUBLIC_HEADER``PRIVATE_HEADER``FILE_SET` (`type` `HEADERS`) | `include`
    | `CMAKE_INSTALL_INCLUDEDIR` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: 'Table 14.1: Default destinations per artifact type'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: While default paths are useful, they aren’t always appropriate. For example,
    CMake defaults the `DESTINATION` for libraries to `lib`. The full path for libraries
    is then computed as `/usr/local/lib` for Unix-like systems and something like
    `C:\Program Files (x86)\<project-name>\lib` on Windows. However, this is not ideal
    for Debian with multi-arch support, which requires an architecture-specific path
    (e.g., `i386-linux-gnu`) when `INSTALL_PREFIX` is `/usr`. Determining the correct
    path for each platform is a common challenge for Unix-like systems. To address
    this, follow the *GNU Coding Standards*, the link to which is added in the *Further
    reading* section at the end of this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We can override the default destinations for each value by setting a `CMAKE_INSTALL_<DIRTYPE>DIR`
    variable. Instead of developing an algorithm to detect the platform and assign
    appropriate paths to the install directory variables, use the CMake `GNUInstallDirs`
    utility module. This module handles most platforms by setting the install directory
    variables accordingly. Just include it using `include()` before any `install()`
    commands, and you’ll be set.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Users needing custom configurations can override the install directory variables
    via the command-line argument like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, installing the public headers of libraries still presents challenges.
    Let’s explore why.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with public headers
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When managing public headers in CMake, it’s best practice to store them in
    a directory that indicates their origin and introduces namespacing, such as `/usr/local/include/calc`.
    This enables their use in C++ projects with the inclusion directive:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Most preprocessors interpret angle-bracketed directives as requests to scan
    standard system directories. We can use the `GNUInstallDirs` module to automatically
    populate the `DESTINATION` part of the installation path, ensuring headers end
    up in the `include` directory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Since CMake 3.23.0, we can explicitly add headers to be installed to the appropriate
    target with the `target_sources()` command and the `FILE_SET` keyword. This method
    is preferred, as it takes care of the *relocation* of headers. Here’s the syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Assuming our headers are in the `src/include/calc` directory, here’s a practical
    example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/02-install-targets/src/CMakeLists.txt (fragment)**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Having defined the file set, we can use it in the installation command like
    so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/02-install-targets/src/CMakeLists.txt (continued)**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We include the `GNUInstallDirs` module and configure the installation of the
    `calc` static library and its headers. Running `cmake` in install mode works as
    expected:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Support for the `FILE_SET HEADERS` keyword is a relatively recent update, and
    unfortunately, not all environments will provide the newer version of CMake**.**
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re stuck on a version older than 3.23, you’ll need to specify public
    headers (as a semicolon-separated list) in the `PUBLIC_HEADER` property of the
    library target, and deal with the relocation manually (more on this in the *Understanding
    the issues with relocatable targets* section):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/03-install-targets-legacy/src/CMakeLists.txt (fragment)**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You’ll also need to change the destination directory to include the library
    name in the `include` path:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/02-install-targets-legacy/src/CMakeLists.txt (continued)**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Explicitly inserting `/calc` in the path is necessary because files specified
    in the `PUBLIC_HEADER` property don’t retain their directory structure. They will
    all be installed in the same destination, even if nested in different base directories.
    This significant drawback led to the development of `FILE_SET`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how to address most installation cases, but how should you approach
    more advanced scenarios?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Low-level installation
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modern CMake is moving away from directly manipulating files. Ideally, we should
    add files to a logical target, using it as a higher level of abstraction to represent
    all underlying assets: source files, headers, resources, configuration, and so
    on. The main advantage is the code’s dryness; usually, adding a file to the target
    requires changing no more than one line.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, adding every installed file to a target isn’t always possible
    or convenient. In such cases, three options are available: `install(FILES)`, `install(PROGRAMS)`,
    and `install(DIRECTORY)`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Installing with install(FILES) and install(PROGRAMS)
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `FILES` and `PROGRAMS` modes are very similar. They can be used to install
    various assets, including public header files, documentation, shell scripts, configuration,
    and runtime assets like images, audio files, and datasets.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the command signature:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The main difference between `FILES` and `PROGRAMS` is the default file permissions
    set on the copied files. `install(PROGRAMS)` sets `EXECUTE` for all users, whereas
    `install(FILES)` does not (though both will set `OWNER_WRITE`, `OWNER_READ`, `GROUP_READ`,
    and `WORLD_READ`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: You can modify this behavior by using the optional `PERMISSIONS` keyword, and
    then choosing the leading keyword (`FILES` or `PROGRAMS`) as an indicator of what’s
    installed. We’ve already covered how `PERMISSIONS`, `CONFIGURATIONS`, and `OPTIONAL`
    work. `COMPONENT` and `EXCLUDE_FROM_ALL` will be discussed later in the *Defining
    components* section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: After the initial keyword, we need to list all the files we want to install.
    CMake supports relative and absolute paths, as well as generator expressions.
    Remember that if your file path starts with a generator expression, it must be
    absolute.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The next required keyword is `TYPE` or `DESTINATION`. You can either explicitly
    provide the `DESTINATION` path or ask CMake to look it up for a specific `TYPE`
    file. Unlike in `install(TARGETS)`, `TYPE` in this context does not select any
    subset of the provided files to be installed. Nevertheless, the computation of
    the installation path follows the same pattern (where the `+` symbol denotes a
    platform-specific path separator):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必需的关键字是 `TYPE` 或 `DESTINATION`。你可以显式地提供 `DESTINATION` 路径，也可以要求 CMake 查找特定
    `TYPE` 文件的路径。与 `install(TARGETS)` 中不同，在此上下文中，`TYPE` 并不选择任何要安装的文件子集。不过，安装路径的计算遵循相同的模式（其中
    `+` 符号表示平台特定的路径分隔符）：
- en: '`${CMAKE_INSTALL_PREFIX} + ${DESTINATION}`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`${CMAKE_INSTALL_PREFIX} + ${DESTINATION}`'
- en: 'Similarly, every `TYPE` will have built-in defaults:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，每个 `TYPE` 都有内置的默认值：
- en: '| **File Type** | **Built-In Default** | **Installation Directory Variable**
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **文件类型** | **内置默认值** | **安装目录变量** |'
- en: '| `BIN` | `bin` | `CMAKE_INSTALL_BINDIR` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `BIN` | `bin` | `CMAKE_INSTALL_BINDIR` |'
- en: '| `SBIN` | `sbin` | `CMAKE_INSTALL_SBINDIR` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `SBIN` | `sbin` | `CMAKE_INSTALL_SBINDIR` |'
- en: '| `LIB` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `LIB` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
- en: '| `INCLUDE` | `include` | `CMAKE_INSTALL_INCLUDEDIR` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `INCLUDE` | `include` | `CMAKE_INSTALL_INCLUDEDIR` |'
- en: '| `SYSCONF` | `etc` | `CMAKE_INSTALL_SYSCONFDIR` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `SYSCONF` | `etc` | `CMAKE_INSTALL_SYSCONFDIR` |'
- en: '| `SHAREDSTATE` | `com` | `CMAKE_INSTALL_SHARESTATEDIR` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `SHAREDSTATE` | `com` | `CMAKE_INSTALL_SHARESTATEDIR` |'
- en: '| `LOCALSTATE` | `var` | `CMAKE_INSTALL_LOCALSTATEDIR` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `LOCALSTATE` | `var` | `CMAKE_INSTALL_LOCALSTATEDIR` |'
- en: '| `RUNSTATE` | `$LOCALSTATE/run` | `CMAKE_INSTALL_RUNSTATEDIR` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `RUNSTATE` | `$LOCALSTATE/run` | `CMAKE_INSTALL_RUNSTATEDIR` |'
- en: '| `DATA` | `$DATAROOT` | `CMAKE_INSTALL_DATADIR` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `DATA` | `$DATAROOT` | `CMAKE_INSTALL_DATADIR` |'
- en: '| `INFO` | `$DATAROOT/info` | `CMAKE_INSTALL_INFODIR` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | `$DATAROOT/info` | `CMAKE_INSTALL_INFODIR` |'
- en: '| `LOCALE` | `$DATAROOT/locale` | `CMAKE_INSTALL_LOCALEDIR` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `LOCALE` | `$DATAROOT/locale` | `CMAKE_INSTALL_LOCALEDIR` |'
- en: '| `MAN` | `$DATAROOT/man` | `CMAKE_INSTALL_MANDIR` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `MAN` | `$DATAROOT/man` | `CMAKE_INSTALL_MANDIR` |'
- en: '| `DOC` | `$DATAROOT/doc` | `CMAKE_INSTALL_DOCDIR` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `DOC` | `$DATAROOT/doc` | `CMAKE_INSTALL_DOCDIR` |'
- en: 'Table 14.2: Built-in defaults per file type'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.2：每种文件类型的内置默认值
- en: 'The behavior here follows the same principle that was described in the *Utilizing
    the default destination for different platforms* subsection: if no installation
    directory variable for this `TYPE` of file is set, CMake will provide a built-in
    default path. Again, for portability, we can use the `GNUInstallDirs` module.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的行为遵循在 *利用不同平台的默认目标* 小节中描述的相同原则：如果没有为该 `TYPE` 文件设置安装目录变量，CMake 将提供一个内置的默认路径。同样，为了便于移植，我们可以使用
    `GNUInstallDirs` 模块。
- en: 'Some of the built-in guesses in the table are prefixed with installation directory
    variables:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的一些内置猜测以安装目录变量为前缀：
- en: '`$LOCALSTATE` is `CMAKE_INSTALL_LOCALSTATEDIR` or defaults to `var`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$LOCALSTATE` 是 `CMAKE_INSTALL_LOCALSTATEDIR`，或者默认为 `var`'
- en: '`$DATAROOT` is `CMAKE_INSTALL_DATAROOTDIR` or defaults to `share`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$DATAROOT` 是 `CMAKE_INSTALL_DATAROOTDIR`，或者默认为 `share`'
- en: 'As with `install(TARGETS)`, the `GNUInstallDirs` module will provide platform-specific
    installation directory variables. Let’s look at an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `install(TARGETS)` 一样，`GNUInstallDirs` 模块将提供平台特定的安装目录变量。我们来看一个示例：
- en: '**ch14/04-install-files/CMakeLists.txt**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/04-install-files/CMakeLists.txt**'
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, CMake installs the two header-only libraries, `basic.h` and `nested/calc_extended.h`,
    into the project-specific subdirectory within the system-wide `include directory`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，CMake 将这两个仅包含头文件的库 `basic.h` 和 `nested/calc_extended.h` 安装到系统范围的 `include`
    目录下的项目特定子目录中。
- en: From the `GNUInstallDirs` source, we know that `CMAKE_INSTALL_INCLUDEDIR` is
    the same for all supported platforms. However, using it is still recommended for
    readability and consistency with more dynamic variables. For instance, `CMAKE_INSTALL_LIBDIR`
    varies by architecture and distribution – `lib`, `lib64`, or `lib/<multiarch-tuple>`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `GNUInstallDirs` 源代码中，我们知道 `CMAKE_INSTALL_INCLUDEDIR` 对所有支持的平台都是相同的。然而，仍然推荐使用它以提高可读性，并与更动态的变量保持一致。例如，`CMAKE_INSTALL_LIBDIR`
    会根据架构和发行版有所不同 —— `lib`、`lib64` 或 `lib/<multiarch-tuple>`。
- en: Since CMake 3.20, you can use the `RENAME` keyword with the `install(FILES)`
    and `install(PROGRAMS)` commands. This keyword has to be followed by a new filename
    and only works if the command installs a single file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从 CMake 3.20 开始，你可以在 `install(FILES)` 和 `install(PROGRAMS)` 命令中使用 `RENAME` 关键字。该关键字后面必须跟一个新文件名，并且只有在命令安装单个文件时才有效。
- en: 'The example in this section demonstrates the ease of installing files in the
    appropriate directory. However, there’s one issue – observe the installation output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例演示了将文件安装到合适目录的简便性。然而，有一个问题 —— 请观察安装输出：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Both files are installed in the same directory, regardless of their original
    nesting. Sometimes, this isn’t desirable. In the next section, we’ll explore how
    to handle this situation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Working with entire directories
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If adding individual files to your installation command isn’t suitable, you
    can opt for a broader approach and work with entire directories. The `install(DIRECTORY)`
    mode is designed for this, copying the specified directories verbatim to the chosen
    destination. Here’s how it looks:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Many options here are similar to those in `install(FILES)` and `install(PROGRAMS)`
    and function in the same manner. One key detail is that if the paths provided
    after the `DIRECTORY` keyword don’t end with `/`, the last directory of the path
    is appended to the destination. For example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This command creates a directory, `/xxx/aaa`, and copies the contents of `aaa`
    to it. In contrast, the following command copies the contents of `aaa` directly
    to `/xxx`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`install(DIRECTORY)` also introduces other mechanisms that are not available
    for files:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Output silencing
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended permission control
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File/directory filtering
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the output silencing option, `MESSAGE_NEVER`. It disables output
    diagnostics during installation. It is very useful when we have many files in
    the directories we’re installing and it would be too noisy to print them all.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding permissions, `install(DIRECTORY)` supports three options:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`USE_SOURCE_PERMISSIONS` sets the permissions on installed files that follow
    the original files. This only works when `FILE_PERMISSIONS` is not set.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILE_PERMISSIONS` allows us to specify the permissions we want to set on installed
    files and directories. The default permissions are `OWNER_WRITE`, `OWNER_READ`,
    `GROUP_READ`, and `WORLD_READ`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DIRECTORY_PERMISSIONS` works similarly to `FILE_PERMISSIONS`, but it will
    set additional `EXECUTE` permissions for all users (this is because `EXECUTE`
    on directories in Unix-like systems denotes permission to list their contents).'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that CMake ignores permissions options on platforms that don’t support
    them. More nuanced permission control is achievable by adding the `PERMISSIONS`
    keyword after each filtering expression. Files or directories matched by this
    will receive the specified permissions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk about filters or “globbing” expressions. They control which files/directories
    from source directories are installed and follow this syntax:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are two matching methods to choose from:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: With `PATTERN`, which is the simpler option, you can provide a pattern with
    the `?` placeholders (matching any character) and the `*` wildcards (matching
    any string). Only paths that end with `<pat>` will be matched.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `REGEX` option is more advanced, supporting regular expressions. It allows
    the matching of any part of the path, although the `^` and `$` anchors can still
    denote the beginning and end of the path.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the `FILES_MATCHING` keyword can be set before the first filter,
    specifying that the filters will apply to files and not directories.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember two caveats:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '`FILES_MATCHING` requires an inclusive filter. You may exclude some files,
    but no files will be copied unless you also include some. However, all directories
    will be created, regardless of filtering.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All subdirectories are included by default; you can only filter out.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each filter method, you can choose to exclude matched paths with the `EXCLUDE`
    command (this only works when `FILES_MATCHING` isn’t used).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific permissions for all matched paths can be set by adding the `PERMISSIONS`
    keyword and a list of desired permissions after any filter. Let’s explore this
    with an example where we install three directories in different ways. We have
    some static data files for runtime use:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need some public headers located in the `src` directory among other
    unrelated files:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we need two configuration files at two levels of nesting. To make
    things more interesting, we’ll make `/etc/calc/` contents accessible only to the
    file owner:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To install the directory with static data files, we start our project with
    the most basic form of the `install(DIRECTORY)` command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command will simply take all the contents of our `data` directory and put
    it in `${CMAKE_INSTALL_PREFIX}` and `share/calc`. Note that our source path ends
    with a `/` symbol to indicate we don’t want to copy the `data` directory itself,
    only its contents.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case is the opposite: we don’t add the trailing `/` because the
    directory should be included. This is because we’re relying on a system-specific
    path for the `INCLUDE` file type, which is provided by `GNUInstallDirs` (note
    how the `INCLUDE` and `EXCLUDE` keywords represent unrelated concepts):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Additionally, we have excluded two paths from this operation: the entire `ignored`
    directory and all files ending with `calc_extended.h` (remember how `PATTERN`
    works).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'The third case installs some default configuration files and sets their permissions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We avoid appending `etc` from the source path to the `SYSCONF` path (as `GNUInstallDirs`
    has already provided this) to prevent duplication. We set two permission rules:
    subdirectories are editable and listable only by the owner, and files ending with
    `nested.conf` are editable only by the owner.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Installing directories covers various use cases, but for other advanced scenarios
    (like post-install configuration), external tools may be required. How do we integrate
    them?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Invoking scripts during installation
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have ever installed a shared library on a Unix-like system, you might
    recall needing to instruct the dynamic linker to scan trusted directories and
    build its cache using `ldconfig` (refer to the *Further reading* section for references).
    To facilitate fully automatic installations, CMake provides the `install(SCRIPT)`
    and `install(CODE)` modes. Here is the complete syntax:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**ch14/06-install-code/src/CMakeLists.txt**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change the artifact type from `ARCHIVE` to `LIBRARY` in the installation script
    and then add logic to run `ldconfig` afterward:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/06-install-code/CMakeLists.txt (fragment)**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `if()` condition ensures the command is appropriate for the operating system
    (`ldconfig` should not be executed on Windows or macOS). The provided code must
    be syntactically valid in CMake (errors will only surface during installation).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the installation command, confirm its success by printing the
    cached libraries:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Both `SCRIPT` and `CODE` modes support generator expressions, adding versatility
    to this command. It can be used for various purposes: printing user messages,
    verifying successful installations, extensive configuration, file signing, and
    more.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s delve into the aspect of managing runtime dependencies in CMake
    installations, one of the newest features of CMake.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Installing runtime dependencies
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve covered almost all kinds of installable artifacts and their respective
    commands. The final subject to discuss is runtime dependencies. Executables and
    shared libraries often depend on other libraries that must be present in the system
    and are dynamically loaded at program initialization. Since version 3.21, CMake
    can build a list of these required libraries for each target and capture their
    location at build time by referencing the appropriate sections of the binary file.
    This list can then be used to install these runtime artifacts in the system for
    future use.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'For a target defined in the project, this can be achieved in two steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Alternatively, this can be accomplished with a single command with the same
    effect:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If a target is imported, rather than defined in the project, its runtime dependencies
    can be installed as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If this feature sounds beneficial for your project, I recommend checking the
    official documentation of the `install()` command to learn more.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand all the different ways we can install files on the system,
    let’s explore how to turn them into a natively available package for other CMake
    projects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable packages
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve extensively used `find_package()` in previous chapters and observed its
    convenience and simplicity. To make our project accessible through this command,
    we need to complete a few steps so CMake can treat our project as a coherent package:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Make our targets relocatable.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the *target export file* to a standard location.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a *config file for the package*.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a *version file* for the package.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start from the beginning: why do targets need to be relocatable and how
    can we do this?'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the issues with relocatable targets
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installation solves many problems but also introduces some complexity. The
    `CMAKE_INSTALL_PREFIX` is platform specific and can be set by the user at the
    installation stage with the `--install-prefix` command-line argument. The challenge
    is that target export files are generated before installation, during the build
    stage, when the final destination of the installed artifacts is unknown. Consider
    this code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/03-install-targets-legacy/src/CMakeLists.txt**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we specifically add the `include` `directory` to the `include`
    `directories` of `calc`. Since this is a relative path, CMake’s exported target
    generation implicitly prepends this path with the contents of the `CMAKE_CURRENT_SOURCE_DIR`
    variable, pointing to the directory where this listfile is located.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'CMake addresses this *carriage-before-the-horse* problem with generator expressions
    that are replaced with their argument or an empty string, depending on the context:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '`$<BUILD_INTERFACE:...>`: This evaluates to the ‘`...`'' argument for regular
    builds but excludes it for installation.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<INSTALL_INTERFACE:...>`: This evaluates to the ‘`...`'' argument for installation
    but excludes it for regular builds.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<BUILD_LOCAL_INTERFACE:...>`: This evaluates to the ‘`...`'' argument when
    used by another target in the same buildsystem (added in CMake 3.26).'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These expressions allow the deferment of the decision of which path to use
    to the later stages of the process: building and installation. Here’s how to use
    them in practice:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/07-install-export-legacy/src/CMakeLists.txt (fragment)**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In `target_include_directories()`, we focus on the last two arguments. The used
    generator expressions are mutually exclusive, meaning only one of the arguments
    will be used in the final step, and the other will be erased.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'For regular builds, the `INTERFACE_INCLUDE_DIRECTORIES` property of the `calc`
    target will be expanded, using the first argument:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On the other hand, when installing, the value will expand with the second argument:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Quotes are not present in the final value; they’re added here to express empty
    text values for clarity.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding `CMAKE_INSTALL_PREFIX`: it should not be used as a component in paths
    specified in targets. It would be evaluated during the build stage, making the
    path absolute and potentially different from the one provided during installation
    (if the `--install-prefix` option is used). Instead, use the `$<INSTALL_PREFIX>`
    generator expression:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Or, even better, you can use relative paths, which will be prepended with the
    correct installation prefix:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For more examples and information, please consult the official documentation
    (a link to this can be found in the *Further reading* section).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Now that our targets are *installation compatible*, we can safely generate and
    install their target export files.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Installing target export files
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously touched on target export files in the *Exporting without installation*
    section. The process for installing target export files is quite similar, and
    so is the command syntax for creating them:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It’s a blend of the plain `export(EXPORT)` and other `install()` commands (its
    options function similarly). Remember, it will create and install a target export
    file for a named export that must be defined with the `install(TARGETS)` command.
    The key difference here is that the generated export file will contain target
    paths evaluated in the `INSTALL_INTERFACE` generator expression, unlike `export(EXPORT)`,
    which uses `BUILD_INTERFACE`. This means we need to be careful about our include
    files and other relatively referenced files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, with CMake 3.23 or newer this won’t be a problem if `FILE_SET HEADERS`
    is used correctly. Let’s see how we can generate and install the export file for
    the targets from the `ch14/02-install-export` example. To do this, we must call
    `install(EXPORT)` after the `install(TARGETS)` command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/07-install-export/src/CMakeLists.txt**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note the reference to the `CalcTargets` export name in `install(EXPORT)`. Running
    `cmake --install` in the build tree will result in the export file being generated
    in the specified destination:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you need to override the default target export filename (`<export name>.cmake`),
    add the `FILE new-name.cmake` argument to change it (the filename must end with
    `.cmake`).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Don’t confuse this – the *target export file* isn’t a *config file*, so you
    can’t use `find_package()` to consume installed targets just yet. However, it’s
    possible to `include()` export files directly if necessary. So, how do we define
    a package that can be consumed by other projects? Let’s find out!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic config files
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complete package definition consists of the target export files, the package’s
    *config file*, and the package’s *version file*. However, technically, all that’s
    needed for `find_package()` to work is a config file. It acts as a package definition,
    responsible for providing any package functions and macros, checking requirements,
    finding dependencies, and including target export files.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, users can install your package anywhere on their system
    by using:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This prefix determines where the installed files will be copied. To support
    this, you must ensure the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The paths on the target properties are relocatable (as described in the *Understanding
    the issues with relocatable targets* section).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The paths that are used in your config file are relative to it.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use such packages that have been installed in non-default locations, the
    consuming projects need to provide `<installation path>` through the `CMAKE_PREFIX_PATH`
    variable during the configuration stage:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `find_package()` command will scan the list of paths that are outlined
    in the documentation (see the *Further reading* section) in a platform-specific
    manner. One pattern checked on Windows and Unix-like systems is:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This indicates that installing the config file in a path such as `lib/calc/cmake`
    should work. Additionally, CMake requires that config files be named `<PackageName>-config.cmake`
    or `<PackageName>Config.cmake` to be found.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the installation of the config file to the `06-install-export` example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/09-config-file/CMakeLists.txt (fragment)**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This command installs `CalcConfig.cmake` from the same source directory (`CMAKE_INSTALL_LIBDIR`
    will be evaluated to the correct `lib` path for the platform).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest config file consists of a single line including the target export
    file:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/09-config-file/CalcConfig.cmake**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`CMAKE_CURRENT_LIST_DIR` refers to the directory where the config file resides.
    Since `CalcConfig.cmake` and `CalcTargets.cmake` are installed in the same directory
    in our example (as set by `install(EXPORT)`), the target export file will be included
    correctly.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify our package’s usability, we’ll create a simple project with one listfile:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/10-find-package/CMakeLists.txt**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To test this, build and install the `09-config-file` example to one directory,
    and then build `10-find-package` while referencing it with the `DCMAKE_PREFIX_PATH`
    argument:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This will produce the following output (all the `<*_tree-of_>` placeholders
    will be replaced with real paths):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This output indicates that the `CalcTargets.cmake` file was found and included
    correctly, and the path to the `include directory` follows the chosen prefix.
    This solution is suitable for basic packaging cases. Now, let’s learn how to handle
    more advanced scenarios.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Creating advanced config files
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to manage more than a single *target export file*, including a
    few macros in your *config file* can be useful. The `CMakePackageConfigHelpers`
    utility module provides access to the `configure_package_config_file()` command.
    To use it, supply a template file that will be interpolated with CMake variables
    to generate a *config file* with two embedded macro definitions:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '`set_and_check(<variable> <path>)`: This works like `set()`, but it checks
    that `<path>` actually exists and fails with `FATAL_ERROR` otherwise. This is
    recommended for use in your config files to detect incorrect paths early.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_required_components(<PackageName>)`: This is added to the end of the
    `config`file. It verifies whether all components required by the user in `find_package(<package>
    REQUIRED <component>)` have been found.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Paths for complex directory trees can be prepared for installation during *config
    file* generation. Here’s the command signature:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `<template>` file will be interpolated with variables and stored in the
    `<output>` path. The `INSTALL_DESTINATION` path is used to transform the paths
    stored in the `PATH_VARS` to be relative to the install destination. The `INSTALL_PREFIX`
    can be provided as a base path to indicate that `INSTALL_DESTINATION` is relative
    to it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NO_SET_AND_CHECK_MACRO` and `NO_CHECK_REQUIRED_COMPONENTS_MACRO` options
    tell CMake not to add these macro definitions to the generated *config file*.
    Let’s see this generation in practice, extending the `07-install-export` example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/11-advanced-config/CMakeLists.txt (fragment)**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the preceding code, we:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Use `include()` to include the utility module with helpers.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `set()` to set a variable that will be used to make a relocatable path.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the `CalcConfig.cmake` config file for the build tree using the `CalcConfig.cmake.in`
    template, and provide `LIB_INSTALL_DIR` as a variable name to be computed as relative
    to `INSTALL_DESTINATION` or `${CMAKE_INSTALL_LIBDIR}/calc/cmake`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the config file that was generated for the build tree to `install(FILE)`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the path in `DESTINATION` in `install(FILES)` and the path in `INSTALL_DESTINATION`
    in `configure_package_config_file()` are equal, which ensures correct relative
    path computation inside of the configuration file.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll need a `config` file template (their names are usually suffixed
    with `.in`):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/11-advanced-config/CalcConfig.cmake.in**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This template begins with a `@PACKAGE_INIT@` placeholder. The generator will
    fill it with the definitions of the `set_and_check` and `check_required_components`
    macros.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The next line sets `CALC_LIB_DIR` to the path passed in the `@PACKAGE_LIB_INSTALL_DIR@`
    placeholder. CMake will fill it with `$LIB_INSTALL_DIR`, provided in the listfile,
    but calculated relative to the installation path. Subsequently, that path is used
    in the `include()` command to include the *target export file*. Finally, `check_required_components()`
    verifies whether all of the components required by the project using this package
    have been found. This command is recommended, even if the package doesn’t have
    any components to ensure the users are using only supported requirements. Otherwise,
    they may incorrectly think they’ve successfully added components (perhaps only
    present in newer versions of the package).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CalcConfig.cmake` *config file*, when generated this way, looks like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following diagram, which shows how the various package files are related
    to each other, puts this into perspective:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The file structure for advanced packages ](img/B19844_14_01.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: The file structure for advanced packages'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: All the required sub-dependencies of a package must also be found in the package
    config file. This can be done by calling the `find_dependency()` macro from the
    `CMakeFindDependencyMacro` helper. We learned how to use it in *Chapter 9*, *Managing
    Dependencies in CMake*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Definitions for any macros or functions exposed to the consuming project should
    be in a separate file included from the package’s *config file*. Interestingly,
    `CMakePackageConfigHelpers` also helps generate package version files. Let’s explore
    this next.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Generating package version files
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As your package evolves, gaining new features and phasing out older ones, it’s
    vital to track these changes in a changelog accessible to developers using your
    package. When a specific feature is required, a developer that is using your package
    can specify the minimum version that supports it in `find_package()`, like so:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: CMake will then search for `Calc`'s config file and check whether a *version
    file* named `<config-file>-version.cmake` or `<config-file>Version.cmake` is present
    in the same directory (e.g., `CalcConfigVersion.cmake`). This file contains version
    information and specifies compatibility with other versions. For instance, even
    if you don’t have the exact version 1.2.3 installed, you might have 1.3.5, which
    is marked as compatible with older versions. CMake will accept this package, knowing
    it’s backward compatible.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `CMakePackageConfigHelpers` utility module to generate package
    *version files* by calling `write_basic_package_version_file()`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: First, provide the `<filename>` for the artifact; ensure it follows the naming
    rules previously discussed. Optionally, you can pass an explicit `VERSION` (in
    major.minor.patch format). If not provided, the version specified in the `project()`
    command is used (an error will occur if the project doesn’t specify one).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'The `COMPATIBILITY` keyword indicates:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '`ExactVersion` must match all three components of the version and doesn’t support
    ranged versions: (e.g., `find_package(<package> 1.2.8...1.3.4)`).'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SameMinorVersion` matches if the first two components are the same (ignores
    `patch`).'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SameMajorVersion` matches if the first component is the same (ignores `minor`
    and `patch`).'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnyNewerVersion`, contrary to its name, matches any older version (e.g., version
    1.4.2 is compatible with `find_package(<package> 1.2.8)`).'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For architecture-dependent packages, an exact architecture match is required.
    However, for architecture-agnostic packages (like header-only libraries or macro
    packages), you can specify the `ARCH_INDEPENDENT` keyword to skip this check.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a practical example of how to provide the *version
    file* for the project that we started in the `07-install-export`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/12-version-file/CMakeLists.txt (fragment)**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For convenience, we configure the version of the package at the top of the file,
    in the `project()` command, switching from the short `project(<name> <languages>)`
    syntax to an explicit, full syntax by adding the `LANGUAGE` keyword.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: After including the helper module, we generate the version file and install
    it alongside `CalcConfig.cmake`. By skipping the `VERSION` keyword, we use the
    `PROJECT_VERSION` variable. The package is marked as fully backward compatible
    with `COMPATIBILITY` `AnyNewerVersion`. This installs the package *version file*
    to the same destination as `CalcConfig.cmake`. That’s it – our package is fully
    configured.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: With this, we concluded the subject of package creation. We now know how to
    deal with relocation and why it is important, how to install *target export files*,
    and how to write *config* and *version files*.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore components and their use with packages.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Defining components
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll begin by addressing potential confusion surrounding the term **component**.
    Consider the full signature for `find_package()`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It’s important not to confuse the components mentioned here with the `COMPONENT`
    keyword that’s used in the `install()` command. Despite sharing the same name,
    they are distinct concepts and must be understood separately. We’ll explore this
    further in the following subsections.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: How to use components in find_package()
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When calling `find_package()` with a list of `COMPONENTS` or `OPTIONAL_COMPONENTS`,
    we indicate to CMake that we are only interested in packages that provide these
    components. However, it’s crucial to understand that verifying this requirement
    is the responsibility of the package. If the package vendor doesn’t implement
    the necessary checks in the config file, as mentioned in the *Creating advanced
    config files* section, the process will not proceed as expected.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Requested components are passed to the config file via the `<package>_FIND_COMPONENTS`
    variable (both optional and non-optional). For every non-optional component, a
    `<package>_FIND_REQUIRED_<component>` variable is set. Package authors could write
    a macro to scan this list and verify the provision of all required components,
    but this is unnecessary. The `check_required_components()` function serves this
    purpose. The *config file* should set the `<package>_<component>_FOUND` variable
    when a necessary component is found. A macro at the file’s end will then verify
    whether all required variables are set.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: How to use components in the install() command
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all produced artifacts need installation in every scenario. For instance,
    a project might install static libraries and public headers for development, but
    by default, it may only need to install a shared library for runtime. To enable
    this dual behavior, artifacts can be grouped under a common name using the `COMPONENT`
    keyword, available in all `install()` commands. Users interested in limiting installation
    to specific components can do so by executing the following case-sensitive command:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Assigning the `COMPONENT` keyword to an artifact doesn’t automatically exclude
    it from the default installation. To achieve this exclusion, the `EXCLUDE_FROM_ALL`
    keyword must be added.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore this concept in a code example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/13-components/CMakeLists.txt (fragment)**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding `install` commands define the following components:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '`lib`: This contains the static library and target export files. It’s installed
    by default.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: This contains C++ header files. Also installed by default.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra`: This executes a piece of code to print a message. Not installed by
    default.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s reiterate:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake --install` without the `--component` argument will install both the
    `lib` and `headers` components.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake --install --component headers` will only install public headers.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake --install --component extra` will print a message that’s inaccessible
    otherwise (the `EXCLUDE_FROM_ALL` keyword prevents that).'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `COMPONENT` keyword isn’t specified for an installed artifact, it defaults
    to `Unspecified`, as defined by the `CMAKE_INSTALL_DEFAULT_COMPONENT_NAME` variable.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Since there’s no way to list all available components from the cmake command
    line, thoroughly documenting your package’s components can be extremely helpful
    for users. An `INSTALL` “`READM`” file is a good place for this information.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: If `cmake` is invoked with the `--component` argument for a non-existent component,
    the command will complete successfully without warnings or errors, but it won’t
    install anything.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning our installation into components allows users to selectively install
    parts of the package. Let’s now turn to managing symbolic links for versioned
    shared libraries, a useful feature for optimizing your installation processes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Managing symbolic links for versioned shared libraries
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The target platform for your installation may use symbolic links to help linkers
    discover the currently installed version of a shared library. After creating a
    `lib<name>.so` symlink to the `lib<name>.so.1` file, it’s possible to link this
    library by passing the `-l<name>` argument to the linker.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake’s `install(TARGETS <target> LIBRARY)` block handles the creation of such
    symlinks when needed. However, we may decide to move that step to another `install()`
    command by adding `NAMELINK_SKIP` to this block:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To assign symlinking to another component (instead of disabling it altogether),
    we can repeat the `install()` command for the same target and specify a different
    component, followed by the `NAMELINK_ONLY` keyword:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The same effect can be achieved with the `NAMELINK_COMPONENT` keyword:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now that we have configured automatic installation, we can provide pre-built
    artifacts for our users using the CPack tool, which is included with CMake.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Packaging with CPack
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building projects from source has its benefits, it can be time-consuming
    and complex, which isn’t ideal for end users, especially non-developers. A more
    convenient distribution method is using binary packages, containing compiled artifacts
    and other necessary static files. CMake supports generating such packages with
    a command-line tool called `cpack`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: To generate a package, select an appropriate package generator for your target
    platform and package type. Don’t confuse package generators with buildsystem generators
    like Unix Makefiles or Visual Studio.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the available package generators:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '| **Generator Name** | **Produced File Types** | **Platform** |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: '| Archive | 7Z, 7zip - (`.7z`)TBZ2 (`.tar.bz2`)TGZ (`.tar.gz`)TXZ (`.tar.xz`)TZ
    (`.tar.Z`)TZST (`.tar.zst`)ZIP (`.zip`) | Cross-platform |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
- en: '| Bundle | macOs Bundle (`.bundle`) | macOS |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
- en: '| Cygwin | Cygwin packages | Cygwin |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| DEB | Debian packages (`.deb`) | Linux |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| External | JSON (`.json`) file for 3rd party packagers | Cross-platform |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| FreeBSD | PKG (`.pkg`) | *BSD, Linux, macOS |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| IFW | QT installer binary | Linux, Windows, macOS |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: '| NSIS | Binary (`.exe`) | Windows |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: '| NuGet | NuGet package (`.nupkg`) | Windows |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| productbuild | PKG (`.pkg`) | macOS |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: '| RPM | RPM (`.rpm`) | Linux |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| WIX | Microsoft Installer (`.msi`) | Windows |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: 'Table 14.3: Available package generators'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Most of these generators have extensive configurations. While it’s beyond this
    book’s scope to delve into all their details, you can find more information in
    the *Further reading* section. We’ll focus on a general use case.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: To use CPack, configure your project’s installation with the necessary `install()`
    commands and build your project. The resulting `cmake_install.cmake` in the build
    tree is used by CPack to prepare binary packages based on the `CPackConfig.cmake`
    file. While you can create this file manually, using `include(CPack)` in your
    project’s listfile is easier. It generates the configuration in the build tree
    and supplies default values where needed.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extend the `13-components` example for CPack use:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/14-cpack/CMakeLists.txt (fragment)**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The CPack module extracts the following variables from the `project()` command:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_NAME`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_VERSION`'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_FILE_NAME`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CPACK_PACKAGE_FILE_NAME` stores the structure of the package name:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, `CPACK_SYSTEM_NAME` is the target OS name, like `Linux` or `win32`. For
    example, by executing a ZIP generator on Debian, CPack will generate a file named
    `CPackPackage-1.2.3-Linux.zip`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate packages after building your project, go to the build tree of your
    project and run:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'CPack reads options from the `CPackConfig.cmake` file, but you can override
    these settings:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '`-G <generators>`: Semicolon-separated list of package generators. The default
    value can be specified in the `CPackConfig.cmake` in the `CPACK_GENERATOR` variable.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-C <configs>`: Semicolon-separated list of build configurations (debug, release)
    to generate packages for (required for multi-configuration buildsystem generators).'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-D <var>=<value>`: This overrides a variable that’s set in the `CPackConfig.cmake`
    file.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--config <config-file>`: This uses a specified config file instead of the
    default `CPackConfig.cmake`.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--verbose, -V`: This provides verbose output.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P <packageName>`: This overrides the package name.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-R <packageVersion>`: This overrides the package version.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--vendor <vendorName>`: This overrides the package vendor.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-B <packageDirectory>`: This specifies the output directory for `cpack` (by
    default, this will be the current working directory).'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s try generating packages for our `14-cpack` example project. We’re going
    to use ZIP, 7Z, and the Debian package generator:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You should get these packages:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.7z`'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.deb`'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.zip`'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These binary packages are ready for publication on your project’s website, a
    GitHub release, or a package repository for end users.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating the intricacies of writing cross-platform installation scripts can
    be daunting, but CMake significantly simplifies this task. Although it requires
    some initial setup, CMake streamlines the process, integrating seamlessly with
    the concepts and techniques we’ve explored throughout this book.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'We began by understanding how to export CMake targets from projects, enabling
    their use in other projects without installation. This was followed by insights
    into installing projects that are already configured for export. Delving into
    installation basics, we focused on a crucial aspect: installing CMake targets.
    We now have a grasp of how CMake allocates different destinations for various
    artifact types and the special considerations for public headers. We also examined
    other modes of the `install()` command, encompassing the installation of files,
    programs, and directories, and executing scripts during installation.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Our journey then led us to CMake’s reusable packages. We explored how to make
    project targets relocatable, facilitating user-defined installation locations.
    This included creating fully defined packages consumable via `find_package()`,
    entailing the preparation of *target export files*, *config files*, and *version
    files*. Acknowledging diverse user needs, we learned how to group artifacts and
    actions into installation components, distinguishing them from the components
    of CMake packages. Our exploration culminated in an introduction to CPack. We
    discovered how to prepare basic binary packages, offering an efficient method
    to distribute pre-compiled software. While mastering the nuances of installation
    and packaging in CMake is an ongoing journey, this chapter lays a robust foundation.
    It equips us to handle common scenarios and delve deeper with confidence.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll apply our accumulated knowledge by crafting a cohesive,
    professional project, showcasing practical applications of these CMake techniques.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GNU coding standards for destinations: [https://www.gnu.org/prep/standards/html_node/Directory-Variables.html](https://www.gnu.org/prep/standards/html_node/Directory-Variables.html)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion on new public header management with the `FILE_SET` keyword:[https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860](https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860)
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to install a shared library: [https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating relocatable packages: [https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages](https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'List of paths scanned by `find_package()` to find the config file: [https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure](https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Full documentation of `CMakePackageConfigHelpers`: [https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html
    )'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPack package generators: [https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html](https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html)'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On preferred package generators for different platforms:[https://stackoverflow.com/a/46013099](https://stackoverflow.com/a/46013099)
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPack utility module documentation: [https://cmake.org/cmake/help/latest/module/CPack.html](https://cmake.org/cmake/help/latest/module/CPack.html)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code94081075213645359.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
