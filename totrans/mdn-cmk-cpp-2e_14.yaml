- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing and Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our project has been built, tested, and documented. Now, it’s finally time
    to release it to our users. This chapter primarily focuses on the final two steps
    we need to take: installation and packaging. These are advanced techniques that
    build on top of everything we’ve learned so far: managing targets and their dependencies,
    transient usage requirements, generator expressions, and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: Installation allows our project to be discoverable and accessible system-wide.
    We will cover how to export targets for use by other projects without needing
    installation and how to install our projects for easy system-wide accessibility.
    We’ll learn how to configure our project to automatically place various artifact
    types in their appropriate directories. To handle more advanced scenarios, we’ll
    introduce low-level commands for installing files and directories, as well as
    for executing custom scripts and CMake commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll explore setting up reusable CMake packages that other projects
    can discover using the `find_package()` command. We’ll explain how to ensure that
    targets and their definitions are not restricted to a specific file system location.
    We’ll also discuss how to write basic and advanced **config files**, along with
    the **version files** associated with packages. Then, to make things modular,
    we’ll briefly introduce the concept of components, both in terms of CMake packages
    and the `install()` command. All this preparation will pave the way for the final
    aspect we’ll be covering in this chapter: using CPack to generate archives, installers,
    bundles, and packages that are recognized by all kinds of package managers in
    different operating systems. These packages can distribute pre-built artifacts,
    executables, and libraries. It’s the easiest way for end users to start using
    our software.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting without installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing projects on the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging with CPack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch14](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch14).
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the examples provided in this book, always use the recommended commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To install examples, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting without installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we make the targets of project `A` available to the consuming project,
    `B`? Usually, we’d use the `find_package()` command, but that requires creating
    a package and installing it on the system. While useful, this approach involves
    some work. Sometimes, we just need a quick way to build a project and make its
    targets available for other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'One time-saving method is to include in project `B` the main listfile of `A`,
    which already contains all the target definitions. However, this file might also
    include global configuration, CMake commands with side effects, additional dependencies,
    and perhaps unwanted targets for `B` (like unit tests). So, this is not the best
    approach. Instead, we can provide a **target export file** for the consuming project,
    `B`, to include with the `include()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will define all targets of `A` with the correct properties set, using commands
    such as `add_library()` and `add_executable()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must specify all targets to export after the `TARGETS` keyword and provide
    the destination filename after `FILE`. The other arguments are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the explanation of the individual arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAMESPACE` is recommended to indicate that the target has been imported from
    other projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APPEND` prevents CMake from erasing the file’s contents before writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPORT_LINK_INTERFACE_LIBRARIES` exports target link dependencies (including
    imported and config-specific variants).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s apply this exporting method to the `Calc` library example, which provides
    two simple methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/01-export/src/include/calc/basic.h**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to declare the `Calc` target so we have something to export:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/01-export/src/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to generate the export file, we are using the `export(TARGETS)` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/01-export/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our exported target declaration file will be located in the `cmake` subdirectory
    of the build tree (following the convention for `.cmake` files). To avoid repeating
    this path later, we’re setting it in the `EXPORT_DIR` variable. Then, we call
    `export()` to generate the target declaration file, `CalcTargets.cmake`, with
    the `calc` target. For projects including this file, it will be visible as `Calc::calc`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this export file isn’t *a package* yet. More importantly, all paths
    in this file are absolute and hardcoded to the build tree, making them non-relocatable
    (discussed in the *Understanding the issues with relocatable targets* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `export()` command also has a shorter version using the `EXPORT` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, it requires the name of a predefined export rather than a list of exported
    targets. Such `<export>` instances are named lists of targets that are created
    by `install(TARGETS)` (we’ll cover this command in the *Installing logical targets*
    section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a tiny example demonstrating how this shorthand is used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/01-export/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code works similarly to the previous example, but now it shares a single
    target list between the `export()` and `install()` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both methods of generating export files yield similar results. They include
    some boilerplate code and a few lines defining the target. With `<build-tree>`
    set to the build tree path, they’ll create a **target export file** similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**<build-tree>/cmake/CalcTargets.cmake (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Normally, we wouldn’t edit or even open this file, but it’s important to note
    that the paths will be hardcoded in it (see the highlighted lines). In its current
    form, the built project isn’t relocatable. To change that, some additional steps
    are required. In the next section, we’ll explain what relocation is and why it
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: Installing projects on the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *First Steps with CMake*, we indicated that CMake offers a
    command-line mode for installing built projects on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<dir>` is the path to the generated build tree (required). The `<options>`
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--config <cfg>`: This selects the build configuration for multi-configuration
    generators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--component <comp>`: This limits the installation to the given component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--default-directory-permissions <permissions>`: This sets the default permissions
    for the installed directories (in `<u=rwx,g=rx,o=rx>` format).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--install-prefix <prefix>`: This specifies the non-default installation path
    (stored in the `CMAKE_INSTALL_PREFIX` variable). It defaults to `/usr/local` on
    Unix-like systems and to `c:/Program Files/${PROJECT_NAME}` on Windows. Before
    CMake 3.21, you’ll have to use a less-explicit option: `--prefix <prefix>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v, --verbose`: This increases the verbosity of the output (achievable also
    by setting the `VERBOSE` environment variable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installations typically involve copying generated artifacts and necessary dependencies
    to a system directory. Using CMake introduces a convenient installation standard
    to all CMake projects and offers several additional benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides platform-specific installation paths for artifacts, depending on
    their types (by following *GNU coding standards*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enhances the installation process by generating target export files, allowing
    direct reuse of project targets by other projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates discoverable packages through **config files**, wrapping the target
    export files and package-specific CMake macros and functions defined by the author.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These features are quite powerful as they save a lot of time and simplify the
    usage of projects that are prepared this way. The first step in performing a basic
    installation is copying the built artifacts to their destination directory. This
    brings us to the `install()` command and its various modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`install(``TARGETS)`: This installs output artifacts such as libraries and
    executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(FILES|PROGRAMS)`: This installs individual files and sets their permissions.
    These files don’t need to be part of any logical targets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(DIRECTORY)`: This installs entire directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(SCRIPT|CODE)`: This runs a CMake script or a snippet during installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(EXPORT)`: This generates and installs a target export file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(RUNTIME_DEPENDENCY_SET <set-name> [...])`: This installs runtime dependency
    sets defined in the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(IMPORTED_RUNTIME_ARTIFACTS <target>... [...])`: This queries imported
    targets for runtime artifacts and installs them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding these commands to your listfile generates a `cmake_install.cmake` file
    in your build tree. While it’s possible to manually invoke this script with `cmake
    -P`, this is not recommended. The file is intended for internal use by CMake when
    `cmake --install` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `install()` mode has a comprehensive set of options, with a few shared
    across modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DESTINATION`: This specifies the installation path. Relative paths are prepended
    with `CMAKE_INSTALL_PREFIX`, while absolute paths are used verbatim (and not supported
    by `cpack`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PERMISSIONS`: This sets file permissions on supported platforms. The available
    values include `OWNER_READ`, `OWNER_WRITE`, `OWNER_EXECUTE`, `GROUP_READ`, `GROUP_WRITE`,
    `GROUP_EXECUTE`, `WORLD_READ`, `WORLD_WRITE`, `WORLD_EXECUTE`, `SETUID`, and `SETGID`.
    Default directory permissions created during installation time can be set with
    the `CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIGURATIONS`: This specifies configurations (`Debug`, `Release`). Options
    following this keyword apply only if the current build configuration is in the
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONAL`: This prevents errors when the installed files don’t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two shared options, `COMPONENT` and `EXCLUDE_FROM_ALL`, are used in component-specific
    installations. These will be discussed in the *Defining components* section later
    in the chapter. For now, let’s take a look at the first installation mode: `install(TARGETS)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing logical targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Targets defined by `add_library()` and `add_executable()` can easily be installed
    with the `install(TARGETS)` command. This means copying the artifacts that have
    been produced by the buildsystem to the appropriate destination directories and
    setting suitable file permissions for them. The general signature for this mode
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After the initial mode specifier, that is, `TARGETS`, we must provide a list
    of targets we’d like to install. Here, we may optionally assign them to a **named
    export** with the `EXPORT` option, which can be used in `export(EXPORT)` and `install(EXPORT)`
    to produce a target export file. Then, we must configure the installation of output
    artifacts (grouped by type). Optionally, we can provide a list of directories
    that will be added to the target export file for each target in its `INTERFACE_INCLUDE_DIRECTORIES`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '`[<output-artifact-configuration>...]` provides a list of configuration blocks.
    The full syntax of a single block is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The command mandates that every output artifact block starts with `<TYPE>`
    (this is the only required element). CMake recognizes several of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARCHIVE`: Static libraries (`.a`) and DLL import libraries for Windows-based
    systems (`.lib`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIBRARY`: Shared libraries (`.so`), but not DLLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNTIME`: Executables and DLLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBJECTS`: *Object files* from `OBJECT` libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FRAMEWORK`: Static and shared libraries that have the `FRAMEWORK` property
    set (this excludes them from `ARCHIVE` and `LIBRARY`). This is macOS-specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUNDLE`: Executables marked with `MACOSX_BUNDLE` (also not part of `RUNTIME`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILE_SET <set>`: Files in the `<set>` file set specified for the target. Either
    C++ header files or C++ module headers (since CMake 3.23).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUBLIC_HEADER`, `PRIVATE_HEADER`, `RESOURCE`: Files specified in the target
    properties with the same name (on Apple platforms, they should be set on the `FRAMEWORK`
    or `BUNDLE` targets).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CMake documentation claims that if you only configure one artifact type
    (for example, `LIBRARY`), only this type will be installed. For CMake version
    3.26.0, this is not true: all the artifacts will be installed as if they were
    configured with the default options. This can be solved by specifying `<TYPE>
    EXCLUDE_FROM_ALL` for all unwanted artifact types.'
  prefs: []
  type: TYPE_NORMAL
- en: A single `install(TARGETS)` command can have multiple artifact configuration
    blocks. However, be aware that you may only specify one of each type per call.
    That is, if you’d like to configure different destinations of `ARCHIVE` artifacts
    for the `Debug` and `Release` configurations, then you must make two separate
    `install(TARGETS ... ARCHIVE)` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also omit the type name and specify options for all the artifacts.
    Installation would then be then performed for every file that’s produced by these
    targets, regardless of their type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In many cases, you don’t need to provide the `DESTINATION` explicitly, thanks
    to the built-in defaults, but there are a few caveats to keep in mind when dealing
    with different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the default destination for different platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When CMake installs your project’s files, it copies them into a specific directory
    in the system. Different file types belong in different directories. This directory
    is determined by the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in the previous section, you can explicitly provide the `DESTINATION`
    component for installation, or let CMake use a built-in default based on the type
    of the artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Artifact type** | **Built-in default** | **Install directory variable**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `RUNTIME` | `bin` | `CMAKE_INSTALL_BINDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `LIBRARY``ARCHIVE` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `PUBLIC_HEADER``PRIVATE_HEADER``FILE_SET` (`type` `HEADERS`) | `include`
    | `CMAKE_INSTALL_INCLUDEDIR` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.1: Default destinations per artifact type'
  prefs: []
  type: TYPE_NORMAL
- en: While default paths are useful, they aren’t always appropriate. For example,
    CMake defaults the `DESTINATION` for libraries to `lib`. The full path for libraries
    is then computed as `/usr/local/lib` for Unix-like systems and something like
    `C:\Program Files (x86)\<project-name>\lib` on Windows. However, this is not ideal
    for Debian with multi-arch support, which requires an architecture-specific path
    (e.g., `i386-linux-gnu`) when `INSTALL_PREFIX` is `/usr`. Determining the correct
    path for each platform is a common challenge for Unix-like systems. To address
    this, follow the *GNU Coding Standards*, the link to which is added in the *Further
    reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can override the default destinations for each value by setting a `CMAKE_INSTALL_<DIRTYPE>DIR`
    variable. Instead of developing an algorithm to detect the platform and assign
    appropriate paths to the install directory variables, use the CMake `GNUInstallDirs`
    utility module. This module handles most platforms by setting the install directory
    variables accordingly. Just include it using `include()` before any `install()`
    commands, and you’ll be set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users needing custom configurations can override the install directory variables
    via the command-line argument like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, installing the public headers of libraries still presents challenges.
    Let’s explore why.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with public headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When managing public headers in CMake, it’s best practice to store them in
    a directory that indicates their origin and introduces namespacing, such as `/usr/local/include/calc`.
    This enables their use in C++ projects with the inclusion directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Most preprocessors interpret angle-bracketed directives as requests to scan
    standard system directories. We can use the `GNUInstallDirs` module to automatically
    populate the `DESTINATION` part of the installation path, ensuring headers end
    up in the `include` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since CMake 3.23.0, we can explicitly add headers to be installed to the appropriate
    target with the `target_sources()` command and the `FILE_SET` keyword. This method
    is preferred, as it takes care of the *relocation* of headers. Here’s the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming our headers are in the `src/include/calc` directory, here’s a practical
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/02-install-targets/src/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined the file set, we can use it in the installation command like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/02-install-targets/src/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the `GNUInstallDirs` module and configure the installation of the
    `calc` static library and its headers. Running `cmake` in install mode works as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Support for the `FILE_SET HEADERS` keyword is a relatively recent update, and
    unfortunately, not all environments will provide the newer version of CMake**.**
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re stuck on a version older than 3.23, you’ll need to specify public
    headers (as a semicolon-separated list) in the `PUBLIC_HEADER` property of the
    library target, and deal with the relocation manually (more on this in the *Understanding
    the issues with relocatable targets* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/03-install-targets-legacy/src/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll also need to change the destination directory to include the library
    name in the `include` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/02-install-targets-legacy/src/CMakeLists.txt (continued)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Explicitly inserting `/calc` in the path is necessary because files specified
    in the `PUBLIC_HEADER` property don’t retain their directory structure. They will
    all be installed in the same destination, even if nested in different base directories.
    This significant drawback led to the development of `FILE_SET`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how to address most installation cases, but how should you approach
    more advanced scenarios?
  prefs: []
  type: TYPE_NORMAL
- en: Low-level installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modern CMake is moving away from directly manipulating files. Ideally, we should
    add files to a logical target, using it as a higher level of abstraction to represent
    all underlying assets: source files, headers, resources, configuration, and so
    on. The main advantage is the code’s dryness; usually, adding a file to the target
    requires changing no more than one line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, adding every installed file to a target isn’t always possible
    or convenient. In such cases, three options are available: `install(FILES)`, `install(PROGRAMS)`,
    and `install(DIRECTORY)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing with install(FILES) and install(PROGRAMS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `FILES` and `PROGRAMS` modes are very similar. They can be used to install
    various assets, including public header files, documentation, shell scripts, configuration,
    and runtime assets like images, audio files, and datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the command signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between `FILES` and `PROGRAMS` is the default file permissions
    set on the copied files. `install(PROGRAMS)` sets `EXECUTE` for all users, whereas
    `install(FILES)` does not (though both will set `OWNER_WRITE`, `OWNER_READ`, `GROUP_READ`,
    and `WORLD_READ`).
  prefs: []
  type: TYPE_NORMAL
- en: You can modify this behavior by using the optional `PERMISSIONS` keyword, and
    then choosing the leading keyword (`FILES` or `PROGRAMS`) as an indicator of what’s
    installed. We’ve already covered how `PERMISSIONS`, `CONFIGURATIONS`, and `OPTIONAL`
    work. `COMPONENT` and `EXCLUDE_FROM_ALL` will be discussed later in the *Defining
    components* section.
  prefs: []
  type: TYPE_NORMAL
- en: After the initial keyword, we need to list all the files we want to install.
    CMake supports relative and absolute paths, as well as generator expressions.
    Remember that if your file path starts with a generator expression, it must be
    absolute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next required keyword is `TYPE` or `DESTINATION`. You can either explicitly
    provide the `DESTINATION` path or ask CMake to look it up for a specific `TYPE`
    file. Unlike in `install(TARGETS)`, `TYPE` in this context does not select any
    subset of the provided files to be installed. Nevertheless, the computation of
    the installation path follows the same pattern (where the `+` symbol denotes a
    platform-specific path separator):'
  prefs: []
  type: TYPE_NORMAL
- en: '`${CMAKE_INSTALL_PREFIX} + ${DESTINATION}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, every `TYPE` will have built-in defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File Type** | **Built-In Default** | **Installation Directory Variable**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BIN` | `bin` | `CMAKE_INSTALL_BINDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `SBIN` | `sbin` | `CMAKE_INSTALL_SBINDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `LIB` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `INCLUDE` | `include` | `CMAKE_INSTALL_INCLUDEDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `SYSCONF` | `etc` | `CMAKE_INSTALL_SYSCONFDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `SHAREDSTATE` | `com` | `CMAKE_INSTALL_SHARESTATEDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCALSTATE` | `var` | `CMAKE_INSTALL_LOCALSTATEDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `RUNSTATE` | `$LOCALSTATE/run` | `CMAKE_INSTALL_RUNSTATEDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `DATA` | `$DATAROOT` | `CMAKE_INSTALL_DATADIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `INFO` | `$DATAROOT/info` | `CMAKE_INSTALL_INFODIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `LOCALE` | `$DATAROOT/locale` | `CMAKE_INSTALL_LOCALEDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `MAN` | `$DATAROOT/man` | `CMAKE_INSTALL_MANDIR` |'
  prefs: []
  type: TYPE_TB
- en: '| `DOC` | `$DATAROOT/doc` | `CMAKE_INSTALL_DOCDIR` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.2: Built-in defaults per file type'
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior here follows the same principle that was described in the *Utilizing
    the default destination for different platforms* subsection: if no installation
    directory variable for this `TYPE` of file is set, CMake will provide a built-in
    default path. Again, for portability, we can use the `GNUInstallDirs` module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the built-in guesses in the table are prefixed with installation directory
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$LOCALSTATE` is `CMAKE_INSTALL_LOCALSTATEDIR` or defaults to `var`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$DATAROOT` is `CMAKE_INSTALL_DATAROOTDIR` or defaults to `share`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with `install(TARGETS)`, the `GNUInstallDirs` module will provide platform-specific
    installation directory variables. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/04-install-files/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, CMake installs the two header-only libraries, `basic.h` and `nested/calc_extended.h`,
    into the project-specific subdirectory within the system-wide `include directory`.
  prefs: []
  type: TYPE_NORMAL
- en: From the `GNUInstallDirs` source, we know that `CMAKE_INSTALL_INCLUDEDIR` is
    the same for all supported platforms. However, using it is still recommended for
    readability and consistency with more dynamic variables. For instance, `CMAKE_INSTALL_LIBDIR`
    varies by architecture and distribution – `lib`, `lib64`, or `lib/<multiarch-tuple>`.
  prefs: []
  type: TYPE_NORMAL
- en: Since CMake 3.20, you can use the `RENAME` keyword with the `install(FILES)`
    and `install(PROGRAMS)` commands. This keyword has to be followed by a new filename
    and only works if the command installs a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example in this section demonstrates the ease of installing files in the
    appropriate directory. However, there’s one issue – observe the installation output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Both files are installed in the same directory, regardless of their original
    nesting. Sometimes, this isn’t desirable. In the next section, we’ll explore how
    to handle this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Working with entire directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If adding individual files to your installation command isn’t suitable, you
    can opt for a broader approach and work with entire directories. The `install(DIRECTORY)`
    mode is designed for this, copying the specified directories verbatim to the chosen
    destination. Here’s how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Many options here are similar to those in `install(FILES)` and `install(PROGRAMS)`
    and function in the same manner. One key detail is that if the paths provided
    after the `DIRECTORY` keyword don’t end with `/`, the last directory of the path
    is appended to the destination. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a directory, `/xxx/aaa`, and copies the contents of `aaa`
    to it. In contrast, the following command copies the contents of `aaa` directly
    to `/xxx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`install(DIRECTORY)` also introduces other mechanisms that are not available
    for files:'
  prefs: []
  type: TYPE_NORMAL
- en: Output silencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended permission control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File/directory filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the output silencing option, `MESSAGE_NEVER`. It disables output
    diagnostics during installation. It is very useful when we have many files in
    the directories we’re installing and it would be too noisy to print them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding permissions, `install(DIRECTORY)` supports three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USE_SOURCE_PERMISSIONS` sets the permissions on installed files that follow
    the original files. This only works when `FILE_PERMISSIONS` is not set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILE_PERMISSIONS` allows us to specify the permissions we want to set on installed
    files and directories. The default permissions are `OWNER_WRITE`, `OWNER_READ`,
    `GROUP_READ`, and `WORLD_READ`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DIRECTORY_PERMISSIONS` works similarly to `FILE_PERMISSIONS`, but it will
    set additional `EXECUTE` permissions for all users (this is because `EXECUTE`
    on directories in Unix-like systems denotes permission to list their contents).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that CMake ignores permissions options on platforms that don’t support
    them. More nuanced permission control is achievable by adding the `PERMISSIONS`
    keyword after each filtering expression. Files or directories matched by this
    will receive the specified permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk about filters or “globbing” expressions. They control which files/directories
    from source directories are installed and follow this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two matching methods to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: With `PATTERN`, which is the simpler option, you can provide a pattern with
    the `?` placeholders (matching any character) and the `*` wildcards (matching
    any string). Only paths that end with `<pat>` will be matched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `REGEX` option is more advanced, supporting regular expressions. It allows
    the matching of any part of the path, although the `^` and `$` anchors can still
    denote the beginning and end of the path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the `FILES_MATCHING` keyword can be set before the first filter,
    specifying that the filters will apply to files and not directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember two caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FILES_MATCHING` requires an inclusive filter. You may exclude some files,
    but no files will be copied unless you also include some. However, all directories
    will be created, regardless of filtering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All subdirectories are included by default; you can only filter out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each filter method, you can choose to exclude matched paths with the `EXCLUDE`
    command (this only works when `FILES_MATCHING` isn’t used).
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific permissions for all matched paths can be set by adding the `PERMISSIONS`
    keyword and a list of desired permissions after any filter. Let’s explore this
    with an example where we install three directories in different ways. We have
    some static data files for runtime use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need some public headers located in the `src` directory among other
    unrelated files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need two configuration files at two levels of nesting. To make
    things more interesting, we’ll make `/etc/calc/` contents accessible only to the
    file owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the directory with static data files, we start our project with
    the most basic form of the `install(DIRECTORY)` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This command will simply take all the contents of our `data` directory and put
    it in `${CMAKE_INSTALL_PREFIX}` and `share/calc`. Note that our source path ends
    with a `/` symbol to indicate we don’t want to copy the `data` directory itself,
    only its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case is the opposite: we don’t add the trailing `/` because the
    directory should be included. This is because we’re relying on a system-specific
    path for the `INCLUDE` file type, which is provided by `GNUInstallDirs` (note
    how the `INCLUDE` and `EXCLUDE` keywords represent unrelated concepts):'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we have excluded two paths from this operation: the entire `ignored`
    directory and all files ending with `calc_extended.h` (remember how `PATTERN`
    works).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third case installs some default configuration files and sets their permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We avoid appending `etc` from the source path to the `SYSCONF` path (as `GNUInstallDirs`
    has already provided this) to prevent duplication. We set two permission rules:
    subdirectories are editable and listable only by the owner, and files ending with
    `nested.conf` are editable only by the owner.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing directories covers various use cases, but for other advanced scenarios
    (like post-install configuration), external tools may be required. How do we integrate
    them?
  prefs: []
  type: TYPE_NORMAL
- en: Invoking scripts during installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have ever installed a shared library on a Unix-like system, you might
    recall needing to instruct the dynamic linker to scan trusted directories and
    build its cache using `ldconfig` (refer to the *Further reading* section for references).
    To facilitate fully automatic installations, CMake provides the `install(SCRIPT)`
    and `install(CODE)` modes. Here is the complete syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**ch14/06-install-code/src/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the artifact type from `ARCHIVE` to `LIBRARY` in the installation script
    and then add logic to run `ldconfig` afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/06-install-code/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `if()` condition ensures the command is appropriate for the operating system
    (`ldconfig` should not be executed on Windows or macOS). The provided code must
    be syntactically valid in CMake (errors will only surface during installation).
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the installation command, confirm its success by printing the
    cached libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `SCRIPT` and `CODE` modes support generator expressions, adding versatility
    to this command. It can be used for various purposes: printing user messages,
    verifying successful installations, extensive configuration, file signing, and
    more.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s delve into the aspect of managing runtime dependencies in CMake
    installations, one of the newest features of CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Installing runtime dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve covered almost all kinds of installable artifacts and their respective
    commands. The final subject to discuss is runtime dependencies. Executables and
    shared libraries often depend on other libraries that must be present in the system
    and are dynamically loaded at program initialization. Since version 3.21, CMake
    can build a list of these required libraries for each target and capture their
    location at build time by referencing the appropriate sections of the binary file.
    This list can then be used to install these runtime artifacts in the system for
    future use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a target defined in the project, this can be achieved in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this can be accomplished with a single command with the same
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If a target is imported, rather than defined in the project, its runtime dependencies
    can be installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If this feature sounds beneficial for your project, I recommend checking the
    official documentation of the `install()` command to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand all the different ways we can install files on the system,
    let’s explore how to turn them into a natively available package for other CMake
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve extensively used `find_package()` in previous chapters and observed its
    convenience and simplicity. To make our project accessible through this command,
    we need to complete a few steps so CMake can treat our project as a coherent package:'
  prefs: []
  type: TYPE_NORMAL
- en: Make our targets relocatable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the *target export file* to a standard location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a *config file for the package*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a *version file* for the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start from the beginning: why do targets need to be relocatable and how
    can we do this?'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the issues with relocatable targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installation solves many problems but also introduces some complexity. The
    `CMAKE_INSTALL_PREFIX` is platform specific and can be set by the user at the
    installation stage with the `--install-prefix` command-line argument. The challenge
    is that target export files are generated before installation, during the build
    stage, when the final destination of the installed artifacts is unknown. Consider
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/03-install-targets-legacy/src/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we specifically add the `include` `directory` to the `include`
    `directories` of `calc`. Since this is a relative path, CMake’s exported target
    generation implicitly prepends this path with the contents of the `CMAKE_CURRENT_SOURCE_DIR`
    variable, pointing to the directory where this listfile is located.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake addresses this *carriage-before-the-horse* problem with generator expressions
    that are replaced with their argument or an empty string, depending on the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$<BUILD_INTERFACE:...>`: This evaluates to the ‘`...`'' argument for regular
    builds but excludes it for installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<INSTALL_INTERFACE:...>`: This evaluates to the ‘`...`'' argument for installation
    but excludes it for regular builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<BUILD_LOCAL_INTERFACE:...>`: This evaluates to the ‘`...`'' argument when
    used by another target in the same buildsystem (added in CMake 3.26).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These expressions allow the deferment of the decision of which path to use
    to the later stages of the process: building and installation. Here’s how to use
    them in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/07-install-export-legacy/src/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In `target_include_directories()`, we focus on the last two arguments. The used
    generator expressions are mutually exclusive, meaning only one of the arguments
    will be used in the final step, and the other will be erased.
  prefs: []
  type: TYPE_NORMAL
- en: 'For regular builds, the `INTERFACE_INCLUDE_DIRECTORIES` property of the `calc`
    target will be expanded, using the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, when installing, the value will expand with the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Quotes are not present in the final value; they’re added here to express empty
    text values for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding `CMAKE_INSTALL_PREFIX`: it should not be used as a component in paths
    specified in targets. It would be evaluated during the build stage, making the
    path absolute and potentially different from the one provided during installation
    (if the `--install-prefix` option is used). Instead, use the `$<INSTALL_PREFIX>`
    generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, even better, you can use relative paths, which will be prepended with the
    correct installation prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: For more examples and information, please consult the official documentation
    (a link to this can be found in the *Further reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: Now that our targets are *installation compatible*, we can safely generate and
    install their target export files.
  prefs: []
  type: TYPE_NORMAL
- en: Installing target export files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We previously touched on target export files in the *Exporting without installation*
    section. The process for installing target export files is quite similar, and
    so is the command syntax for creating them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: It’s a blend of the plain `export(EXPORT)` and other `install()` commands (its
    options function similarly). Remember, it will create and install a target export
    file for a named export that must be defined with the `install(TARGETS)` command.
    The key difference here is that the generated export file will contain target
    paths evaluated in the `INSTALL_INTERFACE` generator expression, unlike `export(EXPORT)`,
    which uses `BUILD_INTERFACE`. This means we need to be careful about our include
    files and other relatively referenced files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, with CMake 3.23 or newer this won’t be a problem if `FILE_SET HEADERS`
    is used correctly. Let’s see how we can generate and install the export file for
    the targets from the `ch14/02-install-export` example. To do this, we must call
    `install(EXPORT)` after the `install(TARGETS)` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/07-install-export/src/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the reference to the `CalcTargets` export name in `install(EXPORT)`. Running
    `cmake --install` in the build tree will result in the export file being generated
    in the specified destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If you need to override the default target export filename (`<export name>.cmake`),
    add the `FILE new-name.cmake` argument to change it (the filename must end with
    `.cmake`).
  prefs: []
  type: TYPE_NORMAL
- en: Don’t confuse this – the *target export file* isn’t a *config file*, so you
    can’t use `find_package()` to consume installed targets just yet. However, it’s
    possible to `include()` export files directly if necessary. So, how do we define
    a package that can be consumed by other projects? Let’s find out!
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic config files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complete package definition consists of the target export files, the package’s
    *config file*, and the package’s *version file*. However, technically, all that’s
    needed for `find_package()` to work is a config file. It acts as a package definition,
    responsible for providing any package functions and macros, checking requirements,
    finding dependencies, and including target export files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, users can install your package anywhere on their system
    by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This prefix determines where the installed files will be copied. To support
    this, you must ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The paths on the target properties are relocatable (as described in the *Understanding
    the issues with relocatable targets* section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The paths that are used in your config file are relative to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use such packages that have been installed in non-default locations, the
    consuming projects need to provide `<installation path>` through the `CMAKE_PREFIX_PATH`
    variable during the configuration stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find_package()` command will scan the list of paths that are outlined
    in the documentation (see the *Further reading* section) in a platform-specific
    manner. One pattern checked on Windows and Unix-like systems is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that installing the config file in a path such as `lib/calc/cmake`
    should work. Additionally, CMake requires that config files be named `<PackageName>-config.cmake`
    or `<PackageName>Config.cmake` to be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the installation of the config file to the `06-install-export` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/09-config-file/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This command installs `CalcConfig.cmake` from the same source directory (`CMAKE_INSTALL_LIBDIR`
    will be evaluated to the correct `lib` path for the platform).
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest config file consists of a single line including the target export
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/09-config-file/CalcConfig.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`CMAKE_CURRENT_LIST_DIR` refers to the directory where the config file resides.
    Since `CalcConfig.cmake` and `CalcTargets.cmake` are installed in the same directory
    in our example (as set by `install(EXPORT)`), the target export file will be included
    correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify our package’s usability, we’ll create a simple project with one listfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/10-find-package/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, build and install the `09-config-file` example to one directory,
    and then build `10-find-package` while referencing it with the `DCMAKE_PREFIX_PATH`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output (all the `<*_tree-of_>` placeholders
    will be replaced with real paths):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This output indicates that the `CalcTargets.cmake` file was found and included
    correctly, and the path to the `include directory` follows the chosen prefix.
    This solution is suitable for basic packaging cases. Now, let’s learn how to handle
    more advanced scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Creating advanced config files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to manage more than a single *target export file*, including a
    few macros in your *config file* can be useful. The `CMakePackageConfigHelpers`
    utility module provides access to the `configure_package_config_file()` command.
    To use it, supply a template file that will be interpolated with CMake variables
    to generate a *config file* with two embedded macro definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_and_check(<variable> <path>)`: This works like `set()`, but it checks
    that `<path>` actually exists and fails with `FATAL_ERROR` otherwise. This is
    recommended for use in your config files to detect incorrect paths early.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_required_components(<PackageName>)`: This is added to the end of the
    `config`file. It verifies whether all components required by the user in `find_package(<package>
    REQUIRED <component>)` have been found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Paths for complex directory trees can be prepared for installation during *config
    file* generation. Here’s the command signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `<template>` file will be interpolated with variables and stored in the
    `<output>` path. The `INSTALL_DESTINATION` path is used to transform the paths
    stored in the `PATH_VARS` to be relative to the install destination. The `INSTALL_PREFIX`
    can be provided as a base path to indicate that `INSTALL_DESTINATION` is relative
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NO_SET_AND_CHECK_MACRO` and `NO_CHECK_REQUIRED_COMPONENTS_MACRO` options
    tell CMake not to add these macro definitions to the generated *config file*.
    Let’s see this generation in practice, extending the `07-install-export` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/11-advanced-config/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `include()` to include the utility module with helpers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `set()` to set a variable that will be used to make a relocatable path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the `CalcConfig.cmake` config file for the build tree using the `CalcConfig.cmake.in`
    template, and provide `LIB_INSTALL_DIR` as a variable name to be computed as relative
    to `INSTALL_DESTINATION` or `${CMAKE_INSTALL_LIBDIR}/calc/cmake`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the config file that was generated for the build tree to `install(FILE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the path in `DESTINATION` in `install(FILES)` and the path in `INSTALL_DESTINATION`
    in `configure_package_config_file()` are equal, which ensures correct relative
    path computation inside of the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll need a `config` file template (their names are usually suffixed
    with `.in`):'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/11-advanced-config/CalcConfig.cmake.in**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This template begins with a `@PACKAGE_INIT@` placeholder. The generator will
    fill it with the definitions of the `set_and_check` and `check_required_components`
    macros.
  prefs: []
  type: TYPE_NORMAL
- en: The next line sets `CALC_LIB_DIR` to the path passed in the `@PACKAGE_LIB_INSTALL_DIR@`
    placeholder. CMake will fill it with `$LIB_INSTALL_DIR`, provided in the listfile,
    but calculated relative to the installation path. Subsequently, that path is used
    in the `include()` command to include the *target export file*. Finally, `check_required_components()`
    verifies whether all of the components required by the project using this package
    have been found. This command is recommended, even if the package doesn’t have
    any components to ensure the users are using only supported requirements. Otherwise,
    they may incorrectly think they’ve successfully added components (perhaps only
    present in newer versions of the package).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CalcConfig.cmake` *config file*, when generated this way, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram, which shows how the various package files are related
    to each other, puts this into perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The file structure for advanced packages ](img/B19844_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: The file structure for advanced packages'
  prefs: []
  type: TYPE_NORMAL
- en: All the required sub-dependencies of a package must also be found in the package
    config file. This can be done by calling the `find_dependency()` macro from the
    `CMakeFindDependencyMacro` helper. We learned how to use it in *Chapter 9*, *Managing
    Dependencies in CMake*.
  prefs: []
  type: TYPE_NORMAL
- en: Definitions for any macros or functions exposed to the consuming project should
    be in a separate file included from the package’s *config file*. Interestingly,
    `CMakePackageConfigHelpers` also helps generate package version files. Let’s explore
    this next.
  prefs: []
  type: TYPE_NORMAL
- en: Generating package version files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As your package evolves, gaining new features and phasing out older ones, it’s
    vital to track these changes in a changelog accessible to developers using your
    package. When a specific feature is required, a developer that is using your package
    can specify the minimum version that supports it in `find_package()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: CMake will then search for `Calc`'s config file and check whether a *version
    file* named `<config-file>-version.cmake` or `<config-file>Version.cmake` is present
    in the same directory (e.g., `CalcConfigVersion.cmake`). This file contains version
    information and specifies compatibility with other versions. For instance, even
    if you don’t have the exact version 1.2.3 installed, you might have 1.3.5, which
    is marked as compatible with older versions. CMake will accept this package, knowing
    it’s backward compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `CMakePackageConfigHelpers` utility module to generate package
    *version files* by calling `write_basic_package_version_file()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: First, provide the `<filename>` for the artifact; ensure it follows the naming
    rules previously discussed. Optionally, you can pass an explicit `VERSION` (in
    major.minor.patch format). If not provided, the version specified in the `project()`
    command is used (an error will occur if the project doesn’t specify one).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `COMPATIBILITY` keyword indicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExactVersion` must match all three components of the version and doesn’t support
    ranged versions: (e.g., `find_package(<package> 1.2.8...1.3.4)`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SameMinorVersion` matches if the first two components are the same (ignores
    `patch`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SameMajorVersion` matches if the first component is the same (ignores `minor`
    and `patch`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnyNewerVersion`, contrary to its name, matches any older version (e.g., version
    1.4.2 is compatible with `find_package(<package> 1.2.8)`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For architecture-dependent packages, an exact architecture match is required.
    However, for architecture-agnostic packages (like header-only libraries or macro
    packages), you can specify the `ARCH_INDEPENDENT` keyword to skip this check.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a practical example of how to provide the *version
    file* for the project that we started in the `07-install-export`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/12-version-file/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, we configure the version of the package at the top of the file,
    in the `project()` command, switching from the short `project(<name> <languages>)`
    syntax to an explicit, full syntax by adding the `LANGUAGE` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: After including the helper module, we generate the version file and install
    it alongside `CalcConfig.cmake`. By skipping the `VERSION` keyword, we use the
    `PROJECT_VERSION` variable. The package is marked as fully backward compatible
    with `COMPATIBILITY` `AnyNewerVersion`. This installs the package *version file*
    to the same destination as `CalcConfig.cmake`. That’s it – our package is fully
    configured.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we concluded the subject of package creation. We now know how to
    deal with relocation and why it is important, how to install *target export files*,
    and how to write *config* and *version files*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore components and their use with packages.
  prefs: []
  type: TYPE_NORMAL
- en: Defining components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll begin by addressing potential confusion surrounding the term **component**.
    Consider the full signature for `find_package()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It’s important not to confuse the components mentioned here with the `COMPONENT`
    keyword that’s used in the `install()` command. Despite sharing the same name,
    they are distinct concepts and must be understood separately. We’ll explore this
    further in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: How to use components in find_package()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When calling `find_package()` with a list of `COMPONENTS` or `OPTIONAL_COMPONENTS`,
    we indicate to CMake that we are only interested in packages that provide these
    components. However, it’s crucial to understand that verifying this requirement
    is the responsibility of the package. If the package vendor doesn’t implement
    the necessary checks in the config file, as mentioned in the *Creating advanced
    config files* section, the process will not proceed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Requested components are passed to the config file via the `<package>_FIND_COMPONENTS`
    variable (both optional and non-optional). For every non-optional component, a
    `<package>_FIND_REQUIRED_<component>` variable is set. Package authors could write
    a macro to scan this list and verify the provision of all required components,
    but this is unnecessary. The `check_required_components()` function serves this
    purpose. The *config file* should set the `<package>_<component>_FOUND` variable
    when a necessary component is found. A macro at the file’s end will then verify
    whether all required variables are set.
  prefs: []
  type: TYPE_NORMAL
- en: How to use components in the install() command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all produced artifacts need installation in every scenario. For instance,
    a project might install static libraries and public headers for development, but
    by default, it may only need to install a shared library for runtime. To enable
    this dual behavior, artifacts can be grouped under a common name using the `COMPONENT`
    keyword, available in all `install()` commands. Users interested in limiting installation
    to specific components can do so by executing the following case-sensitive command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Assigning the `COMPONENT` keyword to an artifact doesn’t automatically exclude
    it from the default installation. To achieve this exclusion, the `EXCLUDE_FROM_ALL`
    keyword must be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore this concept in a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/13-components/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `install` commands define the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lib`: This contains the static library and target export files. It’s installed
    by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: This contains C++ header files. Also installed by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra`: This executes a piece of code to print a message. Not installed by
    default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s reiterate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake --install` without the `--component` argument will install both the
    `lib` and `headers` components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake --install --component headers` will only install public headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake --install --component extra` will print a message that’s inaccessible
    otherwise (the `EXCLUDE_FROM_ALL` keyword prevents that).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `COMPONENT` keyword isn’t specified for an installed artifact, it defaults
    to `Unspecified`, as defined by the `CMAKE_INSTALL_DEFAULT_COMPONENT_NAME` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Since there’s no way to list all available components from the cmake command
    line, thoroughly documenting your package’s components can be extremely helpful
    for users. An `INSTALL` “`READM`” file is a good place for this information.
  prefs: []
  type: TYPE_NORMAL
- en: If `cmake` is invoked with the `--component` argument for a non-existent component,
    the command will complete successfully without warnings or errors, but it won’t
    install anything.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning our installation into components allows users to selectively install
    parts of the package. Let’s now turn to managing symbolic links for versioned
    shared libraries, a useful feature for optimizing your installation processes.
  prefs: []
  type: TYPE_NORMAL
- en: Managing symbolic links for versioned shared libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The target platform for your installation may use symbolic links to help linkers
    discover the currently installed version of a shared library. After creating a
    `lib<name>.so` symlink to the `lib<name>.so.1` file, it’s possible to link this
    library by passing the `-l<name>` argument to the linker.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake’s `install(TARGETS <target> LIBRARY)` block handles the creation of such
    symlinks when needed. However, we may decide to move that step to another `install()`
    command by adding `NAMELINK_SKIP` to this block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign symlinking to another component (instead of disabling it altogether),
    we can repeat the `install()` command for the same target and specify a different
    component, followed by the `NAMELINK_ONLY` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The same effect can be achieved with the `NAMELINK_COMPONENT` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have configured automatic installation, we can provide pre-built
    artifacts for our users using the CPack tool, which is included with CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging with CPack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building projects from source has its benefits, it can be time-consuming
    and complex, which isn’t ideal for end users, especially non-developers. A more
    convenient distribution method is using binary packages, containing compiled artifacts
    and other necessary static files. CMake supports generating such packages with
    a command-line tool called `cpack`.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a package, select an appropriate package generator for your target
    platform and package type. Don’t confuse package generators with buildsystem generators
    like Unix Makefiles or Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the available package generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Generator Name** | **Produced File Types** | **Platform** |'
  prefs: []
  type: TYPE_TB
- en: '| Archive | 7Z, 7zip - (`.7z`)TBZ2 (`.tar.bz2`)TGZ (`.tar.gz`)TXZ (`.tar.xz`)TZ
    (`.tar.Z`)TZST (`.tar.zst`)ZIP (`.zip`) | Cross-platform |'
  prefs: []
  type: TYPE_TB
- en: '| Bundle | macOs Bundle (`.bundle`) | macOS |'
  prefs: []
  type: TYPE_TB
- en: '| Cygwin | Cygwin packages | Cygwin |'
  prefs: []
  type: TYPE_TB
- en: '| DEB | Debian packages (`.deb`) | Linux |'
  prefs: []
  type: TYPE_TB
- en: '| External | JSON (`.json`) file for 3rd party packagers | Cross-platform |'
  prefs: []
  type: TYPE_TB
- en: '| FreeBSD | PKG (`.pkg`) | *BSD, Linux, macOS |'
  prefs: []
  type: TYPE_TB
- en: '| IFW | QT installer binary | Linux, Windows, macOS |'
  prefs: []
  type: TYPE_TB
- en: '| NSIS | Binary (`.exe`) | Windows |'
  prefs: []
  type: TYPE_TB
- en: '| NuGet | NuGet package (`.nupkg`) | Windows |'
  prefs: []
  type: TYPE_TB
- en: '| productbuild | PKG (`.pkg`) | macOS |'
  prefs: []
  type: TYPE_TB
- en: '| RPM | RPM (`.rpm`) | Linux |'
  prefs: []
  type: TYPE_TB
- en: '| WIX | Microsoft Installer (`.msi`) | Windows |'
  prefs: []
  type: TYPE_TB
- en: 'Table 14.3: Available package generators'
  prefs: []
  type: TYPE_NORMAL
- en: Most of these generators have extensive configurations. While it’s beyond this
    book’s scope to delve into all their details, you can find more information in
    the *Further reading* section. We’ll focus on a general use case.
  prefs: []
  type: TYPE_NORMAL
- en: To use CPack, configure your project’s installation with the necessary `install()`
    commands and build your project. The resulting `cmake_install.cmake` in the build
    tree is used by CPack to prepare binary packages based on the `CPackConfig.cmake`
    file. While you can create this file manually, using `include(CPack)` in your
    project’s listfile is easier. It generates the configuration in the build tree
    and supplies default values where needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extend the `13-components` example for CPack use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch14/14-cpack/CMakeLists.txt (fragment)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The CPack module extracts the following variables from the `project()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_VERSION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_FILE_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CPACK_PACKAGE_FILE_NAME` stores the structure of the package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, `CPACK_SYSTEM_NAME` is the target OS name, like `Linux` or `win32`. For
    example, by executing a ZIP generator on Debian, CPack will generate a file named
    `CPackPackage-1.2.3-Linux.zip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate packages after building your project, go to the build tree of your
    project and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'CPack reads options from the `CPackConfig.cmake` file, but you can override
    these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-G <generators>`: Semicolon-separated list of package generators. The default
    value can be specified in the `CPackConfig.cmake` in the `CPACK_GENERATOR` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-C <configs>`: Semicolon-separated list of build configurations (debug, release)
    to generate packages for (required for multi-configuration buildsystem generators).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-D <var>=<value>`: This overrides a variable that’s set in the `CPackConfig.cmake`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--config <config-file>`: This uses a specified config file instead of the
    default `CPackConfig.cmake`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--verbose, -V`: This provides verbose output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P <packageName>`: This overrides the package name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-R <packageVersion>`: This overrides the package version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--vendor <vendorName>`: This overrides the package vendor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-B <packageDirectory>`: This specifies the output directory for `cpack` (by
    default, this will be the current working directory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s try generating packages for our `14-cpack` example project. We’re going
    to use ZIP, 7Z, and the Debian package generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get these packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.7z`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.deb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.zip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These binary packages are ready for publication on your project’s website, a
    GitHub release, or a package repository for end users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigating the intricacies of writing cross-platform installation scripts can
    be daunting, but CMake significantly simplifies this task. Although it requires
    some initial setup, CMake streamlines the process, integrating seamlessly with
    the concepts and techniques we’ve explored throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We began by understanding how to export CMake targets from projects, enabling
    their use in other projects without installation. This was followed by insights
    into installing projects that are already configured for export. Delving into
    installation basics, we focused on a crucial aspect: installing CMake targets.
    We now have a grasp of how CMake allocates different destinations for various
    artifact types and the special considerations for public headers. We also examined
    other modes of the `install()` command, encompassing the installation of files,
    programs, and directories, and executing scripts during installation.'
  prefs: []
  type: TYPE_NORMAL
- en: Our journey then led us to CMake’s reusable packages. We explored how to make
    project targets relocatable, facilitating user-defined installation locations.
    This included creating fully defined packages consumable via `find_package()`,
    entailing the preparation of *target export files*, *config files*, and *version
    files*. Acknowledging diverse user needs, we learned how to group artifacts and
    actions into installation components, distinguishing them from the components
    of CMake packages. Our exploration culminated in an introduction to CPack. We
    discovered how to prepare basic binary packages, offering an efficient method
    to distribute pre-compiled software. While mastering the nuances of installation
    and packaging in CMake is an ongoing journey, this chapter lays a robust foundation.
    It equips us to handle common scenarios and delve deeper with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll apply our accumulated knowledge by crafting a cohesive,
    professional project, showcasing practical applications of these CMake techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GNU coding standards for destinations: [https://www.gnu.org/prep/standards/html_node/Directory-Variables.html](https://www.gnu.org/prep/standards/html_node/Directory-Variables.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion on new public header management with the `FILE_SET` keyword:[https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860](https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to install a shared library: [https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating relocatable packages: [https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages](https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'List of paths scanned by `find_package()` to find the config file: [https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure](https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Full documentation of `CMakePackageConfigHelpers`: [https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPack package generators: [https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html](https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On preferred package generators for different platforms:[https://stackoverflow.com/a/46013099](https://stackoverflow.com/a/46013099)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPack utility module documentation: [https://cmake.org/cmake/help/latest/module/CPack.html](https://cmake.org/cmake/help/latest/module/CPack.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code94081075213645359.png)'
  prefs: []
  type: TYPE_IMG
