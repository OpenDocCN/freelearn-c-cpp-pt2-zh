- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Seamlessly Integrating Code Quality Tools with CMake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与CMake无缝集成代码质量工具
- en: So far, we have focused on building and installing projects, as well as generating
    documentation and handling external dependencies. Another major task when writing
    quality software is testing and ensuring that code quality is at the desired level
    by various other means. To achieve high code quality, writing unit tests and executing
    them occasionally is no longer enough. If you want to produce high-quality software,
    having proper test tools that integrate easily with your build system is not a
    luxury but a necessity. Only when building and testing work effortlessly together
    can programmers focus on writing good tests, instead of focusing on getting those
    tests to run. Methods such as test-driven development bring huge value to software
    quality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们集中于构建和安装项目，生成文档以及处理外部依赖项。编写高质量软件的另一个重要任务是测试，并通过其他手段确保代码质量达到预期水平。为了实现高代码质量，仅仅编写单元测试并偶尔执行是不够的。如果你想开发高质量的软件，拥有与构建系统轻松集成的合适测试工具不仅不是奢侈，而是必须的。只有构建和测试能够无缝配合，程序员才能专注于编写良好的测试，而不是花时间确保这些测试能够运行。像测试驱动开发这样的方式为软件质量带来了巨大价值。
- en: However, it is not just writing plain tests that increase the quality. Writing
    good tests is one thing; checking the effectiveness of the tests with coverage
    reports and ensuring general code quality with static code analysis is another.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，提高质量的不仅仅是编写普通的测试。编写良好的测试是一回事；通过覆盖率报告检查测试的有效性，并通过静态代码分析确保整体代码质量是另一回事。
- en: While tests, coverage, and static code analysis help determine whether code
    functions as intended, one problem is often that some of the tools only work with
    a specific compiler or require special compiler settings. In order to benefit
    from the tools, it might be necessary to compile the same source in different
    ways with different compilers. Luckily, this is exactly what CMake is extremely
    good at, which is why CMake can help to boost the quality of code by making these
    quality tools accessible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试、覆盖率和静态代码分析有助于确定代码是否按预期运行，但一个常见的问题是，一些工具仅与特定编译器兼容，或需要特殊的编译器设置。为了利用这些工具，可能需要使用不同的编译器以不同的方式编译相同的源代码。幸运的是，CMake正是擅长这一点，这也是为什么CMake能够帮助提升代码质量，使得这些质量工具易于访问的原因。
- en: The good thing about a lot of the tools for ensuring high code quality is that
    they can often be automated. With today’s easy availability of CI/CD systems,
    creating a high degree of automated checks for good quality software is quite
    easy, especially since, with CMake, these things can often be configured and executed
    right where you define how the software is built. In this chapter, you will learn
    how to define and orchestrate tests using CMake, as well as how to create code
    coverage reports to see which parts of the software are tested at all. We will
    examine how to integrate various code sanitizers and static code analyzers to
    check code quality already while compiling. We will show you various ways to include
    all the tools and how to create a dedicated build type to run static code quality
    tools. Finally, we will have a peek at how to set up micro-benchmarks to check
    the runtime performance of your code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 很多确保高代码质量的工具有一个好处，那就是它们通常可以自动化。随着如今CI/CD系统的普及，创建高程度的自动化检查以确保软件质量变得相当容易，尤其是使用CMake时，这些工具通常可以在定义软件构建方式的地方进行配置和执行。本章将教你如何使用CMake定义和协调测试，并创建代码覆盖率报告，以查看哪些部分的代码已被测试。我们还将探讨如何集成各种代码清理工具和静态代码分析器，在编译时就检查代码质量。我们会展示如何将所有这些工具集成在一起，以及如何创建一个专门的构建类型来运行静态代码质量工具。最后，我们还会看看如何设置微基准测试，检查代码的运行时性能。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主要内容：
- en: Defining, discovering, and running tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义、发现和运行测试
- en: Generating code coverage reports
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成代码覆盖率报告
- en: Sanitizing your code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理代码
- en: Static code analysis using CMake
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CMake进行静态代码分析
- en: Creating custom build types for quality tools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为质量工具创建自定义构建类型
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, the examples are tested with CMake 3.24 and
    run on any of the following compilers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节一样，示例在CMake 3.24下进行测试，并可以在以下任意编译器上运行：
- en: GCC 9 or newer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 9 或更高版本
- en: Clang 12 or newer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 12 或更高版本
- en: MSVC 19 or newer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSVC 19 或更高版本
- en: Some of the examples for code coverage, sanitizers, and static code analysis
    require GCC or Clang to run and will not work with MSVC. To run Clang on Windows,
    take a look at [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible
    Build* *Environments*, where toolchain files are introduced. Some examples need
    the Catch2 unit testing suite installed to compile. Some examples pull dependencies
    from various online locations, so an internet connection is required as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关于代码覆盖率、清理工具和静态代码分析的示例需要 GCC 或 Clang 才能运行，无法在 MSVC 上运行。要在 Windows 上运行 Clang，请查看
    [*第9章*](B30947_09.xhtml#_idTextAnchor146)，*创建可重现的构建* *环境*，该章节介绍了工具链文件的使用。一些示例需要安装
    Catch2 单元测试套件才能编译。某些示例会从不同的在线位置拉取依赖项，因此也需要连接互联网。
- en: 'In addition to a working compiler, the following software is used for the examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个有效的编译器外，以下软件也用于示例中：
- en: '`Gcov`, `Gcovr`, and `lcov` for the Linux examples on code coverage'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gcov`、`Gcovr` 和 `lcov` 用于 Linux 示例中的代码覆盖率'
- en: '`Opencppcoverage` for the Windows examples on code coverage'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Opencppcoverage` 用于 Windows 示例中的代码覆盖率'
- en: '`Clang-tidy`, `Cppcheck`, `Cpplint`, and `include-what-you-use` for the examples
    on static code analyzers'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clang-tidy`、`Cppcheck`、`Cpplint` 和 `include-what-you-use` 用于静态代码分析器的示例'
- en: All examples and source code are available on the GitHub repository of this
    book at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有示例和源代码都可以在 [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)
    的 GitHub 仓库中找到。
- en: If any software is missing, the related examples will be excluded from the build.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少某些软件，相关示例将从构建中排除。
- en: Defining, discovering, and running tests
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义、发现和运行测试
- en: Testing is the staple diet for any software engineer who takes pride in quality
    software. The number of frameworks to write unit tests in the various languages
    is huge, and, especially for C++, CMake includes modules to work with most of
    the more popular ones.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何注重软件质量的工程师的主食。各种语言中用于编写单元测试的框架数量庞大，尤其是在 C++ 中，CMake 包含了与大多数流行框架一起使用的模块。
- en: 'At very abstract levels, all unit testing frameworks do the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常抽象的层面上，所有单元测试框架都执行以下操作：
- en: Allow the formulation and grouping of test cases
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对测试用例进行定义和分组
- en: Contain some form of assertion to check for various test conditions
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含某种形式的断言来检查不同的测试条件
- en: Discover and run test cases, either altogether or a selection of them
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现并运行测试用例，可以是全部或其中的某些测试
- en: Produce a test result in a variety of formats, such as plain text, JSON, and
    XML
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以多种格式（如纯文本、JSON 和 XML）生成测试结果
- en: With the CTest utility, CMake includes a built-in way to execute almost any
    test. Any CMake project that has set `enable_testing()` and added at least one
    test with `add_test()` has testing support enabled. Any call to `enable_testing()`
    will enable test discovery in the current directory and any directory below it,
    so it is often a good idea to set it in the top-level `CMakeLists.txt` before
    any calls to `add_subdirectory`. The CTest module of CMake automatically sets
    `enable_testing` if used with `include(CTest)`, unless the `BUILD_TESTING` option
    was set to `OFF`. /
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CTest 工具，CMake 提供了一种内置的执行几乎任何测试的方法。任何已设置 `enable_testing()` 并通过 `add_test()`
    添加了至少一个测试的 CMake 项目，都启用了测试支持。任何对 `enable_testing()` 的调用都会启用当前目录及其子目录中的测试发现，因此通常建议在顶层
    `CMakeLists.txt` 文件中设置它，且在任何调用 `add_subdirectory` 之前进行设置。CMake 的 CTest 模块会自动设置
    `enable_testing`，如果与 `include(CTest)` 一起使用，除非将 `BUILD_TESTING` 选项设置为 `OFF`。
- en: It is good practice to not build and run tests that depend on the `BUILD_TESTING`
    option. A common pattern here is to put all parts of a project that concern testing
    into their own subfolder and only include the subfolder if `BUILD_TESTING` is
    set to `ON`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议构建和运行依赖于 `BUILD_TESTING` 选项的测试。一个常见的做法是将所有与测试相关的部分放入自己的子文件夹中，并且只有在 `BUILD_TESTING`
    设置为 `ON` 时才包含该子文件夹。
- en: 'The CTest module should generally be included only in the top-level `CMakeLists.txt`
    file of a project. Since CMake version 3.21, the `PROJECT_IS_TOP_LEVEL` variable
    can be used to test whether the current `CMakeLists.txt` file is the top level.
    This variable will be `true` for the top-level directory of a project and top-level
    directories of projects added with `ExternalProject`. For directories added with
    `add_subdirectory` or `FetchContent`, the value is `false`. As such, CTest should
    be included like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CTest 模块通常应该仅在项目的顶级 `CMakeLists.txt` 文件中包含。自 CMake 版本 3.21 起，可以使用 `PROJECT_IS_TOP_LEVEL`
    变量来测试当前的 `CMakeLists.txt` 文件是否为顶级文件。对于项目的顶级目录及通过 `ExternalProject` 添加的项目的顶级目录，该变量的值为
    `true`。对于通过 `add_subdirectory` 或 `FetchContent` 添加的目录，值为 `false`。因此，CTest 应该像这样被包含：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Generally, projects should rely on the `BUILD_TESTING` flag to determine whether
    tests should be built and included. However, especially for open source projects
    or projects with complicated requirements regarding testing, providing an additional
    `option()` to disable testing for only one specific project can be convenient
    for developers using the project. The resulting CMake code could look something
    like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，项目应该依赖 `BUILD_TESTING` 标志来确定是否应该构建和包含测试。然而，特别是对于开源项目或具有复杂测试需求的项目，提供一个额外的
    `option()` 来禁用仅特定项目的测试对于开发者来说是非常方便的。生成的 CMake 代码可能如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unit tests are, in essence, small programs that run a list of assertions inside,
    and if any of the assertions fail, they return a non-zero return value. There
    are many frameworks and libraries that help to organize tests and write assertions,
    but from the outside, checking assertions and returning a corresponding value
    is the core functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试本质上是小型程序，它们在内部运行一系列断言，如果任何断言失败，它们将返回一个非零的返回值。有许多框架和库可以帮助组织测试和编写断言，但从外部来看，检查断言并返回相应的值是核心功能。
- en: 'Tests can be added to any `CMakeLists.txt` file with the `add_test` function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以通过 `add_test` 函数添加到任何 `CMakeLists.txt` 文件中：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`COMMAND` can be the name of an executable target defined in the project or
    a full path to an arbitrary executable. Any arguments needed for the test are
    also included. Using target names is the preferred way, as CMake will then substitute
    the path to the executable automatically. The `CONFIGURATION` option is used to
    tell CMake for which build configurations the test is valid. For most test cases,
    this is irrelevant, but for micro-benchmarking, for instance, this can be quite
    useful. `WORKING_DIRECTORY` should be an absolute path. By default, tests are
    executed in `CMAKE_CURRENT_BINARY_DIR`. The `COMMAND_EXPAND_LISTS` option ensures
    that any lists passed as part of the `COMMAND` option are expanded.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMMAND` 可以是项目中定义的可执行目标的名称，也可以是任意可执行文件的完整路径。任何测试所需的参数也包括在内。使用目标名称是首选的方式，因为这样
    CMake 会自动替换可执行文件的路径。`CONFIGURATION` 选项用于告诉 CMake 测试适用于哪些构建配置。对于大多数测试用例，这一点无关紧要，但对于微基准测试等，这可能非常有用。`WORKING_DIRECTORY`
    应该是绝对路径。默认情况下，测试在 `CMAKE_CURRENT_BINARY_DIR` 中执行。`COMMAND_EXPAND_LISTS` 选项确保作为
    `COMMAND` 选项一部分传递的任何列表都会被展开。'
- en: 'A simple project including a test might look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个测试的简单项目可能如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, an executable target called `simple_test` is used as a test
    called `example_test`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用一个名为 `simple_test` 的可执行目标作为一个名为 `example_test` 的测试。
- en: 'CTest will consume the information about the tests and execute them. The tests
    are executed by running the `ctest` command standalone or as a special target
    as part of the build step of CMake. Both ways of executing require that the project
    has been built beforehand. Either of the two following commands will execute the
    tests:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CTest 将消耗有关测试的信息并执行它们。测试通过单独运行 `ctest` 命令或作为 CMake 构建步骤的一部分执行的特殊目标来执行。无论哪种执行方式，都要求项目在执行之前已经构建。以下两条命令都将执行测试：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Invoking CTest as a target of the build has the advantage that CMake will check
    first whether all the needed targets are built and on the newest version, but
    running `ctest` directly offers more control over the tests to be executed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CTest 作为构建的目标来调用的优点是，CMake 会首先检查所有需要的目标是否已构建并且是最新版本，但直接运行 `ctest` 则提供了更多对执行测试的控制。
- en: 'The output of `ctest` might look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctest` 的输出可能类似于以下内容：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Generally, the test suppresses all output to `stdout`. By passing the `-V` or
    `--verbose` command-line argument, the output is always printed. However, usually,
    you’re only interested in the output of the failed tests. So, the `--output-on-failure`
    argument is often the better alternative. This way, only failed tests produce
    output. For very verbose tests, the output can be limited in size with the `--test-output-size-passed
    <size>` and `--test-output-size-failed <size>` options, where size is the number
    of bytes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试会抑制所有输出到 `stdout`。通过传递 `-V` 或 `--verbose` 命令行参数，输出将始终打印出来。然而，通常情况下，你只对失败的测试的输出感兴趣。因此，`--output-on-failure`
    参数通常是更好的选择。这样，只有失败的测试会产生输出。对于非常详细的测试，可以使用 `--test-output-size-passed <size>` 和
    `--test-output-size-failed <size>` 选项来限制输出的大小，其中 size 为字节数。
- en: Having one or more calls to `add_test` in the build tree will cause CMake to
    write out an input file for CTest in `CMAKE_CURRENT_BINARY_DIR`. The input files
    for CTest are not necessarily located at the top level of the project but where
    they are defined instead. To list all tests but not execute them, the `-N` option
    for CTest is used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建树中有一个或多个对 `add_test` 的调用，会导致 CMake 在 `CMAKE_CURRENT_BINARY_DIR` 中为 CTest
    写出一个输入文件。CTest 的输入文件不一定位于项目的顶层，而是位于定义它们的位置。要列出所有测试但不执行它们，可以使用 CTest 的 `-N` 选项。
- en: A very useful feature of CTest is that it caches the states of tests between
    runs. This allows you to only run tests that failed in the last run. To do this,
    run `ctest --rerun-failed`. If no tests failed or no tests were run before, all
    tests will be run.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CTest 的一个非常有用的功能是，它在每次运行之间缓存测试的状态。这使得你只需运行上次运行中失败的测试。要做到这一点，可以运行 `ctest --rerun-failed`。如果没有测试失败或之前没有运行过任何测试，所有测试都会被执行。
- en: 'Sometimes, you do not want to execute the full test set – for instance, if
    a single failing test needs to be fixed. The `-E` and `-R` command-line options
    take `-E` option excludes tests matching the pattern, and the `-R` option selects
    tests to be included. The options can be combined. The following command would
    run all tests that begin with `FeatureX` but exclude the test called `FeatureX_Test_1`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能不想执行完整的测试集——例如，如果需要修复某个单一失败的测试。`-E` 和 `-R` 命令行选项分别表示 `-E` 选项排除匹配模式的测试，而
    `-R` 选项选择需要包含的测试。这些选项可以组合使用。以下命令将执行所有以 `FeatureX` 开头的测试，但排除名为 `FeatureX_Test_1`
    的测试：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way to selectively execute tests is to label them using the `LABELS`
    properties for tests, and then select the labels to run with the `-L` option of
    CTest. A test can have multiple labels assigned, separated by a semicolon, as
    shown in the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有选择性地执行测试的方法是使用 `LABELS` 属性为测试标记标签，然后使用 CTest 的 `-L` 选项选择要执行的标签。一个测试可以分配多个标签，标签之间用分号分隔，如以下示例所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `-L` command line option takes a regex to filter the labels:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`-L` 命令行选项接受一个正则表达式，用于过滤标签：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will only execute `labeled_test_1` and `labeled_test_3`, as they both have
    the `example` label assigned, but not `labeled_test_2` or any other tests that
    have no label assigned.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只执行 `labeled_test_1` 和 `labeled_test_3`，因为它们都被分配了 `example` 标签，但不会执行 `labeled_test_2`
    或任何其他没有分配标签的测试。
- en: 'By formulating the regex accordingly, multiple labels can be combined:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过相应地制定正则表达式，可以将多个标签组合在一起：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will execute all the tests from the example but no other tests that have
    no label assigned.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行所有来自示例的测试，但不会执行其他没有分配标签的测试。
- en: Using labels would be particularly useful to mark tests that are designed to
    fail or similar, or tests that are only relevant in certain execution contexts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签特别有助于标记设计上会失败的测试或类似的测试，或者仅在某些执行上下文中相关的测试。
- en: 'The last alternative to the regex or label-based test selection is to use the
    `-I` option, which takes the assigned test numbers. The argument for the `-I`
    option is somewhat complicated:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式或标签基础的测试选择的最后一个替代方法是使用 `-I` 选项，它接受分配的测试编号。`-I` 选项的参数有些复杂：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With `Start`, `End`, and `Stride`, a range for the tests to be executed in can
    be specified. The three numbers are for the range combined with explicit test
    numbers, `test#`. Alternatively, a file containing the argument can be passed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Start`、`End` 和 `Stride`，可以指定要执行的测试范围。三个数字表示与显式测试编号 `test#` 结合的范围。或者，也可以传递包含参数的文件。
- en: 'The following call will execute all odd tests from `1` to `10`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下调用将执行从 `1` 到 `10` 的所有奇数测试：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, tests `1`, `3`, `5`, `7`, and `9` will be executed. The following command
    will execute only the tests and `8`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试 `1`、`3`、`5`、`7` 和 `9` 将被执行。以下命令将只执行测试 `8`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that, in this call, `End` is set to `0`, so no test range is executed.
    To combine the range and explicit test numbers, the following command will execute
    all odd tests from `1` to `10`, and additionally test `6` and `8`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此调用中，`End`被设置为`0`，因此没有执行测试范围。要结合范围和显式的测试编号，以下命令将执行从`1`到`10`的所有奇数测试，并另外测试`6`和`8`：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The cumbersome handling of the `-I` option and the fact that adding new tests
    might reassign the numbers are two reasons why this method is rarely used in practice.
    Usually, filtering either by labels or test names is preferred.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`-I`选项的繁琐以及添加新测试可能会重新分配编号，是这种方法在实践中很少使用的两个原因。通常，更倾向于通过标签或测试名称进行过滤。
- en: Another common pitfall when writing tests is that they are not independent enough.
    So, test `2` might accidentally depend on a previous execution of test `1`. To
    harden against this accidental dependency, CTest has the ability to randomize
    test execution order with the `--schedule-random` command-line argument. This
    will ensure that tests are executed in an arbitrary order.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试时的另一个常见陷阱是测试不够独立。因此，测试`2`可能意外地依赖于测试`1`的先前执行。为了防止这种意外依赖，CTest可以通过`--schedule-random`命令行参数随机化测试执行顺序。这将确保测试以任意顺序执行。
- en: Automatically discovering tests
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动发现测试
- en: Defining tests with `add_test` is one way to expose them to CTest. One drawback
    is that this will register the whole executable as a single test. In most cases,
    however, a single executable will contain many unit tests and not just one, so
    when one of the tests inside the executable fails, it might be hard to figure
    out which test exactly failed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add_test`定义测试是将测试暴露给CTest的一种方式。一个缺点是，这将把整个可执行文件注册为一个单独的测试。然而，在大多数情况下，一个可执行文件将包含许多单元测试，而不仅仅是一个，因此当其中一个测试失败时，可能很难确定究竟是哪个测试失败了。
- en: 'Consider a C++ file containing the following test code, and let’s assume that
    the Fibonacci function contains a bug, so `Fibonacci(0)` will not return `1` as
    it should but something else instead:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含以下测试代码的C++文件，假设Fibonacci函数包含一个bug，因此`Fibonacci(0)`不会返回`1`，而是返回其他值：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If all these tests are compiled into the same executable, called `Fibonacci`,
    then adding them with `add_test` will only indicate that the executable failed,
    not telling us in which of the scenarios seen in the previous code block it did
    so.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将所有这些测试编译到同一个可执行文件中，名为`Fibonacci`，那么通过`add_test`将它们添加进去时，只会显示可执行文件失败，但不会告诉我们它在前面代码块中的哪个场景下失败了。
- en: 'The result of the test will look something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结果将类似于以下内容：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That is hardly helpful to figure out which of the test cases failed. Luckily,
    with Catch2 and GoogleTest, there is a way to expose the internal tests to CTest
    so that they are executed as regular tests. For GoogleTest, the module to do so
    is provided by CMake itself; Catch2 provides this functionality in its own CMake
    integration. Discovering the tests with Catch2 is done with `catch_discover_tests`,
    while for GoogleTest, `gtest_discover_tests` is used. The following example will
    expose tests written in the Catch2 framework to CTest:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做对确定哪个测试用例失败并没有太大帮助。幸运的是，使用Catch2和GoogleTest时，可以通过将内部测试暴露给CTest来使它们作为常规测试执行。对于GoogleTest，CMake本身提供了执行此操作的模块；Catch2则在其自己的CMake集成中提供了这一功能。使用Catch2发现测试是通过`catch_discover_tests`，而对于GoogleTest，则使用`gtest_discover_tests`。以下示例将把在Catch2框架中编写的测试暴露给CTest：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that, in order to have the function available, the `Catch` module has
    to be included. For GoogleTest, it works very similarly:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使该函数可用，必须包含`Catch`模块。对于GoogleTest，它的工作方式非常相似：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When using the discovery functions, each test case defined in a test executable
    will be treated as its own test by CTest. If tests are exposed like this, the
    result of a call to CTest might look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用发现功能时，在测试可执行文件中定义的每个测试用例将被CTest视为其自己的测试。如果像这样暴露测试，则调用CTest的结果可能如下所示：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we can see exactly which of the defined test cases failed. In this case,
    the `Fibonacci(0) returns 1` test case did not behave as expected. This comes
    in especially handy when using an editor or IDE with integrated testing functionality.
    The discovery functions both work by running the specified executable, with an
    option to only print the test names to register them internally with CTest, so
    there is a slight overhead added to each build step. Discovering tests more granularly
    also has the advantage that their execution can be better parallelized by CMake,
    as described in the *Running tests in parallel and managing test resources* section
    of this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以清楚地看到哪些已定义的测试用例失败了。在这种情况下，`Fibonacci(0) returns 1` 测试用例没有按预期行为工作。当使用具有集成测试功能的编辑器或IDE时，这尤其有用。发现功能通过运行指定的可执行文件来工作，可以选择仅打印测试名称并将其内部注册到
    CTest，因此每个构建步骤会有一些额外的开销。更细粒度地发现测试也有一个优点，即其执行可以更好地由 CMake 并行化，如本章的*并行运行测试和管理测试资源*部分所述。
- en: 'Both `gtest_discover_tests` and `catch_discover_tests` have various options,
    such as adding a prefix or suffix to the test names or a list of properties to
    add to the generated tests. The full documentation for the functions can be found
    here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtest_discover_tests` 和 `catch_discover_tests` 都有多种选项，例如为测试名称添加前缀或后缀，或将属性列表添加到生成的测试中。有关这些函数的完整文档可以在这里找到：'
- en: '**Catch2**: [https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Catch2**: [https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md)'
- en: '**GoogleTest**: [https://cmake.org/cmake/help/v3.21/module/GoogleTest.html](https://cmake.org/cmake/help/v3.21/module/GoogleTest.html)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GoogleTest**: [https://cmake.org/cmake/help/v3.21/module/GoogleTest.html](https://cmake.org/cmake/help/v3.21/module/GoogleTest.html)'
- en: Catch2 and GoogleTest are just two of the many testing frameworks out there;
    there might be more test suites that carry this functionality that aren’t as well
    known.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Catch2 和 GoogleTest 只是众多测试框架中的两个；可能还有其他未广为人知的测试套件也具备相同功能。
- en: Now, let’s move on from finding tests and have a closer look at how to control
    test behavior.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从寻找测试转向更深入地了解如何控制测试行为。
- en: Advanced ways to determine test success or failure
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定测试成功或失败的高级方法
- en: By default, CTest determines whether a test failed or passed based on the return
    value of the command. `0` means all tests were successful; anything other than
    `0` is interpreted as a failure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CTest 会根据命令的返回值来判断测试是否失败或通过。`0` 表示所有测试成功；任何非 `0` 的返回值都被视为失败。
- en: 'Sometimes, the return value is not enough to determine whether a test passes
    or fails. If you need to check program output for a certain string, the `FAIL_REGULAR_EXPRESSION`
    and `PASS_REGULAR_EXPRESSION` test properties can be used, as shown in the following
    example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅凭返回值不足以判断测试是否通过。如果需要检查程序输出中是否包含某个字符串，可以使用 `FAIL_REGULAR_EXPRESSION` 和 `PASS_REGULAR_EXPRESSION`
    测试属性，如下例所示：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These properties would cause the `some_test` test to fail if the output contains
    either `"Warning"` or `"Error"`. If the `"Success"` string is found, the test
    is considered to have passed. If `PASS_REGULAR_EXPRESSION` is set, the test is
    considered to have passed only if the string is present. In both cases, the return
    value will be ignored. If a certain return value of a test needs to be ignored,
    it can be passed with the `SKIP_RETURN_CODE` option.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性会导致 `some_test` 测试失败，如果输出中包含 `"Warning"` 或 `"Error"`。如果发现 `"Success"` 字符串，则认为测试通过。如果设置了
    `PASS_REGULAR_EXPRESSION`，则仅当字符串存在时，测试才会被认为通过。在这两种情况下，返回值将被忽略。如果需要忽略某个测试的特定返回值，可以使用
    `SKIP_RETURN_CODE` 选项。
- en: 'Sometimes, a test is expected to fail. In those cases, setting `WILL_FAIL`
    to `true` will cause the test result to be inverted:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，测试预期会失败。在这种情况下，将 `WILL_FAIL` 设置为 `true` 会导致测试结果反转：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is often better than disabling the test because it will still be executed
    on each test run, and if the test unexpectedly starts to pass again, the developer
    is made aware of it. A special test failure case is when tests fail to return
    or take too much time to complete. For this case, CTest provides the means of
    adding timeouts of tests and even retrying tests if there is a failure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常比禁用测试更好，因为它仍然会在每次测试运行时执行，如果测试意外开始通过，开发人员会立即知道。一个特殊的测试失败情况是测试未返回或完成需要太长时间。对于这种情况，CTest
    提供了添加测试超时的功能，甚至可以在失败时重试测试。
- en: Handling timeouts and repeating tests
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理超时和重试测试
- en: 'Sometimes, we’re not just interested in the success or failure of a test but
    also in how long it takes to complete. The `TIMEOUT` test property takes a number
    of seconds to determine the maximum runtime for a test. If the test exceeds the
    set time, it is terminated and considered a failure. The following command would
    limit the test execution of a test to 10 seconds:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不仅仅关注测试的成功或失败，还关注测试完成所需的时间。`TIMEOUT`测试属性使用一个秒数来确定测试的最大运行时间。如果测试超出了设定的时间，它将被终止并视为失败。以下命令将测试的执行时间限制为10秒：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `TIMEOUT` property often comes in handy for tests that run the risk of falling
    into infinite loops or hanging forever for whatever reason.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIMEOUT`属性通常对于那些有可能因某些原因进入无限循环或永远挂起的测试非常有用。'
- en: Alternatively, CTest accepts the `--timeout` argument, setting a global timeout
    that is applied to all tests that have no `TIMEOUT` property specified. For those
    tests that have `TIMEOUT` defined, the timeout defined in `CmakeLists.txt` takes
    precedence over the timeout passed over the command line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，CTest还接受`--timeout`参数，设置一个全局超时，这个超时适用于所有没有指定`TIMEOUT`属性的测试。对于那些已定义`TIMEOUT`的测试，`CmakeLists.txt`中定义的超时会优先于命令行传递的超时设置。
- en: 'To avoid long test execution, the CTest command line accepts the `--stop-time`
    argument, which takes the real-time of the day as a time limit for the complete
    set of tests. The following command would set a default timeout of 30 seconds
    for each test, and the tests would have to be completed before 23:59:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免长时间的测试执行，CTest命令行接受`--stop-time`参数，该参数以当天的实时时间作为完整测试集的时间限制。以下命令会为每个测试设置一个默认的超时为30秒，且所有测试必须在23:59之前完成：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sometimes, we can expect a test to experience occasional timeouts due to factors
    outside of our control. Very common cases are tests that need some form of network
    communication or a resource that has some kind of bandwidth limitation. Sometimes,
    the only way to get a test to run is to try it again. For this, the `--repeat
    after-timeout:n` command-line argument can be passed to CTest, where *n* is a
    number.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会遇到由于一些不可控因素而导致的测试超时。常见的情况是需要进行某种网络通信或依赖某种带宽有限资源的测试。有时，唯一能让测试继续运行的方法是重新尝试。为此，可以将`--repeat
    after-timeout:n`命令行参数传递给CTest，其中*n*是一个数字。
- en: 'The `--repeat` argument actually has three options:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`--repeat`参数实际上有三个选项：'
- en: '`after-timeout`: This retries the test several times if a timeout occurred.
    Generally, the `--timeout` option should be passed to CTest whenever there are
    repeated timeouts.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after-timeout`：如果发生超时，这会重新尝试测试若干次。通常，若发生重复超时，应将`--timeout`选项传递给CTest。'
- en: '`until-pass`: This reruns a test until it passes or the number of retries is
    reached. Setting this as a general rule in a CI environment is a bad idea, as
    tests should generally always pass.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until-pass`：这个选项会一直重新运行测试，直到通过或者达到重试次数为止。在CI环境中，作为一般规则设置此选项是不推荐的，因为测试通常应该总是通过的。'
- en: '`until-fail`: Tests are rerun a number of times or until they fail. This is
    often used if a test fails occasionally to find out how frequently this happens.
    The `--repeat-until-fail` argument works exactly like `--repeat:until-fail:n`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until-fail`：测试会重新运行若干次，直到失败为止。这通常用于测试偶尔失败的情况，目的是找出这种失败发生的频率。`--repeat-until-fail`参数与`--repeat:until-fail:n`的作用完全相同。'
- en: As mentioned, the reason for failing tests might be the unavailability of resources
    that the test depends on. One common case for external resources being unavailable
    is that they are flooded with requests from tests. The *Running tests in parallel
    and managing test resources* section explores a few options to avoid such complications.
    Another common cause for timeouts when accessing external resources is that the
    resource is not yet available when the tests run.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试失败的原因可能是测试依赖的资源不可用。外部资源不可用的常见情况是它们被测试请求淹没。*并行运行测试和管理测试资源*部分探讨了避免此类问题的一些方法。另一种常见的超时原因是，当测试运行时，外部资源尚未可用。
- en: In the next section, we will see how to write test fixtures that can be used
    to ensure that resources are started before a test run.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将看到如何编写测试夹具，确保在测试运行之前资源已经启动。
- en: Writing test fixtures
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试夹具
- en: 'Tests should, in general, be independent of each other. There are cases where
    tests might depend on a precondition that is not controlled by the test itself.
    For instance, a test might require a server to be running in order to test a client.
    These dependencies can be expressed in CMake by defining them as test fixtures,
    using the `FIXTURE_SETUP`, `FIXTURE_CLEANUP`, and `FIXTURE_REQUIRED` test properties.
    All three properties take a list of strings to identify a fixture. A test might
    indicate that it needs a particular fixture by defining the `FIXTURE_REQUIRED`
    property. This will ensure that the test named `fixture` completes successfully
    before it is executed. Similarly, a test might declare it in `FIXTURE_CLEANUP`
    to indicate that it must be run after the completion of the test requiring the
    fixture. The fixtures defined in the cleanup part are always run, regardless of
    whether a test succeeded or failed. Consider the following example, which can
    be found in the `chapter07/fixture_example` directory in the repository:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常应该彼此独立。也有一些情况，测试可能依赖于一个前提条件，而这个前提条件并不由测试本身控制。例如，某个测试可能要求一个服务器正在运行，才能测试客户端。这些依赖关系可以通过在
    CMake 中定义测试固定装置（test fixtures）来表达，使用`FIXTURE_SETUP`、`FIXTURE_CLEANUP`和`FIXTURE_REQUIRED`测试属性。所有三个属性都接受一个字符串列表来标识一个固定装置。一个测试可以通过定义`FIXTURE_REQUIRED`属性来表明它需要某个特定的固定装置。这将确保在执行该测试之前，名为`fixture`的测试已经成功完成。同样，一个测试可以在`FIXTURE_CLEANUP`中声明，表示它必须在依赖该固定装置的测试完成后执行。清理部分中定义的固定装置无论测试成功与否，都会被执行。考虑以下示例，它可以在代码库的`chapter07/fixture_example`目录中找到：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, a program called `echo_server` is used as a fixture so that
    another program called `echo_client` can use it. The execution of `echo_server`
    with the `--start` and `--stop` arguments are formulated as tests, with the names
    `start_server` and `stop_server`, respectively. The `start_server` test is marked
    as the setup of the fixture, with the name `server`. The `stop_server` test is
    set up likewise but is marked as the cleanup routine of the fixture. Finally,
    the actual test called `client_test` is set up, and it gets passed to the `server`
    fixture as a required precondition.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，名为`echo_server`的程序作为固定装置使用，以便另一个名为`echo_client`的程序可以使用它。`echo_server`的执行通过`--start`和`--stop`参数被制定为两个测试，分别命名为`start_server`和`stop_server`。`start_server`测试被标记为固定装置的设置部分，命名为`server`。`stop_server`测试同样被设置，但标记为固定装置的清理部分。最后，实际的测试`client_test`被设置，并作为必要的前提条件传递给`server`固定装置。
- en: 'If the `client_test` test is now run using CTest, the fixtures are automatically
    invoked with it. The fixture tests show up as regular tests in the output for
    CTest, as shown in the following example output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在使用 CTest 运行`client_test`，固定装置会自动与测试一起调用。固定装置测试会作为常规测试出现在 CTest 的输出中，如下所示的示例输出所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that CTest was invoked with a regex filter that only matches the client
    test, but CTest started the fixture anyway. To not overwhelm test fixtures when
    tests are executed in parallel, they can be defined as resources, as shown in
    the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，CTest是通过正则表达式过滤器调用的，仅匹配客户端测试，但CTest仍然启动了固定装置。为了避免在并行执行测试时过度加载测试固定装置，可以将它们定义为资源，如下一节所示。
- en: Running tests in parallel and managing test resources
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行运行测试并管理测试资源
- en: 'If a project has many tests, executing them in parallel will speed them up.
    By default, CTest runs tests serially; by passing the `-j` option to the call
    to CTest, tests can be run in parallel. Alternatively, the number of parallel
    threads can be defined in the `CTEST_PARALLEL_LEVEL` environment variable. By
    default, CTest assumes that each test will run on a single CPU. If a test requires
    multiple processors to run successfully, the `PROCESSORS` property for the test
    can be set to define the number of processors required:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个项目有很多测试，并行执行它们会加速测试过程。默认情况下，CTest 按序列运行测试；通过向 CTest 调用传递`-j`选项，可以并行运行测试。或者，也可以在`CTEST_PARALLEL_LEVEL`环境变量中定义并行线程的数量。默认情况下，CTest假设每个测试只会在单个
    CPU 上运行。如果一个测试需要多个处理器才能成功运行，则可以为该测试设置`PROCESSORS`属性，以定义所需的处理器数量：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will tell CTest that the `concurrency_test` test requires two CPUs to
    run. When running tests parallel with `-j 8`, `concurrency_test` will occupy two
    of the eight available “slots” for parallel execution. If, in this case, the `PROCESSORS`
    property is be set to `8`, this would mean that no other test can run parallel
    to `concurrency_test`. When setting a value for `PROCESSORS` that is higher than
    the available number of parallel slots or CPUs on the system, the test will run
    as soon as the full pool is available. Sometimes, some tests do not just require
    a specific number of processors but also need to run exclusively, without any
    other test running. To achieve this, the `RUN_SERIAL` property can be set to `true`
    for a test. This might have a serious impact on the overall test performance,
    so use this with caution. A more granular way to control this is by using the
    `RESOURCE_LOCK` property, which contains a list of strings. The strings have no
    particular meaning, except that CTest prevents two tests from running in parallel
    if they list the same strings. This way, partial serialization can be achieved
    without halting the whole test execution. It also is a nice way to specify whether
    tests need a particular unique resource, such as a certain file, a database, or
    similar. Consider the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the `database_test_1`, `database_test_2`, and `database_test_3`
    tests are prevented from running in parallel. The `some_other_test` test is not
    affected by the database tests, but `yet_another_test` will not run together with
    any of the database tests and `some_other_test`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures as resources
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: While not technically required, if `RESOURCE_LOCK` is used together with `FIXTURE_SETUP`,
    `FIXTURE_CLEANUP`, and `FIXTURE_REQUIRED`, it is good practice to use the same
    identifiers for the same resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Managing the parallelism of tests with `RESOURCE_LOCK` is very handy when tests
    need exclusive access to some resource. In most cases, it is entirely sufficient
    to manage the parallelism. Since CMake 3.16, this can be controlled on an even
    more granular level with the `RESOURCE_GROUPS` property. Resource groups allow
    you to not just specify *which* resources are used but also *how much* of a resource
    is used. Common scenarios are defining the amount of memory a particular greedy
    operation might need or avoiding overrunning the connection limit of a certain
    service. Resource groups often come into play when working on projects that use
    the GPU for general-purpose computing, defining how many slots of a GPU each test
    needs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Resource groups are quite a step up in complexity compared to simple resource
    locks. To use them, CTest has to do the following things:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Know which resources a test needs to run**: This is defined by setting the
    test properties in a project'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Know which resources a system has available**: This is done from outside
    a project when running tests'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pass on information about which resources to use for a test**: This is done
    by using environment variables'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like resource locks, resource groups are arbitrary strings used to identify
    resources. The definition of the actual resource tied to the label is left to
    the user. The resource groups are defined as `name:value` pairs, which are separated
    by commas if there are multiple groups. A test can define which resources to use
    with the `RESOURCE_GROUPS` property, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, `SomeTest` states that it uses two CPUs and 500 MB
    of memory. It uses a total of six instances of a client-server pair, each pair
    having several servers and clients assigned. The first pair consists of one server
    instance and one client instance; the second pair requires one server but two
    client instances.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The last line, `4, servers:1,clients:1`, is shorthand to tell CTest to use four
    instances of the same pair, consisting of one `servers` resource and one `clients`
    resource. This means this test will not run unless a total of six servers and
    seven clients are available, in addition to the required CPUs and memory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The available system resources are specified in a JSON file that is passed to
    CTest, either by the `ctest --resource-spec-file` command-line parameter or by
    setting the `CTEST_RESOURCE_SPEC_FILE` variable when calling CMake. Setting the
    variable should be done by using `cmake -D` and not done in `CMakeLists.txt`,
    as specifying the system resources should be done from outside a project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample resource specification file for the preceding example could look like
    this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This file specifies a system with 4,096 MB of memory, 8 CPUs, 2x4 server instances,
    and 2x8 client instances for a total of 8 servers and 16 clients. If a resource
    request for a test cannot be satisfied with the available system resources, it
    fails to run, throwing an error like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The current example would be able to run with this specification, as it needs
    a total of six servers and seven clients. CTest has no way of ensuring that the
    specified resources are actually available or not; this is the task of the user
    or the CI system. For instance, a resource file might specify that there are eight
    CPUs available, while the hardware actually only contains four cores.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The information about the assigned resource groups is passed to the test over
    environment variables. The `CTEST_RESOURCE_GROUP_COUNT` environment variable specifies
    the total number of resource groups assigned to a test. If it is not set, this
    means that CTest was invoked without an environment file. Tests should check this
    and act accordingly. If a test cannot run without the resources, it should either
    fail or indicate that it did not run by returning the respective return code or
    string defined in the `SKIP_RETURN_CODE` or `SKIP_REGULAR_EXPRESSION` property.
    The resource groups assigned to the test are passed with pairs of environment
    variables:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`CTEST_RESOURCE_GROUP_<ID>`, which will contain the type of resource group.
    In the example from earlier, this will be either `"mem_mb"`, `"cpus"`, `"clients"`,
    or `"servers"`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CTEST_RESOURCE_GROUP_<ID>_<TYPE>`, which will contain a pair of `id:slots`
    for the types.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is up to the implementation of the test on how the resource groups are used
    and internally distributed. So far, we have seen how tests are executed with CTest,
    but defining and discovering the tests is equally important.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Writing and running tests is obviously one of the major boosters of code quality.
    However, another interesting metric is often how much of your code is actually
    covered by tests. Surveying and reporting code coverage can give interesting hints,
    not just about how widely a software is tested but also about where gaps lie.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Generating code coverage reports
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being aware of how much of your code is covered by tests is a great benefit
    and often gives a very good impression of how well-tested a given software is.
    It can also give hints to developers about the execution paths and edge cases
    that are not covered by tests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: To get code coverage in C++
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few tools that help you get code coverage in C++. Arguably, the
    most popular is *Gcov* from GNU. It’s been around for years and works well with
    GCC and Clang. Although it does not work with Microsoft’s Visual Studio, using
    Clang to build and run software provides a viable alternative for Windows. Alternatively,
    the `OpenCppCoverage` tool can be used to get coverage data on Windows to build
    with MSVC.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The coverage information generated by Gcov can be collected in summarized reports
    with the Gcovr or LCOV tools.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Generating coverage reports using Clang or GCC
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to create code coverage reports with Gcovr.
    Generating these reports roughly works in the following way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The program and libraries to be tested are compiled with special flags so that
    they expose the coverage information.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program is run, and the coverage information is stored in a file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The coverage analyzers, such as Gcovr or LCOV, analyze the coverage files and
    generate reports.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, the reports are stored or further analyzed to display trends in
    coverage.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common setting for code coverage is that you want to have information about
    how much of a project’s code is covered by the unit tests. In order to do this,
    the code has to be compiled with the necessary flags so that the information is
    exposed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<LANG>_COMPILER_FLAGS` cache variable should be passed to CMake over the
    command line. When using GCC or Clang, this might look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: An alternative method is to define the respective preset, as explained in [*Chapter
    9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible Build* *Environments*.
    When building for coverage, it is often a good idea to compile with the debug
    information enabled and disable any optimization with the `-Og` flag. Additionally,
    specifying the `-fkeep-inline-functions` and `-fkeep-static-consts` compiler flags
    will prevent you from optimizing out static and inlined functions if they are
    never used. This will make sure that all possible execution branches are compiled
    into code; otherwise, the coverage report might be misleading, especially for
    inlined functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Coverage reports work not just for single executables but also for libraries.
    However, the libraries must be compiled with coverage flags on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: As the compiler flags for coverage are set globally, the options will be passed
    on to projects added with `FetchContent` or `ExternalProject`, which might increase
    compilation time considerably.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Compiling sources using GCC or Clang with the coverage flags enabled will create
    `.gcno` files in the build directories for each object file and executable. These
    files contain meta information for Gcov about which calls and execution paths
    are available in the respective compilation units. In order to find out which
    of these paths are used, the programs have to be run.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Check out the versions of Gcov and GCC
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: A common cause for failure and frustration when trying to extract code coverage
    information is that the versions of GCC and Gcov do not match. Always check with
    `g++ --version` and `gcov --version` that they are the same.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In a scenario where we want to find out the code coverage of tests, running
    CTest will generate the coverage results. Alternatively, running the executables
    directly will produce the same results. Running executables with coverage enabled
    will generate `.gcda` files in the build directories that contain information
    about the calls in the respective object files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Once these files are generated, running Gcovr on them will create information
    about the coverage. By default, Gcovr outputs the information to `stdout`, but
    it can also generate HTML pages, JSON files, or SonarQube reports.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the pitfalls is that Gcovr expects all source and object files to be
    in the same directory, which is not the case with CMake. So, we have to pass the
    respective directories to Gcov with the `-r` option, like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Such a call might produce an HTML file that looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Example output for a coverage run](img/B30947_07_01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Example output for a coverage run
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative to Gcovr is LCOV, which works in a very similar way. In
    contrast to Gcovr, LCOV cannot directly produce HTML or XML output but will assemble
    any coverage information in an intermediate format, which can then be consumed
    by various converters. To produce HTML output, the `genhtml` tool is often used.
    To generate a report using LCOV, the commands might look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A coverage report generated with LCOV might look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – An example coverage report generated with LCOV](img/B30947_07_02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – An example coverage report generated with LCOV
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note that these calls will only create coverage reports for the last run. If
    you want to assemble them into a time series to see whether code coverage increases
    or decreases, there are various CI tools available, such as Codecov and Cobertura,
    to do this. Such tools can generally parse output from Gcovr or LCOV and assemble
    it into fancy graphics, showing the coverage trends. The detailed documentation
    for Gcovr can be found at [https://gcovr.com/en/stable/](https://gcovr.com/en/stable/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Creating coverage reports for MSVC
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building software using MSVC, the `OpenCppCoverage` tool is an alternative
    to Gcov. It works by analyzing the program databases (`.pdb`) produced by the
    MSVC compiler, rather than by compiling the source with different flags. The command
    to generate an HTML coverage report for a single executable might look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since this will only generate the coverage report for a single executable,
    `OpenCppCoverage` enables you to read the input from previous rounds and combine
    it into a report like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will combine the input of the first two runs into a common report. To consume
    the coverage information, the `export_type` option has to be `binary`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use for coverage reports is to find out how much code is covered by
    the tests defined in a project. In this case, using CTest as the test driver is
    convenient. As CTest will run the actual tests as subprocesses, the `--cover_children`
    option has to be passed to `OpenCppCoverage`. To avoid generating coverage reports
    for the system libraries used, adding a module and a source filter might be required.
    The command might look something like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A slight downside to this approach is that the coverage report will include
    a coverage report for CTest itself. The generated HTML report might look like
    this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – A coverage report generated with OpenCppCoverage](img/B30947_07_03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – A coverage report generated with OpenCppCoverage
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Visual Studio, an alternative to the command line is to use a plugin.
    The plugin can be found on the Visual Studio marketplace: [https://marketplace.visualstudio.com/items?itemName=OpenCppCoverage.OpenCppCoveragePlugin](https://marketplace.visualstudio.com/items?itemName=OpenCppCoverage.OpenCppCoveragePlugin)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'For the full documentation, consult the GitHub page of `OpenCppCoverage`: [https://github.com/OpenCppCoverage/OpenCppCoverage](https://github.com/OpenCppCoverage/OpenCppCoverage)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how much of your code is covered by the supplied tests is a piece of
    very valuable information regarding code quality. In fact, in a lot of regulated
    industries, such as healthcare, aviation, and the car industry, providing code
    coverage reports might be required by the regulatory bodies. However, only knowing
    how much code is executed is obviously not enough; the quality of the underlying
    code is of even more importance. Some compilers provide useful tools to detect
    common errors in your code with the help of so-called sanitizers. In the next
    section, you will learn how to use and apply the sanitizers using CMake.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing your code
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today’s compilers are often more than just programs to convert text to binary
    code. They are complex software suites that have built-in functionality to ensure
    code quality. The focus on how much compilers are aware of code quality issues
    has drastically increased, especially with the advent of LLVM and Clang. These
    quality tools are commonly called **sanitizers** and are enabled by passing certain
    flags to the compiler and linker.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Code sanitizers are a way to bring additional quality checks into code by using
    the compiler to decorate the binary code with annotations and hooks, detecting
    various runtime issues. When the code is executed, the annotations are checked
    and confirmed if any violations are reported. Sanitizers are relatively fast,
    but they obviously have an impact on the runtime behavior of any program. If the
    sanitizers catch anything, programs are terminated with `abort()` and return with
    non-zero. This is particularly useful with testing because this means any test
    violating a sanitizer will be marked as a failure.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most common types of sanitizers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The **address sanitizer** (**ASan**) detects memory access errors such as out-of-bounds
    and use-after-free bugs. On some platforms, the ASan can even be run with hardware
    assistance.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **leak sanitizer** (**LSan**), which is part of the ASan, can be used to
    detect memory leaks.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In GCC and Clang, there are a few specialized versions of the general ASan,
    such as the **kernel address sanitizer** (**KASAN**) to detect memory errors in
    the Linux kernel.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **memory sanitizer** (**MSan**) detects uninitialized memory reads.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **thread sanitizer** (**TSan**) will report data races. Because of the way
    the TSan works, it cannot be run together with the ASan and LSan.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **undefined behavior sanitizer** (**UBSan**) detects and reports cases where
    code results in undefined behavior. Using variables before initialization or ambiguity
    regarding operator precedence are common examples.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Clang suite leads the field with the availability of sanitizers, with GCC
    coming a close second. Microsoft has been a bit slower in adopting the features,
    but from MSVC version 16.9, which comes with Visual Studio 19, the Microsoft compilers
    support at least the ASan. For details on what the respective sanitizers do and
    how to configure them in detail, refer to the helpful documentation of the various
    compilers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The sanitizers are enabled by passing various compiler flags that cause a compiler
    to add extra debugging information to the binaries. When the binaries are executed,
    the sanitizer code will perform its check and print out any errors to `stderr`.
    As the code needs to be executed for the sanitizers to find any potential bugs,
    having high code coverage is essential to improve the reliability of the sanitizers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: To enable the ASan in GCC or Clang, the `-fsanitize=<sanitizer>` compiler flag
    has to be passed. For MSVC, the corresponding option is `/fsanitize=<sanitizer>`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler flags are passed into CMake with the `CMAKE_CXX_FLAGS` cache variable.
    So, calling CMake from the command line with a sanitizer enabled would look like
    this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When using CMake presets, the cache variables to contain the compiler flags
    can also be defined there. Presets are covered in depth in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible Build* *Environments*. Setting the `sanitizer` option globally
    will also affect any projects included that use `FetchContent` or `ExternalProject`
    after the flags are set, so act with caution there. For the ASan, use `-fsanitizer=address`
    on GCC and Clang, and `/fsanitizer=address` on MSVC. The MSan is enabled with
    `-fsanitize=memory`, the LSan is enabled with `-fsanitize=leak`, the TSan is enabled
    with `-fsanitize=thread`, and the UBSan is enabled with `-fsanitize=undefined`
    for GCC and Clang only at the time of writing. To get a more concise output for
    the ASan, LSan, and MSan, tell the compiler to explicitly keep the frame pointer.
    This is done by setting `-fno-omit-framepointer` in GCC and Clang. MSVC only supports
    this for x86 builds with the `/``Oy-` option.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `CMAKE_CXX_FLAGS` variable to enable sanitizers in `CMakeLists.txt`
    itself is discouraged, as the sanitizers are neither built nor have any usage
    requirements to use any of the targets defined by a project. Additionally, setting
    the `CMAKE_CXX_FLAGS` variable in `CMakeLists.txt` might conflict with what the
    user might pass from the command line.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizers are a very powerful tool to increase code quality. Together with
    unit tests and the coverage report, they provide three of the four major concepts
    to ensure code quality. The fourth option to automatically ensure code quality
    is using static code analyzers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis using CMake
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests, sanitizers, and coverage reports all depend on code being actually
    run to detect possible errors. Static code analysis analyzes code without running
    it. The good thing about that is that all code that is compiled can be analyzed,
    not just the parts that are covered by tests. This, of course, also means that
    different kinds of glitches can be found. A downside of static code analysis is
    that it can take a very long time to run tests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake supports several tools for static code analysis that are enabled either
    by setting a property or a global variable. All of the tools, except *link what
    you use*, are external programs that need to be installed and found in the path
    of the system. *Link what you use* uses the linker of a system, so no further
    installation is necessary. The tools supported by CMake are the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`LANG>_CLANG_TIDY` property or the `CMAKE_<LANG>_CLANG_TIDY` variable.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_CPPCHECK` property or the `CMAKE_<LANG>_CPPCHECK` variable.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_CPPLINT` property or the `CMAKE_<LANG>_CPPLINT` variable. Cpplint was
    originally developed at Google, and because of this, it has the Google C++ style
    hardcoded within.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_INCLUDE_WHAT_YOU_USE` property or the `CMAKE_<LANG>_INCLUDE_WHAT_YOU_USE`
    variable.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LINK_WHAT_YOU_USE` property or the `CMAKE_LINK_WHAT_YOU_USE` variable. Note
    that this is not dependent on the language chosen.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all tools, `<LANG>` is either `C` or `CXX`. The properties contain a semicolon-separated
    list containing the respective executable and command-line arguments. As of CMake
    3.21, automatic execution of the static code analyzers is only supported for the
    Ninja and Makefile generators. Visual Studio handles the static code analyzers
    over settings of the IDE, which CMake cannot control. lwyu is a special case because
    it uses special flags for the `ldd` or `ld` linker and is not a special tool.
    So, the `LINK_WHAT_YOU_USE` property is just a Boolean value and not a command
    line. It also means that lwyu is only supported on ELF platforms.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the coverage reports and the sanitizers earlier in this chapter, the static
    code analysis tools are enabled by passing the command in the respective variable
    to CMake over the command line, or by using a preset. If the variable is set,
    then the static code analyzers will be executed automatically when compiling the
    source files. Enabling `clang-tidy` for a build might look like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The command and the arguments are formatted as a semicolon-separated list. In
    the preceding example, all checks for `clang-tidy` are enabled with `-checks=*`,
    and a filter is added to only apply `clang-tidy` to the `include` files of the
    current project with `-header-filter=<sourceDir/*>`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The same patterns work when using Cppcheck, Cpplint, and iwyu, as the following
    examples show:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The static code analyzers will run when compiling the files in a project. The
    output of any finding will be printed out with any usual compiler warnings or
    errors. By default, all non-critical findings of the analyzers will not cause
    the build to fail. For high-quality software where zero-tolerance against warnings
    exists, the appropriate flags can be passed to Cppcheck and Clang-Tidy:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: For Clang-Tidy, passing `--warnings-as-errors=*` will cause a compilation to
    fail on any issue found
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Cppcheck, passing the `--error-exitcode=1` parameter will cause Cppcheck
    to exit with `1` instead of `0` if an issue is found, and the build will fail
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iwyu** and **cpplint**, unfortunately, lack similar flags.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: A very nice feature of Clang-Tidy is that it can automatically apply fixes to
    source files. This can be done by additionally passing the `--fix` and `--fix-error`
    flags to Clang-Tidy.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Attention when building incrementally
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: All the static code analyzers work only if a file is actually compiled. To ensure
    that the static code analyzers catch all errors, they have to be run on a clean
    build.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of lwyu, all the static code analyzers look at the source
    files to find any issues; conversely, **lwyu** will look at the binary files to
    find unused dependencies.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The lwyu analyzer is intended to help speed up builds and reduce the complexity
    of the dependencies tree. The command for lwyu is defined in `CMAKE_LINK_WHAT_YOU_USE_CHECK`.
    This variable is just a Boolean option, not a command for an external like the
    other tools. If set, it will pass the respective flags to the linker to output
    any unused direct dependencies. As of CMake version 3.21, this is defined as the
    `ldd –u -r` command. The usage of `ldd` means that this analyzer is only available
    for ELF platforms. lwyu can be enabled by passing a simple option, like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of lwyu might look something like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example shows that `libssl.so` was linked but not used, even the ones indirectly
    linked by any dependencies.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the various static code analyzers and iwyu and lwyu helps
    to keep codebases small and free from common code smells. So far in this chapter,
    we have looked at how tests are defined, sanitizers, and static code analysis,
    which deal with checking whether code functions correctly. One of the problems
    we’ve seen is that if the combinations must be enabled for all the single targets,
    `CMakeLists.txt` can become cluttered, especially for large projects. A clean
    alternative is to provide a custom build type that enables compile-time code analysis
    globally.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom build types for quality tools
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed build types such as `Debug`, `Release`, `RelWithDebInfo`,
    and `MinSizeRel`, which are provided by CMake by default. These build types can
    be extended with custom build types that pass global flags to all targets. For
    the code quality tools that rely on certain compiler flags, providing a custom
    build type can simplify `CMakeLists.txt` considerably, especially for large projects.
    Creating a custom build type is also much preferred to directly interfering with
    the global `CMAKE_<LANG>_FLAGS`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Do not override CMAKE_<LANG>_FLAGS
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Setting the global compiler option is over the generic `CMAKE_<LANG>_FLAGS`
    in your `CMakeLists.txt`. These flags are intended to be set outside a project,
    either by passing them over the command line or by supplying them with a toolchain
    file. Modifying them inside a project creates a high chance of interfering with
    the cases where they are set from the outside.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: For multi-configuration generators such as MSVC or Ninja Multi-Config, the available
    build types are stored in the `CMAKE_CONFIGURATION_TYPES` cache variable. For
    single configuration generators such as Make or Ninja, the current build type
    is stored in the `CMAKE_BUILD_TYPE` variable. Custom build types should be defined
    on the top-level project.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom build type called `Coverage` could be added to `CMakeLists.txt`, like
    this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s break down what happens in the preceding example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: First, it is determined whether the current `Generator` is a multi or single-configuration
    generator. This is stored in the `GENERATOR_IS_MULTI_CONFIG` global property.
    Since the property cannot be used directly in an `if` statement, the property
    is retrieved and stored in the `IS_MULTI_CONFIG` variable.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the current generator is indeed a multi-configuration generator, the custom
    build configuration called `Coverage` is added to `CMAKE_CONFIGURATION_TYPES`
    and made available to the generator, but only if it does not yet exist.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the generator is a single configuration generator, a hint that the `Coverage`
    build exists is added by setting the `STRINGS` property of the `CMAKE_BUILD_TYPE`
    cache variable. This will create a drop-down menu with the valid options in the
    CMake GUI. For convenience, the supported build types are stored in the `KNOWN_BUILD_TYPES`
    variable.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the current build type is usually supplied from the outside for single configuration
    generators, it is prudent to check for unknown build types and abort the configuration
    if an unknown build type is specified. Printing a message as `FATAL_ERROR` will
    cause CMake to stop the build.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this, the `Coverage` build type is added to CMake, but the build type
    is not yet configured to add a custom compiler and linker flags to the build.
    To define the flags, two sets of cache variables are used:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_<LANG>_FLAGS_<CONFIGURATION>`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_<TARGET_TYPE>_LINKER_FLAGS_<CONFIGURATION>`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<CONFIGURATION>` is the name of the custom build type, `<LANG>` is the programming
    language, and `<TARGET_TYPE>` for the linker flags are either executable or the
    various types of libraries. It can be useful to base the configuration for a custom
    build on existing build types to reuse any of the configuration options. The following
    example sets up the `Coverage` build type for a Clang- or GCC-compatible compiler,
    based on the flags of the `Debug` build type:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The flags can also contain generator expressions to account for different compilers
    when setting the flags. Marking the flags as `advanced` will help prevent accidental
    change of the variables by the user:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Sometimes, the filename for libraries should reflect that they are created
    with a special build type. Setting `CMAKE_<CONFIGURATION>_POSTFIX` for the custom
    build type will achieve that. This is already common practice for debug builds,
    so the files can be distinguished from the release build when packaged together.
    Related to this is the `DEBUG_CONFIGURATIONS` global property, which contains
    the configurations that are considered non-optimized and are used for debugging.
    If the custom build is considered a non-release build, adding to the property,
    as follows, should be considered:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `DEBUG_CONFIGURATION` property should be set on the top-level project before
    any calls to `target_link_libraries`. The `DEBUG_CONFIGURATIONS` property is currently
    only used by `target_link_libraries`, where, for historical reasons, the libraries
    can be prefixed with `debug` or optimized to indicate that they should only be
    linked for the respective build configuration. Nowadays, this is rarely used,
    as generator expressions allow for more granular control of this.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: That concludes this chapter. We have covered the most common aspects of testing
    and quality tools and hope that we have contributde to your journey toward excellent
    software quality.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining high-quality software is a huge and complex task, and today, there
    is such a multitude of tools and techniques to test software that it can be hard
    to up. With the techniques and tools described in this chapter, we hope to have
    given a brief overview of the most common tasks and tools used in modern C++ development.
    CTest and CMake can help orchestrate the various kinds of tests to get the most
    out of the tools. In this chapter, you’ve seen how tests can be defined and run,
    how to execute them in parallel, and how to manage test resources. We’ve explored
    how to define test fixtures and how to define advanced ways to determine whether
    a test succeeded or failed, based on its output.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: We illustrated how to set up code coverage reports using Gcov and how to define
    custom build types to pass the necessary compiler flags. We looked at how various
    tools for static code analysis can be included in CMake projects and how the sanitizers
    of various compilers can be used.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to use external programs from within CMake
    and how to perform platform-independent tasks.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are tests defined in CMake?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can CTest be told to execute a specific test?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can an unstable test be repeated until it either succeeds or fails?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are tests run in parallel and random order?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you prevent multiple tests from using a unique test resource at the
    same time?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are static code analyzers enabled for targets?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are custom build types defined?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests are defined by using the `add_test` function.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either by using a regex on the test’s name with `ctest -R` or by using the test
    number, using `ctest -I`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By calling `ctest --repeat:until-pass:n` or `ctest --repeat:until-fail:n`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By running `ctest -j <``num_of_jobs> --schedule-random`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By setting the `RESOURCE_LOCK` or `RESOURCE_GROUP` property for the respective
    tests.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static code analyzers are enabled by passing the command line, including any
    arguments, to the respective target properties.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By either adding them to the `CMAKE_CONFIGURATION_TYPES` property for multi-configuration-type
    generators or by adding them to the `CMAKE_BUILD_TYPE` property.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
