- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seamlessly Integrating Code Quality Tools with CMake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have focused on building and installing projects, as well as generating
    documentation and handling external dependencies. Another major task when writing
    quality software is testing and ensuring that code quality is at the desired level
    by various other means. To achieve high code quality, writing unit tests and executing
    them occasionally is no longer enough. If you want to produce high-quality software,
    having proper test tools that integrate easily with your build system is not a
    luxury but a necessity. Only when building and testing work effortlessly together
    can programmers focus on writing good tests, instead of focusing on getting those
    tests to run. Methods such as test-driven development bring huge value to software
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is not just writing plain tests that increase the quality. Writing
    good tests is one thing; checking the effectiveness of the tests with coverage
    reports and ensuring general code quality with static code analysis is another.
  prefs: []
  type: TYPE_NORMAL
- en: While tests, coverage, and static code analysis help determine whether code
    functions as intended, one problem is often that some of the tools only work with
    a specific compiler or require special compiler settings. In order to benefit
    from the tools, it might be necessary to compile the same source in different
    ways with different compilers. Luckily, this is exactly what CMake is extremely
    good at, which is why CMake can help to boost the quality of code by making these
    quality tools accessible.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing about a lot of the tools for ensuring high code quality is that
    they can often be automated. With today’s easy availability of CI/CD systems,
    creating a high degree of automated checks for good quality software is quite
    easy, especially since, with CMake, these things can often be configured and executed
    right where you define how the software is built. In this chapter, you will learn
    how to define and orchestrate tests using CMake, as well as how to create code
    coverage reports to see which parts of the software are tested at all. We will
    examine how to integrate various code sanitizers and static code analyzers to
    check code quality already while compiling. We will show you various ways to include
    all the tools and how to create a dedicated build type to run static code quality
    tools. Finally, we will have a peek at how to set up micro-benchmarks to check
    the runtime performance of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining, discovering, and running tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating code coverage reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizing your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static code analysis using CMake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom build types for quality tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the previous chapters, the examples are tested with CMake 3.24 and
    run on any of the following compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: GCC 9 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang 12 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSVC 19 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the examples for code coverage, sanitizers, and static code analysis
    require GCC or Clang to run and will not work with MSVC. To run Clang on Windows,
    take a look at [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible
    Build* *Environments*, where toolchain files are introduced. Some examples need
    the Catch2 unit testing suite installed to compile. Some examples pull dependencies
    from various online locations, so an internet connection is required as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to a working compiler, the following software is used for the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Gcov`, `Gcovr`, and `lcov` for the Linux examples on code coverage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Opencppcoverage` for the Windows examples on code coverage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Clang-tidy`, `Cppcheck`, `Cpplint`, and `include-what-you-use` for the examples
    on static code analyzers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All examples and source code are available on the GitHub repository of this
    book at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: If any software is missing, the related examples will be excluded from the build.
  prefs: []
  type: TYPE_NORMAL
- en: Defining, discovering, and running tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is the staple diet for any software engineer who takes pride in quality
    software. The number of frameworks to write unit tests in the various languages
    is huge, and, especially for C++, CMake includes modules to work with most of
    the more popular ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'At very abstract levels, all unit testing frameworks do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allow the formulation and grouping of test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contain some form of assertion to check for various test conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover and run test cases, either altogether or a selection of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce a test result in a variety of formats, such as plain text, JSON, and
    XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the CTest utility, CMake includes a built-in way to execute almost any
    test. Any CMake project that has set `enable_testing()` and added at least one
    test with `add_test()` has testing support enabled. Any call to `enable_testing()`
    will enable test discovery in the current directory and any directory below it,
    so it is often a good idea to set it in the top-level `CMakeLists.txt` before
    any calls to `add_subdirectory`. The CTest module of CMake automatically sets
    `enable_testing` if used with `include(CTest)`, unless the `BUILD_TESTING` option
    was set to `OFF`. /
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to not build and run tests that depend on the `BUILD_TESTING`
    option. A common pattern here is to put all parts of a project that concern testing
    into their own subfolder and only include the subfolder if `BUILD_TESTING` is
    set to `ON`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CTest module should generally be included only in the top-level `CMakeLists.txt`
    file of a project. Since CMake version 3.21, the `PROJECT_IS_TOP_LEVEL` variable
    can be used to test whether the current `CMakeLists.txt` file is the top level.
    This variable will be `true` for the top-level directory of a project and top-level
    directories of projects added with `ExternalProject`. For directories added with
    `add_subdirectory` or `FetchContent`, the value is `false`. As such, CTest should
    be included like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, projects should rely on the `BUILD_TESTING` flag to determine whether
    tests should be built and included. However, especially for open source projects
    or projects with complicated requirements regarding testing, providing an additional
    `option()` to disable testing for only one specific project can be convenient
    for developers using the project. The resulting CMake code could look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unit tests are, in essence, small programs that run a list of assertions inside,
    and if any of the assertions fail, they return a non-zero return value. There
    are many frameworks and libraries that help to organize tests and write assertions,
    but from the outside, checking assertions and returning a corresponding value
    is the core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests can be added to any `CMakeLists.txt` file with the `add_test` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`COMMAND` can be the name of an executable target defined in the project or
    a full path to an arbitrary executable. Any arguments needed for the test are
    also included. Using target names is the preferred way, as CMake will then substitute
    the path to the executable automatically. The `CONFIGURATION` option is used to
    tell CMake for which build configurations the test is valid. For most test cases,
    this is irrelevant, but for micro-benchmarking, for instance, this can be quite
    useful. `WORKING_DIRECTORY` should be an absolute path. By default, tests are
    executed in `CMAKE_CURRENT_BINARY_DIR`. The `COMMAND_EXPAND_LISTS` option ensures
    that any lists passed as part of the `COMMAND` option are expanded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple project including a test might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, an executable target called `simple_test` is used as a test
    called `example_test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'CTest will consume the information about the tests and execute them. The tests
    are executed by running the `ctest` command standalone or as a special target
    as part of the build step of CMake. Both ways of executing require that the project
    has been built beforehand. Either of the two following commands will execute the
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Invoking CTest as a target of the build has the advantage that CMake will check
    first whether all the needed targets are built and on the newest version, but
    running `ctest` directly offers more control over the tests to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of `ctest` might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Generally, the test suppresses all output to `stdout`. By passing the `-V` or
    `--verbose` command-line argument, the output is always printed. However, usually,
    you’re only interested in the output of the failed tests. So, the `--output-on-failure`
    argument is often the better alternative. This way, only failed tests produce
    output. For very verbose tests, the output can be limited in size with the `--test-output-size-passed
    <size>` and `--test-output-size-failed <size>` options, where size is the number
    of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Having one or more calls to `add_test` in the build tree will cause CMake to
    write out an input file for CTest in `CMAKE_CURRENT_BINARY_DIR`. The input files
    for CTest are not necessarily located at the top level of the project but where
    they are defined instead. To list all tests but not execute them, the `-N` option
    for CTest is used.
  prefs: []
  type: TYPE_NORMAL
- en: A very useful feature of CTest is that it caches the states of tests between
    runs. This allows you to only run tests that failed in the last run. To do this,
    run `ctest --rerun-failed`. If no tests failed or no tests were run before, all
    tests will be run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you do not want to execute the full test set – for instance, if
    a single failing test needs to be fixed. The `-E` and `-R` command-line options
    take `-E` option excludes tests matching the pattern, and the `-R` option selects
    tests to be included. The options can be combined. The following command would
    run all tests that begin with `FeatureX` but exclude the test called `FeatureX_Test_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to selectively execute tests is to label them using the `LABELS`
    properties for tests, and then select the labels to run with the `-L` option of
    CTest. A test can have multiple labels assigned, separated by a semicolon, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-L` command line option takes a regex to filter the labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will only execute `labeled_test_1` and `labeled_test_3`, as they both have
    the `example` label assigned, but not `labeled_test_2` or any other tests that
    have no label assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'By formulating the regex accordingly, multiple labels can be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will execute all the tests from the example but no other tests that have
    no label assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Using labels would be particularly useful to mark tests that are designed to
    fail or similar, or tests that are only relevant in certain execution contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last alternative to the regex or label-based test selection is to use the
    `-I` option, which takes the assigned test numbers. The argument for the `-I`
    option is somewhat complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With `Start`, `End`, and `Stride`, a range for the tests to be executed in can
    be specified. The three numbers are for the range combined with explicit test
    numbers, `test#`. Alternatively, a file containing the argument can be passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following call will execute all odd tests from `1` to `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So, tests `1`, `3`, `5`, `7`, and `9` will be executed. The following command
    will execute only the tests and `8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in this call, `End` is set to `0`, so no test range is executed.
    To combine the range and explicit test numbers, the following command will execute
    all odd tests from `1` to `10`, and additionally test `6` and `8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The cumbersome handling of the `-I` option and the fact that adding new tests
    might reassign the numbers are two reasons why this method is rarely used in practice.
    Usually, filtering either by labels or test names is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Another common pitfall when writing tests is that they are not independent enough.
    So, test `2` might accidentally depend on a previous execution of test `1`. To
    harden against this accidental dependency, CTest has the ability to randomize
    test execution order with the `--schedule-random` command-line argument. This
    will ensure that tests are executed in an arbitrary order.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically discovering tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining tests with `add_test` is one way to expose them to CTest. One drawback
    is that this will register the whole executable as a single test. In most cases,
    however, a single executable will contain many unit tests and not just one, so
    when one of the tests inside the executable fails, it might be hard to figure
    out which test exactly failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a C++ file containing the following test code, and let’s assume that
    the Fibonacci function contains a bug, so `Fibonacci(0)` will not return `1` as
    it should but something else instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If all these tests are compiled into the same executable, called `Fibonacci`,
    then adding them with `add_test` will only indicate that the executable failed,
    not telling us in which of the scenarios seen in the previous code block it did
    so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the test will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That is hardly helpful to figure out which of the test cases failed. Luckily,
    with Catch2 and GoogleTest, there is a way to expose the internal tests to CTest
    so that they are executed as regular tests. For GoogleTest, the module to do so
    is provided by CMake itself; Catch2 provides this functionality in its own CMake
    integration. Discovering the tests with Catch2 is done with `catch_discover_tests`,
    while for GoogleTest, `gtest_discover_tests` is used. The following example will
    expose tests written in the Catch2 framework to CTest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in order to have the function available, the `Catch` module has
    to be included. For GoogleTest, it works very similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the discovery functions, each test case defined in a test executable
    will be treated as its own test by CTest. If tests are exposed like this, the
    result of a call to CTest might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see exactly which of the defined test cases failed. In this case,
    the `Fibonacci(0) returns 1` test case did not behave as expected. This comes
    in especially handy when using an editor or IDE with integrated testing functionality.
    The discovery functions both work by running the specified executable, with an
    option to only print the test names to register them internally with CTest, so
    there is a slight overhead added to each build step. Discovering tests more granularly
    also has the advantage that their execution can be better parallelized by CMake,
    as described in the *Running tests in parallel and managing test resources* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `gtest_discover_tests` and `catch_discover_tests` have various options,
    such as adding a prefix or suffix to the test names or a list of properties to
    add to the generated tests. The full documentation for the functions can be found
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Catch2**: [https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GoogleTest**: [https://cmake.org/cmake/help/v3.21/module/GoogleTest.html](https://cmake.org/cmake/help/v3.21/module/GoogleTest.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch2 and GoogleTest are just two of the many testing frameworks out there;
    there might be more test suites that carry this functionality that aren’t as well
    known.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on from finding tests and have a closer look at how to control
    test behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced ways to determine test success or failure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, CTest determines whether a test failed or passed based on the return
    value of the command. `0` means all tests were successful; anything other than
    `0` is interpreted as a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the return value is not enough to determine whether a test passes
    or fails. If you need to check program output for a certain string, the `FAIL_REGULAR_EXPRESSION`
    and `PASS_REGULAR_EXPRESSION` test properties can be used, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These properties would cause the `some_test` test to fail if the output contains
    either `"Warning"` or `"Error"`. If the `"Success"` string is found, the test
    is considered to have passed. If `PASS_REGULAR_EXPRESSION` is set, the test is
    considered to have passed only if the string is present. In both cases, the return
    value will be ignored. If a certain return value of a test needs to be ignored,
    it can be passed with the `SKIP_RETURN_CODE` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a test is expected to fail. In those cases, setting `WILL_FAIL`
    to `true` will cause the test result to be inverted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is often better than disabling the test because it will still be executed
    on each test run, and if the test unexpectedly starts to pass again, the developer
    is made aware of it. A special test failure case is when tests fail to return
    or take too much time to complete. For this case, CTest provides the means of
    adding timeouts of tests and even retrying tests if there is a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Handling timeouts and repeating tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we’re not just interested in the success or failure of a test but
    also in how long it takes to complete. The `TIMEOUT` test property takes a number
    of seconds to determine the maximum runtime for a test. If the test exceeds the
    set time, it is terminated and considered a failure. The following command would
    limit the test execution of a test to 10 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `TIMEOUT` property often comes in handy for tests that run the risk of falling
    into infinite loops or hanging forever for whatever reason.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, CTest accepts the `--timeout` argument, setting a global timeout
    that is applied to all tests that have no `TIMEOUT` property specified. For those
    tests that have `TIMEOUT` defined, the timeout defined in `CmakeLists.txt` takes
    precedence over the timeout passed over the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid long test execution, the CTest command line accepts the `--stop-time`
    argument, which takes the real-time of the day as a time limit for the complete
    set of tests. The following command would set a default timeout of 30 seconds
    for each test, and the tests would have to be completed before 23:59:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, we can expect a test to experience occasional timeouts due to factors
    outside of our control. Very common cases are tests that need some form of network
    communication or a resource that has some kind of bandwidth limitation. Sometimes,
    the only way to get a test to run is to try it again. For this, the `--repeat
    after-timeout:n` command-line argument can be passed to CTest, where *n* is a
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--repeat` argument actually has three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`after-timeout`: This retries the test several times if a timeout occurred.
    Generally, the `--timeout` option should be passed to CTest whenever there are
    repeated timeouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`until-pass`: This reruns a test until it passes or the number of retries is
    reached. Setting this as a general rule in a CI environment is a bad idea, as
    tests should generally always pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`until-fail`: Tests are rerun a number of times or until they fail. This is
    often used if a test fails occasionally to find out how frequently this happens.
    The `--repeat-until-fail` argument works exactly like `--repeat:until-fail:n`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, the reason for failing tests might be the unavailability of resources
    that the test depends on. One common case for external resources being unavailable
    is that they are flooded with requests from tests. The *Running tests in parallel
    and managing test resources* section explores a few options to avoid such complications.
    Another common cause for timeouts when accessing external resources is that the
    resource is not yet available when the tests run.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to write test fixtures that can be used
    to ensure that resources are started before a test run.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tests should, in general, be independent of each other. There are cases where
    tests might depend on a precondition that is not controlled by the test itself.
    For instance, a test might require a server to be running in order to test a client.
    These dependencies can be expressed in CMake by defining them as test fixtures,
    using the `FIXTURE_SETUP`, `FIXTURE_CLEANUP`, and `FIXTURE_REQUIRED` test properties.
    All three properties take a list of strings to identify a fixture. A test might
    indicate that it needs a particular fixture by defining the `FIXTURE_REQUIRED`
    property. This will ensure that the test named `fixture` completes successfully
    before it is executed. Similarly, a test might declare it in `FIXTURE_CLEANUP`
    to indicate that it must be run after the completion of the test requiring the
    fixture. The fixtures defined in the cleanup part are always run, regardless of
    whether a test succeeded or failed. Consider the following example, which can
    be found in the `chapter07/fixture_example` directory in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a program called `echo_server` is used as a fixture so that
    another program called `echo_client` can use it. The execution of `echo_server`
    with the `--start` and `--stop` arguments are formulated as tests, with the names
    `start_server` and `stop_server`, respectively. The `start_server` test is marked
    as the setup of the fixture, with the name `server`. The `stop_server` test is
    set up likewise but is marked as the cleanup routine of the fixture. Finally,
    the actual test called `client_test` is set up, and it gets passed to the `server`
    fixture as a required precondition.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `client_test` test is now run using CTest, the fixtures are automatically
    invoked with it. The fixture tests show up as regular tests in the output for
    CTest, as shown in the following example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that CTest was invoked with a regex filter that only matches the client
    test, but CTest started the fixture anyway. To not overwhelm test fixtures when
    tests are executed in parallel, they can be defined as resources, as shown in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests in parallel and managing test resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a project has many tests, executing them in parallel will speed them up.
    By default, CTest runs tests serially; by passing the `-j` option to the call
    to CTest, tests can be run in parallel. Alternatively, the number of parallel
    threads can be defined in the `CTEST_PARALLEL_LEVEL` environment variable. By
    default, CTest assumes that each test will run on a single CPU. If a test requires
    multiple processors to run successfully, the `PROCESSORS` property for the test
    can be set to define the number of processors required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell CTest that the `concurrency_test` test requires two CPUs to
    run. When running tests parallel with `-j 8`, `concurrency_test` will occupy two
    of the eight available “slots” for parallel execution. If, in this case, the `PROCESSORS`
    property is be set to `8`, this would mean that no other test can run parallel
    to `concurrency_test`. When setting a value for `PROCESSORS` that is higher than
    the available number of parallel slots or CPUs on the system, the test will run
    as soon as the full pool is available. Sometimes, some tests do not just require
    a specific number of processors but also need to run exclusively, without any
    other test running. To achieve this, the `RUN_SERIAL` property can be set to `true`
    for a test. This might have a serious impact on the overall test performance,
    so use this with caution. A more granular way to control this is by using the
    `RESOURCE_LOCK` property, which contains a list of strings. The strings have no
    particular meaning, except that CTest prevents two tests from running in parallel
    if they list the same strings. This way, partial serialization can be achieved
    without halting the whole test execution. It also is a nice way to specify whether
    tests need a particular unique resource, such as a certain file, a database, or
    similar. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `database_test_1`, `database_test_2`, and `database_test_3`
    tests are prevented from running in parallel. The `some_other_test` test is not
    affected by the database tests, but `yet_another_test` will not run together with
    any of the database tests and `some_other_test`.
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures as resources
  prefs: []
  type: TYPE_NORMAL
- en: While not technically required, if `RESOURCE_LOCK` is used together with `FIXTURE_SETUP`,
    `FIXTURE_CLEANUP`, and `FIXTURE_REQUIRED`, it is good practice to use the same
    identifiers for the same resources.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the parallelism of tests with `RESOURCE_LOCK` is very handy when tests
    need exclusive access to some resource. In most cases, it is entirely sufficient
    to manage the parallelism. Since CMake 3.16, this can be controlled on an even
    more granular level with the `RESOURCE_GROUPS` property. Resource groups allow
    you to not just specify *which* resources are used but also *how much* of a resource
    is used. Common scenarios are defining the amount of memory a particular greedy
    operation might need or avoiding overrunning the connection limit of a certain
    service. Resource groups often come into play when working on projects that use
    the GPU for general-purpose computing, defining how many slots of a GPU each test
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resource groups are quite a step up in complexity compared to simple resource
    locks. To use them, CTest has to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Know which resources a test needs to run**: This is defined by setting the
    test properties in a project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Know which resources a system has available**: This is done from outside
    a project when running tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pass on information about which resources to use for a test**: This is done
    by using environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Like resource locks, resource groups are arbitrary strings used to identify
    resources. The definition of the actual resource tied to the label is left to
    the user. The resource groups are defined as `name:value` pairs, which are separated
    by commas if there are multiple groups. A test can define which resources to use
    with the `RESOURCE_GROUPS` property, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `SomeTest` states that it uses two CPUs and 500 MB
    of memory. It uses a total of six instances of a client-server pair, each pair
    having several servers and clients assigned. The first pair consists of one server
    instance and one client instance; the second pair requires one server but two
    client instances.
  prefs: []
  type: TYPE_NORMAL
- en: The last line, `4, servers:1,clients:1`, is shorthand to tell CTest to use four
    instances of the same pair, consisting of one `servers` resource and one `clients`
    resource. This means this test will not run unless a total of six servers and
    seven clients are available, in addition to the required CPUs and memory.
  prefs: []
  type: TYPE_NORMAL
- en: The available system resources are specified in a JSON file that is passed to
    CTest, either by the `ctest --resource-spec-file` command-line parameter or by
    setting the `CTEST_RESOURCE_SPEC_FILE` variable when calling CMake. Setting the
    variable should be done by using `cmake -D` and not done in `CMakeLists.txt`,
    as specifying the system resources should be done from outside a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample resource specification file for the preceding example could look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This file specifies a system with 4,096 MB of memory, 8 CPUs, 2x4 server instances,
    and 2x8 client instances for a total of 8 servers and 16 clients. If a resource
    request for a test cannot be satisfied with the available system resources, it
    fails to run, throwing an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The current example would be able to run with this specification, as it needs
    a total of six servers and seven clients. CTest has no way of ensuring that the
    specified resources are actually available or not; this is the task of the user
    or the CI system. For instance, a resource file might specify that there are eight
    CPUs available, while the hardware actually only contains four cores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information about the assigned resource groups is passed to the test over
    environment variables. The `CTEST_RESOURCE_GROUP_COUNT` environment variable specifies
    the total number of resource groups assigned to a test. If it is not set, this
    means that CTest was invoked without an environment file. Tests should check this
    and act accordingly. If a test cannot run without the resources, it should either
    fail or indicate that it did not run by returning the respective return code or
    string defined in the `SKIP_RETURN_CODE` or `SKIP_REGULAR_EXPRESSION` property.
    The resource groups assigned to the test are passed with pairs of environment
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CTEST_RESOURCE_GROUP_<ID>`, which will contain the type of resource group.
    In the example from earlier, this will be either `"mem_mb"`, `"cpus"`, `"clients"`,
    or `"servers"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CTEST_RESOURCE_GROUP_<ID>_<TYPE>`, which will contain a pair of `id:slots`
    for the types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is up to the implementation of the test on how the resource groups are used
    and internally distributed. So far, we have seen how tests are executed with CTest,
    but defining and discovering the tests is equally important.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and running tests is obviously one of the major boosters of code quality.
    However, another interesting metric is often how much of your code is actually
    covered by tests. Surveying and reporting code coverage can give interesting hints,
    not just about how widely a software is tested but also about where gaps lie.
  prefs: []
  type: TYPE_NORMAL
- en: Generating code coverage reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being aware of how much of your code is covered by tests is a great benefit
    and often gives a very good impression of how well-tested a given software is.
    It can also give hints to developers about the execution paths and edge cases
    that are not covered by tests.
  prefs: []
  type: TYPE_NORMAL
- en: To get code coverage in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few tools that help you get code coverage in C++. Arguably, the
    most popular is *Gcov* from GNU. It’s been around for years and works well with
    GCC and Clang. Although it does not work with Microsoft’s Visual Studio, using
    Clang to build and run software provides a viable alternative for Windows. Alternatively,
    the `OpenCppCoverage` tool can be used to get coverage data on Windows to build
    with MSVC.
  prefs: []
  type: TYPE_NORMAL
- en: The coverage information generated by Gcov can be collected in summarized reports
    with the Gcovr or LCOV tools.
  prefs: []
  type: TYPE_NORMAL
- en: Generating coverage reports using Clang or GCC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to create code coverage reports with Gcovr.
    Generating these reports roughly works in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The program and libraries to be tested are compiled with special flags so that
    they expose the coverage information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program is run, and the coverage information is stored in a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The coverage analyzers, such as Gcovr or LCOV, analyze the coverage files and
    generate reports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, the reports are stored or further analyzed to display trends in
    coverage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A common setting for code coverage is that you want to have information about
    how much of a project’s code is covered by the unit tests. In order to do this,
    the code has to be compiled with the necessary flags so that the information is
    exposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<LANG>_COMPILER_FLAGS` cache variable should be passed to CMake over the
    command line. When using GCC or Clang, this might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: An alternative method is to define the respective preset, as explained in [*Chapter
    9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible Build* *Environments*.
    When building for coverage, it is often a good idea to compile with the debug
    information enabled and disable any optimization with the `-Og` flag. Additionally,
    specifying the `-fkeep-inline-functions` and `-fkeep-static-consts` compiler flags
    will prevent you from optimizing out static and inlined functions if they are
    never used. This will make sure that all possible execution branches are compiled
    into code; otherwise, the coverage report might be misleading, especially for
    inlined functions.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage reports work not just for single executables but also for libraries.
    However, the libraries must be compiled with coverage flags on.
  prefs: []
  type: TYPE_NORMAL
- en: As the compiler flags for coverage are set globally, the options will be passed
    on to projects added with `FetchContent` or `ExternalProject`, which might increase
    compilation time considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling sources using GCC or Clang with the coverage flags enabled will create
    `.gcno` files in the build directories for each object file and executable. These
    files contain meta information for Gcov about which calls and execution paths
    are available in the respective compilation units. In order to find out which
    of these paths are used, the programs have to be run.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the versions of Gcov and GCC
  prefs: []
  type: TYPE_NORMAL
- en: A common cause for failure and frustration when trying to extract code coverage
    information is that the versions of GCC and Gcov do not match. Always check with
    `g++ --version` and `gcov --version` that they are the same.
  prefs: []
  type: TYPE_NORMAL
- en: In a scenario where we want to find out the code coverage of tests, running
    CTest will generate the coverage results. Alternatively, running the executables
    directly will produce the same results. Running executables with coverage enabled
    will generate `.gcda` files in the build directories that contain information
    about the calls in the respective object files.
  prefs: []
  type: TYPE_NORMAL
- en: Once these files are generated, running Gcovr on them will create information
    about the coverage. By default, Gcovr outputs the information to `stdout`, but
    it can also generate HTML pages, JSON files, or SonarQube reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the pitfalls is that Gcovr expects all source and object files to be
    in the same directory, which is not the case with CMake. So, we have to pass the
    respective directories to Gcov with the `-r` option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a call might produce an HTML file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Example output for a coverage run](img/B30947_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Example output for a coverage run
  prefs: []
  type: TYPE_NORMAL
- en: 'Another alternative to Gcovr is LCOV, which works in a very similar way. In
    contrast to Gcovr, LCOV cannot directly produce HTML or XML output but will assemble
    any coverage information in an intermediate format, which can then be consumed
    by various converters. To produce HTML output, the `genhtml` tool is often used.
    To generate a report using LCOV, the commands might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A coverage report generated with LCOV might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – An example coverage report generated with LCOV](img/B30947_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – An example coverage report generated with LCOV
  prefs: []
  type: TYPE_NORMAL
- en: Note that these calls will only create coverage reports for the last run. If
    you want to assemble them into a time series to see whether code coverage increases
    or decreases, there are various CI tools available, such as Codecov and Cobertura,
    to do this. Such tools can generally parse output from Gcovr or LCOV and assemble
    it into fancy graphics, showing the coverage trends. The detailed documentation
    for Gcovr can be found at [https://gcovr.com/en/stable/](https://gcovr.com/en/stable/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating coverage reports for MSVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When building software using MSVC, the `OpenCppCoverage` tool is an alternative
    to Gcov. It works by analyzing the program databases (`.pdb`) produced by the
    MSVC compiler, rather than by compiling the source with different flags. The command
    to generate an HTML coverage report for a single executable might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this will only generate the coverage report for a single executable,
    `OpenCppCoverage` enables you to read the input from previous rounds and combine
    it into a report like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will combine the input of the first two runs into a common report. To consume
    the coverage information, the `export_type` option has to be `binary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common use for coverage reports is to find out how much code is covered by
    the tests defined in a project. In this case, using CTest as the test driver is
    convenient. As CTest will run the actual tests as subprocesses, the `--cover_children`
    option has to be passed to `OpenCppCoverage`. To avoid generating coverage reports
    for the system libraries used, adding a module and a source filter might be required.
    The command might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A slight downside to this approach is that the coverage report will include
    a coverage report for CTest itself. The generated HTML report might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – A coverage report generated with OpenCppCoverage](img/B30947_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – A coverage report generated with OpenCppCoverage
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Visual Studio, an alternative to the command line is to use a plugin.
    The plugin can be found on the Visual Studio marketplace: [https://marketplace.visualstudio.com/items?itemName=OpenCppCoverage.OpenCppCoveragePlugin](https://marketplace.visualstudio.com/items?itemName=OpenCppCoverage.OpenCppCoveragePlugin)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the full documentation, consult the GitHub page of `OpenCppCoverage`: [https://github.com/OpenCppCoverage/OpenCppCoverage](https://github.com/OpenCppCoverage/OpenCppCoverage)'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how much of your code is covered by the supplied tests is a piece of
    very valuable information regarding code quality. In fact, in a lot of regulated
    industries, such as healthcare, aviation, and the car industry, providing code
    coverage reports might be required by the regulatory bodies. However, only knowing
    how much code is executed is obviously not enough; the quality of the underlying
    code is of even more importance. Some compilers provide useful tools to detect
    common errors in your code with the help of so-called sanitizers. In the next
    section, you will learn how to use and apply the sanitizers using CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today’s compilers are often more than just programs to convert text to binary
    code. They are complex software suites that have built-in functionality to ensure
    code quality. The focus on how much compilers are aware of code quality issues
    has drastically increased, especially with the advent of LLVM and Clang. These
    quality tools are commonly called **sanitizers** and are enabled by passing certain
    flags to the compiler and linker.
  prefs: []
  type: TYPE_NORMAL
- en: Code sanitizers are a way to bring additional quality checks into code by using
    the compiler to decorate the binary code with annotations and hooks, detecting
    various runtime issues. When the code is executed, the annotations are checked
    and confirmed if any violations are reported. Sanitizers are relatively fast,
    but they obviously have an impact on the runtime behavior of any program. If the
    sanitizers catch anything, programs are terminated with `abort()` and return with
    non-zero. This is particularly useful with testing because this means any test
    violating a sanitizer will be marked as a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the most common types of sanitizers:'
  prefs: []
  type: TYPE_NORMAL
- en: The **address sanitizer** (**ASan**) detects memory access errors such as out-of-bounds
    and use-after-free bugs. On some platforms, the ASan can even be run with hardware
    assistance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **leak sanitizer** (**LSan**), which is part of the ASan, can be used to
    detect memory leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In GCC and Clang, there are a few specialized versions of the general ASan,
    such as the **kernel address sanitizer** (**KASAN**) to detect memory errors in
    the Linux kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **memory sanitizer** (**MSan**) detects uninitialized memory reads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **thread sanitizer** (**TSan**) will report data races. Because of the way
    the TSan works, it cannot be run together with the ASan and LSan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **undefined behavior sanitizer** (**UBSan**) detects and reports cases where
    code results in undefined behavior. Using variables before initialization or ambiguity
    regarding operator precedence are common examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Clang suite leads the field with the availability of sanitizers, with GCC
    coming a close second. Microsoft has been a bit slower in adopting the features,
    but from MSVC version 16.9, which comes with Visual Studio 19, the Microsoft compilers
    support at least the ASan. For details on what the respective sanitizers do and
    how to configure them in detail, refer to the helpful documentation of the various
    compilers.
  prefs: []
  type: TYPE_NORMAL
- en: The sanitizers are enabled by passing various compiler flags that cause a compiler
    to add extra debugging information to the binaries. When the binaries are executed,
    the sanitizer code will perform its check and print out any errors to `stderr`.
    As the code needs to be executed for the sanitizers to find any potential bugs,
    having high code coverage is essential to improve the reliability of the sanitizers.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the ASan in GCC or Clang, the `-fsanitize=<sanitizer>` compiler flag
    has to be passed. For MSVC, the corresponding option is `/fsanitize=<sanitizer>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler flags are passed into CMake with the `CMAKE_CXX_FLAGS` cache variable.
    So, calling CMake from the command line with a sanitizer enabled would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When using CMake presets, the cache variables to contain the compiler flags
    can also be defined there. Presets are covered in depth in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible Build* *Environments*. Setting the `sanitizer` option globally
    will also affect any projects included that use `FetchContent` or `ExternalProject`
    after the flags are set, so act with caution there. For the ASan, use `-fsanitizer=address`
    on GCC and Clang, and `/fsanitizer=address` on MSVC. The MSan is enabled with
    `-fsanitize=memory`, the LSan is enabled with `-fsanitize=leak`, the TSan is enabled
    with `-fsanitize=thread`, and the UBSan is enabled with `-fsanitize=undefined`
    for GCC and Clang only at the time of writing. To get a more concise output for
    the ASan, LSan, and MSan, tell the compiler to explicitly keep the frame pointer.
    This is done by setting `-fno-omit-framepointer` in GCC and Clang. MSVC only supports
    this for x86 builds with the `/``Oy-` option.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `CMAKE_CXX_FLAGS` variable to enable sanitizers in `CMakeLists.txt`
    itself is discouraged, as the sanitizers are neither built nor have any usage
    requirements to use any of the targets defined by a project. Additionally, setting
    the `CMAKE_CXX_FLAGS` variable in `CMakeLists.txt` might conflict with what the
    user might pass from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizers are a very powerful tool to increase code quality. Together with
    unit tests and the coverage report, they provide three of the four major concepts
    to ensure code quality. The fourth option to automatically ensure code quality
    is using static code analyzers.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis using CMake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests, sanitizers, and coverage reports all depend on code being actually
    run to detect possible errors. Static code analysis analyzes code without running
    it. The good thing about that is that all code that is compiled can be analyzed,
    not just the parts that are covered by tests. This, of course, also means that
    different kinds of glitches can be found. A downside of static code analysis is
    that it can take a very long time to run tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake supports several tools for static code analysis that are enabled either
    by setting a property or a global variable. All of the tools, except *link what
    you use*, are external programs that need to be installed and found in the path
    of the system. *Link what you use* uses the linker of a system, so no further
    installation is necessary. The tools supported by CMake are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LANG>_CLANG_TIDY` property or the `CMAKE_<LANG>_CLANG_TIDY` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_CPPCHECK` property or the `CMAKE_<LANG>_CPPCHECK` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_CPPLINT` property or the `CMAKE_<LANG>_CPPLINT` variable. Cpplint was
    originally developed at Google, and because of this, it has the Google C++ style
    hardcoded within.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<LANG>_INCLUDE_WHAT_YOU_USE` property or the `CMAKE_<LANG>_INCLUDE_WHAT_YOU_USE`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LINK_WHAT_YOU_USE` property or the `CMAKE_LINK_WHAT_YOU_USE` variable. Note
    that this is not dependent on the language chosen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all tools, `<LANG>` is either `C` or `CXX`. The properties contain a semicolon-separated
    list containing the respective executable and command-line arguments. As of CMake
    3.21, automatic execution of the static code analyzers is only supported for the
    Ninja and Makefile generators. Visual Studio handles the static code analyzers
    over settings of the IDE, which CMake cannot control. lwyu is a special case because
    it uses special flags for the `ldd` or `ld` linker and is not a special tool.
    So, the `LINK_WHAT_YOU_USE` property is just a Boolean value and not a command
    line. It also means that lwyu is only supported on ELF platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the coverage reports and the sanitizers earlier in this chapter, the static
    code analysis tools are enabled by passing the command in the respective variable
    to CMake over the command line, or by using a preset. If the variable is set,
    then the static code analyzers will be executed automatically when compiling the
    source files. Enabling `clang-tidy` for a build might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The command and the arguments are formatted as a semicolon-separated list. In
    the preceding example, all checks for `clang-tidy` are enabled with `-checks=*`,
    and a filter is added to only apply `clang-tidy` to the `include` files of the
    current project with `-header-filter=<sourceDir/*>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same patterns work when using Cppcheck, Cpplint, and iwyu, as the following
    examples show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The static code analyzers will run when compiling the files in a project. The
    output of any finding will be printed out with any usual compiler warnings or
    errors. By default, all non-critical findings of the analyzers will not cause
    the build to fail. For high-quality software where zero-tolerance against warnings
    exists, the appropriate flags can be passed to Cppcheck and Clang-Tidy:'
  prefs: []
  type: TYPE_NORMAL
- en: For Clang-Tidy, passing `--warnings-as-errors=*` will cause a compilation to
    fail on any issue found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Cppcheck, passing the `--error-exitcode=1` parameter will cause Cppcheck
    to exit with `1` instead of `0` if an issue is found, and the build will fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iwyu** and **cpplint**, unfortunately, lack similar flags.'
  prefs: []
  type: TYPE_NORMAL
- en: A very nice feature of Clang-Tidy is that it can automatically apply fixes to
    source files. This can be done by additionally passing the `--fix` and `--fix-error`
    flags to Clang-Tidy.
  prefs: []
  type: TYPE_NORMAL
- en: Attention when building incrementally
  prefs: []
  type: TYPE_NORMAL
- en: All the static code analyzers work only if a file is actually compiled. To ensure
    that the static code analyzers catch all errors, they have to be run on a clean
    build.
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of lwyu, all the static code analyzers look at the source
    files to find any issues; conversely, **lwyu** will look at the binary files to
    find unused dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lwyu analyzer is intended to help speed up builds and reduce the complexity
    of the dependencies tree. The command for lwyu is defined in `CMAKE_LINK_WHAT_YOU_USE_CHECK`.
    This variable is just a Boolean option, not a command for an external like the
    other tools. If set, it will pass the respective flags to the linker to output
    any unused direct dependencies. As of CMake version 3.21, this is defined as the
    `ldd –u -r` command. The usage of `ldd` means that this analyzer is only available
    for ELF platforms. lwyu can be enabled by passing a simple option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of lwyu might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This example shows that `libssl.so` was linked but not used, even the ones indirectly
    linked by any dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the various static code analyzers and iwyu and lwyu helps
    to keep codebases small and free from common code smells. So far in this chapter,
    we have looked at how tests are defined, sanitizers, and static code analysis,
    which deal with checking whether code functions correctly. One of the problems
    we’ve seen is that if the combinations must be enabled for all the single targets,
    `CMakeLists.txt` can become cluttered, especially for large projects. A clean
    alternative is to provide a custom build type that enables compile-time code analysis
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom build types for quality tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed build types such as `Debug`, `Release`, `RelWithDebInfo`,
    and `MinSizeRel`, which are provided by CMake by default. These build types can
    be extended with custom build types that pass global flags to all targets. For
    the code quality tools that rely on certain compiler flags, providing a custom
    build type can simplify `CMakeLists.txt` considerably, especially for large projects.
    Creating a custom build type is also much preferred to directly interfering with
    the global `CMAKE_<LANG>_FLAGS`.
  prefs: []
  type: TYPE_NORMAL
- en: Do not override CMAKE_<LANG>_FLAGS
  prefs: []
  type: TYPE_NORMAL
- en: Setting the global compiler option is over the generic `CMAKE_<LANG>_FLAGS`
    in your `CMakeLists.txt`. These flags are intended to be set outside a project,
    either by passing them over the command line or by supplying them with a toolchain
    file. Modifying them inside a project creates a high chance of interfering with
    the cases where they are set from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: For multi-configuration generators such as MSVC or Ninja Multi-Config, the available
    build types are stored in the `CMAKE_CONFIGURATION_TYPES` cache variable. For
    single configuration generators such as Make or Ninja, the current build type
    is stored in the `CMAKE_BUILD_TYPE` variable. Custom build types should be defined
    on the top-level project.
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom build type called `Coverage` could be added to `CMakeLists.txt`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down what happens in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it is determined whether the current `Generator` is a multi or single-configuration
    generator. This is stored in the `GENERATOR_IS_MULTI_CONFIG` global property.
    Since the property cannot be used directly in an `if` statement, the property
    is retrieved and stored in the `IS_MULTI_CONFIG` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the current generator is indeed a multi-configuration generator, the custom
    build configuration called `Coverage` is added to `CMAKE_CONFIGURATION_TYPES`
    and made available to the generator, but only if it does not yet exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the generator is a single configuration generator, a hint that the `Coverage`
    build exists is added by setting the `STRINGS` property of the `CMAKE_BUILD_TYPE`
    cache variable. This will create a drop-down menu with the valid options in the
    CMake GUI. For convenience, the supported build types are stored in the `KNOWN_BUILD_TYPES`
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the current build type is usually supplied from the outside for single configuration
    generators, it is prudent to check for unknown build types and abort the configuration
    if an unknown build type is specified. Printing a message as `FATAL_ERROR` will
    cause CMake to stop the build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this, the `Coverage` build type is added to CMake, but the build type
    is not yet configured to add a custom compiler and linker flags to the build.
    To define the flags, two sets of cache variables are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_<LANG>_FLAGS_<CONFIGURATION>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_<TARGET_TYPE>_LINKER_FLAGS_<CONFIGURATION>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<CONFIGURATION>` is the name of the custom build type, `<LANG>` is the programming
    language, and `<TARGET_TYPE>` for the linker flags are either executable or the
    various types of libraries. It can be useful to base the configuration for a custom
    build on existing build types to reuse any of the configuration options. The following
    example sets up the `Coverage` build type for a Clang- or GCC-compatible compiler,
    based on the flags of the `Debug` build type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The flags can also contain generator expressions to account for different compilers
    when setting the flags. Marking the flags as `advanced` will help prevent accidental
    change of the variables by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, the filename for libraries should reflect that they are created
    with a special build type. Setting `CMAKE_<CONFIGURATION>_POSTFIX` for the custom
    build type will achieve that. This is already common practice for debug builds,
    so the files can be distinguished from the release build when packaged together.
    Related to this is the `DEBUG_CONFIGURATIONS` global property, which contains
    the configurations that are considered non-optimized and are used for debugging.
    If the custom build is considered a non-release build, adding to the property,
    as follows, should be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `DEBUG_CONFIGURATION` property should be set on the top-level project before
    any calls to `target_link_libraries`. The `DEBUG_CONFIGURATIONS` property is currently
    only used by `target_link_libraries`, where, for historical reasons, the libraries
    can be prefixed with `debug` or optimized to indicate that they should only be
    linked for the respective build configuration. Nowadays, this is rarely used,
    as generator expressions allow for more granular control of this.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes this chapter. We have covered the most common aspects of testing
    and quality tools and hope that we have contributde to your journey toward excellent
    software quality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maintaining high-quality software is a huge and complex task, and today, there
    is such a multitude of tools and techniques to test software that it can be hard
    to up. With the techniques and tools described in this chapter, we hope to have
    given a brief overview of the most common tasks and tools used in modern C++ development.
    CTest and CMake can help orchestrate the various kinds of tests to get the most
    out of the tools. In this chapter, you’ve seen how tests can be defined and run,
    how to execute them in parallel, and how to manage test resources. We’ve explored
    how to define test fixtures and how to define advanced ways to determine whether
    a test succeeded or failed, based on its output.
  prefs: []
  type: TYPE_NORMAL
- en: We illustrated how to set up code coverage reports using Gcov and how to define
    custom build types to pass the necessary compiler flags. We looked at how various
    tools for static code analysis can be included in CMake projects and how the sanitizers
    of various compilers can be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to use external programs from within CMake
    and how to perform platform-independent tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are tests defined in CMake?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can CTest be told to execute a specific test?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can an unstable test be repeated until it either succeeds or fails?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are tests run in parallel and random order?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you prevent multiple tests from using a unique test resource at the
    same time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are static code analyzers enabled for targets?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are custom build types defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests are defined by using the `add_test` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either by using a regex on the test’s name with `ctest -R` or by using the test
    number, using `ctest -I`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By calling `ctest --repeat:until-pass:n` or `ctest --repeat:until-fail:n`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By running `ctest -j <``num_of_jobs> --schedule-random`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By setting the `RESOURCE_LOCK` or `RESOURCE_GROUP` property for the respective
    tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static code analyzers are enabled by passing the command line, including any
    arguments, to the respective target properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By either adding them to the `CMAKE_CONFIGURATION_TYPES` property for multi-configuration-type
    generators or by adding them to the `CMAKE_BUILD_TYPE` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
