["```cpp\ncd ~ # User's home directory on Linux/macOS (feel free to pick another location)\nmkdir minimal-cmake\ncd minimal-cmake\ngit clone https://github.com/PacktPublishing/Minimal-CMake.git .\n```", "```cpp\ncd C:\\Users\\%USERNAME% # User's home directory on Windows (feel free to pick another location)\nmkdir minimal-cmake\ncd minimal-cmake\ngit clone https://github.com/PacktPublishing/Minimal-CMake.git .\n```", "```cpp\ncd ch2/part-1\n```", "```cpp\nCMakeLists.txt\nmain.c\n```", "```cpp\ncmake -B build\n```", "```cpp\n-- The C compiler identification is AppleClang 15.0.0.15000100\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info – done\n-- Check for working C compiler: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/cc - skipped\n-- Detecting C compile features\n-- Detecting C compile features – done\n-- Configuring done (3.4s)\n-- Generating done (0.0s)\n-- Build files have been written to: /path/to/minimal-cmake/ch2/part-1/build\n```", "```cpp\nUsage\n  cmake [options] <path-to-source>\n  cmake [options] <path-to-existing-build>\n  cmake [options] -S <path-to-source> -B <path-to-build>\nSpecify a source directory to (re-)generate a build system for it in the current working directory. Specify an existing build directory to re-generate its build system.\n```", "```cpp\ncmake --build build\n```", "```cpp\n./build/minimal-cmake\n```", "```cpp\nHello, CMake!\n```", "```cpp\nbuild\\Debug\\minimal-cmake.exe\n```", "```cpp\ncmake_minimum_required(VERSION 3.28)\nproject(minimal-cmake LANGUAGES C)\nadd_executable(${PROJECT_NAME})\ntarget_sources(${PROJECT_NAME} PRIVATE main.c)\ntarget_compile_features(${PROJECT_NAME} PRIVATE c_std_17)\n```", "```cpp\ncmake_minimum_required(VERSION 3.28)\n```", "```cpp\nCMake Error at CMakeLists.txt:1 (cmake_minimum_required):\n    CMake 3.28 or higher is required.  You are running version 3.15.5\n```", "```cpp\nCompatibility with CMake < 3.5 will be removed from a future version of CMake.\n```", "```cpp\ntarget_sources(${PROJECT_NAME} PRIVATE main)\n```", "```cpp\ntarget_sources(${PROJECT_NAME} PRIVATE main.c)\n```", "```cpp\nCMake Warning (dev) at CMakeLists.txt:4 (target_sources):\n  Policy CMP0115 is not set: Source file extensions must be explicit.  Run \"cmake --help-policy CMP0115\" for policy details.  Use the cmake_policy command to set the policy and suppress this warning.\n  File: /path/to/main.c\n```", "```cpp\nCMake Error at CMakeLists.txt:4 (target_sources):\n  Cannot find source file: main\n```", "```cpp\nproject(minimal-cmake LANGUAGES C)\n```", "```cpp\nCMake Warning (dev) in CMakeLists.txt:\nNo project() command is present.  The top-level CMakeLists.txt file must contain a literal, direct call to the project() command.  Add a line of code such as\n    project(ProjectName)\nnear the top of the file, but after cmake_minimum_required().\nCMake is pretending there is a \"project(Project)\" command on the first line.\n```", "```cpp\nadd_executable(${PROJECT_NAME})\n```", "```cpp\nmessage(STATUS \"PROJECT_NAME: \" ${PROJECT_NAME})\n```", "```cpp\ntarget_sources(${PROJECT_NAME} PRIVATE main.c)\n```", "```cpp\ntarget_compile_features(${PROJECT_NAME} PRIVATE c_std_17)\n```", "```cpp\nINTERNAL, so we shouldn’t depend on this in our scripts, but as a debugging aid it’s sometimes useful to check.\n\t\t\tSpecifying a generator\n\t\t\tIf we would like more control over the generator CMake uses, we can specify this explicitly by using the `-G` argument, `cmake -B build -G <generator>`, as in this example:\n\n```", "```cpp\n\n\t\t\tHere, we’ve referenced the Ninja build system generator ([https://ninja-build.org/](https://ninja-build.org/)), a build tool designed to run builds as fast as possible. Unfortunately, if we try and run this command on macOS or Linux, we’ll get an error as we currently do not have Ninja installed (fortunately on Windows, Ninja comes bundled with Visual Studio, and if we’re using the Developer Command Prompt or have run `VsDevCmd.bat`, we’ll have it in our path).\n\t\t\tNinja can be downloaded from GitHub ([https://github.com/ninja-build/ninja/releases](https://github.com/ninja-build/ninja/releases)), and once the executable is on your machine, you can add it to your `PATH` or move it to an appropriate folder such as `/usr/local/bin` or `/opt/bin`.\n\t\t\tSecurity settings for macOS\n\t\t\tOn macOS, you may need to open **System Settings** and navigate to **Privacy and Security** to allow Ninja to run because it is not from an identified developer.\n\t\t\tIt may also be easier to acquire Ninja through a package manager, particularly on Linux (e.g., `apt-get` `install ninja-build`).\n\t\t\tNinja advantages\n\t\t\tNinja is designed to be fast, so it’s well worth setting it up for use with future chapters when we start building larger third-party dependencies. Ninja will take full advantage of all system cores by default, and this really shows when comparing build times against other generators. Ninja’s multi-config generator support is also useful.\n\t\t\tOne thing to mention is even with this change to the generator behind the scenes, we can still use `cmake --build build` to build our project; there is no need to memorize any other build-specific commands. This consistency is invaluable as it reduces the cognitive load when working with different build systems, they’re largely abstracted away from us and we can focus on our project.\n\t\t\tIf you have generated some build artifacts using one generator and would like to switch to another, this requires deleting the build folder and starting over (e.g., `rm -rf build` or `cmake -B build –G <new-generator>`). If you aren’t switching generators, a useful argument to be aware of (added in CMake `3.24`) is `--fresh`:\n\n```", "```cpp\n\n\t\t\tUsing `--fresh` will remove the existing `CMakeCache.txt` and `CMakeFiles/` directory and restore them to the state they’d be if you were doing the first configure.\n\t\t\tCMake configs\n\t\t\tNow that we know how to specify a generator, we can talk about the one remaining topic in this chapter, configs (a concept inextricably linked to generators themselves). Generators come in two varieties, either single-config or multi-config. We’ve actually already encountered one of each already. Make is a single-config generator, and the default config we built without specifying anything was `Debug`. Visual Studio is a multi-config generator, which is why when we ran our earlier example on Windows, we had to specify the `Debug/` folder inside the `build/` folder instead of only the `build/` folder (`build\\Debug\\minimal-cmake.exe` versus `build/minimal-cmake`).\n\t\t\tSingle-config generators\n\t\t\tWith a single-config generator, when we run `cmake -B build`, we can pass an additional argument to set a CMake variable called `CMAKE_BUILD_TYPE`. We do this with `-D` to define a CMake variable and override the default value (one set by CMake or us in our `CMakeLists.txt` file). To be explicit about the config/build type, we’d write the following:\n\n```", "```cpp\n\n\t\t\tUsually, there are at least three build types: `Debug`, `Release`, and `RelWithDebInfo` (there’s also `MinSizeRel` with Visual Studio). These build types essentially control what underlying compiler flags are set for things such as optimization, debugging, and logging through defines. When developing code, we usually want to use the `Debug` configuration to allow us to easily step through our code in a debugger. When we’re ready to share our project with users, we use the `Release` configuration to get maximum performance. `RelWithDebInfo` is a happy medium. Some optimizations may be disabled compared to `Release`, but performance will be similar. Debug symbols are also created to make debugging `Release` builds easier.\n\t\t\tThe defaults are more than sufficient for our purposes but, in advanced cases, it is possible to create your own build types (this is easier said than done as you need to know the compiler flags to use across a host of platforms/compilers, but if you ever did need to do this, you can).\n\t\t\tOne thing to be aware of when changing `CMAKE_BUILD_TYPE` is the artifacts in your build folder will be completely rebuilt depending on the build type. So, for example, if you have a larger project, and you normally have `-DCMAKE_BUILD_TYPE=Release` set, if you run `cmake -B build -DCMAKE_BUILD_TYPE=Debug` and run `cmake --build build`, the release files will be overwritten, and so switching back again to `Release` will wipe out all the `Debug` build files. For this reason, it is wise to use different folders for the different configurations to make this switching back and forward more efficient. To illustrate, we could have the following:\n\n```", "```cpp\n\n\t\t\tTo build each config, you’d then use either `cmake --build build-debug` or `cmake --build build-release`. You could also group the different configurations under the build folder (e.g., `build/debug` or `build/release`), but remember each subfolder is completely distinct and nothing is shared between the two when using single-config generators.\n\t\t\tLet’s now explore multi-config generators.\n\t\t\tMulti-config generators\n\t\t\tWith a multi-config generator, `CMAKE_BUILD_TYPE` goes away and instead, the config is specified at build time rather than configuration time. It also handles the case described earlier where different build types can overwrite one another.\n\t\t\tWith a multi-config generator, you’d configure it in this way:\n\n```", "```cpp\n\n\t\t\tThen, when building, you pass an additional argument, `--config`, along with the config type:\n\n```", "```cpp\n\n\t\t\tMulti-config generators will create subdirectories inside the build folder you specified. In the case of Ninja Multi-Config, this will be `Debug`, `Release`, and `RelWithDebInfo` (no `MinSizeRel`). Multi-config generators are a good choice to stick with and, in later chapters, we’ll cover a couple more reasons why to prefer them.\n\t\t\tThat covers the most essential operations you’ll perform when working with CMake on a daily basis. There are many more options and tools available to streamline usage and simplify project configuration, but you could survive with what we’ve covered here for some time.\n\t\t\tProject next steps\n\t\t\tNow we’ve been through our first `CMakeLists.txt` file and are more familiar with build types (configs) and generators, it’s time to look at a real program and see how we can start to evolve it with CMake’s help.\n\t\t\tStaying with the book’s sample code, navigate to `ch2/part-2` in your terminal and run the commands we’re now intimately familiar with, `cmake -B build` (feel free to specify a generator of your choosing such as `-G \"Ninja Multi-Config\"`), followed by `cmake --``build build`.\n\t\t\tAfter configuring and building, we can run the sample application by typing `./build/Debug/minimal-cmake_game-of-life` on macOS and Linux, or `build\\Debug\\minimal-cmake_game-of-life.exe` on Windows (for brevity, we’ll use the POSIX path convention from macOS and Linux going forward; this is one reason to recommend using Git Bash from within Terminal on Windows as the experience will be more consistent).\n\t\t\tYou should see the following printed (several blank lines omitted here):\n\n```", "```cpp\n\n\t\t\tPress *Enter* on your keyboard and you’ll see the pattern denoted by the `@` symbols update (hitting *Enter* repeatedly will cause the scene to keep updating).\n\t\t\tWhat you are seeing is an incredibly simple implementation of John Horton Conway’s *Game of Life*. *Game of Life* is an example of cellular automaton. Conway’s *Game of Life* is represented as a grid, with each cell in either an on or off state. A set of rules is processed for each update to decide which cells turn on, which turn off, and which stay the same. The topic is vast; if you would like to learn more about it, please check out the Wikipedia pages about both Conway’s *Game of Life* ([https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)) and cellular automaton more generally ([https://en.wikipedia.org/wiki/Cellular_automaton](https://en.wikipedia.org/wiki/Cellular_automaton)).\n\t\t\tFor our purposes, we’d just like something interesting to look at so we can start to evolve it over time. The implementation is written in C and the `CMakeLists.txt` file differs from the first one we looked at by only the name (the *Game of Life* implementation lives in `main.c`).\n\t\t\tIn the book’s repository (available from [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)), every `ch<n>/part-<n>` section in each chapter builds on the last in some small way. To help make sense of these incremental changes, see the following callout about using Visual Studio Code to make visualizing these differences easier.\n\t\t\tVisual Studio Code compare\n\t\t\tA useful feature in Visual Studio Code is the `code .` from your terminal will help with this, so all related files can be easily accessed). It’s then simple to highlight what has changed between versions of our `CMakeLists.txt` files without needing to switch back and forth between them. Focusing on the changes instead of reviewing an entire file, which may be very similar to the previous one, is an efficient strategy.\n\t\t\tDon’t worry too much about the code. It’s not super important how it works; what is important is how CMake can start to help us organize and enhance our application.\n\t\t\tAdding another file\n\t\t\tBefore we wrap up, let’s make one small addition to our application. We’d like to improve the performance of our update logic in our current implementation of *Game of Life*. One subtlety of implementing *Game of Life* is we can’t change the board we’re reading from at the same time. If we do, then the cells from the row we’re on will have changed from their earlier state by the time we get to the next row, which will mean the simulation won’t run correctly. In the implementation in `ch2/part2` (a reminder to refer to [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake) to find this), we simply make a copy of the whole board, read from that in `update_board` (see line 72 in `ch2/part-2/main.c`) and write back to the original board. This is okay, but if most cells don’t change, it’s wasteful. A better approach is to record the cells that change, and then write back to the original board at the end. By doing this, we only need to allocate memory for cells that change instead of the whole board.\n\t\t\tAdding a dynamic array\n\t\t\tLet’s add a simple data structure to make this possible. C unfortunately doesn’t have a built-in dynamic array, which would be particularly useful in this case, so let’s add one.\n\t\t\tMoving to `ch2/part3` from the book’s GitHub repository, there are two new files, `array.h` and `array.c`. To keep them grouped logically together, they’ve been added to a folder called `array`. The interface provided by `array.h` is like that of `std::vector` from C++. It’s a little trickier to use as C doesn’t support generics/templates, but for our purposes, it’ll be a huge help.\n\t\t\tWith this file added, we need to ensure CMake knows about it; otherwise, it won’t be built. To do this, we simply add `array/array.c` to the existing `target_sources` command from earlier:\n\n```", "```cpp\nld: Undefined symbols:\n  _array_free, referenced from:\n      _update_board in main.c.o\n  _array_size, referenced from:\n      _update_board in main.c.o\n      _update_board in main.c.o\n      _update_board in main.c.o\n  _internal_array_grow, referenced from:\n      _update_board in main.c.o\n      _update_board in main.c.o\n```", "```cpp\nfile(GLOB sources CONFIGURE_DEPENDS *.c)\ntarget_sources(foobar PRIVATE ${sources})\n```", "```cpp\ntarget_sources(\n  ${PROJECT_NAME} PRIVATE main.c array/array.h array/array.c)\n```", "```cpp\n\n```"]