- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Supporting Tools and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re going to cover some of the fantastic tools that complement
    the core CMake ecosystem to make developing with CMake easier, faster, and more
    enjoyable. There are some brilliant projects that extend and enhance CMake, and
    knowing about them can make a significant difference in your development experience.
    We’ll also look at some other popular **integrated development environments**
    (**IDEs**) and see how to get them to play nicely with CMake.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we’ll cover some recommended practices when it comes to
    developing C/C++ applications and how CMake can help with this, as well as some
    final suggestions on structuring our CMake scripts. Finally, we’ll look at the
    road ahead and introduce some CMake topics we didn’t have the opportunity to cover
    in this book and where you can go to learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: CMake Tools for Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code extras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake with other IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C/C++ build recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake script structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along, please ensure you have met the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Windows, Mac, or Linux machine with an up-to-date **operating** **system**
    (**OS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code examples in this chapter can be found by following this link: https://github.com/PacktPublishing/Minimal-CMake.'
  prefs: []
  type: TYPE_NORMAL
- en: CMake Tools for Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the outset of this book, we recommended using **Visual Studio Code** as the
    editor of choice to ensure a consistent experience whether you’re developing on
    Windows, macOS, or Linux. This is completely optional, but there’s a lot to like
    when it comes to using CMake with Visual Studio Code. In this section, we’ll discuss
    how best to use the examples from this book and show how to configure, build,
    and debug our projects all from within Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: If you follow the steps in [*Chapter 1*](B21152_01.xhtml#_idTextAnchor019),
    *Getting Started*, in the *Visual Studio Code setup* section, you’ll already have
    **CMake Tools** installed as part of the **C/C++** **Extension Pack**.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the Minimal CMake source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to navigate around the *Minimal CMake* source code, it is recommended
    to open a Visual Studio Code project from the root of the repository. This can
    be achieved by cloning the repository, and then opening Visual Studio Code from
    that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You could also change directory to the `mc` folder (`cd mc`), and then run `code
    .` to open Visual Studio Code from there.
  prefs: []
  type: TYPE_NORMAL
- en: This is great for navigating the examples and comparing differences and updates
    between each of the parts, but it’s unfortunately not ideal for building and running
    the individual examples. To get a more representative experience of using CMake
    Tools from Visual Studio Code for configuring, building, and debugging the examples,
    it’s easier to open a new instance of Visual Studio Code for each directory that
    contains a root-level `CMakeLists.txt` file. For example, in the case of some
    of the later examples, from the terminal, you would change directory to `ch10/part-5/app`,
    and then type `code .` from that folder (or simply type `code ch10/part-5/app`
    if you were at the root of the repository); this is how you would normally work
    with a CMake project. The accompanying source code is made up of many nested projects
    evolving over time; each `ch<n>/part-<n>` `README.md` file lists the root folders
    to open for reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the workflow described previously, Visual Studio Code also supports
    multi-root workspaces (see [https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces)
    for more information). To activate multi-root workspaces, you can either use the
    **Workspaces: Add Folder to Workspace...** option from the Command Palette, or
    navigate to the **File** menu and select **Add Folder** **to Workspace...**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: The Add Folder to Workspace… option](img/B21152_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The Add Folder to Workspace… option'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then select a folder containing the `CMakeLists.txt` file that you’d
    like to run the example from (in the later examples in the book, this will usually
    be the `app` folder). The following is an example showing the workspace view in
    Visual Studio Code **EXPLORER**:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.2: Multi-workspace view in \uFEFFEXPLORER](img/B21152_11_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Multi-workspace view in EXPLORER'
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to save a workspace and track the folders that are part of it.
    If you choose to do this, a new file will be created with the same name as the
    workspace and the `.code-workspace` file extension. It’s also possible to add
    a display name for folders, which can be useful in helping identify them if multiple
    folders at different positions in the hierarchy share the same name (in the example
    before, the bottom two sub-folders would just be called `app` without the name
    override).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the content of the `.code-workspace` file from the workspace
    displayed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Visual Studio Code CMake Tools extension also respects multi-root workspaces
    and makes it possible to switch between workspaces when building using the **PROJECT
    OUTLINE** section of the CMake Tools extension in the sidebar (just click the
    gear icon to set the active workspace). Multi-root workspaces can be very convenient
    for keeping multiple projects in a single repository together.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring, building, and debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From within Visual Studio Code, say you’ve opened a project view for a specific
    folder, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Pressing `F1` will open the Command Palette. From there, typing CMake will
    display all the CMake commands available through the Visual Studio Code CMake
    Tools extension. There, you can search for commands such as `configure` and `build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21152_11_3.jpg)![](img/B21152_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: CMake Tools configure and build commands'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a very convenient CMake Tools panel available in the Visual Studio
    Code sidebar with an array of options to allow you to configure, build, test,
    debug, and launch the application all from within Visual Studio Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: The Visual Studio Code CMake Tools panel](img/B21152_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: The Visual Studio Code CMake Tools panel'
  prefs: []
  type: TYPE_NORMAL
- en: Hovering over each row will display an icon on the right that can be pressed
    to perform that specific action. This is much simpler than configuring a specific
    task in the `launch.json` file within Visual Studio Code, which is needed for
    C/C++ applications not using CMake.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible users on macOS may experience an issue with the `lldb-mi`. The
    workaround for this is to provide `miDebuggerPath` in your workspace or user `settings.json`
    file. The following is an example path; the exact location may differ slightly
    in your case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To open the `settings.json` file, simply hit `F1` to bring up the Command Palette,
    then search `settings`, and select either **Preferences: Open User Settings (JSON)**
    or **Preferences: Open Workspace Settings (JSON)** depending on where you’d like
    to set the option (system-wide, or just for this workspace).'
  prefs: []
  type: TYPE_NORMAL
- en: If, for whatever reason, the CMake `launch.json` file and manually set the executable
    location and working directory. To achieve this, go to the **RUN AND DEBUG** panel
    in Visual Studio Code, and press **create a** **launch.json file**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: The Visual Studio Code RUN AND DEBUG panel](img/B21152_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: The Visual Studio Code RUN AND DEBUG panel'
  prefs: []
  type: TYPE_NORMAL
- en: Either `launch.json` will open, or the Command Palette will open with an option
    to select a debugger. This will vary depending on the platform you’re on. If you
    configure and build using CMake first, then a C++ debugger will be displayed (if
    there’s no build folder, only the default options will be present).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `launch.json` file should initially look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a button toward the lower right of the screen called **Add Configuration...**;
    pressing it will display a list of debug options. Select the most appropriate
    option depending on your platform, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**macOS**: **{} C/C++: (****lldb) Launch**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Window**s: **{} C/C++: (****Windows) Launch**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux**: **{} C/C++: (****gdb) Launch**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generated configuration then needs two minor changes: `"program"` needs
    to be set to the location of your executable and `"cwd"` should be set to the
    working directory you’d like the application to run from (in most cases, this
    will be the same as `${workspaceFolder}`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example macOS configuration is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this change, pressing *F5* or the **Start Debugging** play symbol from
    the **RUN AND DEBUG** sidebar panel will launch the application and allow you
    to place breakpoints and step through your code. Next, we’ll look at how CMake
    presets integrate with Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code and CMake presets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio Code handles the configure and build stages similarly to how CMake
    does natively from the command line (making a best guess about the generator and
    choosing some sensible defaults for things such as the `build` folder, which,
    by default, is set to `${workspaceFolder}/build`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is Visual Studio Code works even better with projects taking
    advantage of CMake presets. If a `CMakePresets.json` file is present at the root
    of the project, when pressing the configure button from within the CMake Tools
    extension in Visual Studio Code, the Command Palette will prompt you to select
    a preset first. It also offers the choice to create a brand-new preset should
    you wish to. Selecting a preset will then configure the project using all the
    settings defined in that preset. The output is displayed in the **OUTPUT** window,
    usually displayed at the bottom of the Visual Studio Code window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Visual Studio Code CMake – configuring the output](img/B21152_11_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Visual Studio Code CMake – configuring the output'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **Build** icon (appearing next to the Build heading in the CMake
    Tools extension), will then build the application for us, and if we click the
    play icon (displayed when hovering over the **Debug** or **Launch** headings in
    the CMake Tools extension), the application will start. **Debug** is particularly
    useful as it’s possible to then set breakpoints in Visual Studio Code and use
    the **VARIABLES** and **WATCH** window to see the state of variables in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the `enable_testing()` command be added to our `CMakeLists.txt`
    files (just after `include(CTest)` is fine). Using `ctest` from the command line
    works without it, but for things to work nicely with Visual Studio Code, it’s
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to packaging, CMake Tools unfortunately doesn’t respect the `"condition"`
    property we used to hide packaging configurations for other platforms. This means
    the packaging presets will be missing when viewed from CMake Tools. To restore
    them, simply remove the `"condition"` blocks from the package presets in our `CMakePresets.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you’d remove the following from the `windows` package preset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With these removed, you’ll see the package preset appear as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: Package preset listed in CMake Tools](img/B21152_11_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Package preset listed in CMake Tools'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the pencil icon will let you then select from one of the available
    presets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: Selecting a package preset from the Command Palette](img/B21152_11_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Selecting a package preset from the Command Palette'
  prefs: []
  type: TYPE_NORMAL
- en: This is a small inconvenience and hopefully will be fixed in a future version
    of CMake Tools. For an example of our project with the small tweaks to make it
    fully compatible with CMake Tools, please see `ch11/part-1/app`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging CMakeLists.txt files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another excellent feature worth briefly mentioning is support for debugging
    `CMakeLists.txt` files. Most of the time, your `CMakeLists.txt` files should be
    simple and declarative enough to not call for debugging, but there’ll undoubtedly
    be cases where stepping through the code to see what’s happening can be incredibly
    useful. After opening Visual Studio Code from a directory containing a `CMakeLists.txt`
    file, open the Command Palette (*F1* or *Cmd* + *Shift* + *P* on macOS, *Ctrl*
    + *Shift* + *P* on Windows/Linux), and search for `CMake Debugger`; this will
    present the **CMake: Configure with CMake Debugger** option. Prior to this, if
    you add some breakpoints (to add breakpoints, click in the left-hand margin of
    the Visual Studio Code text editor, just to the left of the line numbers, or just
    right of the sidebar), execution will stop there and you can then use the **VARIABLES**
    and **WATCH** window to better understand the state of the script as it’s processed.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.9* shows an example of what you can expect. In it, we’ve stopped
    on a breakpoint inside an if `APPLE` check. We can see the value of several watch
    variables that have been added, and the **Locals** section contains all relevant
    cache variables, local variables, directories, and targets.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: Visual Studio Code CMake debugger](img/B21152_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Visual Studio Code CMake debugger'
  prefs: []
  type: TYPE_NORMAL
- en: Note that debugging our main `CMakeLists.txt` file doesn’t work quite as well
    with super builds, as the call to our `ExternalProject_Add` command won’t process
    our file directly. To work around this, simply create another regular build (using
    one of the regular CMake presets, such as `multi-ninja`) and then debug using
    that instead.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more information about CMake Tools by visiting [https://github.com/microsoft/vscode-cmake-tools](https://github.com/microsoft/vscode-cmake-tools)
    and exploring the documentation. More information can also be found by going to
    [https://code.visualstudio.com/docs/cpp/cmake-linux](https://code.visualstudio.com/docs/cpp/cmake-linux)
    for another perspective on getting set up with CMake and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code extras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers an assortment of useful tools and features closely related
    to Visual Studio Code and CMake that can make development easier and may come
    in useful while working on future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax highlighting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first is a useful extension that provides syntax highlighting in `CMakeLists.txt`
    and `.cmake` files. The extension is simply called `twxs.cmake`. It can either
    be downloaded from [https://marketplace.visualstudio.com/items?itemName=twxs.cmake](https://marketplace.visualstudio.com/items?itemName=twxs.cmake),
    or from within the Visual Studio Code extension manager in the sidebar. It not
    only provides syntax highlighting but also useful snippets and completions.
  prefs: []
  type: TYPE_NORMAL
- en: Generating compile_commands.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using either Ninja or Make generators, a cache variable can be provided
    to CMake called `CMAKE_EXPORT_COMPILE_COMMANDS` to enable the generation of a
    file called `compile_commands.json`. `CMAKE_EXPORT_COMPILE_COMMANDS` can be added
    to a CMake preset or it can be passed at the command line when running the configure
    step, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"configurations": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '"compileCommands": "${workspaceFolder}/build/multi-ninja/compile_commands.json"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '],'
  prefs: []
  type: TYPE_NORMAL
- en: '"version": 4'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: python3 -m pip install cmakelang
  prefs: []
  type: TYPE_NORMAL
- en: 'python3 -m pip install pyyaml # required by cmake-format'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: export PATH="$HOME/.local/bin:$PATH"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: cmake-format CMakeLists.txt -i
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'line_width: 80'
  prefs: []
  type: TYPE_NORMAL
- en: 'tab_size: 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'enable_sort: True'
  prefs: []
  type: TYPE_NORMAL
- en: 'dangle_parens: False'
  prefs: []
  type: TYPE_NORMAL
- en: 'dangle_align: ''prefix'''
  prefs: []
  type: TYPE_NORMAL
- en: 'command_case: ''canonical'''
  prefs: []
  type: TYPE_NORMAL
- en: 'keyword_case: ''upper'''
  prefs: []
  type: TYPE_NORMAL
- en: 'line_ending: ''auto'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'cmake --preset vs # option 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'cmake -B build/vs -G "Visual Studio 17" # option 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: cmake -B build/vs -G "Visual Studio 17" -DSUPERBUILD=ON
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: set_property(
  prefs: []
  type: TYPE_NORMAL
- en: DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
  prefs: []
  type: TYPE_NORMAL
- en: PROPERTY VS_ specific ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build and launch the application, we can use the **Local Windows Debugger**
    option at the top center of the screen or press *F5* (to build without running,
    use *F7*):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.14: Visual Studio configuration and launch options](img/B21152_11_15.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.14: Visual Studio configuration and launch options'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember to pick the configuration that maps to the configuration we built our
    third-party dependencies for if using a later part of this book as an example.
    You may experience linker errors if you build your dependencies in `Debug` and
    then try to build the application in `Release` (or vice versa).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once everything has finished building and you can run the executable, in all
    examples from [*Chapter 2*](B21152_02.xhtml#_idTextAnchor032) to [*Chapter 9*](B21152_09.xhtml#_idTextAnchor195),
    you’ll see the following error message printed:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is because the application is looking for the resource (shader) files in
    the `build/vs/<config>` folder, not the root folder of the project where we’d
    normally run things from the terminal.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We saw one way how to address this in [*Chapter 10*](B21152_10.xhtml#_idTextAnchor214),
    *Packaging the Project for Sharing*, but if we’re not at that stage yet, a useful
    workaround is to provide a CMake cache variable called `CMAKE_VS_DEBUGGER_WORKING_DIRECTORY`
    to set the location of the working directory within Visual Studio. This can be
    achieved by setting `CMAKE_VS_DEBUGGER_WORKING_DIRECTORY` for the whole project,
    or by adding the following command to our `CMakeLists.txt` file for a particular
    target:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'cmake --preset xcode # option 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'cmake -B build/xcode -G Xcode # option 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: set_target_properties(
  prefs: []
  type: TYPE_NORMAL
- en: ${PROJECT_NAME} PROPERTIES
  prefs: []
  type: TYPE_NORMAL
- en: XCODE_GENERATE_SCHEME TRUE
  prefs: []
  type: TYPE_NORMAL
- en: XCODE_SCHEME_WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: set_target_properties(
  prefs: []
  type: TYPE_NORMAL
- en: ${PROJECT_NAME}
  prefs: []
  type: TYPE_NORMAL
- en: PROPERTIES
  prefs: []
  type: TYPE_NORMAL
- en: CXX_STANDARD_REQUIRED ON
  prefs: []
  type: TYPE_NORMAL
- en: 'CMakeLists.txt file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As well as this, it’s also generally recommended to enable as many warnings
    as possible to help catch errors early in the coding process (this can help catch
    things such as uninitialized variable usage and out-of-bounds array access, as
    well as many other things). To enable these warnings, we need to set various compiler
    flags depending on the compiler we’re using. We can use CMake generator expressions
    to help with this and set the correct warnings for whichever compiler we’re using,
    be that **Microsoft Visual C++** (**MSVC**), **GNU Compiler Collection** (**GCC**),
    or Clang.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code is a snippet of what this might look like:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet above, we use a CMake variable to hold the various compile flags
    we’d like to see, and then apply them using the `target_compile_options` command.
    The warnings you decide to opt in or out of will depend on the project and coding
    practices you’d like to adopt. There’s an excellent list of warnings and what
    they mean available from the `cppbestpractices` GitHub page ([https://github.com/cpp-best-practices/cppbestpractices/blob/master/02-Use_the_Tools_Available.md#compilers](https://github.com/cpp-best-practices/cppbestpractices/blob/master/02-Use_the_Tools_Available.md#compilers)).
    To see an example of the full set of warnings, see `ch11/part-2/app/CMakeLists.txt`.
    Try compiling the project to see how many warnings are detected in the *Minimal
    CMake* example code (there are quite a few, for demonstration purposes, of course).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Unity builds
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: CMake offers a build setting called `.c` or `.cpp` files) and concatenating
    them together. This is done using the regular C/C++ preprocessor `#include` directive.
    CMake will generate these files dynamically and compile them instead of the existing
    `.c/.cpp` files. In our `app` example project, a single unity `.cpp` file is created
    called `unity_0_cxx.cxx`, which includes all `.cpp` files in our project (this
    file can be found in the `build` folder under `CMakeFiles/minimal-cmake_game-of-life_window.dir/Unity`).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To enable unity builds, pass `-DCMAKE_UNITY_BUILD=ON` at the command line (or
    feel free to create a unity CMake preset to do so). One of the downsides to unity
    builds is they break a core rule in C/C++, and that’s that a `.c` or `.cpp` file
    can define values with internal linkage and those definitions are private. This
    means there’s no way they can conflict with any other files as they’re compiled
    individually (this applies to anonymous namespaces as well). When unity builds
    are enabled however, and these source files are grouped together, if two variables
    or functions happen to share a name, things will break (you’ll most likely get
    a multiply defined symbol error). Unity builds can also cause the opposite problem,
    which is where silent dependencies are introduced between source files. Things
    might compile in a unity build if a `.cpp` file pulls in an `include` from an
    earlier `.cpp` file in the same unity file but then won’t compile on its own if
    that include is missing.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensuring a project works with both unity builds and without can be a challenge
    unless building with each of them is enabled regularly. The one other downside
    to unity builds is in certain cases, their use can slow down iteration times.
    This is because making a change to one `.cpp` file will trigger recompilation
    of all other files in the same unity file it’s in (as that unity file is compiled
    as one). The change in build time will vary depending on the unity file grouping
    but can lead to longer compile times for minor changes. When working iteratively,
    it may be best to disable unity builds and only enable them for continuation integration
    builds to reduce external resource usage.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: It is possible to fine-tune unity builds by excluding files that may not compile
    cleanly, but this can be a laborious process. Trying to enable unity builds for
    an already mature project can be a challenge; so, if you think you’d benefit from
    them, enabling them early in the development process is a wise move. It’s also
    important to measure and profile the time-saving, if any, to understand the impact
    they’re having. To learn more about unity builds, see [https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html](https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: CMake script structure
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To try and keep things simple, in *Minimal CMake*, we opted to limit the number
    of `CMakeLists.txt` files in the project to keep things mostly in one place (we
    at most have two `CMakeLists.txt` files per project, one for the third-party dependencies
    and one for the main application itself). This has some advantages; keeping things
    centralized can make things easier to find and make understanding a project easier,
    but as a project grows, dealing with a single, enormous file can become a maintenance
    nightmare (especially with larger teams).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To help improve the separation of concerns and make things more modular, it’s
    possible to add `CMakeLists.txt` files to separate directories to handle building
    separate parts of the application and then bring them into the main build using
    `add_subdirectory`. For example, we could move our testing and packaging logic
    to their respective folders, and then include them from the top-level `CMakeLists.txt`
    file in the following way:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are some subtleties that we need to be aware of when making these kinds
    of changes though, in this case with the `tests` subfolder. By moving the logic
    from `app/CMakeLists.txt` to `app/tests/CMakeLists.txt`, any relative paths we’d
    been using will no longer work; so, we need to account for them (in our case,
    we need to update the path to `shaders-compiled.cmake` to include the full path
    by using `CMAKE_SOURCE_DIR` explicitly). We need to also remember to call `enable_testing()`
    from the top-level `CMakeLists.txt` file otherwise the tests in the subfolder
    won’t be discovered when using CTest.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we’re creating an executable target in the `tests` folder as well, by default,
    it will end up in a `tests` subfolder inside the `build` folder. This will break
    our `RPATH` loading; so, to keep things simple, we ensure it goes to the same
    output directory as before. We can achieve this by using the following command
    in `app/tests/CMakeLists.txt`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately for us, `CMAKE_BINARY_DIR` will work correctly if we’re using a
    single or multi-config generator (it will map to the correct config folder in
    the multi-config generator case). To see everything in context, please see `ch11/part-3/app`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We could go even further and move our install logic to a separate `CMakeLists.txt`
    file or extract our utility functions to new `.cmake` files and use `include`
    to bring them in. We can also use the interface target technique discussed in
    [*Chapter 9*](B21152_09.xhtml#_idTextAnchor195), *Writing Tests for the Project*,
    to make a separate target with all the C/C++ warning compilation flags set on
    it, and then have our application and test links against it. CMake offers a large
    degree of freedom and flexibility when it comes to how you structure your scripts,
    and with time and experience (and by reading other `CMakeLists.txt` files), you’ll
    get a feel for what works best for you.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Future topics
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: This brings us to the end of our CMake journey. The idea with this book has
    always been to try and share the best bits of CMake without getting hung up on
    the minutiae (there has undoubtedly been some minutiae, granted, but it could
    have been much worse). The idea was to show working, practical examples you can
    use and learn from. Without seeing a tool such as CMake in action, it makes it
    next to impossible to appreciate what it can do and to be able to start to understand
    it. We’ve covered a lot of ground, and you hopefully have the tools available
    to start building your own libraries and applications, as well as integrating
    what you build with incredible open source software that’s easier than ever to
    use.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: With all that said, there’s still a lot we haven’t covered and a lot more to
    learn. If you’re interested in using CMake to build code for other platforms (for
    example, Android or iOS), **toolchain files** are something to investigate. They
    allow you to build code for a target platform that’s different from the host platform.
    This can be useful when building code for embedded devices, mobile platforms,
    different OSs, or different architectures (e.g., ARM versus x86_64).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We didn’t discuss using a fully-fledged package manager with our project. It’s
    worth exploring the open source package managers `vcpkg` will download prebuilt
    binaries for the library you want to use if they exist for the platform/architecture
    you’re using (they also use toolchain files for this reason; so, understanding
    how they work and why they’re needed will help).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There’s another useful tool called `CPM.cmake` ([https://github.com/cpm-cmake/CPM.cmake](https://github.com/cpm-cmake/CPM.cmake))
    that acts as a wrapper around CMake’s `FetchContent` command. It offers a much
    more succinct way to define dependencies (their location, name, and version).
    For example, using Catch2 looks like the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There’s also the matter of continuous delivery and continuous integration to
    automate builds on every change to catch issues early. A deep dive into this is
    beyond the scope of this book, but to see a simple example of using GitHub Actions
    to build, test, and package our code, take a look at the `.github/workflows/cmake.yml`
    file from the root of the *Minimal* *CMake* repository.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: There are a lot more resources available to help continue learning CMake. The
    first place to start is CMake's official documentation ([https://cmake.org/cmake/help/latest/](https://cmake.org/cmake/help/latest/)).
    It’s not perfect, but it’s improving all the time and is a key resource to lean
    on when looking for details about specific features or properties. If you get
    stuck and need to ask for help, the CMake Discourse community ([https://discourse.cmake.org/](https://discourse.cmake.org/))
    is a great resource and has lots of CMake experts ready and willing to answer
    your questions (searching through the question archive can turn up lots of useful
    information too). In addition to the CMake Discourse community, you can find more
    help by visiting the C++ Slack Workspace ([https://cpplang.slack.com/](https://cpplang.slack.com/)).
    There’s a dedicated CMake channel there and lots of friendly, helpful people with
    vast amounts of CMake knowledge to dispense.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another resource you might also find helpful is *Mastering CMake*, a book originally
    written by Ken Martin and Bill Hoffman now freely available online at [https://cmake.org/cmake/help/book/mastering-cmake/](https://cmake.org/cmake/help/book/mastering-cmake/).
    It’s a little dated, but there’s a lot of valuable information there. Speaking
    of books, *Professional CMake: A Practical Guide* ([https://crascit.com/professional-cmake/](https://crascit.com/professional-cmake/))
    by Craig Scott is an incredibly detailed reference on CMake that covers just about
    everything you’d ever need to know about it.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you’ve enjoyed this book and would like to learn more about CMake, there
    are several more books about CMake from Packt worth checking out, including *Modern
    CMake for C++: Discover a better approach to building, testing, and packaging
    your software*, *CMake Best Practices: Upgrade your C++ builds with CMake for
    maximum efficiency and scalability*, and *CMake Cookbook: Building, testing, and
    packaging modular software with* *modern CMake*.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, to see more real-life examples, there are some helpful GitHub repositories
    out there with recommendations and proven approaches to setting up CMake-based
    projects. This includes `cmake_template` from `cppbestpractices` (see [https://github.com/cpp-best-practices/cmake_template](https://github.com/cpp-best-practices/cmake_template))
    and [https://github.com/pr0g/cmake-examples](https://github.com/pr0g/cmake-examples)
    from the author of this book (where this whole endeavor started). There’s also
    an extensive collection of links and resources to repositories, books, and articles
    listed on the `awesome-cmake` GitHub repository ([https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake)).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We’re (finally) done. This brings us to the end of the book and our transformation
    from CMake novice to confident CMake practitioner is complete.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this chapter, we spent some time getting more familiar with the CMake Tools
    extension for Visual Studio Code and understanding how it can make working with
    CMake easier and more enjoyable. From debugging our CMake scripts to integrating
    seamlessly with CMake presets, CMake Tools is an essential addition when working
    with CMake in Visual Studio Code. We then touched on a few more extensions to
    provide enhancements for syntax highlighting and automatic formatting, improving
    our overall editing experience. We then turned our attention to other popular
    editors to understand how to ensure they work with our project from the outset.
    After that, we looked at some recommendations for how to build our C/C++ code
    and the various pros and cons to keep in mind. Next was a discussion of how to
    split our `CMakeLists.txt` file to keep things manageable as our project grows.
    There’s no right or wrong way to do this but knowing some techniques to break
    things down can help keep maintenance in check (especially as a project or team
    grows). Finally, we looked to the future, getting a glimpse of what else CMake
    has to offer and where to go to learn more.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s been a privilege to get to share this knowledge with you, and hopefully,
    there has been something of value you’ve taken away from it. The aim has always
    been to get to the point where you know enough CMake so you can get things done,
    and then get on with building your app/library/tool and focus on what matters
    most to you. CMake, while by no means perfect, is the predominant build tool in
    the C and C++ ecosystem, so being proficient with it is a valuable skill and will
    unlock access to other frameworks and libraries to make creating your own software
    simpler.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Thank you for reading and happy building!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
