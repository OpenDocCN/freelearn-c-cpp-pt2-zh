- en: Testing Dashboards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying tests to the CDash dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting test coverage to the CDash dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the AddressSanitizer and reporting memory defects to CDash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ThreadSanitizer and reporting data races to CDash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CDash is a web service used to aggregate the test results reported by CTest
    during a test run or nightly testing, or in a continuous integration setting.
    Reporting to the dashboard is what we refer to as **CDash time**, as illustrated
    by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa7c19ee-f725-4708-b9bc-e12a2f761021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we will demonstrate recipes to report test results to a CDash
    dashboard. We will discuss strategies for reporting test coverage, as well as
    memory defects and data races collected with tools such as the AddressSanitizer
    and the ThreadSanitizer, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to report to CDash: either through the test target of a
    build or by using a CTest script. We will demonstrate the test target route in
    the first two recipes and will use the CTest script route in the last two recipes.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a CDash dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation of CDash requires a web server (Apache, NGINX, or IIS) with
    PHP and SSL enabled, and access to a MySQL or PostgreSQL database server. It is
    outside of the scope of this book to discuss the setup of a CDash web service
    in detail; we refer the reader to its official documentation, at [https://public.kitware.com/Wiki/CDash:Installation](https://public.kitware.com/Wiki/CDash:Installation).
  prefs: []
  type: TYPE_NORMAL
- en: Installing a CDash instance is not a requirement for producing the recipes in
    this chapter since Kitware offers two public dashboards ([https://my.cdash.org](https://my.cdash.org)
    and [https://open.cdash.org](https://open.cdash.org)). We will reference the former
    in the recipes.
  prefs: []
  type: TYPE_NORMAL
- en: For readers that decide to install their own CDash instance, we recommend using
    a MySQL backend, since this seems to be the configuration used by [https://my.cdash.org](https://my.cdash.org)
    and [https://open.cdash.org](https://open.cdash.org), and also seems to be better
    tested by the community.
  prefs: []
  type: TYPE_NORMAL
- en: Docker can also be used to provision a CDash instance without too much effort.
    A request for an official image is currently open on the CDash issue tracker,
    at [https://github.com/Kitware/CDash/issues/562](https://github.com/Kitware/CDash/issues/562).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying tests to the CDash dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-01),
    and includes a C++ example. The Recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will extend the test example of Recipe 1, *Creating a simple
    unit test,* from [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests,* and deploy the test result to [https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook),
    which we created for this book on the public dashboard ([https://my.cdash.org](https://my.cdash.org))
    provided to the community by Kitware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by reusing the example source code from Recipe 1, *Creating a
    simple unit test,* in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml),
    *Creating and Running Tests*, which sums integers given as command-line arguments.
    The example consists of three source files: `main.cpp`, `sum_integers.cpp`, and `sum_integers.hpp`.
    These sources are unchanged. We will also reuse the file `test.cpp` from [Chapter
    4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running Tests,*
    but will rename it to `test_short.cpp`. We will extend the example with `test_long.cpp`,
    containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then organize these files into the following file tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now describe how to configure, build, test, and finally, submit the
    test results for our example project to the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source targets are defined in `src/CMakeLists.txt`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests are defined in `tests/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-level `CMakeLists.txt` file references the two preceding files, and
    the new element in this recipe is the line containing `include(CTest)`, which
    allows us to report to a CDash dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we create the file `CTestConfig.cmake` in the same directory as
    the top-level `CMakeLists.txt` file. This new file contains the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to configure and build the project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Having built the code, we can run the test set and report the test results
    to the dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can browse the test results in our browser (in this case, the test
    results are reported to [https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook)))[:](https://my.cdash.org/index.php?project=cmake-cookbook))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c8d388dc-34e6-4a5f-8fa7-346970897f2f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A high-level overview of the workflow shows that CTest runs the tests and records
    results locally in XML files. These XML files are then sent to the CDash server,
    where they can be browsed and analyzed. We can obtain more details about the passed
    or failed tests (in this example, there are no failed tests) by clicking on the
    2 under Pass, as shown in the preceding screenshot. The details, as shown in the
    following screenshot, record information about the machine that ran the tests,
    as well as timing information. Again, the test output for individual tests can
    be browsed online.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cb76099-2d97-4568-94d3-385789b08490.png)'
  prefs: []
  type: TYPE_IMG
- en: 'CTest supports three different running submission modes: Experimental, Nightly,
    and Continuous. We have used `ctest --dashboard Experimental`, and thus, the test
    results appear under Experimental. The Experimental mode is useful for testing
    the current state of the code, for debugging a new dashboard script (see Recipes
    3 and 4 in this chapter), or for debugging a CDash server or project. The Nightly
    mode will update (or down-date) the code to the repository snapshot closest to
    the latest nightly start time, which can be set in `CTestConfig.cmake`; it gives
    all nightly tests in a project that receives frequent updates a well-defined reference
    point. For instance, the nightly start time can be set to midnight, Coordinated
    Universal Time, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Continuous mode is useful for a continuous integration workflow and will
    update the code to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and submitting to the Experimental dashboard can be done
    with just one command - the `cmake --build . --target Experimental` command.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we deployed to CDash directly from the test target. It is possible
    to use a dedicated CTest script instead, and we will demonstrate this approach
    later in this chapter, in the upcoming Recipes 3 and 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'CDash allows you to monitor not only whether tests are passing or failing,
    but also the test timing. You can configure margins for test timing: if a test
    takes more time than allotted, it will be marked as failing. This is useful for
    benchmark tests, to automatically detect performance degradation in test timing
    when refactoring code.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the official CDash documentation for a detailed discussion of CDash definitions
    and configuration settings, at [https://public.kitware.com/Wiki/CDash:Documentation](https://public.kitware.com/Wiki/CDash:Documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Reporting test coverage to the CDash dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-02),
    and it includes a C++ example. The recipe is valid with CMake version 3.5 (and
    higher) and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will measure the test coverage and report it to the CDash
    dashboard, where we will be able to browse the test coverage analysis line-by-line,
    in order to identify untested or unused code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will extend the source code of the previous recipe with a minor change in `src/sum_integers.cpp`,
    where we will add a function - `sum_integers_unused`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to detect this unused code with a test coverage analysis, by using
    gcov ([https://gcc.gnu.org/onlinedocs/gcc/Gcov.html](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html)).
    Apart from the preceding modification, we will use the unmodified sources of the
    previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Through the following steps, we will enable coverage analysis and upload the
    results to the dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: The top-level `CMakeLists.txt` and `tests/CMakeLists.txt` files are unchanged
    from the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will extend `src/CMakeLists.txt`, with an option to add compile flags for
    code coverage. This option is enabled by default, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then configure, build, and deploy to CDash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an output similar to the previous recipe, but in addition,
    the last step will perform a test coverage analysis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can verify the test results in our browser (in this case, the test
    results are reported to [https://my.cdash.org/index.php?project=cmake-cookbook](https://my.cdash.org/index.php?project=cmake-cookbook))[)](https://my.cdash.org/index.php?project=cmake-cookbook))[:](https://my.cdash.org/index.php?project=cmake-cookbook))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e22437a3-f9f6-443d-bd7f-491693d1e7bd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test coverage analysis is summarized with a percentage of 66.67%. To get
    further insights, we can click on the percentage and obtain a coverage analysis
    for the two subdirectories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e4cef79-019f-463a-8842-d147e4218bdb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By browsing the subdirectory links, we can inspect the test coverage percentage
    for individual files, and can even browse a line-by-line summary (for example, `src/sum_integers.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09b351b7-fae6-49fb-b13d-919aaa31175f.png)'
  prefs: []
  type: TYPE_IMG
- en: The green lines have been traversed when running the test suite, whereas the
    red lines have not. Through this, we can not only identify unused/untested code
    (with the function `sum_integers_unused`) but can also see how often each line
    has been traversed. For instance, the code line `sum += i` has been visited 1,005
    times (5 times during `test_short`, and 1,000 times during `test_long`). Test
    coverage analysis is an indispensable companion to automated testing, and CDash
    provides us with an interface to browse and analyze the results graphically in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further reading, we recommend the following blog post, which discusses
    additional coverage features in CDash: [https://blog.kitware.com/additional-coverage-features-in-cdash/](https://blog.kitware.com/additional-coverage-features-in-cdash/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the AddressSanitizer and reporting memory defects to CDash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03),
    and includes a C++ and a Fortran example. The recipe is valid with CMake version
    3.5 (and higher), and has been tested on GNU/Linux and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: AddressSanitizer (ASan) is a memory error detector for C++, C, and Fortran.
    It can find memory defects, such as use after free, use after return, use after
    scope, buffer overflows, initialization order bugs, and memory leaks (see [https://github.com/google/sanitizers/wiki/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)). AddressSanitizer
    is a part of LLVM, starting with version 3.1, and is a part of GCC, starting with
    version 4.8\. In this recipe, we will fabricate two bugs in our code, which may
    go undetected in a normal test run. To detect these bugs, we will couple CTest
    with dynamic analysis by using AddressSanitizer, and will report the defects to
    CDash.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will use two source files and two tests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The file `buggy.cpp` contains two buggy functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions are exposed in the corresponding header file (`buggy.hpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The test source, `leaky.cpp`, verifies the return code from `function_leaky`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Correspondingly, `use_after_free.cpp` checks the return value of `function_use_after_free`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to compile our code with particular flags to take advantage of ASan.
    Then, we will run tests and submit them to the dashboard. Let us take a look at
    how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The buggy library is defined in `src/CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To the file `src/CMakeLists.txt`, we will add an option and code to sanitize
    using ASan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The two tests are defined in `tests/CMakeLists.txt` compactly, using a `foreach`
    loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The top-level `CMakeLists.txt` is essentially unchanged with respect to the
    previous recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `CTestConfig.cmake` file is unchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we will report to CDash using a CTest script; for this, we
    will create a file, `dashboard.cmake` (in the same directory as the main `CMakeLists.txt`
    and `CTestConfig.cmake`), containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute the `dashboard.cmake` script directly. Note how we pass the
    generator to use with the `CTEST_CMAKE_GENERATOR` option, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will appear on the CDash site, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1e9c27b-1250-42b4-ad1a-1e9afa699d37.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we successfully reported memory bugs to the Dynamic Analysis
    section of the dashboard. We can gain further insights by browsing the defects
    (under Defect Count):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efcbb7fd-4cb6-4843-9b32-6904c5d15419.png)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on the individual links, it is possible to browse the full output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it is also possible to generate the AddressSanitizer report locally.
    In this example, we need to set `ENABLE_ASAN`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `leaky` test executable directly produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Correspondingly, we can obtain detailed output by running the `use_after_free`
    executable directly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we test without the AddressSanitizer (`ENABLE_ASAN` is `OFF` by default),
    no error is reported in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, `leaky` will just waste memory, whereas `use_after_free` may result
    in non-deterministic failures. One way to debug these failures is to use valgrind
    ([http://valgrind.org](http://valgrind.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast to the previous two recipes, we have used a CTest script to configure,
    build, and test the code, and to submit the report to the dashboard. To understand
    how this recipe works, take a closer look at the `dashboard.cmake` script. First,
    we define the project name and set the host reporting and the build name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the `CTEST_BUILD_NAME` evaluates to `Linux-x86_64`. In your case,
    you may observe a different result, depending on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we specify paths for the source and build directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We could set the generator to `Unix Makefiles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for a more portable test script, we prefer to provide the generator
    *via* the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code snippet in `dashboard.cmake` figures out the number of available
    cores on the machine and sets the parallel level of the test step to the number
    of available cores, in order to minimize the total test time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we start the testing step and configure the code, with `ENABLE_ASAN`
    set to `ON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining commands in `dashboard.cmake` map to the build, test, memcheck,
    and submit steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The attentive reader will have noticed that we did not search for the AddressSanitizer
    on our system prior to linking our target against it. A real-world, complete use
    case would have done that, to avoid unpleasant surprises during the linking stage.
    We will remind the reader that we showed a method to probe for the availability
    of sanitizers in Recipe 7, *Probing compiler flags,* in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml),
    *Configure-time and Build-time Operations*.
  prefs: []
  type: TYPE_NORMAL
- en: For more AddressSanitizer documentation and examples, see [https://github.com/google/sanitizers/wiki/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer).
    AddressSanitizer is not limited to C and C++. For a Fortran example, we refer
    the reader to the code repository at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03/fortran-example](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-03/fortran-example).
  prefs: []
  type: TYPE_NORMAL
- en: CMake utilities to discover sanitizers and adjust compiler flags are available
    at [https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following blog post discusses examples of how to add support for dynamic
    analysis tools, and it inspired the present recipe: [https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/](https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/).
  prefs: []
  type: TYPE_NORMAL
- en: Using the ThreadSanitizer and reporting data races to CDash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-14/recipe-04),
    and includes a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will reuse the approach from the previous example, but use
    ThreadSanitizer, or TSan, in combination with CTest and CDash, to identify data
    races and report these to a CDash dashboard. The documentation for ThreadSanitizer
    can be found online, at [https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual](https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will work with the following example code (`example.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example code, we start 16 threads, and each of these threads calls
    the `increase` function. The `increase` function sleeps for one second, then prints
    and increments an integer, `s`. We anticipate that this example code will manifest
    data races, because all threads read and modify the same address, without any
    explicit synchronization or coordination. In other words, we expect that the final
    `s`, which is printed at the end of the code, may differ from run to run. The
    code is buggy, and we will try to identify the data race with the help of ThreadSanitizer.
    Without running ThreadSanitizer, we may not see any problems with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us go through the necessary steps in detail, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The file `CMakeLists.txt` starts by defining a minimum supported version, project
    name, supported languages, and, in this case, a requirement of the C++11 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we locate the Threads library, define the executable, and link it against
    the Threads library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we offer the option and code to compile and link with support for the
    ThreadSanitizer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as a test, we execute the compiled example itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The file `CTestConfig.cmake` is unchanged with respect to the previous recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding `dashboard.cmake` script is a simple adaptation to TSan from
    the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us take this example for a spin. Once again, we will set the generator
    passing the `CTEST_CMAKE_GENERATOR` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'On the dashboard, we will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2fcd3c00-6d80-44c6-b1a5-2b41ba53258d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the dynamic analysis in more detail as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e8eaa44b-4031-4992-979b-24e772d3b04b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core ingredients for this recipe are in the following section of `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The ingredients are also in the updated steps in `dashboard.cmake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous recipe, we can also inspect the output from ThreadSanitizer
    locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be a natural step to apply TSan on an OpenMP code, but please note
    that OpenMP is known to generate false positives under TSan, in some cases. For
    the Clang compilers, a workaround would be to recompile the compiler itself, and
    its `libomp`, with `-DLIBOMP_TSAN_SUPPORT=TRUE`. In general, using sanitizers
    in a sensible way may require a recompilation of the entire tool-stack, in order
    to avoid false positives. This will probably be the case for a C++ project using
    pybind11; we would need to recompile Python with the sanitizers enabled to get
    anything meaningful. Alternatively, the Python binding can be left out from the
    sanitizing by using sanitizer suppression, as explained at [https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions](https://github.com/google/sanitizers/wiki/ThreadSanitizerSuppressions).
    This may not be possible if, for example, a shared library is called by both by
    a sanitized binary and a Python plugin.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following blog post discusses examples of how to add support for dynamic
    analysis tools, and it inspired the present recipe: [https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/](https://blog.kitware.com/ctest-cdash-add-support-for-new-dynamic-analysis-tools/).'
  prefs: []
  type: TYPE_NORMAL
