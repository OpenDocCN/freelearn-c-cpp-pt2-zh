- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Software for Apple Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of software development, building applications for Apple platforms—macOS,
    iOS, watchOS, and tvOS—comes with its unique set of requirements and best practices.
    Because of the closed ecosystem, Apple platforms have some unique build characteristics,
    especially for applications with a graphical user interface and more complex library
    frameworks. For those cases, Apple uses specific formats called app bundles and
    frameworks. This chapter delves into the intricacies of using CMake, a powerful
    cross-platform build system, to target Apple’s ecosystem effectively. Whether
    you are a seasoned developer looking to streamline your workflow or a newcomer
    eager to explore Apple-specific development, this chapter will equip you with
    the knowledge and tools to master the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using XCode as a CMake generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an application bundle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Apple library framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing software to use it in the Apple store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the previous chapters, the examples are tested with CMake 3.24 on macOS
    Sonoma 14.2 and run on either of the following compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: Apple Clang 15 or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode 15.4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the examples require you to have set up code signing for Xcode, which
    requires an Apple ID that is enrolled in the developer program.
  prefs: []
  type: TYPE_NORMAL
- en: All examples and source code are available in the GitHub repository of this
    book at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: If any of the software is missing, the corresponding examples will be excluded
    from the build.
  prefs: []
  type: TYPE_NORMAL
- en: Developing on Apple with CMake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing on macOS, it’s important to understand Apple’s ecosystem and
    development expectations. Apple strongly encourages developers to use Xcode as
    their primary development environment, and CMake can generate build instructions
    for it. Xcode is a comprehensive suite of tools that includes a code editor, debugger,
    and other utilities designed specifically for macOS and iOS development. Apple
    frequently updates Xcode to include the latest features, bug fixes, and performance
    improvements. Therefore, developers are expected to upgrade to the latest version
    of Xcode regularly to ensure compatibility and take advantage of new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command generates build instructions for Xcode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, CMake will generate an Xcode project file
    with the `.xcodeproj` extension in the build directory. This project can be opened
    directly in Xcode, or the project can be built through CMake by calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the project is updated by CMake, Xcode will detect changes and reload the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: While Xcode is the preferred IDE, it is not the only option available. **Visual
    Studio Code** (**VS Code**), for instance, is a popular alternative that many
    developers use for its versatility and extensive extensions ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: While Xcode is the recommended generator for macOS, other generators such as
    Ninja or Makefiles are also available. While they lack some specifics of the Apple
    integration, they are lightweight and can also be used to build simple applications
    and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The Xcode generator in CMake creates project files that can be opened and managed
    directly in Xcode. This ensures that the build process leverages Xcode’s capabilities,
    such as optimized build settings, resource management, and seamless integration
    with macOS features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Xcode supports a large variety of build settings, which can be configured through
    CMake by using the `XCODE_ATTRIBUTE_<SETTING>` property. To obtain a list of all
    possible settings, either consult the developer documentation from Apple or run
    the following build directory call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Xcode attributes can either be set globally or per target, as the following
    example illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As the example shows, Xcode attributes can also be set only for a particular
    build variant with the `[variant=ConfigName]` postfix, where the configurations
    are the usual CMake build variants such as `Debug` and `Release`. If a project
    is built with another generator than Xcode, the attributes have no effect. To
    create simple applications, choosing the Xcode generator and setting the appropriate
    attributes is sufficient. However, to build and distribute more complex software
    for Apple, there is no way around looking into application bundles and Apple frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Apple application bundles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An Apple application bundle is a directory structure used on macOS and iOS
    to package and organize all files required by an application. This includes the
    executable binary, resources such as images and sounds, metadata such as the app’s
    `Info.plist` file, and more. Application bundles make it easy to distribute and
    manage applications because they encapsulate all necessary components in a single
    directory that the user can move, copy, or delete as a unit. Application bundles
    appear as single files in the Finder, but they are directories with a specific
    structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notably, this structure is flattened for iOS, tvOs, and watchOS targets, which
    is handled by CMake itself. To mark an executable as a bundle, the `MACOSX_BUNDLE`
    keyword is added to the target like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the keyword tells CMake to create the directory structure for the app
    bundle and to generate an `Info.plist` file. The `Info.plist` file is a critical
    file for the app bundle as it contains essential configuration for the package.
    CMake will generate a default `Info.plist` file, which works well in a lot of
    cases. However, you can use a custom `Info.plist` template by specifying the path
    to the template file using the `MACOSX_BUNDLE_INFO_PLIST` property on a target
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The template file uses the same syntax as `configure_file` as described in
    [*Chapter 8*](B30947_08.xhtml#_idTextAnchor132), *Executing Custom Tasks with
    CMake*. Some of the identifiers are set automatically from CMake. Here’s an example
    of a custom `Info.plist.in` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this, a basic app bundle can be defined and built. While this works best
    with the Xcode generator, creating the file structure and the `Info.plist` file
    also works with other generators such as Ninja or Makefiles. However, if an application
    contains interface builder files or storyboards, Xcode is the only way to go.
    Let’s have a look at how resource files are included.
  prefs: []
  type: TYPE_NORMAL
- en: Resource files for Apple application bundles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apple comes with its own SDK for building applications, which supports storyboard
    or interface builder files to define user interfaces. To create bundles, these
    files are compiled into an Apple-specific resource format and placed in the appropriate
    location in the bundle. Only the Xcode generator supports the automatic handling
    of these files, so at that point, there is little use in sticking to any other
    generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Storyboard and interface builder sources must be included as sources in the
    `add_executable()` or `target_sources()` commands. To ensure they are automatically
    compiled and copied to the correct location within the bundle, these sources should
    have the `MACOSX_PACKAGE_LOCATION` file property set. To avoid having to retype
    all the filenames, putting them into a variable can be handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With that, you should be set up to create Apple application bundles to create
    executables. If you want to build complex libraries for Apple that are easily
    redistributable, the way to go is to use frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Apple frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: macOS frameworks are collections of reusable classes, functions, and resources
    designed to simplify the development of macOS applications. They provide a structured
    way to access system functionality and integrate seamlessly with macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linking against frameworks is very similar to linking normal libraries. First,
    they are located with `find_package` or `find_library` and then used with `target_link_libraries`,
    with a slightly different syntax. The following example links the `Cocoa` framework
    to the `ch11_hello_world_apple` target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Not that the `–framework` keyword is necessary and that the name should be quoted.
    If multiple frameworks are linked, all of them need to be quoted individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can use frameworks, let’s look into creating our own. Frameworks
    are quite similar to app bundles, with a few differences. Notably, it is possible
    to install multiple versions of the same framework on macOS. In addition to the
    resources, frameworks also contain the header and libraries needed to use it.
    Let’s have a look at the file structure of a framework to understand how frameworks
    allow for multiple versions and to populate the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The top level of the framework must end with `.framework`, and typically, all
    the top-level files except the `Versions` folder are symlinks pointing to folders
    or files in the `Versions` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `Versions` folder contains the different versions of the libraries. The
    names of the directories can be arbitrary, but usually, they are either named
    `A`, `B`, `C`, and so on or use numeric versions.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the convention used, a symlink called `Current` needs to be there
    and is expected to point to the latest version. Each version must have a `Resources`
    subfolder that contains the `Info.plist` file as described in the section about
    application bundles.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake supports the creation of macOS frameworks out of the box by setting the
    `FRAMEWORK` and `FRAMEWORK_VERSION` properties of a target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As frameworks often contain header files, they can be specified with the `PUBLIC_HEADER`
    and `PRIVATE_HEADER` properties so that they are copied to the correct places.
    Custom `Info.plist` files for frameworks can be set using the `MACOSX_FRAMEWORK_INFO_PLIST`
    property. If no custom `Info.plist` file is provided, CMake will generate a default
    one, which in most cases is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we covered the basics of building software for macOS, but one thing
    that is missing is signing the code for releasing it on Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Code signing for macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a lot of use cases, creating unsigned apps or frameworks might be enough;
    however, if applications are to be distributed through the official channels for
    macOS, signing is a must. Signing works through Xcode itself; however, it is also
    possible to use CMake for signing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign, there are three pieces of information needed: the *ID of the bundle
    or framework*, the *development team ID*, and the *code signing entity*. Values
    can be set with the `XCODE_ATTRIBUTE_DEVELOPMENT_TEAM` and `XCODE_ATTRIBUTE_CODE_SIGN_ENTITY`
    Xcode attributes. Typically, these are set on a project level and not for individual
    targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The signing identity denotes the certificate provider and can usually be left
    as `"Apple Development"`, which causes Xcode to select the appropriate signing
    identity. Before Xcode version 11, the signing identity had to be set to `"Mac
    Developer"` for macOS or `"iPhone Developer"` for iOS, tvOS, or watchOS applications.
    The team ID is a 10-digit code that is assigned to the Apple developer account,
    which can be created on Apple’s developer portal ([https://developer.apple.com](https://developer.apple.com)).
    Certificates for signing can be downloaded through Xcode.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Apple ecosystem is somewhat special in handling because of its closed design
    in comparison to Linux or even Windows, but especially in the mobile market, there
    is often no way around building for Apple if one does not want to leave a significant
    market out. With the information in this chapter, such as creating app bundles
    and frameworks and signing your software, you should be set up to start deploying
    to Apple. While building for Apple needs you to use Xcode and possibly even means
    that you need to own Apple hardware, this is not the case for all other platforms.
    CMake excels at being platform-independent and at building software across different
    platforms, which is what we will be looking at in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which is the best-suited generator for building software for Apple?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are Xcode attributes set?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between application bundles and frameworks regarding
    different versions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is needed to sign an application bundle or framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While different generators work for Apple, it is recommended to use Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By setting either the `CMAKE_XCODE_ATTRIBUTE_<ATTRIBUTE>` variable or the `XCODE_ATTRIBUTE_<ATTRIBUTE>`
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only one version of an application bundle can be installed at one time, while
    there can be multiple versions of frameworks installed at the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To sign software for Apple, you need an Apple ID that is enrolled in the developer
    program and Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
