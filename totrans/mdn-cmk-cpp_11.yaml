- en: '*Chapter 11*: Installing and Packaging'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our project has been built, tested, and documented. Now, it''s finally time
    to release it to our users. This chapter is mainly about the two last steps we''ll
    need to take to do that: installation and packaging. These are advanced techniques
    that build on top of everything we''ve learned so far: managing targets and their
    dependencies, transient usage requirements, generator expressions, and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: Installation allows our project to be discoverable and accessible system-wide.
    In this chapter, we will cover how to export targets so that another project can
    use them without installation, as well as how to install our projects so that
    they can easily be used by any program on the system. In particular, we'll learn
    how to configure our project so that it can automatically put different artifact
    types in the correct directory. To handle more advanced scenarios, we'll introduce
    low-level commands for installing files and directories, as well as for executing
    custom scripts and CMake commands.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll learn how to set up reusable CMake packages so that they can be
    discovered by calling `find_package()` from other projects. Specifically, we'll
    explain how to make sure that targets and their definitions are not fixed to a
    specific location on the filesystem. We'll also discuss how to write basic and
    advanced config files, along with the *version files* associated with packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to make things modular, we''ll briefly introduce the concept of components,
    both in terms of CMake packages and the `install()` command. All this preparation
    will pave the way for the final aspect we''ll be covering in this chapter: using
    CPack to generate archives, installers, bundles, and packages that are recognized
    by all kinds of package managers in different operating systems. These can be
    used to carry pre-built artifacts, executables, and libraries. It''s the easiest
    way for end users to start using our software.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting without installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing projects on the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging with CPack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter11](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: 'To build examples provided in this book always use recommended commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting without installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we make the targets of project `A` available to the consuming project
    `B`? Usually, we'd reach for the `find_package()` command, but that would mean
    that we'd need to create a package and install it on the system. That approach
    is useful, but it takes some work. Sometimes, we just need a really quick way
    to build a project and make its targets available for other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could save some time by including the main listfile of `A`: it contains
    all the target definitions already. Unfortunately, it also potentially contains
    a lot of other things: global configuration, requirements, CMake commands with
    side effects, additional dependencies, and perhaps targets that we don''t want
    in `B` (such as unit tests). So, let''s not do that. It''s better to achieve this
    by providing `B`, can include with the `include()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Doing this will provide definitions (commands such as `add_library()` and `add_executable()`)
    for all the targets of `A` with the correct properties set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we''re not going to write such a file manually â€“ that wouldn''t
    be a very DRY approach. CMake can generate these files for us with the `export()`
    command, which has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We must supply all the targets that we''d like to export after the `TARGET`
    keyword and provide the destination filename after `FILE`. The other arguments
    are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAMESPACE` is recommended as a hint, stating that the target has been imported
    from other projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`APPEND` tells CMake that it shouldn''t erase the contents of the file before
    writing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPORT_LINK_INTERFACE_LIBRARIES` will export target link dependencies (including
    imported and config-specific variants).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see this in action with our example Calc library, which provides two
    simple methods:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/01-export/src/include/calc/calc.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare its target like so:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/01-export/src/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we ask CMake to generate the export file with the `export(TARGETS)` command:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/01-export/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that the `EXPORT_DIR` variable has been set
    to the `cmake` subdirectory of the build tree (as per the convention for `.cmake`
    files). Then, we export the target declaration file, `CalcTargets.cmake`, with
    a single target `calc` that's visible as `Calc::calc` for projects that will include
    this file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this export file is not a package yet. And, more importantly, all
    the paths in this file are absolute and hardcoded to the build tree. In other
    words, they're non-relocatable (we'll discuss this in the *Understanding the issues
    with relocatable targets* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `export()` command also has a shorter version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it requires a `<export>` name rather than a list of exported targets.
    Such `<export>` instances are named lists of targets that are defined by `install(TARGETS)`
    (we''ll cover this command in the *Installing logical targets* section). Here''s
    a tiny example demonstrating how this shorthand is used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/01-export/CMakeLists.txt (continued)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code works exactly like the previous one, but now, a single target
    list between the `export()` and `install()` commands is being shared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both ways of generating export files will produce the same results. They will
    contain some boilerplate code and a few lines defining the target. With `/tmp/b`
    set to the build tree path, they''ll look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: /tmp/b/cmake/CalcTargets.cmake (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Normally, we wouldn't edit this file or even open it, but I wanted to highlight
    the hardcoded paths in this generated file. In its current form, the package is
    not relocatable. If we want to change that, we'll need to jump through some hoops
    first. We'll explore why that's important in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing projects on the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014), *First Steps
    with CMake*, we indicated that CMake offers a command-line mode that installs
    built projects on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`<dir>` is the path to the generated build tree (required). Our `<options>`
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--config <cfg>`: This picks the build configuration for a multi-configuration
    generator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--component <comp>`: This limits the installation to the given component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--default-directory-permissions <permissions>`: This sets the default permissions
    for the installed directories (in `<u=rwx,g=rx,o=rx>` format).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--prefix <prefix>`: This specifies the non-default installation path (stored
    in the `CMAKE_INSTALL_PREFIX` variable). It defaults to `/usr/local` for Unix-like
    systems and `c:/Program Files/${PROJECT_NAME}` for Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v, --verbose`: This makes the output verbose (this can also be achieved by
    setting the `VERBOSE` environment variable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installations can consist of many steps, but at their core, they copy the generated
    artifacts and the necessary dependencies to a directory somewhere on the system.
    Using CMake for installation not only introduces a convenient standard to all
    CMake projects but also does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides a platform-specific installation path for artifacts, depending on their
    types (by following *GNU Coding Standards*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhances the installation process by generating target export files, which allow
    project targets to be directly reused by other projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates discoverable packages through config files, which wrap the target export
    files and package-specific CMake macros and functions defined by the author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features are quite powerful as they save a lot of time and simplify the
    usage of projects that are prepared this way. The first step in performing a basic
    installation is copying the built artifacts to their destination directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the `install()` command and its various modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`install(TARGETS)`: This installs output artifacts such as libraries and executables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(FILES|PROGRAMS)`: This installs individual files and sets their permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(DIRECTORY)`: This installs whole directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(SCRIPT|CODE)`: This runs a CMake script or a snippet during installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install(EXPORT)`: This generates and installs a target export file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding these commands to your listfile will generate a `cmake_install.cmake`
    file in your build tree. While it's possible to invoke this script manually with
    `cmake -P`, it isn't recommended. This file is meant to be used by CMake internally
    when `cmake --install` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Upcoming CMake versions will also support installing runtime artifacts and dependency
    sets, so be sure to check the latest documentation to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every `install()` mode has an extensive set of options. A few of them are shared
    and work the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DESTINATION`: This specifies the installation path. Relative paths will be
    prepended with `CMAKE_INSTALL_PREFIX`, while absolute paths are used verbatim
    (and not supported by `cpack`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PERMISSIONS`: This sets file permissions on platforms that support them. The
    available values are `OWNER_READ`, `OWNER_WRITE`, `OWNER_EXECUTE`, `GROUP_READ`,
    `GROUP_WRITE`, `GROUP_EXECUTE`, `WORLD_READ`, `WORLD_WRITE`, `WORLD_EXECUTE`,
    `SETUID`, and `SETGID`. The default permissions for directories that are created
    during installation time can be set by specifying the `CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIGURATIONS`: This specifies a list of configurations (`Debug`, `Release`).
    Any of the options in this command that follow this keyword will only be applied
    if the current build config is in this list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONAL`: This disables raising errors when the installed files don''t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two shared options are also used in component-specific installations: `COMPONENT`
    and `EXCLUDE_FROM_ALL`. We''ll discuss these in detail in the *Defining components*
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the first installation mode: `install(TARGETS)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing logical targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Targets defined by `add_library()` and `add_executable()` can easily be installed
    with the `install(TARGETS)` command. This means copying the artifacts that have
    been produced by the buildsystem to the appropriate destination directories and
    setting suitable file permissions for them. The general signature for this mode
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After the initial mode specifier â€“ that is, `TARGETS` â€“ we must provide a list
    of targets we'd like to install. Here, we may optionally assign them to a `EXPORT`
    option, which can be used in `export(EXPORT)` and `install(EXPORT)` to produce
    a target export file. Then, we must configure the installation of output artifacts
    (grouped by type). Optionally, we can provide a list of directories that will
    be added to the target export file for each target in its `INTERFACE_INCLUDE_DIRECTORIES`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '`[<output-artifact-configuration>...]` provides a list of configuration blocks.
    The full syntax of a single block is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Every output artifact block has to start with `<TYPE>` (this is the only required
    element). CMake recognizes several of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARCHIVE`: Static libraries (`.a`) and DLL import libraries for Windows-based
    systems (`.lib`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIBRARY`: Shared libraries (`.so`), but not DLLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUNTIME`: Executables and DLLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBJECTS`: *Object files* from `OBJECT` libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FRAMEWORK`: Static and shared libraries that have the `FRAMEWORK` property
    set (this excludes them from `ARCHIVE` and `LIBRARY`). This is macOS-specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUNDLE`: Executables marked with `MACOSX_BUNDLE` (also not part of `RUNTIME`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUBLIC_HEADER`, `PRIVATE_HEADER`, `RESOURCE`: Files specified in the target
    properties with the same name (on Apple platforms, they should be set on the `FRAMEWORK`
    or `BUNDLE` targets).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The CMake documentation claims that if you only configure one artifact type
    (for example, `LIBRARY`), only this type will be installed. For CMake version
    3.20.0, this is not true: all the artifacts will be installed as if they were
    configured with the default options. This can be solved by specifying `<TYPE>
    EXCLUDE_FROM_ALL` for all unwanted artifact types.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A single `install(TARGETS)` command can have multiple artifact configuration
    blocks. However, be aware that you may only specify one of each type per call.
    That is, if you'd like to configure different destinations of `ARCHIVE` artifacts
    for the `Debug` and `Release` configurations, then you must make two separate
    `install(TARGETS ... ARCHIVE)` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also omit the type name and specify options for all the artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Installation would be then performed for every file that's produced by these
    targets, regardless of their type.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you don't always need to provide an installation directory with `DESTINATION`.
    Let's see why.
  prefs: []
  type: TYPE_NORMAL
- en: Working out the correct destination for different platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The formula for a destination path is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If `DESTINATION` isn''t provided, CMake will use a built-in default for every
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_11.1_B17205.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While default paths are sometimes useful, they aren't correct for every situation.
    For example, by default, CMake will "guess" that `DESTINATION` for libraries should
    be `lib`. The full path for libraries will be computed to `/usr/local/lib` for
    all Unix-like systems, and something like `C:\Program Files (x86)\<project-name>\lib`
    on Windows. This won't be a very good choice for Debian with multi-arch support,
    which requires a path to a specific architecture (for example, `i386-linux-gnu`)
    when `INSTALL_PREFIX` is `/usr`. Figuring out the correct path for every platform
    is a common problem for Unix-like systems. To get it right, we need to follow
    *GNU Coding Standards* (a link to this can be found in the *Further reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: Before going with a "guess," CMake will check if a `CMAKE_INSTALL_<DIR>DIR`
    variable for this artifact type was set and use the path from there. What we need
    is an algorithm that will detect the platform and fill the install directory variables
    with the appropriate paths. CMake simplifies this by providing the `GNUInstallDirs`
    utility module, which handles most platforms by setting the install directory
    variables accordingly. Just `include()` it before calling any `install()` commands
    and you'll be set.
  prefs: []
  type: TYPE_NORMAL
- en: Users that need custom configuration can provide install directory variables
    through the command line with `-DCMAKE_INSTALL_BINDIR=/path/in/the/system`.
  prefs: []
  type: TYPE_NORMAL
- en: However, installing the public headers of libraries can be a little tricky.
    Let's see why.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with public headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `install(TARGETS)` documentation recommends that we specify public headers
    (as a semicolon-separated list) in the `PUBLIC_HEADER` property of the library
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/02-install- targets/src/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we''re using the default "guess" for Unix, files will end up in `/usr/local/include`.
    This isn''t necessarily the best practice. Ideally, we''d like to put these public
    headers in a directory that would indicate their origin and introduce namespacing;
    for example, `/usr/local/include/calc`. This will allow us to use them in all
    the projects on this system, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Most preprocessors recognize directives with angle brackets as a request to
    scan standard system directories. This is where the `GNUInstallDirs` module, which
    we mentioned earlier, comes in. It defines the installation variables for the
    `install()` command, though we can also use them explicitly. In this case, we
    want to prepend the public header''s destination, `calc`, with `CMAKE_INSTALL_INCLUDEDIR`:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/02-install-targets/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After including the listfile from `src`, which defined our `calc` target, we
    must configure the installation of the static library and its public headers.
    We have included the `GNUInstallDirs` module and explicitly specified `DESTINATION`
    for `PUBLIC_HEADERS`. Running `cmake` in install mode will work exactly as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This works well for this basic case, but there''s a slight drawback: files
    specified in this way don''t retain their directory structure. They will all be
    installed in the same destination, even if they''re nested in different base directories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plans for newer versions (CMake 3.23.0) to manage headers better
    with the `FILE_SET` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See the *Further reading* section for a link to the discussion on official forums.
    Until that option is released, we can use this mechanism with the `PRIVATE_HEADER`
    and `RESOURCE` artifact types. But how can we specify a more complex installation
    directory structure?
  prefs: []
  type: TYPE_NORMAL
- en: Low-level installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modern CMake is moving away from the concept of manipulating files directly.
    Ideally, we''d always add them to a logical target and use that as a higher level
    of abstraction to represent all the underlying assets: source files, headers,
    resources, configuration, and so on. The main advantage is the dryness of the
    code: usually, we won''t need to change more than one line to add a file to the
    target.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, adding every installed file to a target isn''t always possible
    or convenient. For such cases, three choices are available: `install(FILES)`,
    `install(PROGRAMS)`, and `install(DIRECTORY)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing file sets with install(FILES|PROGRAMS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `FILES` and `PROGRAMS` modes are very similar. They can be used to install
    public header files, documentation, shell scripts, configuration, and all kinds
    of assets, including images, audio files, and datasets to be used at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the command signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference between `FILES` and `PROGRAMS` is the default file permission
    set on newly copied files. `install(PROGRAMS)` will also set `EXECUTE` for all
    users, while `install(FILES)` will not (both will set `OWNER_WRITE`, `OWNER_READ`,
    `GROUP_READ`, and `WORLD_READ`). You can change this behavior by providing the
    optional `PERMISSIONS` keyword, then picking the leading keyword as an indicator
    of what''s installed: `FILES` or `PROGRAMS`. We''ve already discussed how `PERMISSIONS`,
    `CONFIGURATIONS`, and `OPTIONAL` work. `COMPONENT` and `EXCLUDE_FROM_ALL` will
    be discussed later in the *Defining components* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Right after the initial keyword, we need to list all the files we want to install.
    CMake supports relative and absolute paths, as well as generator expressions.
    Just keep in mind that if your file path starts with a generator expression, it
    must be absolute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next required keyword is `TYPE` or `DESTINATION`. We can explicitly provide
    the `DESTINATION` path or ask CMake to look it up for a specific `TYPE` file.
    Unlike in `install(TARGETS)`, `TYPE` doesn''t claim to selectively install any
    subset of the provided files to be installed. Nevertheless, computing the installation
    path follows the same pattern (the `+` symbol denotes a platform-specific path
    separator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And similarly, every `TYPE` will have built-in guesses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_11.2_B17205.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The behavior here follows the same principle that was described in the *Working
    out the correct destination for different platforms* section: if no installation
    directory variable for this `TYPE` file is set, CMake will fall back to the default
    "guess" path. Again, we can use the `GNUInstallDirs` module for portability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the built-in guesses in the table are prefixed with installation directory
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$LOCALSTATE` is `CMAKE_INSTALL_LOCALSTATEDIR` or defaults to `var`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$DATAROOT` is `CMAKE_INSTALL_DATAROOTDIR` or defaults to `share`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with `install(TARGETS)`, if the `GNUInstallDirs` module is included, it
    will provide platform-specific installation directory variables. Let''s look at
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/03-install-files/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this case, CMake will install the two header-only libraries â€“ that is, `calc.h`
    and `nested/calc_extended.h` â€“ in the project-specific subdirectory in the system-wide
    *include directory*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We know from the `GNUInstallDirs` source that `CMAKE_INSTALL_INCLUDEDIR` contains
    the same path for all supported platforms. However, it's still recommended to
    use it for readability and consistency with more dynamic variables. For example,
    `CMAKE_INSTALL_LIBDIR` will vary by architecture and distribution â€“ `lib`, `lib64`,
    or `lib/<multiarch-tuple>`.
  prefs: []
  type: TYPE_NORMAL
- en: CMake 3.20 also adds a somewhat useful `RENAME` keyword to the `install(FILES|PROGRAMS)`
    command, which has to be followed by a new filename (this only works if the `files...`
    list contains a single file).
  prefs: []
  type: TYPE_NORMAL
- en: 'The example in this section shows how easy it can be to install files in the
    appropriate directory. There''s one problem, though â€“ take a look at the installation
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Both files were installed in the same directory, regardless of nesting. Sometimes,
    that's not what we want. In the next section, we'll learn how to deal with this.
  prefs: []
  type: TYPE_NORMAL
- en: Working with whole directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don''t want to add individual files to your installation command, you
    can choose the broader approach and work with entire directories instead. The
    `install(DIRECTORY)` mode was created for this purpose. It will copy the listed
    directories verbatim to the chosen destination. Let''s see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, many options are repeated from `install(FILES|PROGRAMS)`. They
    work the same way. There''s one detail worth noting: if the paths that are provided
    after the `DIRECTORY` keyword do not end with `/`, the last directory of the path
    will be appended to the destination, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a directory called `/x/a` and copy the contents of `a` to
    it. Now, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will copy the contents of `a` directly to `/x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`install(DIRECTORY)` also introduces other mechanisms that are not available
    for files:'
  prefs: []
  type: TYPE_NORMAL
- en: Output silencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended permission control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File/directories filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the output silencing option, `MESSAGE_NEVER`. It disables output
    diagnostics during installation. It is very useful when we have many files in
    the directories we're installing and it would be too noisy to print them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up are permissions. This `install()` mode supports three options for setting
    permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`USE_SOURCE_PERMISSIONS` works exactly as expected â€“ it sets the permissions
    on installed files that follow the original files. This only works when `FILE_PERMISSIONS`
    is not set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILE_PERMISSIONS` is pretty self-explanatory as well. It allows us to specify
    the permissions we want to set on installed files and directories. The default
    permissions are `OWNER_WRITE`, `OWNER_READ`, `GROUP_READ`, and `WORLD_READ`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DIRECTORY_PERMISSIONS` works similarly to the previous option, but it will
    set additional `EXECUTE` permissions for all users (this is because `EXECUTE`
    on directories is understood by Unix-like systems as permission to list their
    contents).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that CMake will ignore permissions options on platforms that don''t support
    them. More permission control can be achieved by adding the `PERMISSIONS` keyword
    after every filtering expression: any files or directories that are matched by
    it will receive permissions that are specified after this keyword instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s talk about filters or "globbing" expressions. You can set multiple filters
    that control which files/directories get installed from source directories. They
    have the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two matching methods to pick from:'
  prefs: []
  type: TYPE_NORMAL
- en: With `PATTERN`, which is the simpler option, we're allowed to provide a pattern
    with `?` placeholders (matches any character) and wildcards, `*` (matches any
    string). Only paths that end with `<pattern>` will be matched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the `REGEX` option is more advanced â€“ it supports regular
    expressions. It also allows us to match any part of the path (we can still use
    the `^` and `$` anchors to denote the beginning and end of the path).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, we can set the `FILES_MATCHING` keyword before the first filter,
    which will specify that any filters will be applied to files and not directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember two caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FILES_MATCHING` requires an inclusive filter in that you may exclude some
    files, but unless you also add an expression to include some of them, no files
    will be copied. However, all directories will be created, regardless of filtering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All subdirectories are filtered in by default; you may only filter out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each filtering method, we may choose to `EXCLUDE` matched paths (this only
    works when `FILES_MATCHING` isn't used).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set specific permissions for all matched paths by adding the `PERMISSIONS`
    keyword and a list of desired permissions after any filter. Let''s try this out.
    In this example, we''ll install three directories in three different ways. We''ll
    have some static data files that will be used at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need some public headers that live in the `src` directory among other,
    unrelated files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will need two configuration files at two levels of nesting. To
    make things more interesting, we are going to make the contents of `/etc/calc/`
    accessible only to the file owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To install the directory with static data files, we''ll start our project with
    the most basic form of the `install(DIRECTORY)` command:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/04-install-directories/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This command will simply take all the contents of our `data` directory and put
    it in `${CMAKE_INSTALL_PREFIX}` and `share/calc`. Note that our source path ends
    with a `/` symbol to indicate we don't want to copy the `data` directory itself,
    only its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case is the opposite: we don''t add the trailing `/` because the
    directory should be included. This is because we''re relying on a system-specific
    path for the `INCLUDE` file type, which is provided by `GNUInstallDirs` (note
    how the `INCLUDE` and `EXCLUDE` keywords represent unrelated concepts):'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/04-install-directories/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we have excluded two paths from this operation: the entire `ignored`
    directory and all files ending with `calc_extended.h` (remember how `PATTERN`
    works).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third case installs some default configuration files and sets their permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/04-install-directories/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we aren''t interested in appending `etc` from the source path to the
    path for the `SYSCONF` type (this has already been provided by including `GNUInstallDirs`)
    because we would end up putting the files in `/etc/etc`. Additionally, we must
    specify two permission rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Subdirectories should only be editable and listable by the owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files ending with `nested.conf` should only be editable by the owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing directories handles a lot of different use cases, but for really
    advanced installation scenarios (such as post-install configuration), we may need
    to involve external tools. How would we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Invoking scripts during installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have ever installed a shared library on a Unix-like system, you may
    remember that before you can use it, you''ll likely need to tell the dynamic linker
    to scan trusted directories and build its cache by calling `ldconfig` (see the
    *Further reading* section for references). If you''d like to make your installation
    fully automatic, CMake offers the `install(SCRIPT|CODE)` command to support such
    cases. Here''s the full command''s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should pick `SCRIPT` or `CODE` mode and provide the appropriate arguments
    â€“ either a path to the CMake script to run or a CMake snippet to execute during
    the installation. To see how this works, we''ll modify the `02-install-targets`
    example to build a shared library:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/05-install-code/src/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change the artifact type from `ARCHIVE` to `LIBRARY` in the installation
    script to copy the files. Then, we can just add the logic to run `ldconfig` after:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/05-install-code/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `if()` condition checks if the command matches the operating system (it
    wouldn't be correct to execute `ldconfig` on Windows or macOS). Of course, the
    provided code must have valid CMake syntax to work (however, it won't be checked
    during the initial build; any failures will surface during installation).
  prefs: []
  type: TYPE_NORMAL
- en: 'After running an installation command, we can confirm that it worked by printing
    the cached libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Both modes support generator expressions, should you need them. As such, this
    command is as versatile as CMake itself and can be used for all sorts of things:
    printing messages for users, verifying that the installation was successful, extensive
    configuration, file signing â€“ you name it.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know all the different ways we can install a set of files on the
    system, let's learn how to turn them into a natively available package for other
    CMake projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have used `find_package()` extensively in previous chapters. We saw how
    convenient it is and how it simplifies the whole process. To make our project
    accessible through this command, we need to complete a few steps so that CMake
    can treat our project as a coherent package:'
  prefs: []
  type: TYPE_NORMAL
- en: Make our targets relocatable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the target export file to a standard location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a config-files and *version file* for the package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start from the beginning: why do targets need to be relocatable and
    how can we do this?'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the issues with relocatable targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installation solves many problems but unfortunately,Â it also introduces some
    complexity: not only is `CMAKE_INSTALL_PREFIX` platform-specific but it can also
    be set by the user at the installation stage with the `--prefix` option. However,
    target export files are generated before the installation, during the build stage,
    at which point we don''t know where the installed artifacts will go. Take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/01-export/src/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we specifically add the *include directory* to the *include
    directories* of `calc`. Since this is a relative path, CMake's exported target
    generation will implicitly prepend this path with the contents of the `CMAKE_CURRENT_SOURCE_DIR`
    variable, which points to the directory where this listfile is located.
  prefs: []
  type: TYPE_NORMAL
- en: However, that's not going to cut it. The installed project shouldn't need files
    from the source or build tree anymore. Everything (including library headers)
    is copied to a shared location, such as `/usr/lib/calc/` on Linux. We cannot use
    the target that's been defined in this snippet in another project since the target's
    *include directory* path still points to its source tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake solves this with two generator expressions that will filter out the expression,
    depending on the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$<BUILD_INTERFACE>`: This includes the content for regular builds but excludes
    it for installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<INSTALL_INTERFACE>`: This includes the content for installation but excludes
    it for regular builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how you can use them in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/06-install-export/src/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For regular builds, the value of the `calc` target property, `INTERFACE_INCLUDE_DIRECTORIES`,
    will be expanded, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Empty double quotes mean that the value provided in `INSTALL_INTERFACE` was
    excluded and evaluated as an empty string. On the other hand, when we install,
    the value will get expanded like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This time, the value that was provided in the `BUILD_INTERFACE` generator expression
    was evaluated as an empty string, and we're left with the value from the other
    generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more word about `CMAKE_INSTALL_PREFIX`: this variable shouldn''t be used
    as a component in paths specified in targets. It would be evaluated during the
    build stage, making the path absolute and not necessarily the same as the one
    that was provided in the installation stage (as users may use the `--prefix` option).
    Instead, use the `$<INSTALL_PREFIX>` generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, even better, you can use relative paths (they will get prepended with the
    correct installation prefix):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Please take a look at the official documentation for more examples and information
    (a link to this can be found in the *Further reading* section).
  prefs: []
  type: TYPE_NORMAL
- en: Now that our targets are "installation-compatible," we can safely generate and
    install their target export files.
  prefs: []
  type: TYPE_NORMAL
- en: Installing target export files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We discussed target export files a little bit in the *Exporting without installation*
    section. Target export files that are intended for installation are quite similar,
    as is the signature of the command for creating them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It's a combination of "plain" `export(EXPORT)` and other `install()` commands
    (its options work the same way). Just remember that it will create and install
    a target export file for a named export that must be defined with the `install(TARGETS)`
    command. The major difference to be aware of here is that the generated export
    file will contain the target paths that were evaluated in the `INSTALL_INTERFACE`
    generator expression and not `BUILD_INTERFACE` like `export(EXPORT)` did.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll generate and install the target export file for the
    target from `chapter-11/06-install-export/src/CMakeLists.txt`. To do so, we must
    call `install(EXPORT)` in our top listfile:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/06-install-export/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Again, note how we're referencing the `CalcTargets` export name in `install(EXPORT)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `cmake --install` in the build tree will result in the export file
    being generated in the specified destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If, for some reason, the override default name for the target export file (`<export
    name>.cmake`) doesn't work for you, you can add the `FILE new-name.cmake` argument
    to change it (the filename must end with `.cmake`).
  prefs: []
  type: TYPE_NORMAL
- en: Don't get confused by this â€“ the target export file isn't a config file, so
    you can't use `find_package()` to consume installed targets just yet. However,
    it's possible to `include()` export files directly if needed. So, how do we define
    the package that can be consumed by other projects? Let's find out!
  prefs: []
  type: TYPE_NORMAL
- en: Writing basic config-files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A complete package definition consists of the target export files, the package's
    *config file*, and the package's *version file*, but technically, all that's needed
    for `find_package()` to work is a config-file. It's considered a package definition
    and it's responsible for providing any package functions and macros, checking
    requirements, finding dependencies, and including target export files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, users can install your package anywhere on their system
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This prefix determines where the installed files will be copied. To support
    this, you must at least ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The paths on the target properties can be relocated (as described in the *Understanding
    the issues with relocatable targets* section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The paths that are used in your config-file are relative to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use such packages that have been installed in non-default locations, the
    consuming projects need to provide `<installation path>` through the `CMAKE_PREFIX_PATH`
    variable during the configuration stage. We can do this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find_package()` command will scan the list of paths that are outlined
    in the documentation (link in the *Further reading* section) in a platform-specific
    way. One of the patterns that''s checked on Windows and Unix-like systems is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that installing the config-file in a path such as `lib/calc/cmake`
    should work just fine. Also, it's important to highlight that config-files must
    be named `<PackageName>-config.cmake` or `<PackageName>Config.cmake` to be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the installation of the config-file to the `06-install-export` example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/07-config-file/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This command will install `CalcConfig.cmake` from the same source directory
    (`CMAKE_INSTALL_LIBDIR` will be evaluated to the correct `lib` path for the platform).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic config-file we can provide consists of a single line that includes
    the target export file:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/07-config-file/CalcConfig.cmake
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `CMAKE_CURRENT_LIST_DIR` variable refers to the directory that the config-file
    lives in. Because `CalcConfig.cmake` and `CalcTargets.cmake` are installed in
    the same directory in our example (as set by `install(EXPORT)`), the target export
    file will be included correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that our package is usable, we''ll create a simple project consisting
    of just one listfile:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/08-find-package/CMakeLists.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this in practice, we can build and install the `07-config-file` example
    to one directory, and then build `08-find-package` while referencing it with the
    `DCMAKE_PREFIX_PATH` argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output (all the `<_tree-of_>` placeholders
    will be replaced with real paths):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `CalcTargets.cmake` file was found and included correctly, and the path
    to the *include directory* was set to follow the chosen prefix. This solves packaging
    for a very basic case. Now, let's learn how to handle more advanced scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Creating advanced config-files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have more things to manage than a single target export file, it might
    be useful to include a few macros in your config-file. The `CMakePackageConfigHelpers`
    utility module gives us access to the `configure_package_config_file()` command.
    To use it, we need to supply a template file that will be interpolated with CMake
    variables to generate a config-file with two embedded macro definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_and_check(<variable> <path>)`: This works like `set()`, but it checks
    that `<path>` actually exists and fails with `FATAL_ERROR` otherwise. It is recommended
    to use this in your config-files to detect incorrect paths early.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_required_components(<PackageName>)`: This is added to the end of the
    config-file and will verify whether all the components in our package, which are
    required by the user in `find_package(<package> REQUIRED <component>)`, have been
    found. This is done by checking that the `<package>_<component>_FOUND` variables
    are true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Paths for more convoluted directory trees can be prepared for the installation
    stage while you''re generating the config-file. Take a look at the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The file that's been provided as `<template>` will be interpolated with variables
    and stored in the `<output>` path. Here, the path that's required after `INSTALL_DESTINATION`
    will be used to transform the paths stored in the variables listed in `PATH_VARS`
    so that they are relative to the install destination. We can also indicate that
    `INSTALL_DESTINATION` is relative to `INSTALL_PREFIX` by providing it as its base
    path.
  prefs: []
  type: TYPE_NORMAL
- en: '`NO_SET_AND_CHECK_MACRO` and `NO_CHECK_REQUIRED_COMPONENTS_MACRO` tell CMake
    not to add these macro definitions to the generated config-file. Let''s see this
    generation in practice. Again, we''ll extend the `06-install-export` example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/09-advanced-config/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at what we must do in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`include()` the utility module with helpers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`set()` a variable that will be used to make a relocatable path.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the `CalcConfig.cmake` config-file for the build tree using the `CalcConfig.cmake.in`
    template located in the source tree. Finally, provide `LIB_INSTALL_DIR` as a variable
    name to be computed as relative to `INSTALL_DESTINATION` or `${CMAKE_INSTALL_LIBDIR}/calc/cmake`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the config-file that was generated for the build tree to `install(FILE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that `DESTINATION` in `install(FILE)` and `INSTALL_DESTINATION` in `install(FILES)`
    are the same so that the relative paths can be computed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll need a config file template (their names are usually suffixed
    with `.in`):'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/09-advanced-config/CalcConfig.cmake.in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It should start with a `@PACKAGE_INIT@` placeholder. The generator will fill
    it with the definitions of the `set_and_check` and `check_required_components`
    commands so that they can consume the project. You may recognize these `@PLACEHOLDERS@`
    from our plain `configure_file()` â€“ they work the same as they do in C++ files.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll set`(CALC_LIB_DIR)` to the path that's passed in the `@PACKAGE_LIB_INSTALL_DIR@`
    placeholder. It will contain the path of `$LIB_INSTALL_DIR` that's provided in
    the listfile, but it will be calculated relative to the installation path. Then,
    we'll use it to include the target export files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `check_required_components()` verifies if all the components that are
    required by the package consumer have been found. Adding this command is recommended,
    even if the package doesn't have any components, to verify that the user has not
    accidentally added unsupported requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CalcConfig.cmake` config-file, when generated this way, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram, which shows how the various package files are related
    to each other, puts this into perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 â€“ The file structure for advanced packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B17205.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 â€“ The file structure for advanced packages
  prefs: []
  type: TYPE_NORMAL
- en: All the required sub-dependencies of a package must also be found in the package
    config file. This can be done by calling the `find_dependency()` macro from the
    `CMakeFindDependencyMacro` helper. We learned how to use it in [*Chapter 7*](B17205_07_Final_JC_ePub.xhtml#_idTextAnchor162),
    *Managing Dependencies with CMake*.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to expose any macros or functions to the consuming project, it
    is recommended that you put their definitions in a separate file that you can
    `include()` from the package's config-file.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, `CMakePackageConfigHelpers` also provides a helper command to
    generate package's version files. Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Generating package version files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As your package grows, it will slowly gain new features, old ones will be marked
    as deprecated, and eventually be removed. It''s important to keep track of these
    modifications in a changelog that''s available to developers that use your package.
    When a specific feature is needed, a developer can find the lowest version that
    supports it and use it as an argument to `find_package()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: CMake will then search the config-file for `Calc` and check if a *version file*
    named `<config-file>-version.cmake` or `<config-file>Version.cmake` is present
    in the same directory, that is, `CalcConfigVersion.cmake`. Next, this file will
    be read for its version information and the compatibility it provides with other
    versions. For example, you may not have version `1.2.3` installed as required,
    but you may have `1.3.5`, which is marked as "compatible" with any older versions.
    CMake will gladly accept such a package as it knows that the package vendor provides
    backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `CMakePackageConfigHelpers` utility module to generate package''s
    *version files* by calling `write_basic_package_version_file()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to provide the `<filename>` property of the artifact we want
    to create; it must follow the rules we outlined earlier. Other than that, keep
    in mind that we should store all the generated files in the build tree.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, we can pass an explicit `VERSION` (the usual format, `major.minor.patch`,
    is supported here). If we don't do this, the version that's provided in the `project()`
    command will be used instead (expect an error if your project doesn't specify
    one).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `COMPATIBILITY` keyword is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExactVersion` must match all three components of the version and won''t support
    ranged versions: `find_package(<package> 1.2.8...1.3.4)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SameMinorVersion` matches if the first two components are the same (ignores
    `patch`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SameMajorVersion` matches if the first component is the same (ignores `minor`
    and `patch`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnyNewerVersion` seems to have a reversed name: it will match any older version.
    In other words, `<package>` on version `1.4.2` will be a good match for `find_package(<package>
    1.2.8)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, all packages must be built for the same architecture as the consuming
    project to match (an exact check is performed). However, for packages that don't
    compile anything (header-only libraries, macro packages, and so on), you can specify
    the `ARCH_INDEPENDENT` keyword to skip this check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time for a practical example. The following code shows how to provide
    the *version file* for the project that we started in the `06-install-export`
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/10-version-file/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, we configure the version of the package at the top of the file,
    in the `project()` command. This requires us to switch from the short `project(<name>
    <languages>)` syntax to an explicit, full syntax by adding the `LANGUAGE` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: After including the helper utility module, we call the generation command and
    write the file to a build tree with a name conforming to the pattern that's required
    by `find_package()`. Here, we deliberately skip the `VERSION` keyword to have
    the version read from the `PROJECT_VERSION` variable. We're also marking our package
    as fully backward compatible with `COMPATIBILITY AnyNewerVersion`. After that,
    we install the package *version file* to the same destination as `CalcConfig.cmake`.
    And that's it â€“ our package is fully configured.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn what components are and how to use them with
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Defining components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start talking about package components by clearing up some possible
    confusion around the term `find_package()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The components that are mentioned here shouldn't be conflated with the `COMPONENT`
    keyword that's used in the `install()` command. They are different concepts that
    must be understood separately, despite sharing the same name. We'll look at this
    in more detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: How to use components in find_package()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we call `find_package()` with a list of `COMPONENTS` or `OPTIONAL_COMPONENTS`,
    we tell CMake that we're only interested in packages that provide them. However,
    it's important to realize that it's up to the package to verify this requirement,
    and if the package vendor doesn't add the necessary checks to the config-file
    mentioned in the *Creating advanced config-file* section, then nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: Requested components are passed to the config-file in the `<package>_FIND_COMPONENTS`
    variable (both optional and not). Additionally, for every non-optional component,
    a `<package>_FIND_REQUIRED_<component>` will be set. As package authors, we could
    write a macro to scan this list and check if we have provided all the required
    components. But we don't need to â€“ this is exactly what `check_required_components()`
    does. To use it, the config-file should set the `<Package>_<Component>_FOUND`
    variable when the necessary component is found. The macro at the end of the file
    will check if all the required variables were set.
  prefs: []
  type: TYPE_NORMAL
- en: How to use components in the install() command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some produced artifacts may not need to be installed for all scenarios. For
    example, a project may install static libraries and public headers for developing
    purposes, but by default, it can just install a shared library for the runtime.
    To make this duality of behavior possible, we can group artifacts under a common
    name by using the `COMPONENT` keyword, which is available in all the `install()`
    commands. Users that are interested in limiting installation to a specific component
    can request this explicitly by running the following command (the component names
    are case-sensitive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Marking an artifact with the `COMPONENT` keyword doesn't mean that it won't
    be installed by default. To prevent this from happening, we must add the `EXCLUDE_FROM_ALL`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore these components using a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/11-components/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'These install commands define the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lib`: This contains the static library and target export files. It''s installed
    by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: This contains public header files. It is installed by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extra`: This executes a piece of code by printing a message. It''s not installed
    by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s reiterate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake --install` without the `--component` argument will install both the
    `lib` and `headers` components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake --install --component headers` will only install public headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake --install --component extra` will print a message that''s inaccessible
    otherwise (because of the `EXCLUDE_FROM_ALL` keyword).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no `COMPONENT` keyword is specified for the installed artifact, it will get
    a default value of `Unspecified` from the `CMAKE_INSTALL_DEFAULT_COMPONENT_NAME`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since there's no easy way to list all the components that are available from
    the `cmake` command line, users of your package will benefit from exhaustive documentation
    listing your package's components. Perhaps the `INSTALL` file would be a good
    place to mention it.
  prefs: []
  type: TYPE_NORMAL
- en: If `cmake` is called with the `--component` argument for a component that doesn't
    exist, then the command will succeed without any warnings or errors. It just won't
    install anything.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning our installation into components enables users to cherry-pick what
    they want to install. We have mostly discussed grouping installed files into components,
    but there are also are procedural steps such as `install(SCRIPT|CODE)` or creating
    symlinks for shared libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Managing symbolic links for versioned shared libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The target platform for your installation may use symbolic links to help linkers
    discover the currently installed version of a shared library. After creating a
    `lib<name>.so` symlink to the `lib<name>.so.1` file, it's possible to link this
    library by passing the `-l<name>` argument to the linker. The creation of such
    symlinks is handled by CMake's `install(TARGETS <target> LIBRARY)` block when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we may decide to move that step into another `install()` command by
    adding `NAMELINK_SKIP` to this block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign symlinking to another component (instead of disabling it altogether),
    we can repeat the `install()` command for the same target and specify a different
    component, followed by the `NAMELINK_ONLY` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The same can be achieved with the `NAMELINK_COMPONENT` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have configured automatic installation, we can provide pre-built
    artifacts for our users using the CPack tool, which is included with CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging with CPack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building projects from a source has its benefits, but it can take a long time
    and introduce a lot of complexity. This isn't the best experience for end users
    who just want to use the package, especially if they aren't developers themselves.
    A much more convenient form of software distribution is to use binary packages
    that contain compiled artifacts and other static files that are needed by the
    runtime. CMake supports generating multiple kinds of such packages through a command-line
    tool called `cpack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the available package generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_11.3_B17205.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of these generators have extensive configurations. It is beyond the scope
    of this book to delve into all their details, so be sure to check out the full
    documentation, which can be found in the *Further reading* section. Instead, we'll
    focus on the general use case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Package generators shouldn't be confused with buildsystem generators (Unix Makefiles,
    Visual Studio, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: To use CPack, we'll need to correctly configure the installation of our project
    with the necessary `install()` commands and build our project. The resulting `cmake_install.cmake`
    that's generated in our build tree will be used by `cpack` to prepare binary packages
    based on the configuration file (`CPackConfig.cmake`). While it's possible to
    create this file manually, it's easier to use `include(CPack)` to include the
    utility module in our project's listfile. It will generate the configuration in
    the project's build tree and supply all the default values where needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can extend the example `11-components` so that it can work
    with CPack:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter-11/12-cpack/CMakeLists.txt (fragment)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is pretty self-explanatory, so we won''t dwell on it too much (please
    refer to the module documentation, which can be found in the *Further reading*
    section). One thing worth noting here is the fact that the `CPack` module will
    infer a few values from the `project()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_VERSION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPACK_PACKAGE_FILE_NAME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last value will be used to produce the output package. Its structure is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, `CPACK_SYSTEM_NAME` is the name of the target OS; for example, `Linux`
    or `win32`. For example, by executing a ZIP generator on Debian, CPack will generate
    a file named `CPackPackage-1.2.3-Linux.zip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After building our project, we can generate actual packages by running the
    `cpack` binary in the build tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically speaking, CPack is capable of reading all its options from the
    configuration file that''s been placed in the current working directory, but you
    may choose to override these settings from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-G <generators>`: This is a semicolon-separated list of package generators
    to use. The default value can be specified in the `CPackConfig.cmake` in the `CPACK_GENERATOR`
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-C <configs>`: This is a semicolon-separated list of build configurations
    (debug, release) to generate packages for (required for multi-configuration buildsystem
    generators).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-D <var>=<value>`: This overrides a `<var>` variable that''s set in the `CPackConfig.cmake`
    file with `<value>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--config <config-file>`: This is the config-file you should use instead of
    the default `CPackConfig.cmake`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--verbose, -V`: Provides verbose output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P <packageName>`: Overrides the package name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-R <packageVersion>`: Overrides the package version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--vendor <vendorName>`: Overrides the package vendor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-B <packageDirectory>`: Specifies the output directory for `cpack` (by default,
    this will be the current working directory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try generating packages for our `12-cpack` output. We''re going to use
    ZIP, 7Z, and the Debian package generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following packages should be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.7z`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.deb`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPackPackage-1.2.3-Linux.zip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this format, binary packages are ready to be published on the website of
    our project, in a GitHub release, or sent to a package repository for end users
    to enjoy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing installation scripts in a cross-platform way is an incredibly complex
    task without a tool such as CMake. While it still requires a little bit of work
    to set up, it's a much more streamlined process that ties closely to all the other
    concepts and techniques we've used so far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: First, we learned how to export CMake targets from projects so that they can
    be consumed in other projects without installing them. Then, we learned how to
    install projects that had already been configured for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we started exploring the basics of installation by starting with
    the most important subject: installing CMake targets. We now know how CMake handles
    different destinations for various artifact types and how to deal with public
    headers that are somewhat special. To manage these installation steps at lower
    levels, we discussed other modes of the `install()` command, including installing
    files, programs, and directories and invoking scripts during the installation.'
  prefs: []
  type: TYPE_NORMAL
- en: After explaining how to codify the installation steps, we learned about CMake's
    reusable packages. Specifically, we learned how to make targets in our projects
    relocatable so that the packages can be installed wherever the user wants. Then,
    we focused on forming a fully-defined package that can be consumed by other projects
    with `find_package()`, which required preparing target export files, config-files,
    and *version files*.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing that different users may need different parts of our package, we
    discovered how to group artifacts and actions in installation components, as well
    as how they differ from the components of CMake packages.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we touched on CPack and learned how to prepare basic binary packages
    that can be used to distribute our software in a pre-compiled form.
  prefs: []
  type: TYPE_NORMAL
- en: There's still a long way to go to fully grasp all the details and complexities
    of installation and packaging, but this chapter has given us a solid foundation
    to handle the most common scenarios and explore them further with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will put everything we've learned so far into practice
    by creating a coherent, professional project.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GNU Coding Standards for Destinations*:[https://www.gnu.org/prep/standards/html_node/Directory-Variables.html](https://www.gnu.org/prep/standards/html_node/Directory-Variables.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Discussion on new public header management with the* `FILE_SET` *keyword*:
    [https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860](https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to install a shared library*:[https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating relocatable packages*: [https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages](https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*List of paths scanned by* `find_package()` *to find the config file*: [https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure](https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Full documentation of* `CMakePackageConfigHelpers`: [https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CPack package generators*:[https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html](https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*On preferred package generators for different platforms*:[https://stackoverflow.com/a/46013099](https://stackoverflow.com/a/46013099)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CPack utility module documentation*:[https://cmake.org/cmake/help/latest/module/CPack.html](https://cmake.org/cmake/help/latest/module/CPack.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
