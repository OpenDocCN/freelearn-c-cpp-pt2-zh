- en: Writing an Installer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating export headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting your targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a superbuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, we have shown how to configure, build, and test our projects
    using CMake. Installing projects is an equally important part of the developer''s
    toolbox, and this chapter will demonstrate how to achieve that. The recipes in
    this chapter cover the install-time operations outlined in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fec2ff3d-3814-4c4d-906e-dca48eece499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will walk you through the various steps to be taken in refining the installation
    of a simple C++ project: from making sure that important files built in your project
    are copied over to the right directories, to ensuring that other projects depending
    on your work can detect it using CMake. The four recipes in this chapter will
    build upon the simple example given in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries*, Recipe 3, *Building and linking shared
    and static libraries*. There we tried to build a very simple library and link
    it into an executable. We also showed how to build both a static and a shared
    library out of the same source files. In this chapter, we will go a bit deeper
    and discuss and formalize what happens at install time.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01) and
    has a C++ example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In this very first recipe, we will introduce our small project and some of the
    basic concepts that will be used also in the subsequent recipes. Installing files,
    libraries, and executables is a very basic task, but it can present some pitfalls.
    We will walk you through these and show you how to effectively avoid many of them
    with CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code from [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml), *From
    a Simple Executable to Libraries*, Recipe 3, *Building and linking shared and
    static libraries*, is used almost unaltered: we will only add a dependency on
    the UUID library. This dependency is conditional, and if the UUID library is not
    found, we will exclude the code using it *via* the preprocessor. The code is properly
    organized into its own `src` subdirectory. The layout of the project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can already see that we have a root `CMakeLists.txt` with one leaf under
    the `src` subdirectory and another under the `tests` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Message.hpp` header file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the corresponding implementation in `Message.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the sample `hello-world.cpp` executable is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us first go through the root `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start, as usual, by requiring a minimum CMake version and defining a C++11
    project. Note that we have set a version for our project with the `VERSION` keyword
    to the `project` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The user can define the installation prefix by means of the `CMAKE_INSTALL_PREFIX`
    variable. CMake will set a sensible default for this variable: `/usr/local` on
    Unix and `C:\Program Files` on Windows, respectively. We print a status message
    reporting its value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, we prefer `Release` configuration for our project. The user will
    be able to set this with the `CMAKE_BUILD_TYPE` variable and we check whether
    that is the case. If not, we set it ourselves to the default, sensible value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we tell CMake where to build the executable, static, and shared library
    targets. This facilitates access to these build targets in case the user does
    not intend to actually install the project. We use the standard CMake `GNUInstallDirs.cmake`
    module. This will guarantee a sensible and portable project layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas the previous commands fixed the location of build output *within* the
    build directory, the following are needed to fix the location of executables,
    libraries, and include files within the install prefix. These will broadly follow
    the same layout, but we define the new `INSTALL_LIBDIR`, `INSTALL_BINDIR`, `INSTALL_INCLUDEDIR`,
    and `INSTALL_CMAKEDIR` variables, which the users can override, if they are so
    inclined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We report the paths where components will be installed to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last directives in the root `CMakeLists.txt` file add the `src` subdirectory,
    enable testing, and add the `tests` subdirectory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We now move on to analyze the `src/CMakeLists.txt` leaf. This file defines
    the actual targets to build:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project depends on the UUID library. As shown in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml),
    *Configure-time and Build-time Operations*, Recipe 8, *Probing execution*, we
    can find it with the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We wish to build a shared library out of our sources and we declare a target
    called `message-shared`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The sources for this target are specified with the `target_sources` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare compile definitions and link libraries for our target. Note that
    all are `PUBLIC`, to ensure that all dependent targets will inherit them properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then we set additional properties of our target. We will comment upon these
    shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add an executable target for our "Hello, world" program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hello-world_wDSO` executable target is linked against the shared library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src/CMakeLists.txt` file contains also the installation directives. Before
    considering these, we need to fix the `RPATH` for our executable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With CMake path manipulations, we set the `message_RPATH` variable. This will
    set `RPATH` appropriately for GNU/Linux and macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this variable to fix the `RPATH` for our executable target, `hello-world_wDSO`.
    This is achieved by means of a target property. We are also setting additional
    properties, and we will comment more on these in a moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We are finally ready to install our library, header, and executable! We use
    the install command offered by CMake to specify where these should go. Note that
    the paths are relative; we will elaborate more on this point further below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` file in the tests directory contains simple directives
    to ensure that the "Hello, World" executable runs correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now configure, build, and install the project and look at the result.
    As soon as any installation directives are added, CMake generates a new target
    called `install` that will run the installation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the build directory on GNU/Linux will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'One the other hand, at the install prefix, you can find the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This means that the locations given in the installation directives are relative
    to the `CMAKE_INSTALL_PREFIX` instance given by the user.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three salient points to this recipe that we need to discuss in more
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `GNUInstallDirs.cmake` to define standard locations for the installation
    of our targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties set on the shared library and executable targets, in particular
    the handling of the `RPATH`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing to standard locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is a good layout for the installation of your project? As long as you
    are the only consumer of your project, this question only has limited relevance.
    However, as soon as you start shipping to the outside world, it will be expected
    that you provide a sensible layout when installing your project. Fortunately,
    there are standards that we can adhere to and CMake can help us with that. Effectively,
    what the `GNUInstallDirs.cmake` module does is to define a set of variables. These
    variables are the names of the subdirectories where different types of files should
    be installed. In our example we used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_INSTALL_BINDIR`: This will give the subdirectory where *user executables*
    should be located, which is the `bin` directory under the chosen install prefix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_INSTALL_LIBDIR`: This expands to the subdirectory where *object code
    libraries *– that is, the static and shared libraries – should be located. On
    a 64-bit system, this is `lib64`, whereas on a 32-bit system, it is just `lib`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_INSTALL_INCLUDEDIR`: Finally, we used this variable to obtain the correct
    subdirectory for our C header files. This variable expands to `include`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The user might, however, want to override these choices. We allowed for that
    with the following stanza in the root `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This effectively redefines the `INSTALL_BINDIR`, `INSTALL_LIBDIR`, and `INSTALL_INCLUDEDIR` convenience
    variables to be used within our project. We also define the additional `INSTALL_CMAKEDIR`
    variable, but its role will be discussed in detail in the next few recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GNUInstallDirs.cmake` module defines additional variables that will help
    to place installed files in the expected subdirectories of the chosen install
    prefix. Please consult the CMake online documentation: [https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html](https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Target properties and RPATH handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us have a closer look at the properties set on the shared library target.
    We had to set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POSITION_INDEPENDENT_CODE 1`: This sets the compiler flags needed for generating
    position-independent code. For more details, please consult [https://en.wikipedia.org/wiki/Position-independent_code](https://en.wikipedia.org/wiki/Position-independent_code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOVERSION ${PROJECT_VERSION_MAJOR}`: This is the version of the application
    programming interface (API) offered by our shared library. Following semantic
    version, we have decided to set it to be the same as the major version of the
    project. CMake targets also have a `VERSION` property. This can be used to specify
    the build version of the target. Note that `SOVERSION` and `VERSION` might differ:
    we might want to offer multiple builds of the same API over time. We are not concerned
    with such granular control in this example: setting just the API version with
    the `SOVERSION` property is enough, CMake will set `VERSION` to the same value
    for us. For more details on please refer to the official documentation: [https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html](https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OUTPUT_NAME "message"`: This tells CMake that the base name for the library
    is just `message` and not the name of the target `message-shared`: `libmessage.so.1`
    will be generated when building. Proper symbolic links to `libmessage.so` will
    also be generated, as can be seen from the contents of the build directory and
    install prefix given previously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG_POSTFIX "_d"`: This tells CMake to add the`_d` postfix to the generated
    shared library if we are building the project in a `Debug` configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUBLIC_HEADER "Message.hpp"`: We use this property to set a list of header
    files, in this case only one, defining the API functions offered by our library.
    This is primarily intended for Framework shared library targets on macOS but it
    can also be used on other operating systems and targets, as we have presently
    done. For more details, please see the official documentation: [https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html](https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MACOSX_RPATH ON`: This sets the directory portion of the “install_name” field
    of shared libraries to `@rpath` on macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WINDOWS_EXPORT_ALL_SYMBOLS ON`: This will force compilation on Windows to
    export all symbols. Note that this is usually not a good practice and we will
    show in Recipe 2, *Generating export headers*, how to take care of symbol visibility
    on different platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us now discuss `RPATH`. We are linking our `hello-world_wDSO` executable
    to `libmessage.so.1`. This means that when the executable is called, the shared
    library will be loaded. Thus the information on the location of the library needs
    to be encoded somewhere in order for the loader to do its job successfully. There
    are two approaches regarding the location of the library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be made known to the linker by setting environment variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On GNU/Linux, this would require appending the path to the `LD_LIBRARY_PATH`
    environment variable. Note that this will most likely pollute the linker path
    for all applications on your system and might cause symbol clashes ([https://gms.tf/ld_library_path-considered-harmful.html](https://gms.tf/ld_library_path-considered-harmful.html)).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On macOS, you can similarly set the `DYLD_LIBRARY_PATH` variable. This suffers
    from the same pitfalls as `LD_LIBRARY_PATH` on GNU/Linux and the situation can
    be ameliorated, albeit only partially, by using the `DYLD_FALLBACK_LIBRARY_PATH`
    variable instead. See the following link for an example of this: [https://stackoverflow.com/a/3172515/2528668](https://stackoverflow.com/a/3172515/2528668).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It could be encoded into the executable, using the `RPATH` to set the run-time
    search path for the executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The latter approach is preferable and more robust. However, which path should
    be chosen when setting the `RPATH` of the dynamic shared object? We need to make
    sure that running the executable *always* finds the correct shared library, regardless
    of whether it is run in the build tree or in the install tree. This is achieved
    by setting the `RPATH` related properties for the `hello-world_wDSO` target to
    look for a path *relative* to the location of the executable itself, either *via*
    the `$ORIGIN` (on GNU/Linux) or `@loader_path` (on macOS) variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `message_RPATH` variable is set, the target properties will do the
    rest of the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us examine this command in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SKIP_BUILD_RPATH OFF`: Tells CMake to generate an appropriate `RPATH` so as
    to be able to run the executable from *within* the build tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BUILD_WITH_INSTALL_RPATH OFF`: Turns off generating executable targets with
    their `RPATH` geared to be the same as the one for the install tree. This would
    prevent us from running the executable from within the build tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INSTALL_RPATH "${message_RPATH}"`: Sets the `RPATH` for the installed executable
    target to a path previously computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INSTALL_RPATH_USE_LINK_PATH ON`: Tells CMake to append linker search paths
    to the `RPATH` executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on how the loader works on Unix systems may be found in this
    blog post: [http://longwei.github.io/rpath_origin/](http://longwei.github.io/rpath_origin/).'
  prefs: []
  type: TYPE_NORMAL
- en: Installation directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let us consider the installation directives. We need to install an
    executable, one library, and one header file. Executables and libraries are build
    targets, so we use the `TARGETS` option to the `install` command. Install rules
    for multiple targets can be set at once: CMake is aware of what kind of targets
    they are; that is, whether they are executables, shared libraries, or static libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Executables will be installed in `RUNTIME DESTINATION`, which we set to `${INSTALL_BINDIR}`.
    Shared libraries are installed to `LIBRARY DESTINATION`, which we set to `${INSTALL_LIBDIR}`.
    Static libraries would be installed to `ARCHIVE DESTINATION`, which we also set
    to `${INSTALL_LIBDIR}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we not only specified `DESTINATION`, but also `COMPONENT`. When installing
    the project with the `cmake --build . --target install `command, all components
    were installed, as expected. However, it might be sometimes desirable to only
    install some of them. This is what the `COMPONENT` keyword can help us with. For
    example, to only install libraries, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `Message.hpp` header file was set as a public header of the project,
    we can use the `PUBLIC_HEADER` keyword to install it along the other targets to
    the chosen destination: `${INSTALL_INCLUDEDIR}/message`. Users of the library
    can now include the header with: `#include <message/Message.hpp>`, provided the
    proper location is passed to the compiler with the `-I` option.'
  prefs: []
  type: TYPE_NORMAL
- en: The various destinations in the installation directives are interpreted as relative
    paths, unless an absolute path is used. But relative to what? There are different
    ways in which CMake can compute the absolute path, depending on what tool is triggering
    the installation. When using `cmake --build . --target install`, as we have done,
    paths will be computed relative to `CMAKE_INSTALL_PREFIX`. However, when using
    CPack, absolute paths will be computed relative to `CPACK_PACKAGING_INSTALL_PREFIX`.
    Usage of CPack will be shown in [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml),
    *Packaging Projects*, Recipe 1, *Generating source and binary packages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another mechanism is available with Unix Makefiles and Ninja generators:
    `DESTDIR`. It is possible to relocate the whole installation tree under the directory
    specified by `DESTDIR`. That is, `env DESTDIR=/tmp/stage cmake --build . --target
    install` will install the project relative to `CMAKE_INSTALL_PREFIX` and under
    the `/tmp/stage` directory. You can read more here: [https://www.gnu.org/prep/standards/html_node/DESTDIR.html](https://www.gnu.org/prep/standards/html_node/DESTDIR.html).'
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting the `RPATH` correctly can be rather tricky, but it is essential for
    third-party users. By default, CMake sets the `RPATH` of executables assuming
    they will be run from the build tree. However, upon installation, the `RPATH`
    is cleared, leading to trouble when a user would like to run `hello-world_wDSO`.
    Using the `ldd` tool on Linux, we can inspect the `hello-world_wDSO` executable
    in the build tree to see where the loader will look for `libmessage.so`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `ldd hello-world_wDSO` in the installation prefix would result instead
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is clearly wrong. However, it would be equally wrong to always hardcode
    the `RPATH` to point to the build tree or to the installation prefix: any of the
    two locations could be erased resulting in corrupted executables. The solution
    presented here sets the `RPATH` differently for the executable in the build tree
    and in the installation prefix, so that it will always point to where "it makes
    sense"; that is, as close to the executable as possible. Running `ldd` in the
    build tree shows the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, in the installation prefix, we now get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the CMake install command with the `TARGETS` signature, since
    we needed to install build targets. The command has, however, four additional
    signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FILES` and `PROGRAMS` signatures. These are used to install files or programs,
    respectively. Upon installation, files will be copied and permissions for them
    set appropriately. That is, for files, read and write permissions to the owner,
    read permissions to the group and other users and groups. For programs, execution
    permissions will be additionally granted. Note that the `PROGRAMS` signature is
    meant for use with executables that are not build targets. See also: [https://cmake.org/cmake/help/v3.6/command/install.html#installing-files](https://cmake.org/cmake/help/v3.6/command/install.html#installing-files).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DIRECTORY` signature. As the name suggests, this is used to install directories.
    When only a directory name is given, it is, as usual, understood to be relative
    to the current source directory. Granular control over installation of directories
    is possible. Please consult the online documentation: [https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories](https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SCRIPT` signature. You can use this one to define custom installation rules
    within a CMake script. See [https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic](https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EXPORT` signature. We defer discussion of this signature to Recipe 3, *Exporting
    your targets*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating export headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-02) and
    has a C++ example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us imagine that the small library that we have introduced has become hugely
    popular, with many people using it. However, some clients would also like a static
    library to be available with the installation. Other clients have noticed that
    all symbols are visible in the shared library. Best practices dictate that shared
    libraries only expose the minimal amount of symbols, thus limiting the visibility
    to the outside world of objects and functions defined in the code. We want to
    make sure that by default all symbols defined in our shared library are hidden
    from the outside world. This will force contributors to the project to clearly
    delimit the interface between the library and external codes, since they will
    have to explicit mark all symbols that also meant to be used outside of the project.
    As such, we wish to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build both a shared and static library from the same set of source files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that only the visibility of symbols in the shared library is properly
    delimited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recipe 3, *Building and linking static and shared libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries*, already showed that CMake offers functionality
    to achieve the first point in a platform-independent way. We did not, however,
    address the issue of symbol visibility. We will revisit both points with the present
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will still use mostly the same code as in the previous recipe, but we will
    need to modify `src/CMakeLists.txt` and the `Message.hpp` header file. The latter
    will include the new, autogenerated header file, `messageExport.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `message_EXPORT` preprocessor directive was introduced in the declaration
    of the `Message` class. This directive will let the compiler generate symbols
    that are visible to the users of the library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from the name of the project, the root `CMakeLists.txt` file is unchanged.
    Let us first look at the `CMakeLists.txt` file in the `src` subdirectory, where
    all the additional work actually happens. We will highlight the changes with respect
    to the file in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare our `SHARED` library target and its sources for the messaging library.
    Note that compile definitions and link libraries are unchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We also set target properties. We have added the `${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}/messageExport.h`
    header file in the list of public headers given as argument to the `PUBLIC_HEADER`
    target property. The `CXX_VISIBILITY_PRESET` and `VISIBILITY_INLINES_HIDDEN` properties
    will be discussed in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the standard CMake module `GenerateExportHeader.cmake` module and
    invoke the `generate_export_header` function. This will generate the `messageExport.h`
    header file in a subdirectory of the build directory. We will discuss this function
    and the generated header in more detail very soon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The export header should be included whenever the visibility of symbols is
    to be changed from its default – hidden – value. We have done that in the `Message.hpp`
    header file, since we want to expose some symbols in our library. Now we list
    the `${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}` directory as a `PUBLIC` include
    directory of the `message-shared` target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can turn our attention to the generation of the static library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a library target to generate the static library. The same sources as
    for the shared library will be compiled to get this target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We set compiler definitions, include directories, and link libraries, exactly
    as we did for the shared library target. Note, however, that we added the `message_STATIC_DEFINE`
    compile definition. This is to make sure that our symbols are properly exposed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We also set properties on the `message-static` target. These will be discussed
    in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the `hello-world_wDSO` executable target, which links against
    the `message-shared` library target, we define another executable target, `hello-world_wAR`.
    This links against the static library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation directives now list the additional `message-static` and `hello-world_wAR`
    targets, but are otherwise unchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe demonstrates how to set the visibility of symbols for a shared
    library. The best practice is to keep all symbols hidden by default, explicitly
    exposing only those symbols that we want to be used by dependents on our library.
    This is achieved in two steps. First of all, we need to instruct the compiler
    to hide symbols. Of course, different compilers will have different options available,
    and directly setting these by hand in our `CMakeLists.txt` would not be cross-platform.
    CMake offers a robust and cross-platform way of setting symbol visibility by setting
    two properties on the shared library target:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CXX_VISIBILITY_PRESET hidden`: This will hide all symbols, unless explicitly
    marked otherwise. When using the GNU compiler, this adds the flag `-fvisibility=hidden`
    for the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VISIBILITY_INLINES_HIDDEN 1`: This will hide symbols for inline functions.
    If using the GNU compiler, this corresponds to `-fvisibility-inlines-hidden`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows, this is the default behavior. Recall, in fact, that we needed to
    override it in the previous recipe by setting the `WINDOWS_EXPORT_ALL_SYMBOLS` property
    to `ON`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we mark the symbols we want to be visible? This is determined by the
    preprocessor, and we thus need to provide preprocessor macros that expand to visibility
    attributes that the given compiler on the chosen platform will understand. Once
    again, CMake comes to the rescue with the `GenerateExportHeader.cmake` module
    file. This module defines the `generate_export_header` function, which we invoked
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The function generates the `messageExport.h` header file, which will contain
    the preprocessor macros needed. The file is generated in the directory `${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}`,
    as requested *via* the `EXPORT_FILE_NAME` option. If this option is left empty,
    the header file would be generated in the current binary directory. The first
    argument to this function is an existing target, `message-shared` in our case.
    Basic invocation of the function only requires passing the name of an existing
    target. Optional arguments, for fine-grained control of all of the generated macros,
    can also be passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BASE_NAME`: This sets the base name of the generated header and macros to
    the passed value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPORT_MACRO_NAME`: This sets the name of the export macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPORT_FILE_NAME`: This sets the name for the export header file generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEPRECATED_MACRO_NAME`: This sets the name for the deprecation macro. This
    is used to mark deprecated code, the compiler will emit a deprecation warning
    if clients use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NO_EXPORT_MACRO_NAME`: This sets the name of the no-export macro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATIC_DEFINE`: This is for the name of the macro to use when also compiling
    a static library out of the same sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NO_DEPRECATED_MACRO_NAME`: This sets the name of the macro to be used to exclude
    deprecated code from being compiled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEFINE_NO_DEPRECATED`: This instructs CMake to generate preprocessor code
    to exclude deprecated code from compilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On GNU/Linux and using the GNU compiler, CMake will generate the following `messageExport.h`
    export header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can prepend the classes and functions to be exposed to users with the `message_EXPORT`
    macro. Deprecation can be achieved by prepending with the `message_DEPRECATED`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'The static library is built out of the same sources. However, all symbols are
    supposed to be visible in the static archive, and as can be seen from the contents
    of the `messageExport.h` header file, the `message_STATIC_DEFINE` macro comes
    to the rescue. Once the target has been declared, we set it as a compile definition.
    The additional target properties on the static library are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARCHIVE_OUTPUT_NAME "message"`: This will ensure that the name of the library
    file is just message, rather than message-static.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG_POSTFIX "_sd"`: This will append the given postfix to the library. This
    uniquely identifies the library as *static* in a `Debug` configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RELEASE_POSTFIX "_s"`: This is similar to the previous property, but just
    appends the postfix for a static library in case the target was built in `Release`
    configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is good practice to hide internal symbols when building a shared library.
    This means that the library shrinks in size, because what you expose to the user
    is less than what you have in the library. This defines the Application Binary
    Interface (ABI), which most of the time should coincide with the Application Programming
    Interface (API). This is done in two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the appropriate compiler flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We mark symbols to be exported with a preprocessor variable (`message_EXPORT`,
    in our example). When compiling, the hiding will be lifted for these symbols (such
    as classes and functions).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Static libraries are just archives of object files. Thus one compiles sources
    into object files and then the archiver bundles them into an archive. There is
    no notion of ABI: all symbols are visible by default and the visibility flags
    for the compiler do not affect static archiving. However, if you are going to
    build a shared and static library from the same source files, you need a way to
    give meaning to the `message_EXPORT` preprocessor variable that now appears in
    the code *in both cases*. This is where the `GenerateExportHeader.cmake` module
    comes in. It will define a header with all the logic for giving the proper definition
    of this preprocessor variable. For shared libraries, it will be what is needed
    by the given combination of platform and compiler. Note that the meaning will
    also change based on whether we are *building* or *using* the shared library.
    Fortunately, CMake takes care of this for us without further intervention. For
    static libraries, it will expand to an empty string doing what we expect: nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The attentive reader will have noticed that building the static and shared
    libraries as shown here will actually require to *compile the sources twice*.
    This was not an expensive operation for our simple example, but it can clearly
    become quite onerous, even for projects that are only slightly bigger than our
    example. Why did we choose this approach over the one using `OBJECT` libraries
    shown in Recipe 3, *Building and linking static and shared libraries*, in [Chapter
    1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml), *From a Simple Executable to Libraries*?
     `OBJECT` libraries take care of the first step in compiling the library: from
    sources to object files. In that step, the preprocessor intervenes and will evaluate
    `message_EXPORT`. Since the compilation of `OBJECT` libraries happens once, `message_EXPORT`
    is either evaluated to a value compatible with building the shared or the static
    library. Thus to avoid ambiguities, we chose the more robust approach of compiling
    twice, letting the preprocessor evaluate the visibility variable correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details on the topic of dynamic shared objects, static archives, and
    symbol visibility, we suggest reading this article: [http://people.redhat.com/drepper/dsohowto.pdf](http://people.redhat.com/drepper/dsohowto.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting your targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-03) and
    has a C++ example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We can imagine that our message library has been a huge success in the open
    source community. People like it a lot and use it in their own projects to print
    their messages to screen. Users particularly like the fact that each printed message
    gets a unique identifier. But users would also like the library to be more easily
    discoverable, once they compile and install it on their systems. This recipe will
    show how CMake can let us export our targets so that other projects using CMake
    can pick them up easily.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code is unchanged with respect to the previous recipe and the structure
    of the project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have added a `cmake` subdirectory containing a `messageConfig.cmake.in`
    file. This file will contain our exported targets. We have also added a test to
    check whether the installation and export of the project work as intended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once again, the root `CMakeLists.txt` file is unchanged with respect to the
    previous recipe. Moving onto the leaf directory `src` containing our sources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to find the UUID library and we can re-use the code used in previous
    recipes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up our shared library target and generate the export header, as
    shown in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We set `PUBLIC` and `INTERFACE` compile definitions for the target. Note the
    use of the `$<INSTALL_INTERFACE:...>` generator expression for the latter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the include directories are set. Once again note the use of `$<BUILD_INTERFACE:...>`
    and `$<INSTALL_INTERFACE:...>` generator expressions. We will comment on these
    later on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We finish off the shared library target by listing link libraries and target
    properties. These are unchanged from the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is done for the `message-static` library target:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first declare it and list its sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We give `PUBLIC` and `INTERFACE` compile definitions, as in the previous recipe,
    but now using the `$<INSTALL_INTERFACE:...>` generator expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We list include directories with the same command used for the shared target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Link libraries and target properties are unchanged with respect to the previous
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Executables are generated with the exact same commands used in the previous
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to look at the installation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We list the installation rules for our targets all together, since CMake can
    correctly place each of the target in the proper destination. This time, we add
    the `EXPORT` keyword so that CMake will generate an exported target file for our
    targets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The auto-generated export target file is called `messageTargets.cmake`, and
    we need to explicitly specify install rules for it. The destination of this file
    is `INSTALL_CMAKEDIR` defined in the root `CMakeLists.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to generate the proper CMake configuration files. These will
    guarantee that a downstream project will be able to find the targets exported
    by the message library. To do so, we first include the `CMakePackageConfigHelpers.cmake`
    standard module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We let CMake generate a file containing version information for our library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `configure_package_config_file` function, we generate the actual
    CMake configuration file. This is based on the template `cmake/messageConfig.cmake.in`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As a last step, we set the install rules for these two auto-generated configuration
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'What are the contents of the `cmake/messageConfig.cmake.in` template file?
    The header of this file serves as documentation for its users. Let us look at
    the actual CMake commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a placeholder that will be replaced by the `configure_package_config_file`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the auto-generated export files for the targets :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we check whether the static and shared libraries and the two "Hello, World"
    executables are present with the `check_required_components` function provided
    by CMake:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We check whether the target `PkgConfig::UUID` exists. If not, we search again
    for the UUID library, but only if we are not on Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us try this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The install tree has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that a `share` subdirectory has appeared and it contains all
    the files that we have asked CMake to autogenerate. From now on, the users of
    our `message` library will be able to locate the `message` library by doing this
    in their own  `CMakeLists.txt` file, provided that they set the `message_DIR` CMake
    variable to point to the `share/cmake/message`  directory in the install tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe has covered a lot of ground; let us make sense of it. CMake targets
    are a very useful abstraction for the operations that the build system will perform.
    Using the `PRIVATE`, `PUBLIC`, and `INTERFACE` keywords, we can set how targets
    within the same project will interact with each other. In practice, this lets
    us define how dependencies of target A will affect target B, which depends on
    A. The full power of this mechanism can be appreciated when other projects want
    to use a library as a dependency. If the proper CMake configuration files are
    made available by the library maintainers, then all dependencies can be easily
    resolved with very few CMake commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem can be solved by following the pattern outlined in the recipe
    for the `message-static`, `message-shared`, `hello-world_wDSO`, and `hello-world_wAR`
    targets. We will analyze the CMake commands for the `message-shared` target alone,
    but the discussion here is general:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate your target and lay out its dependencies within the project build.
    The need to link against the UUID library is a `PUBLIC` requirement for `message-shared`,
    since it will be used both to build targets within the project and targets in
    downstream projects. Compile definitions and include directories need to be set
    both at the `PUBLIC` *or* at the `INTERFACE` level. Some of them will, in fact
    be needed to build targets within the project, others are only relevant for downstream
    projects. Moreover, some of these will only be relevant after the project has
    been installed. This is where the `$<BUILD_INTERFACE:...>` and `$<INSTALL_INTERFACE:...>`
    generator expressions come in. Only downstream targets *external* to the `message`
    library will need these, that is they will only be made visible once the target
    is installed. In our example, the following applies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}>`  will expand
    to `${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}` only when the `message-shared`
    library target is used within our project.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$<INSTALL_INTERFACE:${INSTALL_INCLUDEDIR}>` will expand to `${INSTALL_INCLUDEDIR}`
    only when the `message-shared` library target is used as an exported target within
    another build tree.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the install rules for the target, including the name of the `EXPORT`
    file CMake will have to generate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Describe the install rules for the export file CMake has generated. The `messageTargets.cmake`
    file will be installed to `INSTALL_CMAKEDIR`. The `NAMESPACE` option to the install
    rule for the target export files will prepend the given string to the name of
    the targets. This is helpful to avoid potential name clashes between targets from
    different projects. The `INSTALL_CMAKEDIR` variable was set in the root `CMakeLists.txt`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The final part of our `CMakeLists.txt` generates the configuration files. After
    including the `CMakePackageConfigHelpers.cmake` module, this is done in three
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `write_basic_package_version_file` CMake function to generate a
    package version file. The first argument to the macro is the path to the versioning
    file: `messageConfigVersion.cmake`. We then specify the version in the Major.Minor.Patch
    format, using the `PROJECT_VERSION` CMake variable. Compatibility with newer versions
    of the library can also be specified. In our case, we guarantee compatibility
    when the library has the same major version, hence the `SameMajorVersion` argument.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we configure our template file, `messageConfig.cmake.in`; this file is
    located in the `cmake` subdirectory of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we set the install rules for the newly generated files. Both will be
    installed under `INSTALL_CMAKEDIR`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clients of the message library are now very happy since they can finally install
    the library on their system and have CMake discover it for them with minimal modifications
    to their own `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Clients can now configure their project with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests included with our example show how to check that the installation
    of the targets went according to plan. Looking at the structure of the `tests`
    folder we notice the `use_target` subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This directory contains a small project that uses the exported targets. The
    interesting part is in the `CMakeLists.txt` file specifying the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We test that the small project can be configured to use the installed library.
    This is the set up step of the use-target test fixture, as shown in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests*, Recipe 10, *Using test fixtures*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We test that the small project can be built:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests of the small projects are also run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we tear down the fixture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Note that these tests can only be run *after* the project has been installed.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a superbuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-04) and
    has a C++ example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Our example `message` library has become a huge success, and many other programmers
    use it and are very happy with it. You want to use it in your own project too,
    but are unsure how to manage the dependency properly. You could ship the source
    code for the message library with your own code, but what if the library is already
    installed on the system? [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml),
    *The Superbuild Pattern*, showed that this is a typical scenario for a superbuild,
    but you are unsure on how to install such a project. This recipe will walk you
    through the details of installing a superbuild.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will build a simple executable linking against the `message` library.
    The layout of the project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The main `CMakeLists.txt` file coordinates the superbuild. The `external` subdirectory
    contains CMake instructions to handle the dependencies. The `cmake` subdirectory
    contains a Python script and a template CMake script. These will be used to fine-tune
    the installation, the CMake script being first configured and then executed to
    call the Python script to print the `RPATH` for the installed `use_message` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Printing the `RPATH` can easily be done with platform-native tools that we will
    discuss later on in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `src` subdirectory contains the `CMakeLists.txt` and source file
    for the actual project we want to compile. The `use_message.cpp` source file contains
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by looking at the root `CMakeLists.txt` file, which is coordinating
    the superbuild:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Its preamble is unchanged with respect to the previous recipes. We start by
    declaring a C++11 project, we set a sensible default install prefix, build type,
    output directories for our targets, and layout of components in the install tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the `EP_BASE` directory property. This will set the layout for the subprojects
    in the superbuild. All subprojects will be checked out and built under the `subprojects`
    folder of `CMAKE_BINARY_DIR`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare the `STAGED_INSTALL_PREFIX` variable. This variable points
    to the `stage` subdirectory under the build directory. The project will be installed
    here during the build. This is a way of sandboxing the installation process and
    gives us a chance to check that the whole superbuild will install with a correct
    layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `external/upstream` subdirectory. This contains CMake instructions
    to manage our upstream dependencies, in our case, the `message` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We then include the `ExternalProject.cmake` standard module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We add our own project as an external project, invoking the `ExternalProject_Add`
    command. The `SOURCE_DIR` option specifies that the sources are in the `src` subdirectory.
    We also pass all appropriate CMake arguments to configure our project. Note the
    use of `STAGED_INSTALL_PREFIX` as the installation prefix for the subproject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We now add a test for the `use_message` executable, built by the `recipe-04_core`
    target. This will run the staged installation of the `use_message` executable,
    that is the one located within the build tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can declare install rules. This time they are rather simple. Since
    everything needed has already been installed with the correct layout in the staging
    area, we only need to copy the whole contents of the staging area to the install
    prefix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare an additional installation rule with the `SCRIPT` argument. The
    CMake script `install_hook.cmake` will be executed, but only on GNU/Linux and
    macOS. This script will print the `RPATH` of the installed executable and run
    it. We will discuss this in more detail in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have noticed that `-Dmessage_DIR=${message_DIR}` has been passed as
    a CMake argument to our own project. This will correctly set the location of the
    message library dependency. The value of `message_DIR` is defined in the `CMakeLists.txt` file
    under the `external/upstream/message` directory. This file handles the dependency
    on the `message` library – let us see how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first attempt to find the package. Possibly, the user will have already
    installed it somewhere on the system and may have passed the `message_DIR` option
    when configuring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If that was indeed the case and `message` was found, we report the location
    and the version of the target to the user and add a dummy `message_external` target.
    The dummy target is needed to handle superbuild dependencies correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If the library was not found, we will add it as an external project, download
    it from its online Git repository, and compile it. The install prefix, build type,
    and installation directories layout are all set from the root `CMakeLists.txt`
    file, as are the C++ compiler and flags. The project will be installed to `STAGED_INSTALL_PREFIX`
    and then tested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set the `message_DIR` directory to point to the location of the
    freshly built `messageConfig.cmake` file. Note that the path is saved to the CMake
    cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We are finally ready to compile our own project and successfully link it against
    the `message` library, be it already available on the system or freshly built
    for the purpose. Since this is a superbuild, the code under the `src` subdirectory
    is a fully standalone CMake project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C++11 project, as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We attempt finding the `message` library. Within our superbuild, the configuration
    will have `message_DIR` correctly set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to add our executable target, `use_message`. This is built from
    the `use_message.cpp` source file and links in the `message::message-shared` target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Target properties are set for `use_message`. Note once again the `RPATH` fixing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set install rules for the `use_message` target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now look at the contents of the `install_hook.cmake.in` template CMake
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CMake script is executed outside the scope of our main project and hence
    has no notion of variables or targets defined there. We thus set a variable holding
    the full path to the installed `use_message` executable. Note the use of `@INSTALL_BINDIR@`,
    which will be resolved by `configure_file`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to find the executable for the platform-native tool we will use to
    print the `RPATH` of the installed executable. We will search for  `chrpath`,
    `patchelf`, and `otool`. The search exits as soon one is found to be installed
    with an helpful status message to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We check whether the `_patcher` variable is not empty. It would mean no ELF
    patching tool is available and the operation we want to carry out will fail. We
    emit a fatal error and alert the user that one of the ELF patching tools needs
    to be installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'In case one the ELF patching tools was found, we proceed. We invoke the `print_rpath.py` Python
    script, passing the `_executable` variable as argument. We use `execute_process`
    for this purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We check the `_res` variable for return code. If execution was successful,
    we print the standard output stream captured in the `_out` variable. Otherwise,
    we print the captured standard output and error streams before exiting with a
    fatal error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We invoke once again `execute_process` to run the installed `use_message` executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we report to the user on the result of `execute_process`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The superbuild is a very useful pattern in our CMake toolbox. It lets us manage
    complex projects by separating them into smaller, more manageable subprojects.
    In addition, we can use CMake as a package manager for the project we are building.
    CMake can search for our dependencies and, in case they are not found on the system,
    freshly build them for us. The basic pattern requires three `CMakeLists.txt` files:'
  prefs: []
  type: TYPE_NORMAL
- en: The root `CMakeLists.txt`  file contains settings shared by the project and
    the dependencies. It also includes our own project as an external project. In
    our case, we chose the name `${PROJECT_NAME}_core`; that is, `recipe-04_core`,
    since the project name `recipe-04` is used for the superbuild.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The external `CMakeLists.txt` file will attempt to find our upstream dependencies
    and contains the logic to switch between importing targets or building them, depending
    on whether the dependencies were found or not. It is good practice to have separate
    subdirectories for each dependency, containing a similarly structured `CMakeLists.txt`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `CMakeLists.txt` file for our own project is a standalone CMake
    project file, since, in principle, we can configure and build it on its own without
    the additional facilities for dependency management offered by the superbuild.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will first consider the configuration of the superbuild when the dependency
    on the `message` library is not already satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We will let CMake find the library for us, and this is the output we obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'As instructed, CMake reports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The installation will be staged into the build tree. The staged installation
    is a way of sandboxing the actual installation process. As developers, this is
    useful for checking that all libraries, executables, and files are installed in
    the proper location before running the installation commands. For users, it gives
    the same final structure, but within the build directory. In this way, our project
    is immediately usable, even without running a proper installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A suitable `message` library was not found on the system. CMake will then run
    the commands provided for building the library prior to building our project,
    in order to satisfy this dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the library is already at a known location on the system, we can pass the
  prefs: []
  type: TYPE_NORMAL
- en: '`-Dmessage_DIR` option to CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in fact, the library was found and imported. Only build operations for
    our own project will be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The final installation rule for the project will copy the contents of the staged
    installation prefix to `CMAKE_INSTALL_PREFIX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `.` rather than the `${CMAKE_INSTALL_PREFIX}` absolute path,
    such that this rule can be understood properly also by the CPack tool. Usage of
    CPack will be shown in [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml),
    *Packaging Projects*, Recipe 1, *Generating source and binary packages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `recipe-04_core` project builds a simple executable target that links against
    the `message` shared library. As discussed earlier in this chapter, the `RPATH`
    needs to be set properly in order for the executable to run correctly. Recipe
    1 in this chapter showed how to achieve just that with the help of CMake and the
    same pattern was reused here in the `CMakeLists.txt` handling the creation of
    the `use_message` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that this is indeed enough, we can use a platform-native tool to print
    the `RPATH` of the installed executable. We wrap the call to the tool into a Python
    script, with is further wrapped into a CMake script. Eventually, the CMake script
    is invoked as an installation rule with the `SCRIPT` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'This additional script is executed at the very end of the installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'and on a GNU/Linux system we would see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The utilities we suggest to use to work with Executable and Linkable Format
    (ELF) objects are PatchELF ([https://nixos.org/patchelf.html](https://nixos.org/patchelf.html)),
    chrpath ([https://linux.die.net/man/1/chrpath](https://linux.die.net/man/1/chrpath)),
    and otool ([http://www.manpagez.com/man/1/otool/](http://www.manpagez.com/man/1/otool/)).
    The first one works on GNU/Linux and macOS, whereas chrpath and otool are GNU/Linux
    and macOS specific, respectively.
  prefs: []
  type: TYPE_NORMAL
