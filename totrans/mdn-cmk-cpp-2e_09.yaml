- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Managing Dependencies in CMake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CMake中管理依赖项
- en: 'It doesn’t really matter if your solution is large or small; as it grows, you’ll
    likely choose to rely on other projects. Avoiding the effort of creating and maintaining
    boilerplate code is crucial. This frees up your time for what truly matters: the
    business logic. External dependencies serve multiple purposes. They offer frameworks
    and features, solve complex issues, and play a key role in building and ensuring
    code quality. These dependencies can vary, ranging from specialized compilers
    like **Protocol Buffers** (**Protobuf**) to testing frameworks like Google Test.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的大小无关紧要；随着项目的增长，你很可能会选择依赖其他项目。避免创建和维护模板代码的工作至关重要，这样可以腾出时间专注于真正重要的事情：业务逻辑。外部依赖有多种用途。它们提供框架和功能，解决复杂问题，并在构建和确保代码质量方面发挥关键作用。这些依赖项可以有所不同，从像**Protocol
    Buffers**（**Protobuf**）这样的专用编译器到像Google Test这样的测试框架。
- en: When working with open-source projects or in-house code, managing external dependencies
    efficiently is essential. Doing this manually would require a lot of setup time
    and ongoing support. Luckily, CMake excels at handling various approaches to dependency
    management while staying current with industry standards.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理开源项目或内部代码时，高效管理外部依赖项至关重要。手动进行这些管理将需要大量的设置时间和持续的支持。幸运的是，CMake在处理各种依赖管理方法方面表现出色，同时能够保持与行业标准的同步。
- en: 'We will first learn how to identify and utilize dependencies already present
    on the host system, thereby avoiding unnecessary downloads and extended compilation
    times. This task is relatively straightforward, as many packages are either CMake-compatible
    or supported by CMake right out of the box. We’ll also explore how to instruct
    CMake to locate and include dependencies that lack this native support. For legacy
    packages, an alternative approach can be beneficial in specific situations: we
    can employ the once-popular `pkg-config` tool to handle the more cumbersome tasks.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何识别和利用主机系统上已有的依赖项，从而避免不必要的下载和延长的编译时间。这项任务相对简单，因为许多包要么与CMake兼容，要么CMake自带对其的支持。我们还将探索如何指示CMake查找并包含那些没有本地支持的依赖项。对于旧版包，某些情况下采用替代方法可能会更有效：我们可以使用曾经流行的
    `pkg-config` 工具来处理更繁琐的任务。
- en: 'Additionally, we will delve into managing dependencies that are available online
    but not yet installed on the system. We’ll examine how to fetch these from HTTP
    servers, Git, and other types of repositories. We will also discuss how to choose
    the optimal approach: first, searching within the system and then resorting to
    fetching if the package is not found. Finally, we’ll review an older technique
    for downloading external projects that may be applicable in special cases.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将深入探讨如何管理尚未安装在系统上的在线可用依赖项。我们将研究如何从HTTP服务器、Git和其他类型的仓库中获取这些依赖项。我们还将讨论如何选择最佳方法：首先在系统内搜索，如果未找到包，则转而获取。最后，我们将回顾一种较旧的技术，用于下载外部项目，这在某些特殊情况下可能仍然适用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Using already installed dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已安装的依赖项
- en: Using dependencies not present in the system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用系统中未安装的依赖项
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch09](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中的代码文件，链接为 [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch09](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch09)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `<build tree>` 和 `<source tree>` 占位符替换为适当的路径。提醒一下：**build tree** 是目标/输出目录的路径，**source
    tree** 是你的源代码所在的路径。
- en: Using already installed dependencies
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用已安装的依赖项
- en: When our project depends on a popular library, it’s likely that the operating
    system already has the right package installed. We just have to connect it to
    our project’s build process. How do we do that? We need to find out where the
    package is on the system so CMake can use its files. Doing this by hand is possible,
    but every environment is a little different. A path that works on one system might
    not work on another. So, we should automatically find these paths when building.
    There are different ways to do this, but the best method is usually CMake’s built-in
    `find_package()` command, which knows how to find many commonly used packages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的项目依赖于一个流行的库时，操作系统很可能已经安装了正确的包。我们只需要将它连接到项目的构建过程中。我们该怎么做呢？我们需要找到包在系统中的位置，以便
    CMake 能够使用它的文件。手动完成这一过程是可行的，但每个环境都有些不同。在一个系统上有效的路径可能在另一个系统上无效。因此，我们应该在构建时自动找到这些路径。有多种方法可以实现这一点，但通常最好的方法是
    CMake 内置的`find_package()`命令，它知道如何找到许多常用的包。
- en: 'If our package isn’t supported, we have two options:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的包不受支持，我们有两个选择：
- en: We can write a small plugin called a `find-module` to help `find_package()`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写一个小插件，称为`find-module`，来帮助`find_package()`。
- en: We can use an older method called `pkg-config`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用一种较旧的方法，叫做`pkg-config`。
- en: Let’s start with the recommended option first.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从推荐的选项开始。
- en: Finding packages with CMake’s find_package()
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CMake 的`find_package()`查找包。
- en: 'Let’s start by looking at the following scenario: you want to improve the way
    you’re doing network communication or data storage. Simple plain-text files or
    open-text formats like JSON and XML are too verbose in terms of size. Using a
    binary format would help things, and a well-known library like Google’s Protobuf
    looks like the answer.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看以下场景：你想改进网络通信或数据存储的方式。简单的纯文本文件或像 JSON 和 XML 这样的开放文本格式在大小上过于冗长。使用二进制格式会有所帮助，而像谷歌的
    Protobuf 这样的知名库看起来是答案。
- en: You’ve read the instructions and installed what you need on your system. Now
    what? How do you get CMake’s `find_package()` to find and use this new library?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经阅读了说明并在系统上安装了所需的内容。现在该怎么办呢？如何让 CMake 的`find_package()`找到并使用这个新库？
- en: To execute this example, we have to install the dependencies we want to use
    because the `find_package()` command only looks for packages that are already
    on your system. It assumes you’ve got everything installed, or that users know
    how to install what’s needed if they’re told to. If you want to handle other situations,
    you’ll need a backup plan. You can find more about this in the *Using dependencies
    not present in the system* section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个示例，我们必须安装我们想使用的依赖项，因为`find_package()`命令只会查找已经安装在系统中的包。它假设你已经安装了所有必要的包，或者用户知道如何安装所需的包。如果你想处理其他情况，你需要一个备用计划。你可以在*使用系统中不存在的依赖项*部分找到更多信息。
- en: 'In the case of Protobuf, the situation is fairly straightforward: you can either
    download, compile, and install the library yourself from the official repository
    ([https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf))
    or use the package manager in your operating system. If you’re following these
    examples using the Docker image mentioned in *Chapter 1*, *First Steps with CMake*,
    your dependencies are already installed and you don’t need to do anything. However,
    if you’d like to try installing by yourself, the commands to install the Protobuf
    library and compiler for Debian Linux are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Protobuf，情况相对简单：你可以从官方仓库（[https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf)）下载、编译并安装库，或者使用操作系统中的包管理器。如果你按照*第一章：CMake的第一步*中提到的
    Docker 镜像进行操作，你的依赖项已经安装好了，你无需做任何事情。然而，如果你想自己尝试安装，Debian Linux 上安装 Protobuf 库和编译器的命令如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Many projects these days choose to support CMake. They do this by creating a
    **config file** and putting it in the appropriate system directory during installation.
    Config files are an inherent part of projects opting in to support CMake.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前很多项目选择支持 CMake。它们通过创建一个**配置文件**并在安装过程中将其放入合适的系统目录来实现这一点。配置文件是选择支持 CMake 的项目中不可或缺的一部分。
- en: If you want to use a library that doesn’t have a config file, don’t worry. CMake
    supports an external mechanism to find such libraries called **find modules**.
    Unlike config files, find modules are not part of the project they’re helping
    to locate. In fact, CMake itself often comes with these find modules for many
    popular libraries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用一个没有配置文件的库，别担心。CMake支持一种外部机制来查找此类库，称为**查找模块**。与配置文件不同，查找模块不是它们帮助定位的项目的一部分。实际上，CMake本身通常会为许多流行的库提供这些查找模块。
- en: 'If you’re stuck and without either a config file or a find module, you have
    other choices:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卡住了，既没有配置文件也没有查找模块，你还有其他选择：
- en: Write your own find modules for the specific package and include them in your
    project
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定包编写自己的查找模块并将其包含到你的项目中
- en: Use a FindPkgConfig module to leverage legacy Unix package definition files
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FindPkgConfig模块来利用传统的Unix包定义文件
- en: Write a config file and ask package maintainers to include it
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写配置文件并请求包维护者将其包含进来
- en: You might think that you’re not quite ready to create such merge requests yourself.
    That’s okay because you most likely won’t have to. CMake comes with over 150 find
    modules that can find libraries such as Boost, bzip2, curl, curses, GIF, GTK,
    iconv, ImageMagick, JPEG, Lua, OpenGL, OpenSSL, PNG, PostgreSQL, Qt, SDL, Threads,
    XML-RPC, X11, and zlib, as well as the Protobuf file that we’re going to use in
    this example. A full list is available in the CMake documentation (see the *Further
    reading* section).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为自己还没准备好创建这样的合并请求。没关系，因为你很可能不需要这么做。CMake自带了超过150个查找模块，可以找到如Boost、bzip2、curl、curses、GIF、GTK、iconv、ImageMagick、JPEG、Lua、OpenGL、OpenSSL、PNG、PostgreSQL、Qt、SDL、Threads、XML-RPC、X11和zlib等库，也包括我们在本例中将使用的Protobuf文件。完整列表可以在CMake文档中找到（请参见*进一步阅读*部分）。
- en: 'Both find modules and config files can be used with CMake’s `find_package()`
    command. CMake starts by checking its built-in find modules. If it doesn’t find
    what it needs, it moves on to checking the config files provided by different
    packages. CMake scans paths where packages are usually installed (depending on
    the operating system). It looks for files that match these patterns:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的`find_package()`命令可以使用查找模块和配置文件。CMake首先检查其内建的查找模块。如果没有找到需要的模块，它会继续检查不同包提供的配置文件。CMake会扫描通常安装包的路径（取决于操作系统）。它会寻找与这些模式匹配的文件：
- en: '`<CamelCasePackageName>Config.cmake`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<CamelCasePackageName>Config.cmake`'
- en: '`<kebab-case-package-name>-config.cmake`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<kebab-case-package-name>-config.cmake`'
- en: If you want to add external find modules to your project, set the `CMAKE_MODULE_PATH`
    variable. CMake will scan this directory first.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将外部查找模块添加到你的项目中，设置`CMAKE_MODULE_PATH`变量。CMake会首先扫描这个目录。
- en: 'Going back to our example, the goal is simple: I want to show that I can build
    a project that uses Protobuf effectively. Don’t worry, you don’t need to know
    Protobuf to understand what happens. In basic terms, Protobuf is a library that
    saves data in a specific binary format. This makes it easy to write and read C++
    objects to and from files or over a network. To set this up, we use a `.proto`
    file to give Protobuf the data structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例，目标很简单：我想展示我可以构建一个有效使用Protobuf的项目。别担心，你不需要了解Protobuf就能理解发生了什么。简单来说，Protobuf是一个将数据以特定二进制格式保存的库。这使得将C++对象读写到文件或通过网络传输变得容易。为了设置这个，我们使用一个`.proto`文件来给Protobuf定义数据结构：
- en: '**ch09/01-find-package-variables/message.proto**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/01-find-package-variables/message.proto**'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code is a simple schema definition that includes a single 32-bit integer.
    The Protobuf package comes with a binary that will compile these `.proto` files
    into C++ sources and headers that our application can use. We’ll need to add this
    compilation step to our build process, but we’ll get back to that later. For now,
    let’s see how our `main.cpp` file uses the output generated by Protobuf:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个简单的模式定义，包含了一个32位整数。Protobuf包自带一个二进制文件，该文件会将这些`.proto`文件编译成C++源文件和头文件，我们的应用程序可以使用这些文件。我们需要将这个编译步骤加入到构建过程中，但稍后我们会回到这个话题。现在，让我们看看`main.cpp`文件如何使用Protobuf生成的输出：
- en: '**ch09/01-find-package-variables/main.cpp**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/01-find-package-variables/main.cpp**'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ve included a `message.pb.h` header that I expect Protobuf to generate. This
    header will have the definition for the `Message` object, as configured in `message.proto`.
    In the `main()` function, I’m creating a simple `Message` object. I set its `id`
    field to `123` as a random example and then print its debug information to the
    standard output. Next, a binary version of this object is written to the file
    stream. This is the most basic use case for a serialization library like Protobuf.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了一个 `message.pb.h` 头文件，我期望 Protobuf 会生成这个文件。这个头文件将包含在 `message.proto` 中配置的
    `Message` 对象的定义。在 `main()` 函数中，我创建了一个简单的 `Message` 对象。我将其 `id` 字段设置为 `123`，作为一个随机示例，然后将其调试信息打印到标准输出。接下来，该对象的二进制版本被写入文件流中。这是类似
    Protobuf 这样的序列化库的最基本用例。
- en: The `message.pb.h` header has to be generated before `main.cpp` is compiled.
    This is done by `protoc`, the Protobuf compiler, which takes `message.proto` as
    input. Managing this process sounds complicated, but it’s really not!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`message.pb.h` 头文件必须在编译 `main.cpp` 之前生成。这是通过 Protobuf 编译器 `protoc` 完成的，它将 `message.proto`
    作为输入。管理这个过程听起来很复杂，但其实并不复杂！'
- en: 'This is where the CMake magic happens:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CMake 魔法发生的地方：
- en: '**ch09/01-find-package-variables/CMakeLists.txt**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/01-find-package-variables/CMakeLists.txt**'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s break this down:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐步解析：
- en: 'The first two lines are straightforward: they set up the project and specify
    that it will use the C++ language.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两行是直接的：它们设置了项目并指定将使用 C++ 语言。
- en: '`find_package(Protobuf REQUIRED)` tells CMake to find the Protobuf library
    (by executing the bundled `FindProtobuf.cmake` find module) and prepare it for
    use in our project. If it can’t find the library, the build will stop because
    we used the `REQUIRED` keyword.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package(Protobuf REQUIRED)` 告诉 CMake 查找 Protobuf 库（通过执行捆绑的 `FindProtobuf.cmake`
    查找模块），并为我们的项目做好准备。如果找不到库，构建将停止，因为我们使用了 `REQUIRED` 关键字。'
- en: '`protobuf_generate_cpp` is a custom function defined in the Protobuf find module.
    It automates the process of invoking the `protoc` compiler. After successful compilation,
    it will store paths to the generated sources in variables provided as the first
    two arguments: `GENERATED_SRC` and `GENERATED_HEADER`. All subsequent arguments
    will be treated as a list of files to compile (`message.proto`).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protobuf_generate_cpp` 是在 Protobuf 查找模块中定义的自定义函数。它自动化了调用 `protoc` 编译器的过程。成功编译后，它会将生成的源文件路径存储在作为前两个参数提供的变量中：`GENERATED_SRC`
    和 `GENERATED_HEADER`。所有后续的参数将被视为需要编译的文件列表（`message.proto`）。'
- en: '`add_executable` creates our executable using `main.cpp` and Protobuf-generated
    files.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_executable` 使用 `main.cpp` 和 Protobuf 生成的文件创建我们的可执行文件。'
- en: '`target_link_libraries` tells CMake to link the Protobuf libraries to our executable.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_link_libraries` 告诉 CMake 将 Protobuf 库链接到我们的可执行文件。'
- en: '`target_include_directories()` adds to `include` paths the necessary `INCLUDE_DIRS`
    provided by the package and `CMAKE_CURRENT_BINARY_DIR`. The latter tells the compiler
    where to find the `message.pb.h` header.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_include_directories()` 将包提供的必要 `INCLUDE_DIRS` 和 `CMAKE_CURRENT_BINARY_DIR`
    添加到 `include` 路径。后者告诉编译器在哪里找到 `message.pb.h` 头文件。'
- en: 'The Protobuf find module provides the following functionalities:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 查找模块提供以下功能：
- en: It finds the Protobuf library and its compiler.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它查找 Protobuf 库及其编译器。
- en: It provides helper functions to compile the `.proto` files.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了帮助函数来编译 `.proto` 文件。
- en: It sets variables with paths for inclusion and linking.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了包含和链接的路径变量。
- en: 'While not every module comes with convenient helper functions like Protobuf,
    most modules do set up a few key variables for you. These are useful for managing
    the dependency in your project. Whether you’re using a built-in find module or
    a config file, after the package is successfully found, you can expect some or
    all of the following variables to be set:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非每个模块都提供像 Protobuf 这样的方便助手函数，但大多数模块都会为你设置一些关键变量。这些变量对于管理项目中的依赖关系非常有用。无论你是使用内置的查找模块还是配置文件，在包成功找到之后，你可以期望以下一些或所有变量被设置：
- en: '`<PKG_NAME>_FOUND`: This indicates whether the package was successfully found.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_FOUND`：指示包是否成功找到。'
- en: '`<PKG_NAME>_INCLUDE_DIRS` or `<PKG_NAME>_INCLUDES`: This points to the directories
    where the package’s header files are located.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_INCLUDE_DIRS` 或 `<PKG_NAME>_INCLUDES`：指向包含包头文件的目录。'
- en: '`<PKG_NAME>_LIBRARIES` or `<PKG_NAME>_LIBS`: These are lists of libraries that
    you’ll need to link against.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_LIBRARIES` 或 `<PKG_NAME>_LIBS`：这些是你需要链接的库列表。'
- en: '`<PKG_NAME>_DEFINITIONS`: This contains any compiler definitions needed for
    the package.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_DEFINITIONS`：包含包所需的任何编译器定义。'
- en: After running `find_package()`, you can immediately check the `<PKG_NAME>_FOUND`
    variable to see whether CMake was successful in locating the package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `find_package()` 后，你可以立即检查 `<PKG_NAME>_FOUND` 变量，看看 CMake 是否成功找到了该包。
- en: If a package module is written for CMake 3.10 or newer, it will also likely
    provide target definitions. These targets will be designated as `IMPORTED` targets
    to distinguish them as originating from an external dependency.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个包模块是为 CMake 3.10 或更高版本编写的，它也很可能提供目标定义。这些目标将被标记为 `IMPORTED` 目标，以区分它们来自外部依赖项。
- en: 'Protobuf is a great example to explore when learning about dependencies in
    CMake, as it defines module-specific variables and `IMPORTED` targets. Such targets
    allow us to write even more concise code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 是学习 CMake 中依赖项的一个很好的示例，它定义了模块特定的变量和 `IMPORTED` 目标。这样的目标让我们能够编写更加简洁的代码：
- en: '**ch09/02-find-package-targets/CMakeLists.txt**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/02-find-package-targets/CMakeLists.txt**'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Look at how the highlighted code compares with the previous version of this
    example: instead of using variables that listfiles and directories, it’s a good
    idea to use `IMPORTED` targets. This approach simplifies the listfile. It also
    automatically takes care of transient usage requirements, or propagated properties,
    as illustrated here with `protobuf::libprotobuf` target.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 看看高亮代码与此示例的前一个版本有何不同：与使用列出文件和目录的变量相比，使用 `IMPORTED` 目标是个好主意。这种方法简化了列表文件。它还自动处理了瞬态使用要求或传递的属性，如这里的
    `protobuf::libprotobuf` 目标所示。
- en: 'If you want to know exactly what a specific find module provides, your best
    resource is its online documentation. For example, you can find detailed information
    for Protobuf on the CMake official website at this link: [https://cmake.org/cmake/help/latest/module/FindProtobuf.html](https://cmake.org/cmake/help/latest/module/FindProtobuf.html).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确切知道某个特定的 find 模块提供了什么，最好的资源就是它的在线文档。例如，你可以通过以下链接在 CMake 官方网站上找到 Protobuf
    的详细信息：[https://cmake.org/cmake/help/latest/module/FindProtobuf.html](https://cmake.org/cmake/help/latest/module/FindProtobuf.html)。
- en: To keep things simple, examples in this section will simply fail if the Protobuf
    library is not found in the user’s system. But a really robust solution should
    verify the `Protobuf_FOUND` variable, and present a clear diagnostic message for
    the user (so they can install it) or perform the installation automatically. We’ll
    learn how to do this later in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例，本节中的例子将直接在找不到 Protobuf 库时失败。但一个真正稳健的解决方案应该验证 `Protobuf_FOUND` 变量，并为用户提供明确的诊断信息（以便他们可以安装它），或者自动执行安装。我们将在本章稍后学习如何做到这一点。
- en: 'The `find_package()` command has several arguments you can use. While there’s
    a longer list of them, we’ll focus on the key ones here. The basic format of the
    command is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_package()` 命令有几个可以使用的参数。虽然它们的列表较长，但我们这里将重点介绍关键参数。该命令的基本格式是：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s break down what each of these optional arguments means:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐一解释这些可选参数的含义：
- en: '`[version]` This specifies the minimum version of the package you need in the
    `major.minor.patch.tweak` format (such as `1.22`). You can also specify a range,
    like `1.22...1.40.1`, using three dots as a separator.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[version]` 这指定了你所需的最小版本号，格式为 `major.minor.patch.tweak`（例如 `1.22`）。你还可以指定一个范围，例如
    `1.22...1.40.1`，使用三个点作为分隔符。'
- en: '`EXACT`: Use this with a non-range `[version]` to tell CMake you want an exact
    version and not a newer one.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXACT`：与非范围型的 `[version]` 一起使用，告诉 CMake 你需要一个精确版本，而不是更高版本。'
- en: '`QUIET`: This suppresses all messages about whether the package was found or
    not.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUIET`：这会抑制所有关于包是否被找到的消息。'
- en: '`REQUIRED`: This will stop the build if a package is not found and a diagnostic
    message will be shown even if `QUIET` is used.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REQUIRED`：如果未找到包，构建将停止并显示诊断信息，即使使用了 `QUIET` 参数。'
- en: 'If you’re pretty sure that a package should be on your system but `find_package()`
    isn’t locating it, there’s a way to dig deeper. Starting with CMake 3.24, you
    can run the configure stage in `debug` mode to get more information. Use the following
    command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定一个包应该在你的系统上，但 `find_package()` 无法找到它，你可以深入挖掘。 从 CMake 3.24 开始，你可以在 `debug`
    模式下运行配置阶段以获取更多信息。使用以下命令：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Be cautious with this command. Make sure you type the package name exactly as
    it is because it’s case-sensitive.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令时要小心。确保你准确输入包名，因为它是区分大小写的。
- en: 'More information on the `find_package()` command can be found on the documentation
    page here: [https://cmake.org/cmake/help/latest/command/find_package.html](https://cmake.org/cmake/help/latest/command/find_package.html).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`find_package()`命令的更多信息可以在文档页面找到：[https://cmake.org/cmake/help/latest/command/find_package.html](https://cmake.org/cmake/help/latest/command/find_package.html)。
- en: Find modules are meant as a very convenient way of providing CMake with information
    on installed dependencies. Most popular libraries are widely supported by CMake
    on all major platforms. What can we do, though, when we want to use a third-party
    library that doesn’t have a dedicated find module yet?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查找模块是为CMake提供已安装依赖项信息的非常便捷的方式。大多数流行的库都在所有主要平台上得到CMake的广泛支持。但是，当我们想要使用一个还没有专门查找模块的第三方库时，该怎么办呢？
- en: Writing your own find modules
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写自己的查找模块
- en: On a rare occasion, the library that you really want to use in your project
    doesn’t provide a config file and there’s no find module readily available in
    CMake yet. You can then write a custom find module for that library and ship it
    with your project. This situation is not ideal, but in the interest of taking
    care of the users of your project, it has to be done.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，你想在项目中使用的库没有提供配置文件，并且CMake中也没有现成的查找模块。你可以为该库编写一个自定义的查找模块，并将其随项目一起分发。虽然这种情况并不理想，但为了照顾项目的用户，还是必须这么做。
- en: 'We can try writing a custom find module for the `libpqxx` library, a client
    for the PostgreSQL database. `libpqxx` is preinstalled in the Docker image for
    this book, so there’s no need to worry if you’re using that. Debian users can
    install it using the `libpqxx-dev` package (other operating systems may require
    different commands):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试为`libpqxx`库编写一个自定义的查找模块，`libpqxx`是PostgreSQL数据库的客户端。`libpqxx`已经预安装在本书的Docker镜像中，因此如果你使用的是该镜像，就不必担心。Debian用户可以通过`libpqxx-dev`包安装它（其他操作系统可能需要不同的命令）：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’ll begin by writing a new file named `FindPQXX.cmake` and storing it in
    the `cmake/module` directory within our project’s source tree. To ensure that
    CMake discovers this find module when `find_package()` is called, we’ll add its
    path to the `CMAKE_MODULE_PATH` variable in our `CMakeLists.txt` using `list(APPEND)`.
    Just a quick reminder: CMake will first check the directories listed in `CMAKE_MODULE_PATH`
    to find the find modules before searching in other locations. Your complete listfile
    should look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个名为`FindPQXX.cmake`的新文件，并将其存储在项目源树中的`cmake/module`目录下。为了确保CMake在调用`find_package()`时能够找到这个查找模块，我们将在`CMakeLists.txt`中使用`list(APPEND)`将该路径添加到`CMAKE_MODULE_PATH`变量中。简单提醒一下：CMake会首先检查`CMAKE_MODULE_PATH`中列出的目录，以查找查找模块，然后才会在其他位置进行搜索。你完整的listfile应如下所示：
- en: '**ch09/03-find-package-custom/CMakeLists.txt**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/CMakeLists.txt**'
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With that in place, let’s move on to writing the actual find module. If the
    `FindPQXX.cmake` file is empty, CMake won’t raise any errors, even if you use
    `find_package()` with `REQUIRED`. It’s the responsibility of the find module’s
    author to set the correct variables and follow best practices (like raising errors).
    According to CMake’s guidelines, here are some key points to note:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们将继续编写实际的查找模块。如果`FindPQXX.cmake`文件为空，即使使用`find_package()`并加上`REQUIRED`选项，CMake也不会报错。查找模块的作者需要负责设置正确的变量并遵循最佳实践（例如引发错误）。根据CMake的指南，以下是一些关键点：
- en: When `find_package(<PKG_NAME> REQUIRED)` is called, CMake sets a `<PKG_NAME>_FIND_REQUIRED`
    variable to `1`. The find module should then use `message(FATAL_ERROR)` if the
    library isn’t found.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`find_package(<PKG_NAME> REQUIRED)`时，CMake会将`<PKG_NAME>_FIND_REQUIRED`变量设置为`1`。如果找不到库，查找模块应使用`message(FATAL_ERROR)`。
- en: When `find_package(<PKG_NAME> QUIET)` is used, CMake sets `<PKG_NAME>_FIND_QUIETLY`
    to `1`. The find module should avoid displaying any extra messages.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`find_package(<PKG_NAME> QUIET)`时，CMake会将`<PKG_NAME>_FIND_QUIETLY`设置为`1`。此时，查找模块应避免显示任何额外的消息。
- en: CMake sets a `<PKG_NAME>_FIND_VERSION` variable to the version specified in
    the listfiles. If the find module can’t locate the right version, it should trigger
    a `FATAL_ERROR`.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake会将`<PKG_NAME>_FIND_VERSION`变量设置为listfiles中指定的版本。如果查找模块无法找到正确的版本，应该触发`FATAL_ERROR`。
- en: Of course, it’s best to follow the preceding rules for consistency with other
    find modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最好遵循上述规则，以确保与其他查找模块的一致性。
- en: 'To create an elegant find module for `PQXX`, let’s follow these steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`PQXX`创建一个优雅的查找模块，按照以下步骤操作：
- en: If the paths to the library and headers are already known (supplied by the user
    or retrieved from the cache of a previous run), use these paths to create an `IMPORTED`
    target. If this is done, you can stop here.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果库和头文件的路径已经知道（由用户提供或从上次运行的缓存中检索），则使用这些路径创建`IMPORTED`目标。如果完成此操作，您可以停止这里。
- en: If the paths are not known, begin by finding the library and headers for the
    underlying dependency, which, in this case, is PostgreSQL.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果路径未知，首先找到底层依赖（在本例中是PostgreSQL）的库和头文件。
- en: Next, search the well-known paths to locate the binary version of the PostgreSQL
    client library.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，搜索常见路径以查找PostgreSQL客户端库的二进制版本。
- en: Similarly, scan the known paths to find the PostgreSQL client’s `include` headers.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，扫描已知路径以找到PostgreSQL客户端的`include`头文件。
- en: Finally, confirm whether both the library and include headers are located. If
    they are, create an `IMPORTED` target.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确认是否找到了库和头文件。如果找到了，就创建一个`IMPORTED`目标。
- en: To create a robust find module for `PQXX`, let’s focus on a couple of important
    tasks. First, the creation of an `IMPORTED` target can happen in two scenarios
    – either the user specifies the library’s paths or the paths are automatically
    detected. To keep our code clean and avoid duplication, we’ll write a function
    that manages the outcome of our search process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`PQXX`创建一个强大的查找模块，让我们专注于几个重要任务。首先，`IMPORTED`目标的创建有两种情况——要么用户指定了库的路径，要么路径是自动检测的。为了保持代码的简洁并避免重复，我们将编写一个函数来管理搜索过程的结果。
- en: Defining IMPORTED targets
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义IMPORTED目标
- en: To set up an `IMPORTED` target, all we really need is a library defined with
    the `IMPORTED` keyword. This will enable us to use the `target_link_libraries()`
    command in the calling `CMakeLists.txt` listfile. We need to specify the type
    of the library, and for simplicity, we’ll mark it as `UNKNOWN`. This means we’re
    not concerned about whether the library is static or dynamic; we just want to
    pass an argument to the linker.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个`IMPORTED`目标，我们实际上只需要定义一个带有`IMPORTED`关键字的库。这样，我们就可以在调用的`CMakeLists.txt`列表文件中使用`target_link_libraries()`命令。我们需要指定库的类型，为了简化，我们将其标记为`UNKNOWN`。这意味着我们不关心库是静态的还是动态的，我们只需要将一个参数传递给链接器。
- en: Next, we set the essential properties for our target – namely, `IMPORTED_LOCATION`
    and `INTERFACE_INCLUDE_DIRECTORIES`. We use the arguments provided to the function
    for these settings. It’s possible to specify additional properties like `COMPILE_DEFINITIONS`,
    but they are not needed for `PQXX`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为目标设置必要的属性——即`IMPORTED_LOCATION`和`INTERFACE_INCLUDE_DIRECTORIES`。我们使用传递给函数的参数来进行这些设置。虽然可以指定其他属性，如`COMPILE_DEFINITIONS`，但`PQXX`并不需要这些属性。
- en: After that, to make our find module more efficient, we’ll store the found paths
    in cache variables. This way, we won’t have to repeat the search in future runs.
    It’s worth noting that we explicitly set `PQXX_FOUND` in the cache, making it
    globally accessible and allowing the user’s `CMakeLists.txt` to reference it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，为了提高查找模块的效率，我们将在缓存变量中存储找到的路径。这样，我们在未来的运行中就不需要重复搜索了。值得注意的是，我们在缓存中显式设置了`PQXX_FOUND`，使其全局可访问，并允许用户的`CMakeLists.txt`进行引用。
- en: Finally, we mark these cache variables as `advanced`, hiding them in the CMake
    GUI unless the `advanced` option is activated. This is a common best practice
    that we’ll also adopt.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这些缓存变量标记为`advanced`，在CMake GUI中隐藏它们，除非激活了`advanced`选项。这是一个常见的最佳实践，我们也会采用这种做法。
- en: 'Here’s how the code looks for these operations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些操作的代码示例：
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake**'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we’ll discuss how to use custom or previously stored paths for quicker
    setup.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来讨论如何使用自定义或以前存储的路径来加速设置过程。
- en: Accepting user-provided paths and reusing cached values
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接受用户提供的路径并重用缓存值
- en: 'Let’s address the situation where a user has installed `PQXX` in a non-standard
    location and provides the needed paths via command-line arguments using `-D`.
    If that’s the case, we immediately call the function we defined earlier and stop
    the search by using `return()`. We assume that the user has provided accurate
    paths to both the library and its dependencies, like PostgreSQL:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理一下用户将`PQXX`安装在非标准位置，并通过命令行参数`-D`提供所需路径的情况。如果是这样，我们立即调用之前定义的函数，并使用`return()`停止搜索。我们假设用户已提供了库及其依赖项（如PostgreSQL）的准确路径：
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake (continued)**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake（续）**'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This condition will hold true if a configuration was carried out previously,
    as the variables `PQXX_LIBRARIES` and `PQXX_INCLUDES` are stored in the cache.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果先前已进行过配置，这个条件将成立，因为变量 `PQXX_LIBRARIES` 和 `PQXX_INCLUDES` 已存储在缓存中。
- en: It’s time to see how to handle finding the additional libraries that `PQXX`
    relies on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何处理查找 `PQXX` 依赖的附加库。
- en: Searching for nested dependencies
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索嵌套依赖
- en: 'To utilize `PQXX`, the host system must also have PostgreSQL installed. While
    it’s perfectly fine to use another find module within our current find module,
    we should pass along the `REQUIRED` and `QUIET` flags to ensure consistent behavior
    between the nested search and the main search. To do so, we’ll set two helper
    variables to store the keywords we need to pass and fill them according to arguments
    received from CMake: `PQXX_FIND_QUIETLY` and `PQXX_FIND_REQUIRED`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `PQXX`，主机系统必须安装 PostgreSQL。虽然在当前的查找模块中使用其他查找模块是完全可以的，但我们应该传递 `REQUIRED`
    和 `QUIET` 标志，以确保嵌套搜索和主搜索之间的一致行为。为此，我们将设置两个辅助变量来存储需要传递的关键字，并根据 CMake 接收到的参数填充它们：`PQXX_FIND_QUIETLY`
    和 `PQXX_FIND_REQUIRED`。
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Having this done, we’ll dive into the specifics of pinpointing where the `PQXX`
    library resides in the operating system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将深入探讨如何精准定位 `PQXX` 库在操作系统中的位置。
- en: Searching for library files
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索库文件
- en: 'CMake offers the `find_library()` command to help find library files. This
    command will accept the filenames to look for and a list of possible paths, formatted
    in CMake’s path style:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了 `find_library()` 命令来帮助查找库文件。该命令将接受要查找的文件名和可能的路径列表，路径格式为 CMake 的路径样式：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <VAR_NAME>will serve as the name for variables that store the command’s output.
    If a matching file is found, its path will be stored in the `<VAR_NAME>` variable.
    Otherwise, the `<VAR_NAME>-NOTFOUND` variable will be set to `1`. We’ll use `PQXX_LIBRARY_PATH`
    as our `VAR_NAME`, so we’ll end up with either a path in `PQXX_LIBRARY_PATH` or
    `1` in `PQXX_LIBRARY_PATH-NOTFOUND`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`<VAR_NAME>` 将作为存储命令输出的变量名。如果找到匹配的文件，其路径将存储在 `<VAR_NAME>` 变量中。如果未找到，则 `<VAR_NAME>-NOTFOUND`
    变量将被设置为 `1`。我们将使用 `PQXX_LIBRARY_PATH` 作为我们的 `VAR_NAME`，因此我们最终会得到 `PQXX_LIBRARY_PATH`
    中的路径或 `PQXX_LIBRARY_PATH-NOTFOUND` 中的 `1`。'
- en: 'The `PQXX` library often exports its location to an `$ENV{PQXX_DIR}` environment
    variable, meaning the system may already know its whereabouts. We can include
    this path in our search by first formatting it using `file(TO_CMAKE_PATH)`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`PQXX` 库通常会将其位置导出到 `$ENV{PQXX_DIR}` 环境变量中，这意味着系统可能已经知道它的位置。我们可以通过先使用 `file(TO_CMAKE_PATH)`
    格式化它，然后将此路径包含在我们的搜索中：'
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake (continued)**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake（续）**'
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `NO_DEFAULT_PATH` keyword instructs CMake to bypass its standard list of
    search paths. While you generally wouldn’t want to do this (since the default
    paths are often correct), using `NO_DEFAULT_PATH` allows you to explicitly specify
    your own search locations if needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`NO_DEFAULT_PATH` 关键字指示 CMake 绕过其标准的搜索路径列表。虽然通常不建议这样做（因为默认路径通常是正确的），但使用 `NO_DEFAULT_PATH`
    可以让你在需要时明确指定自己的搜索位置。'
- en: Let’s move on to finding the required header files that can be included by users
    of the library.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们来查找可以被库用户包含的必需头文件。
- en: Searching for header files
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索头文件
- en: To search for all known header files, we’ll use the `find_path()` command, which
    works very similarly to `find_library()`. The main difference is that `find_library()`
    automatically appends system-specific extensions for libraries, whereas with `find_path()`,
    we need to specify exact names.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查找所有已知的头文件，我们将使用 `find_path()` 命令，它的工作方式与 `find_library()` 非常相似。主要区别在于 `find_library()`
    会自动为库添加系统特定的扩展，而使用 `find_path()` 时，我们需要指定确切的名称。
- en: 'Also, don’t get confused here with `pqxx/pqxx`. It’s an actual header file,
    but its extension was intentionally left off by the library creators to align
    with C++ `#include` directives. This allows it to be used with angle brackets,
    like so: `#include <pqxx/pqxx>`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别把 `pqxx/pqxx` 弄混了。它是一个实际的头文件，但其扩展名被库创建者故意省略，以便与 C++ 的 `#include` 指令对齐。这样，它就可以像这样使用尖括号：`#include
    <pqxx/pqxx>`。
- en: 'Here’s the snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码片段：
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake (continued)**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake（续）**'
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we’ll look at how to finalize the search process, handle any missing paths,
    and call the function defining `imported` targets.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何完成搜索过程，处理任何缺失的路径，并调用定义 `imported` 目标的函数。
- en: Returning the final results
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回最终结果
- en: Now, it’s time to check whether we have any `PQXX_LIBRARY_PATH-NOTFOUND` or
    `PQXX_HEADER_PATH-NOTFOUND` variables set. We can either manually print diagnostic
    messages and halt the build, or we can use the `find_package_handle_standard_args()`
    helper function from CMake. This function sets the `<PKG_NAME>_FOUND` variable
    to `1` if the path variables are correctly filled. It also provides appropriate
    diagnostic messages (it will respect the `QUIET` keyword) and will halt execution
    with a `FATAL_ERROR` if a `REQUIRED` keyword is provided in the `find_package()`
    invocation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'If a library is found, we’ll call the function we wrote earlier to define the
    `IMPORTED` targets and store the paths in the cache:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake (continued)**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That’s it! This find module will find `PQXX` and create the appropriate `PQXX::PQXX`
    targets. The complete file is available in the book’s `examples` repository.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: For libraries that are well supported and likely already installed, this method
    is very effective. But what if you’re dealing with older, less-supported packages?
    Unix-like systems have a tool called `pkg-config`, and CMake has a useful wrapper
    module to support it as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Discovering legacy packages with FindPkgConfig
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managing dependencies and figuring out the necessary compile flags is a challenge
    as old as C++ libraries themselves. Various tools have been developed to tackle
    this issue, from simple mechanisms to comprehensive solutions integrated into
    buildsystems and IDEs. PkgConfig ([freedesktop.org/wiki/Software/pkg-config](http://freedesktop.org/wiki/Software/pkg-config))
    is one such tool, once very popular and commonly found on Unix-like systems, although
    it’s also available on macOS and Windows.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'However, PkgConfig is gradually being replaced by more modern solutions. So,
    should you still consider supporting it? Chances are, you probably don’t need
    to. Here’s why:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: If your library doesn’t provide the `.pc` PkgConfig files, there’s little value
    in writing definition files for an aging tool; opt for newer alternatives instead
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can pick a newer version of the library that supports CMake (we’ll discuss
    how to download dependencies from the internet later in this chapter)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the package is widely used, the latest version of CMake might already include
    a find module for it
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a community-created find module is available online and its license allows
    you to use it, that’s another good option
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can write and maintain a find module yourself
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use PkgConfig only if you’re working with a library version that already provides
    a PkgConfig `.pc` file, and no config module or find module is available. Also,
    there should be a strong reason why creating a find module yourself isn’t a viable
    option. If you’re convinced that you don’t need PkgConfig, go ahead and skip this
    section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, not all environments can be quickly updated to the latest versions of
    a library. Many companies are still using legacy systems in production, which
    are no longer receiving the latest packages. If you have a `.pc` file for a specific
    library in your system, it will look something like the one for `foobar` shown
    here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The format of PkgConfig is simple, and many developers familiar with this tool
    prefer using it out of habit over learning more advanced systems like CMake. Despite
    its simplicity, PkgConfig can check whether a specific library and its version
    are available, and it can also get linking flags and directory information for
    the library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: To use it with CMake, you need to find the `pkg-config` tool on your system,
    run specific commands, and then store the results for later use by the compiler.
    Doing all these steps each time you use PkgConfig can feel like a lot of work.
    Luckily, CMake provides a FindPkgConfig find module. If PkgConfig is found, `PKG_CONFIG_FOUND`
    will be set. We can then use `pkg_check_modules()` to look for the package we
    need.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already become familiar with `libpqxx` in the previous section, and
    since it offers a `.pc` file, let’s try and find it using PkgConfig. To put this
    in action, let’s write a simple `main.cpp` file, which utilizes a placeholder
    connection class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**ch09/04-find-pkg-config/main.cpp**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In a typical listfile, we usually start with the `find_package()` function and
    switch to PkgConfig if the library isn’t detected. This approach is useful when
    the environment gets updated, as we can keep using the `main` method without altering
    the code. We’ll skip this part for this example to keep it short.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**ch09/04-find-pkg-config/CMakeLists.txt**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s break down what happens:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The `find_package()` command is used to locate PkgConfig. If `pkg-config` is
    missing, the process stops due to the `REQUIRED` keyword.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pkg_check_modules()` custom macro from the `FindPkgConfig` find module
    sets up a new `IMPORTED` target named `PQXX`. The find module looks for a `libpqxx`
    dependency and will fail if it’s not there, again because of the `REQUIRED` keyword.
    The `IMPORTED_TARGET` keyword is crucial; otherwise, we’d need to define the target
    manually.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We validate the setup with a `message()` function, displaying `PQXX_FOUND`.
    If we hadn’t used `REQUIRED` earlier, this is where we could check whether the
    variable was set, maybe to activate other fallbacks.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `main` executable is declared with `add_executable()`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we use `target_link_libraries()` to link the `PkgConfig::PQXX` target,
    imported by `pkg_check_modules()`. Note that `PkgConfig::` is a fixed prefix and
    `PQXX` is derived from the first argument we passed to the macro.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using this option is faster than creating a find module for dependencies that
    don’t have CMake support. However, it does come with some downsides. One issue
    is that it relies on the older `pkg-config` tool, which may not be available in
    the operating system that builds the project. Additionally, this approach creates
    a special case that needs to be maintained differently from other methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: We’ve discussed how to work with dependencies that are already installed on
    your computer. However, that’s only part of the story. Many times, your project
    will go to users who might not have all the required dependencies on their systems.
    Let’s see how to handle this situation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Using dependencies not present in the system
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CMake excels at managing dependencies, particularly when they’re not already
    installed on the system. There are several approaches you can take. If you’re
    using CMake version 3.14 or newer, the `FetchContent` module is your best choice
    for managing dependencies. Essentially, `FetchContent` is a user-friendly wrapper
    around another module called `ExternalProject`. It not only simplifies the process
    but also adds some extra features. We’ll dive deeper into `ExternalProject` later
    in this chapter. For now, just know that the main difference between the two is
    the order of execution:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`FetchContent` brings dependencies in during the *configuration stage*.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExternalProject` brings dependencies in during the *build stage*.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This order is significant, as targets defined by `FetchContent` during the configuration
    stage will be in the same namespace, and as such can be easily used by our project.
    We can link them with other targets, just as if we had defined them ourselves.
    There are rare cases when this is not desirable, and that’s when `ExternalProject`
    is the necessary choice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to deal with the majority of the cases first.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: FetchContent
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `FetchContent` module is extremely useful; it offers the following features:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Management of directory structure for an external project
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading of sources from a URL (and extracting from archives if needed)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for Git, Subversion, Mercurial, and CVS (Concurrent Versions System)
    repositories
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching updates if needed
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and building the project with CMake, Make, or with a user-specified
    tool
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing nested dependencies on other targets
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The usage of the `FetchContent` module involves three main steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Add the module to your project with `include(FetchContent)`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the dependencies with the `FetchContent_Declare()` command. This will
    instruct FetchContent where the dependencies are and which version should be used.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the dependency setup using the `FetchContent_MakeAvailable()` command.
    This will download, build, install, and add the listfiles to your main project
    for parsing.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You might wonder why *steps 2* and *3* are separate. The reason is to allow
    for **configuration overrides** in multi-layered projects. For example, consider
    a project that depends on external libraries, A and B. Library A also depends
    on B, but its authors are using an older version that differs from the parent
    project’s version (*Figure 9.1*):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_09_01.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The hierarchical project'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: If configuration and download were to occur in the same command, the parent
    project wouldn’t be able to use a newer version, even if it’s backward compatible,
    because the dependency has already configured the *imported targets* for the older
    version introducing conflicts to target names and files of the library.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: To specify what version is needed, the top-most project has to call the `FetchContent_Declare()`
    command and provide overridden configuration for B, before library A is fully
    set up. The subsequent call to `FetchContent_Declare()` in A will be ignored,
    as the B dependency was already configured.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the signature of the `FetchContent_Declare()` command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `depName` is a unique identifier of the dependency and will be later used
    by the `FetchContent_MakeAvailable()` command.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The `contentOptions` provides a detailed configuration of the dependency, which
    can get quite complex. It’s important to realize that, under the hood, `FetchContent_Declare()`
    uses the older `ExternalProject_Add()` command. As a matter of fact, many arguments
    provided to `FetchContent_Declare` are directly forwarded to that internal call.
    Before explaining all the arguments in detail, let’s see a working example that
    downloads a dependency from GitHub.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Basic example with a YAML reader
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve written a tiny program that reads a username from a YAML file and prints
    it out in a welcome message. YAML is a great, simple format to store human-readable
    configuration, but it’s quite complex to parse by machines. I’ve found a neat,
    small project that solves this problem called `yaml-cpp` by Jesse Beder ([https://github.com/jbeder/yaml-cpp](https://github.com/jbeder/yaml-cpp)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The example is fairly straightforward. It’s a greeting program that prints
    a `Welcome <name>` message. The default value of `name` will be `Guest`, but we
    can specify a different name in a YAML configuration file. Here’s the C++ code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**ch09/05-fetch-content/main.cpp**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The configuration file for this example is just a single line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**ch09/05-fetch-content/config.yaml**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll reuse this example in other sections, so take a second to understand
    how it works. Now that we have the code ready, let’s see how we can build it and
    get the dependency in:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**ch09/05-fetch-content/CMakeLists.txt**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can explicitly access the targets created by the `yaml-cpp` library. To
    prove it, we’ll use a `CMakePrintHelpers` helper module:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we build such a project, the configuration stage will print the following
    output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This tells us that the target defined by the `external-yaml-cpp` dependency
    exists; it’s a static library, and its source directory resides inside the build
    tree. This printout isn’t necessary for real-life projects, but it helps to debug
    things if you’re not sure how to correctly include an imported target.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already copied the `.yaml` file to the output with the `configure_file()`
    command, we can run the program:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Everything works like a charm! With hardly any work, we have introduced an external
    dependency and used it in our project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need more than one dependency, we should write multiple calls to the
    `FetchContent_Declare()` command, each time selecting a unique identifier. But
    there’s no need to call `FetchContent_MakeAvailable()` more than once because
    it supports multiple identifiers (these are case-insensitive):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we’ll learn how to write declarations of dependencies.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the dependencies
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `FetchContent_Declare()` command offers a wide range of options, which
    come from the `ExternalProject` module. Essentially, you can perform three main
    actions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Downloading dependencies
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating dependencies
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patching dependencies
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s begin by looking at the most common scenario: fetching files from the
    internet. There are many download sources supported by CMake:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Server (URL)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mercurial
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CVS
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going from the top of the list, we’ll first explore how to download dependencies
    from URLs and customize the process to fit our needs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Downloading from a URL
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can provide a list of URLs to be scanned in sequence until a download succeeds.
    CMake will recognize whether the downloaded file is an archive and will unpack
    it by default.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic declaration:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here are some additional options to further customize this method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`URL_HASH <algo>=<hashValue>`: This checks whether a downloaded file’s checksum
    generated by `<algo>` matches the provided `<hashValue>`. It is recommended to
    guarantee the integrity of downloads. The following algorithms are supported:
    `MD5`, `SHA1`, `SHA224`, `SHA256`, `SHA384`, `SHA512`, `SHA3_224`, `SHA3_256`,
    `SHA3_384`, and `SHA3_512`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOWNLOAD_NO_EXTRACT <bool>`: This explicitly disables extraction after downloading.
    We may consume the filename of downloaded files in the follow-up steps by accessing
    the `<DOWNLOADED_FILE>` variable.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOWNLOAD_NO_PROGRESS <bool>`: This explicitly disables logging of the download
    progress.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMEOUT <seconds>` and `INACTIVITY_TIMEOUT <seconds>`: These set timeouts
    to terminate the download after a fixed total time or period of inactivity.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_USERNAME <username>` and `HTTP_PASSWORD <password>`: These configure
    HTTP authentication. Be cautious not to hardcode credentials.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_HEADER <header1> [<header2>...]`: This adds extra headers to your HTTP
    request, which is useful for AWS or custom tokens.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TLS_VERIFY <bool>`: This verifies the SSL certificate. If this is not set,
    CMake will read this setting from the `CMAKE_TLS_VERIFY` variable, which is set
    to `false` by default. Skipping TLS verification is an unsafe, bad practice and
    should be avoided, especially in production environments.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TLS_CAINFO <file>`: This provides a path to the authority file; if it isn’t
    specified, CMake will read this setting from the `CMAKE_TLS_CAINFO` variable.
    It is useful if your company is issuing self-signed SSL certificates.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The majority of programmers will refer to online repositories like GitHub to
    grab the latest versions of libraries. Here’s how.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Downloading from Git
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To download dependencies from Git, ensure that the host system has Git version
    1.6.5 or later. The following options are essential for cloning the project from
    Git:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both `<url>` and `<tag>` should be compatible with the `git` command. In a production
    environment, it’s advisable to use a specific `git` hash (rather than tag) to
    ensure traceability of the produced binaries and to avoid unnecessary `git` `fetch`
    operations. If you prefer using a branch, stick to remote names such as `origin/main`.
    This ensures the proper synchronization of the local clone.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional options include:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`GIT_REMOTE_NAME <name>`: This sets the remote name (`origin` is the default).'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GIT_SUBMODULES <module>...`: This specifies which submodules to update; since
    3.16, this value defaults to `none` (previously, all submodules were updated).'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GIT_SUBMODULES_RECURSE 1`: This enables the recursive updating of submodules.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GIT_SHALLOW 1`: This performs a shallow clone, which is faster as it skips
    downloading historical commits.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TLS_VERIFY <bool>`: This verifies the SSL certificate. If this is not set,
    CMake will read this setting from the `CMAKE_TLS_VERIFY` variable, which is set
    to `false` by default; skipping TLS verification is an unsafe, bad practice and
    should be avoided, especially in production environments.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your dependency is stored in Subversion, you can also fetch it with CMake.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Downloading from Subversion
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To download from Subversion, we should specify the following options:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Additionally, we may provide the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '`SVN_USERNAME <user>` and `SVN_PASSWORD <password>`: These provide credentials
    for checkout and update. Avoid hardcoding these in your projects.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SVN_TRUST_CERT <bool>`: This skips the verification of the Subversion server
    site certificate. Use this option only if the network path to the server and its
    integrity are trustworthy.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion is very easy to use with CMake. So is Mercurial.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Downloading from Mercurial
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This mode is very straightforward. We need to provide two arguments and we’re
    done:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Lastly, we can use CVS to provide dependencies.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Downloading from CVS
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To check out modules from CVS, we need to provide the following three arguments:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With that, we covered all the download options for `FetchContent_Declare()`.
    CMake supports additional steps that can be executed after a successful download.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Updating and patching
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the `update` step will re-download the external project’s files
    if the download method supports updates, for example, if we configure the Git
    dependency pointing to the `main` or `master` branch. We can override this behavior
    in two ways:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Provide a custom command to be executed during the update with `UPDATE_COMMAND
    <cmd>`.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completely disable the `update` step (to allow building with a disconnected
    network) – `UPDATE_DISCONNECTED <bool>`. Do note that dependency will still be
    downloaded during the first build.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Patch`, on the other hand, is an optional step that will execute after the
    update is fetched. To enable it, we need to specify the exact command we want
    to execute with `PATCH_COMMAND <cmd>`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: CMake documentation warns that some patches may be more “sticky” than others.
    For example, in Git, changed files don’t get restored to the original state during
    the update, and we need to be careful to avoid incorrectly patching the file twice.
    Ideally, the `patch` command should be robust and idempotent.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'You can chain `update` and `patch` commands:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Downloading dependencies is helpful when they’re not already on the system.
    But what if they are? How can we use the local version instead?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Using the installed dependency where possible
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with version 3.24, CMake introduced a feature that allows `FetchContent`
    to skip downloading if the dependencies are already available locally. To enable
    this, simply add the `FIND_PACKAGE_ARGS` keyword to your declaration:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can guess, this keyword instructs the `FetchContent` module to use the
    `find_package()` function before initiating any downloads. If the package is found
    locally, it will be used, and no download or build will occur. Note that this
    keyword should be the last one in the command, as it will consume all subsequent
    arguments.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to update the previous example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**ch09/06-fetch-content-find-package/CMakeLists.txt**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We made two key changes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: We added `FIND_PACKAGE_ARGS` with the `NAMES` keyword to specify that we’re
    looking for the `yaml-cpp` package. Without `NAMES`, CMake would default to using
    the `dependency-id`, which, in this case, is `external-yaml-cpp`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We added `INTERFACE_INCLUDE_DIRECTORIES` in the printed properties. This is
    a one-off check so we can manually verify whether we’re using the installed package
    or if a new one was downloaded.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before testing, make sure the package is actually installed on your system.
    If it’s not, you can install it using the following commands:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this setup, we can now build our project. If all goes well, you should
    see debug output from the `cmake_print_properties()` command. This will indicate
    that we’re using the local version, as shown in the `INTERFACE_INCLUDE_DIRECTORIES`
    property. Keep in mind that this output is specific to your environment, your
    mileage may vary.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you’re not using CMake 3.24, or if you want to support users with older
    versions, you might consider running the `find_package()` command manually. This
    way, you’ll only download packages that aren’t already installed:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Whichever method you choose, trying to use the local version first and downloading
    only if the dependency isn’t found is a thoughtful approach that offers the best
    user experience.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Before the introduction of `FetchContent`, CMake had a simpler module called
    `ExternalProject`. Although `FetchContent` is the recommended choice for most
    situations, `ExternalProject` still has its own set of advantages and can be useful
    in certain cases.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: ExternalProject
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, before `FetchContent` was introduced to CMake, another module
    was serving a similar purpose: `ExternalProject` (added in 3.0.0). As you can
    guess, it was used to fetch external projects from online repositories. Over the
    years, the module was gradually extended for different needs, resulting in quite
    a complicated command: `ExternalProject_Add()`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The `ExternalProject` module populates the dependencies during the build stage.
    That’s quite different from `FetchContent`, which executes in the configuration
    stage. Because of this difference, `ExternalProject` cannot import targets into
    the project like `FetchContent` does. On the other hand, `ExternalProject` can
    install dependencies directly into the system, execute their tests, and do other
    interesting things, like overriding the commands used for configuration and the
    build.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: There is a small set of use cases where this may be necessary. Since there’s
    a lot of overhead needed to use this legacy module effectively, treat it as a
    curiosity. We’re mostly introducing it here to show how the current method evolved
    from it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '`ExternalProject` offers an `ExternalProject_Add` command that configures the
    dependency. Here’s an example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As mentioned, it closely resembles the `FetchContent_Declare` from `FetchContent`.
    You’ll notice that there are two additional keywords in the example: `INSTALL_COMMAND`
    and `TEST_COMMAND`. In this case, they are used to suppress the installation and
    tests of the dependency, as they would normally execute during the build. `ExternalProject`
    executes many steps that are deeply configurable, and they execute in the following
    order:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '`mkdir`: Create a subdirectory for the external project.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`download`: Download the project files from a repository or URL.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`update`: Download updates if supported by the `fetch` method.'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`patch` : Execute a `patch` command that alters downloaded files.'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`configure`: Execute the configure stage.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`build`: Perform the build stage for CMake projects.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`install`: Install CMake projects.'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`test`: Execute the tests.'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of the steps, excluding `mkdir`, you can override the default behavior
    by adding a `<STEP>_COMMAND` keyword. There are plenty of other options – please
    refer to the online documentation for the full reference. If, for some reason,
    you’d like to use this method over the recommended `FetchContent`, there’s an
    ugly hack that can be applied to import the targets anyway by executing CMake
    within CMake. For more details, check out the `ch09/05-external-project` code
    example in the repository for this book.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Typically, we would rely on the library being available in the system. If it’s
    not, we’d resort to `FetchContent`, an approach that is particularly suitable
    for dependencies that are small and quick to compile.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: However, for more substantial libraries like Qt, this method could be time consuming.
    In such cases, package managers offering precompiled libraries tailored to the
    user’s environment become advisable. While tools like Apt or Conan provide solutions,
    they are either too system-specific or complex to be covered in this book. The
    good news is that most users can install the dependencies your project may require,
    as long as clear installation instructions are provided.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has equipped you with the knowledge to identify system-installed
    packages using CMake’s find modules and how to utilize the config files that come
    with the library. For older libraries that don’t support CMake but include `.pc`
    files, the PkgConfig tool and CMake’s bundled `FindPkgConfig` find module can
    be used.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the capabilities of the `FetchContent` module. This module
    allows us to download dependencies from various sources while configuring CMake
    to first scan the system, thereby avoiding unnecessary downloads. We touched upon
    the historical context of these modules and discussed the option of using the
    `ExternalProject` module for special cases.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: CMake is designed to automatically generate build targets when a library is
    located through most of the methods we’ve discussed. This adds a layer of convenience
    and elegance to the process. With this foundation in place, you’re ready to incorporate
    standard libraries into your projects.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn how to provide reusable code on a smaller scale
    with C++20 modules.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: CMake documentation – provided find modules:[https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find
    modules](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#findmodules)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake documentation – *Using Dependencies Guide*:[https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CMake and using git-submodule for dependence projects*:[https://stackoverflow.com/questions/43761594/](https://stackoverflow.com/questions/43761594/)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Piggybacking on PkgConfig:[https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config](https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use ExternalProject:[https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html](https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CMake FetchContent vs. ExternalProject*:[https://www.scivision.dev/cmake-fetchcontent-vs-external-project/](https://www.scivision.dev/cmake-fetchcontent-vs-external-project/)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using CMake with External Projects*:[http://www.saoe.net/blog/using-cmake-with-external-projects/](http://www.saoe.net/blog/using-cmake-with-external-projects/)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code94081075213645359.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
