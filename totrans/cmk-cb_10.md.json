["```cpp\n.\n├── CMakeLists.txt\n└── src\n    ├── bt-randomgen-example.f90\n    ├── CMakeLists.txt\n    ├── interfaces\n    │   ├── CMakeLists.txt\n    │   ├── interface_backtrace.f90\n    │   ├── interface_randomgen.f90\n    │   └── randomgen.c\n    └── utils\n        ├── CMakeLists.txt\n        └── util_strings.f90\n```", "```cpp\nmodule interface_backtrace\n\n  implicit none\n\n  interface\n    function backtrace(buffer, size) result(bt) bind(C, name=\"backtrace\")\n      use, intrinsic :: iso_c_binding, only: c_int, c_ptr\n      type(c_ptr) :: buffer\n      integer(c_int), value :: size\n      integer(c_int) :: bt\n    end function\n\n    subroutine backtrace_symbols_fd(buffer, size, fd) bind(C, name=\"backtrace_symbols_fd\")\n      use, intrinsic :: iso_c_binding, only: c_int, c_ptr\n      type(c_ptr) :: buffer\n      integer(c_int), value :: size, fd\n    end subroutine\n  end interface\n\nend module\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-01 LANGUAGES Fortran C)\n```", "```cpp\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/lib)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/lib)\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/bin)\nset(CMAKE_Fortran_MODULE_DIRECTORY\n  ${CMAKE_CURRENT_BINARY_DIR}/modules)\n```", "```cpp\nadd_subdirectory(src)\n```", "```cpp\nadd_subdirectory(interfaces)\nadd_subdirectory(utils)\n```", "```cpp\ninclude(FortranCInterface)\nFortranCInterface_VERIFY()\n```", "```cpp\nfind_package(Backtrace REQUIRED)\n```", "```cpp\nadd_library(bt-randomgen-wrap SHARED \"\")\n\ntarget_sources(bt-randomgen-wrap\n  PRIVATE\n    interface_backtrace.f90\n    interface_randomgen.f90\n    randomgen.c\n  )\n```", "```cpp\ntarget_link_libraries(bt-randomgen-wrap\n  PUBLIC\n    ${Backtrace_LIBRARIES}\n  )\n```", "```cpp\nadd_library(utils SHARED util_strings.f90)\n```", "```cpp\nadd_executable(bt-randomgen-example bt-randomgen-example.f90)\n```", "```cpp\ntarget_link_libraries(bt-randomgen-example\n  PRIVATE\n    bt-randomgen-wrap\n    utils\n  )\n```", "```cpp\nfunction backtrace(buffer, size) result(bt) bind(C, name=\"backtrace\")\n```", "```cpp\nset_source_files_properties(my_source_file.axx\n  PROPERTIES\n    LANGUAGE CXX\n  )\n```", "```cpp\nset_target_properties(my_target\n   PROPERTIES\n     LINKER_LANGUAGE Fortran\n   )\n```", "```cpp\n.\n├── CMakeLists.txt\n├── README.md\n└── src\n    ├── CMakeLists.txt\n    ├── linear-algebra.cpp\n    └── math\n        ├── CMakeLists.txt\n        ├── CxxBLAS.cpp\n        ├── CxxBLAS.hpp\n        ├── CxxLAPACK.cpp\n        └── CxxLAPACK.hpp\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-02 LANGUAGES CXX C Fortran)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\ninclude(GNUInstallDirs)\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\nset(CMAKE_Fortran_MODULE_DIRECTORY ${PROJECT_BINARY_DIR}/modules)\n```", "```cpp\nadd_subdirectory(src)\n```", "```cpp\nfind_package(BLAS REQUIRED)\nfind_package(LAPACK REQUIRED)\n```", "```cpp\ninclude(FortranCInterface)\nFortranCInterface_VERIFY(CXX)\n```", "```cpp\nFortranCInterface_HEADER(\n  fc_mangle.h\n  MACRO_NAMESPACE \"FC_\"\n  SYMBOLS DSCAL DGESV\n  )\n```", "```cpp\nadd_library(math \"\")\n\ntarget_sources(math\n  PRIVATE\n    CxxBLAS.cpp\n    CxxLAPACK.cpp\n  )\n\ntarget_include_directories(math\n  PUBLIC\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    ${CMAKE_CURRENT_BINARY_DIR}\n  )\n\ntarget_link_libraries(math\n  PUBLIC\n    ${LAPACK_LIBRARIES}\n  )\n```", "```cpp\nadd_executable(linear-algebra \"\")\n\ntarget_sources(linear-algebra\n  PRIVATE\n    linear-algebra.cpp\n  )\n\ntarget_link_libraries(linear-algebra\n  PRIVATE\n    math\n  )\n```", "```cpp\nFortranCInterface_HEADER(\n  fc_mangle.h\n  MACRO_NAMESPACE \"FC_\"\n  SYMBOLS DSCAL DGESV\n  )\n```", "```cpp\n#ifndef FC_HEADER_INCLUDED\n#define FC_HEADER_INCLUDED\n\n/* Mangling for Fortran global symbols without underscores. */\n#define FC_GLOBAL(name,NAME) name##_\n\n/* Mangling for Fortran global symbols with underscores. */\n#define FC_GLOBAL_(name,NAME) name##_\n\n/* Mangling for Fortran module symbols without underscores. */\n#define FC_MODULE(mod_name,name, mod_NAME,NAME) __##mod_name##_MOD_##name\n\n/* Mangling for Fortran module symbols with underscores. */\n#define FC_MODULE_(mod_name,name, mod_NAME,NAME) __##mod_name##_MOD_##name\n\n/* Mangle some symbols automatically. */\n#define DSCAL FC_GLOBAL(dscal, DSCAL)\n#define DGESV FC_GLOBAL(dgesv, DGESV)\n\n#endif\n```", "```cpp\n#include \"account.hpp\"\n\nAccount::Account() : balance(0.0) {}\n\nAccount::~Account() {}\n\nvoid Account::deposit(const double amount) { balance += amount; }\n\nvoid Account::withdraw(const double amount) { balance -= amount; }\n\ndouble Account::get_balance() const { return balance; }\n```", "```cpp\n#pragma once\n\nclass Account {\npublic:\n  Account();\n  ~Account();\n\n  void deposit(const double amount);\n  void withdraw(const double amount);\n  double get_balance() const;\n\nprivate:\n  double balance;\n};\n```", "```cpp\naccount = Account()\n\naccount.deposit(100.0)\naccount.withdraw(50.0)\n\nbalance = account.get_balance()\n```", "```cpp\n# describe the c++ interface\ncdef extern from \"account.hpp\":\n    cdef cppclass Account:\n        Account() except +\n        void deposit(double)\n        void withdraw(double)\n        double get_balance()\n\n# describe the python interface\ncdef class pyAccount:\n    cdef Account *thisptr\n    def __cinit__(self):\n        self.thisptr = new Account()\n    def __dealloc__(self):\n        del self.thisptr\n    def deposit(self, amount):\n        self.thisptr.deposit(amount)\n    def withdraw(self, amount):\n        self.thisptr.withdraw(amount)\n    def get_balance(self):\n        return self.thisptr.get_balance()\n```", "```cpp\n# define minimum cmake version\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\n# project name and supported language\nproject(recipe-03 LANGUAGES CXX)\n\n# require C++11\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\nif(NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE Release CACHE STRING \"Build type\" FORCE)\nendif()\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\n```", "```cpp\n# directory cointaining UseCython.cmake and FindCython.cmake\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake-cython)\n\n# this defines cython_add_module\ninclude(UseCython)\n\n# tells UseCython to compile this file as a c++ file\nset_source_files_properties(account.pyx PROPERTIES CYTHON_IS_CXX TRUE)\n\n# create python module\ncython_add_module(account account.pyx account.cpp)\n\n# location of account.hpp\ntarget_include_directories(account\n  PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}\n  )\n```", "```cpp\n# turn on testing\nenable_testing()\n\n# define test\nadd_test(\n  NAME\n    python_test\n  COMMAND\n    ${CMAKE_COMMAND} -E env ACCOUNT_MODULE_PATH=$<TARGET_FILE_DIR:account>\n    ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/test.py\n  )\n```", "```cpp\nimport os\nimport sys\nsys.path.append(os.getenv('ACCOUNT_MODULE_PATH'))\n\nfrom account import pyAccount as Account\n\naccount1 = Account()\n\naccount1.deposit(100.0)\naccount1.deposit(100.0)\n\naccount2 = Account()\n\naccount2.deposit(200.0)\naccount2.deposit(200.0)\n\naccount1.withdraw(50.0)\n\nassert account1.get_balance() == 150.0\nassert account2.get_balance() == 400.0\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build .\n$ ctest\n\n Start 1: python_test\n1/1 Test #1: python_test ...................... Passed 0.03 sec\n\n100% tests passed, 0 tests failed out of 1\n\nTotal Test time (real) = 0.03 sec\n```", "```cpp\n# directory contains UseCython.cmake and FindCython.cmake\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake-cython)\n\n# this defines cython_add_module\ninclude(UseCython)\n```", "```cpp\n# tells UseCython to compile this file as a c++ file\nset_source_files_properties(account.pyx PROPERTIES CYTHON_IS_CXX TRUE)\n\n# create python module\ncython_add_module(account account.pyx account.cpp)\n```", "```cpp\nadd_test(\n  NAME\n    python_test\n  COMMAND\n    ${CMAKE_COMMAND} -E env ACCOUNT_MODULE_PATH=$<TARGET_FILE_DIR:account>\n    ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/test.py\n  )\n```", "```cpp\n# describe the c++ interface\ncdef extern from \"account.hpp\":\n    cdef cppclass Account:\n        Account() except +\n        void deposit(double)\n        void withdraw(double)\n        double get_balance()\n```", "```cpp\n# describe the python interface\ncdef class pyAccount:\n    cdef Account *thisptr\n    def __cinit__(self):\n        self.thisptr = new Account()\n    def __dealloc__(self):\n        del self.thisptr\n    def deposit(self, amount):\n        self.thisptr.deposit(amount)\n    def withdraw(self, amount):\n        self.thisptr.withdraw(amount)\n    def get_balance(self):\n        return self.thisptr.get_balance()\n```", "```cpp\n#pragma once\n\n#define BOOST_PYTHON_STATIC_LIB\n#include <boost/python.hpp>\n\nclass Account {\npublic:\n  Account();\n  ~Account();\n\n  void deposit(const double amount);\n  void withdraw(const double amount);\n  double get_balance() const;\n\nprivate:\n  double balance;\n};\n\nnamespace py = boost::python;\n\nBOOST_PYTHON_MODULE(account) {\n  py::class_<Account>(\"Account\")\n      .def(\"deposit\", &Account::deposit)\n      .def(\"withdraw\", &Account::withdraw)\n      .def(\"get_balance\", &Account::get_balance);\n}\n```", "```cpp\n# define minimum cmake version\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\n# project name and supported language\nproject(recipe-04 LANGUAGES CXX)\n\n# require C++11\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# we default to Release build type\nif(NOT CMAKE_BUILD_TYPE)\n  set(CMAKE_BUILD_TYPE Release CACHE STRING \"Build type\" FORCE)\nendif()\n```", "```cpp\n# for testing we will need the python interpreter\nfind_package(PythonInterp REQUIRED)\n\n# we require python development headers\nfind_package(PythonLibs ${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} EXACT REQUIRED)\n```", "```cpp\n# now search for the boost component\n# depending on the boost version it is called either python,\n# python2, python27, python3, python36, python37, ...\n\nlist(\n  APPEND _components\n    python${PYTHON_VERSION_MAJOR}${PYTHON_VERSION_MINOR}\n    python${PYTHON_VERSION_MAJOR}\n    python\n  )\n\nset(_boost_component_found \"\")\n\nforeach(_component IN ITEMS ${_components})\n  find_package(Boost COMPONENTS ${_component})\n  if(Boost_FOUND)\n    set(_boost_component_found ${_component})\n    break()\n  endif()\nendforeach()\n\nif(_boost_component_found STREQUAL \"\")\n  message(FATAL_ERROR \"No matching Boost.Python component found\")\nendif()\n```", "```cpp\n# create python module\nadd_library(account\n  MODULE\n    account.cpp\n  )\n\ntarget_link_libraries(account\n  PUBLIC\n    Boost::${_boost_component_found}\n    ${PYTHON_LIBRARIES}\n  )\n\ntarget_include_directories(account\n  PRIVATE\n    ${PYTHON_INCLUDE_DIRS}\n  )\n```", "```cpp\n# prevent cmake from creating a \"lib\" prefix\nset_target_properties(account\n  PROPERTIES\n    PREFIX \"\"\n  )\n\nif(WIN32)\n  # python will not import dll but expects pyd\n  set_target_properties(account\n    PROPERTIES\n      SUFFIX \".pyd\"\n    )\nendif()\n```", "```cpp\n# turn on testing\nenable_testing()\n\n# define test\nadd_test(\n  NAME\n    python_test\n  COMMAND\n    ${CMAKE_COMMAND} -E env ACCOUNT_MODULE_PATH=$<TARGET_FILE_DIR:account>\n    ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/test.py\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build .\n$ ctest\n\n    Start 1: python_test\n1/1 Test #1: python_test ......................   Passed    0.10 sec\n\n100% tests passed, 0 tests failed out of 1\n\nTotal Test time (real) =   0.11 sec\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\n\nfind_package(PythonLibs ${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} EXACT REQUIRED)\n```", "```cpp\nlist(\n  APPEND _components\n    python${PYTHON_VERSION_MAJOR}${PYTHON_VERSION_MINOR}\n    python${PYTHON_VERSION_MAJOR}\n    python\n  )\n\nset(_boost_component_found \"\")\n\nforeach(_component IN ITEMS ${_components})\n  find_package(Boost COMPONENTS ${_component})\n  if(Boost_FOUND)\n    set(_boost_component_found ${_component})\n    break()\n  endif()\nendforeach()\nif(_boost_component_found STREQUAL \"\")\n  message(FATAL_ERROR \"No matching Boost.Python component found\")\nendif()\n```", "```cpp\nset_target_properties(account\n  PROPERTIES\n    PREFIX \"\"\n  )\n```", "```cpp\nBOOST_PYTHON_MODULE(account) {\n  py::class_<Account>(\"Account\")\n      .def(\"deposit\", &Account::deposit)\n      .def(\"withdraw\", &Account::withdraw)\n      .def(\"get_balance\", &Account::get_balance);\n}\n```", "```cpp\nmyaccount = Account()\n```", "```cpp\nfrom account import Account\n\naccount1 = Account()\n\naccount1.deposit(100.0)\naccount1.deposit(100.0)\n\naccount2 = Account()\n\naccount2.deposit(200.0)\naccount2.deposit(200.0)\n\n```", "```cpp\naccount1.withdraw(50.0)\n\nassert account1.get_balance() == 150.0\nassert account2.get_balance() == 400.0\n```", "```cpp\n#pragma once\n\n#include <pybind11/pybind11.h>\n\nclass Account {\npublic:\n  Account();\n  ~Account();\n\n  void deposit(const double amount);\n  void withdraw(const double amount);\n  double get_balance() const;\n\nprivate:\n  double balance;\n};\n\nnamespace py = pybind11;\n\nPYBIND11_MODULE(account, m) {\n  py::class_<Account>(m, \"Account\")\n      .def(py::init())\n      .def(\"deposit\", &Account::deposit)\n      .def(\"withdraw\", &Account::withdraw)\n      .def(\"get_balance\", &Account::get_balance);\n}\n```", "```cpp\n.\n├── account\n│   ├── account.cpp\n│   ├── account.hpp\n│   ├── CMakeLists.txt\n│   └── test.py\n└── CMakeLists.txt\n```", "```cpp\n# define minimum cmake version\ncmake_minimum_required(VERSION 3.11 FATAL_ERROR)\n\n# project name and supported language\nproject(recipe-05 LANGUAGES CXX)\n\n# require C++11\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\n```", "```cpp\nadd_subdirectory(account)\n```", "```cpp\n# turn on testing\nenable_testing()\n\n# define test\nadd_test(\n  NAME\n    python_test\n  COMMAND\n    ${CMAKE_COMMAND} -E env ACCOUNT_MODULE_PATH=$<TARGET_FILE_DIR:account>\n    ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/account/test.py\n  )\n```", "```cpp\ninclude(FetchContent)\n\nFetchContent_Declare(\n  pybind11_sources\n  GIT_REPOSITORY https://github.com/pybind/pybind11.git\n  GIT_TAG v2.2\n)\n\nFetchContent_GetProperties(pybind11_sources)\n\nif(NOT pybind11_sources_POPULATED)\n  FetchContent_Populate(pybind11_sources)\n\n  add_subdirectory(\n    ${pybind11_sources_SOURCE_DIR}\n    ${pybind11_sources_BINARY_DIR}\n    )\nendif()\n```", "```cpp\nadd_library(account\n  MODULE\n    account.cpp\n  )\n\ntarget_link_libraries(account\n  PUBLIC\n    pybind11::module\n  )\n\nset_target_properties(account\n  PROPERTIES\n    PREFIX \"${PYTHON_MODULE_PREFIX}\"\n    SUFFIX \"${PYTHON_MODULE_EXTENSION}\"\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build .\n$ ctest\n\n Start 1: python_test\n1/1 Test #1: python_test ...................... Passed 0.04 sec\n\n100% tests passed, 0 tests failed out of 1\n\nTotal Test time (real) = 0.04 sec\n```", "```cpp\n#include <pybind11/pybind11.h>\n\n// ...\n\nnamespace py = pybind11;\n\nPYBIND11_MODULE(account, m) {\n  py::class_<Account>(m, \"Account\")\n      .def(py::init())\n      .def(\"deposit\", &Account::deposit)\n      .def(\"withdraw\", &Account::withdraw)\n      .def(\"get_balance\", &Account::get_balance);\n}\n```", "```cpp\nadd_subdirectory(\n  ${pybind11_sources_SOURCE_DIR}\n  ${pybind11_sources_BINARY_DIR}\n  )\n```", "```cpp\nadd_library(account\n  MODULE\n    account.cpp\n  )\n\ntarget_link_libraries(account\n  PUBLIC\n    pybind11::module\n  )\n```", "```cpp\nset_target_properties(account\n  PROPERTIES\n    PREFIX ${PYTHON_MODULE_PREFIX}\n    SUFFIX ${PYTHON_MODULE_EXTENSION}\n  )\n```", "```cpp\n#include \"cpp_implementation.hpp\"\n\n#include <cassert>\n\nAccount::Account() {\n  balance = 0.0;\n  is_initialized = true;\n}\n\nAccount::~Account() {\n  assert(is_initialized);\n  is_initialized = false;\n}\n\nvoid Account::deposit(const double amount) {\n  assert(is_initialized);\n  balance += amount;\n}\n\nvoid Account::withdraw(const double amount) {\n  assert(is_initialized);\n  balance -= amount;\n}\n\ndouble Account::get_balance() const {\n  assert(is_initialized);\n  return balance;\n}\n```", "```cpp\n#pragma once\n\nclass Account {\npublic:\n  Account();\n  ~Account();\n\n  void deposit(const double amount);\n  void withdraw(const double amount);\n  double get_balance() const;\n\nprivate:\n  double balance;\n  bool is_initialized;\n};\n```", "```cpp\n#include \"account.h\"\n#include \"cpp_implementation.hpp\"\n\n#define AS_TYPE(Type, Obj) reinterpret_cast<Type *>(Obj)\n#define AS_CTYPE(Type, Obj) reinterpret_cast<const Type *>(Obj)\n\naccount_context_t *account_new() {\n  return AS_TYPE(account_context_t, new Account());\n}\n\nvoid account_free(account_context_t *context) { delete AS_TYPE(Account, context); }\n\nvoid account_deposit(account_context_t *context, const double amount) {\n  return AS_TYPE(Account, context)->deposit(amount);\n}\n\nvoid account_withdraw(account_context_t *context, const double amount) {\n  return AS_TYPE(Account, context)->withdraw(amount);\n}\n\ndouble account_get_balance(const account_context_t *context) {\n  return AS_CTYPE(Account, context)->get_balance();\n}\n```", "```cpp\n/* CFFI would issue warning with pragma once */\n#ifndef ACCOUNT_H_INCLUDED\n#define ACCOUNT_H_INCLUDED\n\n#ifndef ACCOUNT_API\n#include \"account_export.h\"\n#define ACCOUNT_API ACCOUNT_EXPORT\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct account_context;\ntypedef struct account_context account_context_t;\n\nACCOUNT_API\naccount_context_t *account_new();\n\nACCOUNT_API\nvoid account_free(account_context_t *context);\n\nACCOUNT_API\nvoid account_deposit(account_context_t *context, const double amount);\n\nACCOUNT_API\nvoid account_withdraw(account_context_t *context, const double amount);\n\nACCOUNT_API\ndouble account_get_balance(const account_context_t *context);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* ACCOUNT_H_INCLUDED */\n```", "```cpp\nfrom subprocess import check_output\nfrom cffi import FFI\nimport os\nimport sys\nfrom configparser import ConfigParser\nfrom pathlib import Path\n\ndef get_lib_handle(definitions, header_file, library_file):\n    ffi = FFI()\n    command = ['cc', '-E'] + definitions + [header_file]\n    interface = check_output(command).decode('utf-8')\n\n    # remove possible \\r characters on windows which\n    # would confuse cdef\n    _interface = [l.strip('\\r') for l in interface.split('\\n')]\n\n    ffi.cdef('\\n'.join(_interface))\n    lib = ffi.dlopen(library_file)\n    return lib\n\n# this interface requires the header file and library file\n# and these can be either provided by interface_file_names.cfg\n# in the same path as this file\n# or if this is not found then using environment variables\n_this_path = Path(os.path.dirname(os.path.realpath(__file__)))\n_cfg_file = _this_path / 'interface_file_names.cfg'\nif _cfg_file.exists():\n    config = ConfigParser()\n    config.read(_cfg_file)\n    header_file_name = config.get('configuration', 'header_file_name')\n    _header_file = _this_path / 'include' / header_file_name\n    _header_file = str(_header_file)\n    library_file_name = config.get('configuration', 'library_file_name')\n    _library_file = _this_path / 'lib' / library_file_name\n    _library_file = str(_library_file)\nelse:\n    _header_file = os.getenv('ACCOUNT_HEADER_FILE')\n    assert _header_file is not None\n    _library_file = os.getenv('ACCOUNT_LIBRARY_FILE')\n    assert _library_file is not None\n\n_lib = get_lib_handle(definitions=['-DACCOUNT_API=', '-DACCOUNT_NOINCLUDE'],\n                      header_file=_header_file,\n                      library_file=_library_file)\n\n# we change names to obtain a more pythonic API\nnew = _lib.account_new\nfree = _lib.account_free\ndeposit = _lib.account_deposit\nwithdraw = _lib.account_withdraw\nget_balance = _lib.account_get_balance\n\n__all__ = [\n    '__version__',\n    'new',\n    'free',\n    'deposit',\n    'withdraw',\n    'get_balance',\n]\n```", "```cpp\n.\n├── account\n│   ├── account.h\n│   ├── CMakeLists.txt\n│   ├── implementation\n│   │   ├── c_cpp_interface.cpp\n│   │   ├── cpp_implementation.cpp\n│   │   └── cpp_implementation.hpp\n│   ├── __init__.py\n│   └── test.py\n└── CMakeLists.txt\n```", "```cpp\n# define minimum cmake version\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\n# project name and supported language\nproject(recipe-06 LANGUAGES CXX)\n\n# require C++11\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# specify where to place libraries\ninclude(GNUInstallDirs)\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\n```", "```cpp\n# interface and sources\nadd_subdirectory(account)\n```", "```cpp\n# turn on testing\nenable_testing()\n\n# require python\nfind_package(PythonInterp REQUIRED)\n\n# define test\nadd_test(\n  NAME\n    python_test\n  COMMAND\n    ${CMAKE_COMMAND} -E env ACCOUNT_MODULE_PATH=${CMAKE_CURRENT_SOURCE_DIR}\n                            ACCOUNT_HEADER_FILE=${CMAKE_CURRENT_SOURCE_DIR}/account/account.h\n                            ACCOUNT_LIBRARY_FILE=$<TARGET_FILE:account>\n    ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/account/test.py\n  )\n```", "```cpp\nadd_library(account\n  SHARED\n    implementation/c_cpp_interface.cpp\n    implementation/cpp_implementation.cpp\n  )\n\ntarget_include_directories(account\n  PRIVATE\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    ${CMAKE_CURRENT_BINARY_DIR}\n  )\n```", "```cpp\ninclude(GenerateExportHeader)\ngenerate_export_header(account\n  BASE_NAME account\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build .\n$ ctest\n\n    Start 1: python_test\n1/1 Test #1: python_test ...................... Passed 0.14 sec\n\n100% tests passed, 0 tests failed out of 1\n```", "```cpp\n# ...\n\ndef get_lib_handle(definitions, header_file, library_file):\n    ffi = FFI()\n    command = ['cc', '-E'] + definitions + [header_file]\n    interface = check_output(command).decode('utf-8')\n\n    # remove possible \\r characters on windows which\n    # would confuse cdef\n    _interface = [l.strip('\\r') for l in interface.split('\\n')]\n\n    ffi.cdef('\\n'.join(_interface))\n    lib = ffi.dlopen(library_file)\n    return lib\n\n# ...\n\n_this_path = Path(os.path.dirname(os.path.realpath(__file__)))\n_cfg_file = _this_path / 'interface_file_names.cfg'\nif _cfg_file.exists():\n    # we will discuss this section in chapter 11, recipe 3\nelse:\n    _header_file = os.getenv('ACCOUNT_HEADER_FILE')\n    assert _header_file is not None\n    _library_file = os.getenv('ACCOUNT_LIBRARY_FILE')\n    assert _library_file is not None\n\n_lib = get_lib_handle(definitions=['-DACCOUNT_API=', '-DACCOUNT_NOINCLUDE'],\n                      header_file=_header_file,\n                      library_file=_library_file)\n\n# ...\n```", "```cpp\n# we change names to obtain a more pythonic API\nnew = _lib.account_new\nfree = _lib.account_free\ndeposit = _lib.account_deposit\nwithdraw = _lib.account_withdraw\nget_balance = _lib.account_get_balance\n\n__all__ = [\n    '__version__',\n    'new',\n    'free',\n    'deposit',\n    'withdraw',\n    'get_balance',\n]\n```", "```cpp\nimport account\n\naccount1 = account.new()\n\naccount.deposit(account1, 100.0)\n```", "```cpp\nfrom account import lib\n\naccount1 = lib.account_new()\n\nlib.account_deposit(account1, 100.0)\n```", "```cpp\naccount1 = account.new()\naccount.deposit(account1, 10.0)\n\naccount2 = account.new()\naccount.withdraw(account1, 5.0)\naccount.deposit(account2, 5.0)\n```", "```cpp\nadd_test(\n  NAME\n    python_test\n  COMMAND\n    ${CMAKE_COMMAND} -E env ACCOUNT_MODULE_PATH=${CMAKE_CURRENT_SOURCE_DIR}\n                            ACCOUNT_HEADER_FILE=${CMAKE_CURRENT_SOURCE_DIR}/account/account.h\n                            ACCOUNT_LIBRARY_FILE=$<TARGET_FILE:account>\n    ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/account/test.py\n  )\n```", "```cpp\nstruct account_context;\ntypedef struct account_context account_context_t;\n\nACCOUNT_API\naccount_context_t *account_new();\n\nACCOUNT_API\nvoid account_free(account_context_t *context);\n\nACCOUNT_API\nvoid account_deposit(account_context_t *context, const double amount);\n\nACCOUNT_API\nvoid account_withdraw(account_context_t *context, const double amount);\n\nACCOUNT_API\ndouble account_get_balance(const account_context_t *context);\n```", "```cpp\ninclude(GenerateExportHeader)\ngenerate_export_header(account\n  BASE_NAME account\n  )\n```", "```cpp\nfrom cffi import FFI\nimport numpy as np\n\n_ffi = FFI()\n\ndef return_array(context, array_len):\n\n    # create numpy array\n    array_np = np.zeros(array_len, dtype=np.float64)\n\n    # cast a pointer to its data\n    array_p = _ffi.cast(\"double *\", array_np.ctypes.data)\n\n    # pass the pointer\n    _lib.mylib_myfunction(context, array_len, array_p)\n\n    # return the array as a list\n    return array_np.tolist()\n```", "```cpp\nadd_library(account\n  SHARED\n    implementation/fortran_implementation.f90\n  )\n```", "```cpp\ntype :: account\n  private\n  real(c_double) :: balance\n  logical :: is_initialized = .false.\nend type\n```", "```cpp\nmodule account_implementation\n\n  use, intrinsic :: iso_c_binding, only: c_double, c_ptr\n\n  implicit none\n\n  private\n\n  public account_new\n  public account_free\n  public account_deposit\n  public account_withdraw\n  public account_get_balance\n\n  type :: account\n    private\n    real(c_double) :: balance\n    logical :: is_initialized = .false.\n  end type\n\ncontains\n\n  type(c_ptr) function account_new() bind (c)\n    use, intrinsic :: iso_c_binding, only: c_loc\n    type(account), pointer :: f_context\n    type(c_ptr) :: context\n\n    allocate(f_context)\n    context = c_loc(f_context)\n    account_new = context\n    f_context%balance = 0.0d0\n    f_context%is_initialized = .true.\n  end function\n\n  subroutine account_free(context) bind (c)\n    use, intrinsic :: iso_c_binding, only: c_f_pointer\n    type(c_ptr), value :: context\n    type(account), pointer :: f_context\n\n    call c_f_pointer(context, f_context)\n    call check_valid_context(f_context)\n    f_context%balance = 0.0d0\n    f_context%is_initialized = .false.\n    deallocate(f_context)\n  end subroutine\n\n  subroutine check_valid_context(f_context)\n    type(account), pointer, intent(in) :: f_context\n    if (.not. associated(f_context)) then\n        print *, 'ERROR: context is not associated'\n        stop 1\n    end if\n    if (.not. f_context%is_initialized) then\n        print *, 'ERROR: context is not initialized'\n        stop 1\n    end if\n  end subroutine\n\n  subroutine account_withdraw(context, amount) bind (c)\n    use, intrinsic :: iso_c_binding, only: c_f_pointer\n    type(c_ptr), value :: context\n    real(c_double), value :: amount\n    type(account), pointer :: f_context\n\n    call c_f_pointer(context, f_context)\n    call check_valid_context(f_context)\n    f_context%balance = f_context%balance - amount\n  end subroutine\n\n  subroutine account_deposit(context, amount) bind (c)\n    use, intrinsic :: iso_c_binding, only: c_f_pointer\n    type(c_ptr), value :: context\n    real(c_double), value :: amount\n    type(account), pointer :: f_context\n\n    call c_f_pointer(context, f_context)\n    call check_valid_context(f_context)\n    f_context%balance = f_context%balance + amount\n  end subroutine\n\n  real(c_double) function account_get_balance(context) bind (c)\n    use, intrinsic :: iso_c_binding, only: c_f_pointer\n    type(c_ptr), value, intent(in) :: context\n    type(account), pointer :: f_context\n\n    call c_f_pointer(context, f_context)\n    call check_valid_context(f_context)\n    account_get_balance = f_context%balance\n  end function\n\nend module\n```"]