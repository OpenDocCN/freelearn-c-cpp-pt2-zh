- en: Alternative Generators and Cross-compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a CMake project in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-compiling a hello world example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-compiling a Windows binary with OpenMP parallelization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake does not build executables and libraries on its own. Instead, CMake configures
    a project and *generates* files used by another build tool or framework to build
    the project. On GNU/Linux and macOS, CMake typically generates Unix Makefiles,
    but a number of alternatives exist. On Windows, these are typically Visual Studio
    project files or MinGW or MSYS Makefiles. CMake includes a wide range of generators
    for native command-line build tools or integrated development environments (IDEs).
    You can read more about them at the following link: [https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'These generators can be selected using `cmake -G`, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all generators are available on every platform and, depending on the platform
    where CMake runs, typically only a subset is available. To see a list of all available
    generators on the current platform, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we will not cycle through all the available generators but
    we note that most recipes in this book have been tested using the `Unix Makefiles`,
    `MSYS Makefiles`, `Ninja`, and `Visual Studio 15 2017` generators. In this chapter,
    we will focus on developing on/for the Windows platform. We will demonstrate how
    to build a CMake project directly using Visual Studio 15 2017, without using the
    command line. We will also discuss how to cross-compile a Windows executable on
    a Linux or macOS system.
  prefs: []
  type: TYPE_NORMAL
- en: Building a CMake project using Visual Studio 2017
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-13/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-13/recipe-01) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: While earlier versions of Visual Studio required developers to edit source code
    and run CMake commands in different windows, Visual Studio 2017 introduces built-in
    support for CMake projects ([https://aka.ms/cmake](https://aka.ms/cmake)), which
    allows for the entire coding, configuring, building, and testing workflow to happen
    within the same IDE. In this recipe, we will test this and build a simple "hello
    world" CMake example project directly using Visual Studio 2017, without resorting
    to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will use the Windows platform and download and install Visual Studio
    Community 2017 ([https://www.visualstudio.com/downloads/](https://www.visualstudio.com/downloads/)).
    At the time of writing, this version is freely available with a 30-day trial period. The
    steps which we will follow are also nicely explained in this video: [https://www.youtube.com/watch?v=_lKxJjV8r3Y](https://www.youtube.com/watch?v=_lKxJjV8r3Y).
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the installer, make sure to select Desktop development with C++
    on the left panel and also verify that Visual C++ tools for CMake is checked on
    the Summary panel to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e7b747b-5049-444e-a5ce-f261aa133fca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Visual Studio 2017 15.4, you can also build code for the Linux platform.
    For this, select Linux development with C++ under Other Toolsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51a1afdc-95b9-49b2-93f8-e8e1f766d757.png)'
  prefs: []
  type: TYPE_IMG
- en: With this option enabled, you can target both Windows and Linux machines from
    within Visual Studio provided you have configured access to a Linux server. However,
    we will not demonstrate this approach in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will build a Windows binary on Windows, and our goal will
    be to configure and build the following example code (`hello-world.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create the corresponding source code, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory and place `hello-world.cpp` in the newly created directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this directory, create a `CMakeLists.txt` file which contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Open Visual Studio 2017, then navigate to the newly created folder which contains
    both the source file and `CMakeLists.txt` by the following File | Open | Folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the folder is open, notice how the CMake configure step is run automatically
    (bottom panel):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/455fb1b1-7946-474e-abb3-c8c2c157c7df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can right-click on `CMakeLists.txt` (right panel) and select Build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e119f318-5f04-4643-a154-f04eeee87cd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This builds the project (see the output on the bottom panel):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/093bbdb8-c08f-4a58-bf51-983446b33482.png)'
  prefs: []
  type: TYPE_IMG
- en: This successfully compiled the executable. In the next subsection, we will learn
    how to locate the executable and possibly change the build and install paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that Visual Studio 2017 nicely interfaces to CMake, and we have
    been able to configure and build the code from within the IDE. In addition to
    the build step, we could have run install or test steps. These are accessible
    by right-clicking on `CMakeLists.txt` (right panel).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the configuration step was run automatically and we might prefer to
    modify configuration options. We would also like to know the actual build and
    install paths so that we can test our executable. For this, we can select CMake
    | Change CMake Settings, and we arrive at the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b40fbce2-b515-4f7d-9e40-e36da1b31157.png)'
  prefs: []
  type: TYPE_IMG
- en: In the top-left panel, we can now inspect and modify the generator (in this
    case, Ninja), settings, arguments, as well as paths. The build path is highlighted
    in the preceding screenshot. The settings are grouped into build types (`x86-Debug`,
    `x86-Release`, and so on) and we can toggle between these build types in the middle
    of the top panel bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the actual build path, we can test the compiled executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The build and install paths can, of course, be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake support in Visual Studio: [https://aka.ms/cmake](https://aka.ms/cmake)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual C++ for Linux Development with CMake: [https://blogs.msdn.microsoft.com/vcblog/2017/08/25/visual-c-for-linux-development-with-cmake/](https://blogs.msdn.microsoft.com/vcblog/2017/08/25/visual-c-for-linux-development-with-cmake/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official documentation for Visual Studio: [https://www.visualstudio.com/vs/features/ide/](https://www.visualstudio.com/vs/features/ide/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-compiling a hello world example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-13/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-13/recipe-01) and
    has a C++ example. This recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will reuse the "Hello World" example from the previous recipe
    and cross-compile the code from Linux or macOS to Windows. In other words, we
    will configure and compile the code on Linux or macOS and obtain an executable
    for the Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start with a simple hello world example (`hello-world.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also use the unchanged `CMakeLists.txt` from the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To cross-compile the source code, we will need to install a cross-compiler for
    C++ and optionally for C and Fortran. One option is to use packaged MinGW compilers.
    As an alternative to packaged cross-compilers, we can also build a suite of cross-compilers
    from sources using MXE (the M cross environment): [http://mxe.cc](http://mxe.cc).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create three files in this cross-compilation "hello world" example
    following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory holding `hello-world.cpp` and `CMakeLists.txt`, which we
    listed previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `toolchain.cmake` file which contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adjust the `CMAKE_CXX_COMPILER` to the corresponding compiler (path).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, configure the code by pointing `CMAKE_TOOLCHAIN_FILE` to the toolchain
    file (in this example, the MXE compilers built from sources were used):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us build the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have obtained `hello-world.exe` on Linux. Copy the binary to a
    Windows computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On a Windows computer, we can observe the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the binary works on Windows!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we configure and build the code on a host environment (in this case, GNU/Linux
    or macOS) that is different than the target environment (Windows), we need to
    provide CMake with information about the target environment which we have encoded
    in the `toolchain.cmake` file ([https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling)).
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, we provide the name of the target operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we specify the compiler(s), for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple example, we did not have to detect any libraries or header files
    but, if we had to, we would specify the root path using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The target environment can, for instance, be the one provided by an MXE installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we adjust the default behavior of the find commands. We instruct CMake
    to search headers and libraries in the target environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And to search programs in the host environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a more detailed discussion of the various options, see [https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling).
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling a Windows binary with OpenMP parallelization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-13/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-13/recipe-02) and
    has a C++ and Fortran example. The recipe is valid with CMake version 3.9 (and
    higher) and has been tested on GNU/Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will apply what we have learned in the previous recipe,
    albeit to a more interesting and realistic example: we will cross-compile a Windows
    binary which is parallelized using OpenMP.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the unmodified source code from [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs,* Recipe 5, *Detecting the OpenMP parallel environment*.
    The example code sums up all natural numbers up to *N* (`example.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` file is largely unchanged with respect to [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml),
    *Detecting External Libraries and Programs,* Recipe 5, *Detecting the OpenMP parallel
    environment*, except there is an additional install target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will manage to cross-compile an OpenMP-parallelized
    Windows executable:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory holding `example.cpp` and `CMakeLists.txt`, which we listed
    previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use the same `toolchain.cmake` as in the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Adjust the `CMAKE_CXX_COMPILER` to the corresponding compiler (path).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, configure the code by pointing `CMAKE_TOOLCHAIN_FILE` to the toolchain
    file (in this example, the MXE compilers built from sources were used):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us build the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Copy the binary `example.exe` to a Windows computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On a Windows computer, we can see the following example output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the binary works on Windows and we can observe a speed-up thanks
    to the OpenMP parallelization!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have successfully built an executable for parallel execution on the Windows
    platform using cross-compilation with a simple toolchain. We were able to specify
    the number of OpenMP threads by setting `OMP_NUM_THREADS`. Going from 1 thread
    to 2 threads, we have observed a reduction of runtime from 2.6 to 1.3 seconds.
    For a discussion of the toolchain file, please see the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to cross-compile for a set of target platforms, for instance,
    Android. For examples, we refer the reader to [https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html).
  prefs: []
  type: TYPE_NORMAL
