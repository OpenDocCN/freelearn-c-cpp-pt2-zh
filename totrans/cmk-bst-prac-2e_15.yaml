- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-Platform-Compiling Custom Toolchains
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the powerful features of CMake is its support for the cross-platform
    building of software. Simply put, this means that with CMake, a project from any
    platform can be built for any other platform, if the necessary tools are available
    on the system running CMake. When building software, we typically talk about compilers
    and linkers, and they are, of course, essential tools for building software. However,
    if we take a closer look, there are often some other tools, libraries, and files
    involved when building software. Collectively, these are commonly known as toolchains
    in CMake.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: So far in this book, all the examples were built for the system that CMake was
    running on. In these cases, CMake usually does a pretty good job of finding the
    correct toolchain to use. However, if the software is built for another platform,
    the toolchain usually must be specified by the developer. Toolchain definitions
    might be relatively straightforward and just specify the target platform, or they
    might be as complex as specifying paths to individual tools needed to build the
    software, or specific compiler flags to create binaries for a specific chipset.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In the context of cross-compiling, toolchains are often accompanied by `root`
    folder for finding the necessary libraries and files to compile and link the software
    to the intended target platform.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: While cross-compiling might be intimidating at first, it is often not as hard
    as it seems when using CMake properly. In this chapter, we will look at how to
    use toolchain files and how to write them yourself. We will look in detail at
    which tools are involved at particular stages of building software. Finally, we
    will look at how to set up CMake so that it can run tests with an emulator.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following main topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Using existing cross-platform toolchain files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating toolchain files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing cross-compiled binaries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a toolchain for supported features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be proficient in handling existing toolchains
    and in how to build and test software for different platforms, using CMake. We
    will take a deeper look into how to test a compiler for a certain feature to determine
    whether it suits our purposes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the previous chapters, the examples are tested with CMake 3.25 and
    are run on either of the following compilers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The **GNU Compiler Collection 9** (**GCC 9**) or newer, including the cross-compiler
    for the **arm hard float** (**armhf**) architecture
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang 12 or newer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Visual Studio C++ 19** (**MSVC 19**) or newer'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the Android examples, the **Android Native Development Kit** (**Android
    NDK**) 23b or newer is required. Instructions on installation can be found in
    the official Android developer documentation: [https://developer.android.com/studio/projects/install-ndk](https://developer.android.com/studio/projects/install-ndk).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the Apple-embedded examples, Xcode 12 or newer and the **iOS Software Development
    Kit 12.4** (**iOS SDK 12.4**) are recommended.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All examples and source code are available in the GitHub repository for this
    book. If any of the software is missing, the corresponding examples will be excluded
    from the build. The repository can be found here: [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Using existing cross-platform toolchain files
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building software for multiple platforms, the most straightforward way
    to do this is to compile software on the target system itself. The downside of
    that is that each developer has to have a running version of the target system
    to build the software. If these are desktop systems, that might work reasonably
    well, although moving between different installations to develop the software
    also makes the developer workflow quite tedious. Less powerful devices such as
    embedded systems might be very uncomfortable because of the lack of proper development
    tools, or because compiling the software takes very long.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, a much more convenient way from the developer’s perspective is to
    use cross-compiling. This means the software engineer writes code and builds the
    software on their own machine, but the resulting binaries are for a different
    platform. The machine and platform on which the software is built are usually
    called the *host machine* and *host platform*, whereas the platform on which the
    software should run is called the *target platform*. For instance, the developer
    writes code on their *x64* desktop machine running Linux, but the resulting binaries
    are for embedded Linux on an *arm64* processor. So, the host platform is *x64
    Linux* and the target platform is *arm64 Linux*. To cross-compile software, the
    following two things are needed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: A toolchain capable of producing binaries in the correct format
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any dependencies of the project compiled for the target system
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The toolchain is a set of tools, such as a compiler, linker, and archiver, to
    produce binaries that run on the host system but produce output for the target
    system. The dependencies are usually collected in a *sysroot* directory. Sysroots
    are directories containing a reduced version of a root filesystem where the needed
    libraries are stored. For cross-compilation, these directories serve as the root
    to search for any dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Some tools, such as the `CMAKE_TOOLCHAIN_FILE` variable or, since CMake 3.21,
    with the `--toolchain` option, like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These calls are equivalent. If `CMAKE_TOOLCHAIN_FILE` is set as an environment
    variable, CMake will interpret this as well. If you use CMake presets, the configure
    presets may configure a toolchain file with the `toolchainFile` option, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `toolchainFile` option supports macro expansion, as described in [*Chapter
    9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible Build Environments*.
    If the path to the toolchain file is a relative path, CMake will first look relative
    to the `build` directory, and if the file is not found there, it will then search
    from the source directory. As `CMAKE_TOOLCHAIN_FILE` is a cache variable, it only
    needs to be specified for the first run of CMake; subsequent runs will use the
    cached value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first run, CMake will perform some internal queries to establish which
    features a toolchain supports. This happens regardless of whether the toolchain
    is specified with a toolchain file or if the default system toolchain is used.
    A more in-depth look at how these tests happen is provided in the *Testing a toolchain
    for supported features* section. CMake will output the results of the tests for
    the various features and properties on the first run, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The detection of the features mostly happens on the first call to `project()`
    in a `CMakeLists.txt` file. However, any later call to `project()` that enables
    a previously disabled language further detection will then be triggered. The same
    happens if `enable_language()` is used to enable an additional programming language
    in a `CMakeLists.txt` file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: As the features and test results of the toolchains are cached, changing the
    toolchain of a configured build directory cannot be done. CMake might detect that
    the toolchain has changed, but usually, the replacement of the cache variables
    is incomplete. Because of this, the build directory should be fully deleted before
    changing the toolchain.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Switching toolchains after configuration
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Always clear the build directory completely before switching toolchains. Deleting
    only the `CMakeCache.txt` file will not be enough, as toolchain-related things
    might be cached in various locations. If you regularly build projects for multiple
    platforms, using separate build directories for each toolchain can speed up the
    development process considerably.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: CMake works under the paradigm that a project should use the same toolchain
    for everything. Because of this, using multiple toolchains is not directly supported.
    If this is really needed, the parts of a project that need a different toolchain
    have to be configured as sub-builds, as described in [*Chapter 10*](B30947_10.xhtml#_idTextAnchor158),
    *Handling Distributed Repositories and Dependencies in* *a Super-Build*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Toolchains should be kept as small as possible and be completely decoupled from
    any project. Ideally, they are reusable for different projects. Often, toolchain
    files come bundled together, with any SDK or sysroot used for cross-compiling.
    However, they sometimes need to be written manually.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Creating toolchain files
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Toolchain files might seem intimidating at first, but on closer inspection,
    they are often relatively trivial. The misconception that defining cross-compilation
    toolchains is hard stems from the fact that there are many overly complicated
    examples of toolchain files found on the internet. Many of them were written for
    early versions of CMake and, thus, implemented many additional tests and checks
    that are now part of CMake itself. CMake toolchain files basically do the following
    things:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Define the target system and architecture.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide paths to any tools needed to build the software for the defined platform.
    Often, these are just compilers.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set default flags for the compiler and linkers.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point to the sysroot and possibly any staging directory if cross-compiling.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set hints for the search order of any `find_` commands of CMake. Changing the
    search order is something the project might define, and it is debatable whether
    this belongs in the toolchain file or should be handled by the project. See [*Chapter
    5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries and
    Dependency Management*, for details on `find_` commands.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample toolchain doing all these things might look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example would define a toolchain targeting a build for a Linux operating
    system running on an `/usr/bin/` folders on the host system. Then, the compiler
    flags to print all warnings demanded by strict `-pedantic` flag. Next, the sysroot
    to find any required libraries is set to `/home/builder/raspi-sysroot/`, and the
    staging directory to install things when cross-compiling is set to `/home/builder/raspi-sysroot-staging/`.
    Finally, the search behavior for CMake is changed so that programs are searched
    only on the host system but libraries, `include` files, and packages are only
    searched in the sysroot. It is a controversial debate whether a toolchain file
    should influence the search behavior or not. Typically, only the project knows
    what it is trying to find, so making assumptions in the toolchain file might break
    that. However, only the toolchain knows which system root to use and what kinds
    of files are present inside it, so having the toolchain define this might be convenient.
    A good compromise is to use a CMake preset to define the toolchain and the search
    behavior, instead of putting it either in the project or the toolchain file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Defining the target system
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The target system for cross-compiling is defined by the following three variables
    – `CMAKE_SYSTEM_NAME`, `CMAKE_SYSTEM_PROCESSOR`, and `CMAKE_SYSTEM_VERSION`. These
    correspond to the `CMAKE_HOST_SYSTEM_NAME`, `CMAKE_HOST_SYSTEM_PROCESSOR`, and
    `CMAKE_HOST_SYSTEM_VERSION` variables, respectively, which describe the platform
    on which the build is performed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The `CMAKE_SYSTEM_NAME` variable describes the target operating system for which
    the software is to be built. Setting this variable is important, as this will
    cause CMake to set the `CMAKE_CROSSCOMPILING` variable to `true`. Typical values
    are `Linux`, `Windows`, `Darwin`, `Android`, or `QNX`, although you could use
    more specific platform names, such as `WindowsPhone`, `WindowsCE`, or `WindowsStore`.
    For bare-metal embedded devices, the `CMAKE_SYSTEM_NAME` variable is set to `Generic`.
    Unfortunately, at the time of writing, there exists no official list of supported
    systems in the CMake documentation. However, if necessary, the files in the `/Modules/Platform`
    folder in the local CMake installation can be inspected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The `CMAKE_SYSTEM_PROCESSOR` variable is used to describe the hardware architecture
    of the platform. If not specified, the value of the `CMAKE_HOST_SYSTEM_PROCESSOR`
    variable will be assumed. The target processor architecture should also be set
    when cross-compiling to a 32-bit platform from a 64-bit platform, even if the
    processors are of the same type. For Android and Apple platforms, the processor
    is often not specified. When cross-compiling for Apple targets, the actual device
    is defined by the SDK that is used, which is specified by the `CMAKE_OSX_SYSROOT`
    variable. When cross-compiling for Android, specialized variables such as `CMAKE_ANDROID_ARCH_ABI`,
    `CMAKE_ANDROID_ARM_MODE`, and (optionally) `CMAKE_ANDROID_ARM_NEON` are used to
    control the target architecture. Building for Android will be covered in more
    depth in the *Cross-compiling for* *Android* section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The last variable to define a target system is `CMAKE_SYSTEM_VERSION`. The content
    of it depends on the system being built. For `WindowsCE`, `WindowsStore`, and
    `WindowsPhone`, it will be used to define which version of the Windows SDK to
    use. On Linux, it is often omitted or might contain the kernel revision of the
    target system if this is relevant.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `CMAKE_SYSTEM_NAME`, `CMAKE_SYSTEM_PROCESSOR`, and `CMAKE_SYSTEM_VERSION`
    variables, target platforms are usually fully specified. However, some generators
    such as Visual Studio support their native platforms directly. For these, the
    architecture can be set with the `-A` command-line option of CMake, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When using a preset, the `architecture` setting may be used in a configure preset
    for the same effect. Once the target system is defined, the tools to actually
    build the software are defined.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers, such as Clang and `CMAKE_<LANG>_COMPILER_TARGET` variable is
    used. For Clang, the value is a target triple such as `arm-linux-gnueabihf`, and
    for QNX GCC, the compiler name and target have a value such as `gcc_ntoarmv7le`.
    The supported triples for Clang are described in its official documentation at
    [https://clang.llvm.org/docs/CrossCompilation.html](https://clang.llvm.org/docs/CrossCompilation.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: For the available options for QNX, the QNX documentation found at [https://www.qnx.com/developers/docs/](https://www.qnx.com/developers/docs/)
    should be consulted.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a toolchain file that uses Clang might look something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, Clang is used to compile C and C++ code for a Linux system
    running on an ARM processor, with hardware floating-point support. Defining the
    target system often has a direct influence on the build tools that will be used.
    In the next section, we will look at how the compiler and the related tools are
    selected for cross-compilation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the build tools
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building software, the compiler is the tool that often comes to mind, and
    in most cases, it is sufficient to set the compiler in a toolchain file. The path
    to the compiler is set by the `CMAKE_<LANG>_COMPILER` cache variable, which may
    be set in the toolchain file or passed manually to CMake. If the path is absolute,
    it will be used directly; otherwise, the same search order as when using `find_program()`
    will be used, which is one of the reasons why changing the search behavior in
    a toolchain file has to be treated with care. If neither the toolchain file nor
    the user does not specify the compiler, CMake will try to choose one automatically
    based on the target platform and generator specified. Additionally, the compiler
    can be set over an environment variable that is named after `<LANG>`. So, `C`
    will set the C compiler, `CXX` the C++ compiler, `ASM` the assembler, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Some generators such as Visual Studio may support their own toolset definition,
    which works differently. They can be set with the `-T` command-line option. The
    following command would tell CMake to generate code for Visual Studio to produce
    binaries for a 32-bit system, but using 64-bit compilers to do so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The values might also be set with the `CMAKE_GENERATOR_TOOLSET` variable from
    a toolchain file. This should not be set inside a project, as it obviously does
    not conform to the idea of CMake project files being agnostic to the generator
    and platform used.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: For Visual Studio users, it is possible to have multiple competing instances
    of the same Visual Studio version installed by having the preview and official
    release of the same version installed. If this is the case, the `CMAKE_GENERATOR_INSTANCE`
    variable may be set to the absolute installation path of Visual Studio in the
    toolchain file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: By specifying the compiler to use, CMake will choose the default flags for the
    compiler and linker and make them available in the project, by setting `CMAKE_<LANG>_FLAGS`
    and `CMAKE_<LANG>_FLAGS_<CONFIG>`, where `<LANG>` stands for the respective programming
    language and `<CONFIG>` for the build configuration, such as debug or release.
    The default linker flags are set by the `CMAKE_<TARGETTYPE>_LINKER_FLAGS` and
    `CMAKE_<TARGETTYPE>_LINKER_FLAGS_<CONFIG>` variables, where `<TARGETTYPE>` is
    either `EXE`, `STATIC`, `SHARED`, or `MODULE`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'To add custom flags to the default flags, there exists a variable with `_INIT`
    appended to each of the variables – for example, `CMAKE_<LANG>_FLAGS_INIT`. When
    working with toolchain files, `_INIT` variables are used to set any necessary
    flags. A toolchain file compiling with GCC to a 32-bit target from a 64-bit host
    would look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For simple projects, setting up the target system and the toolchain might be
    already enough to start creating binaries, but for more complex projects, they
    might need access to libraries and headers of the target system. For such cases,
    sysroots can be specified in the toolchain files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Setting the sysroot
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When cross-compiling, all linked dependencies obviously have to match the target
    platform as well, and a common way of dealing with this is to create a sysroot,
    which is the root filesystem of the target system in a folder. While sysroots
    may contain full systems, they are often stripped down to just provide what is
    needed. Sysroots are described in detail in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible* *Build Environments*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Setting the sysroot is done by setting `CMAKE_SYSROOT` to its path. If this
    is set, CMake will, by default, look in the sysroot first for libraries and header
    files unless specified differently, as described in [*Chapter 5*](B30947_05.xhtml#_idTextAnchor084),
    *Integrating Third-Party Libraries and Dependency Management*. In most cases,
    CMake will also automatically set the necessary compiler and linker flags to make
    the tools work with the sysroot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In cases where the build artifacts should not be installed directly in the sysroot,
    the `CMAKE_STAGING_PREFIX` variable can be set to provide an alternative installation
    path. This is often the case when the sysroot should be kept clean or when it
    is mounted as read-only. Note that the `CMAKE_STAGING_PREFIX` setting will not
    add this directory to `CMAKE_SYSTEM PREFIX_PATH`, so things installed in the staging
    directory will only be found with `find_package()` if the `CMAKE_FIND_ROOT_PATH_MODE_PACKAGE`
    variable in the toolchain is set to `BOTH` or `NEVER`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Defining the target system and setting the toolchain configuration, the sysroot,
    and the staging directory are often all that are needed for cross-compiling. Two
    exceptions are cross-compiling for Android and Apple’s iOS, tvOS, or watchOS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling for Android
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the past, compatibility between Android’s NDK and various CMake versions
    was sometimes a bit of an unhappy relationship, as new versions of the NDK suddenly
    no longer worked the same way with CMake as previous releases did. However, this
    condition has now been vastly improved, as from the r23 version, the Android NDK
    now uses CMake’s internal support for toolchains. Together with a CMake version
    of 3.21 or higher, building for Android has become reasonably convenient, so using
    these or newer versions is recommended. The official documentation for the Android
    NDK’s integration with CMake can be found here: [https://developer.android.com/ndk/guides/cmake](https://developer.android.com/ndk/guides/cmake).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，Android的NDK与不同CMake版本之间的兼容性有时关系并不顺畅，因为NDK的新版本往往不再以与以前版本相同的方式与CMake协作。然而，从r23版本开始，这一情况得到了极大的改善，因为Android
    NDK现在使用CMake内部对工具链的支持。结合CMake 3.21或更高版本，为Android构建变得相对方便，因此推荐使用这些或更新的版本。关于Android
    NDK与CMake集成的官方文档可以在此处找到：[https://developer.android.com/ndk/guides/cmake](https://developer.android.com/ndk/guides/cmake)。
- en: 'As of r23, the NDK provides its own CMake toolchain file, located at `<NDK_ROOT>/build/cmake/android.toolchain.cmake`,
    which can be used like any regular toolchain file. The NDK also includes all necessary
    tools for a Clang-based toolchain, so usually, no further tools have to be defined.
    To control the target platform, the following CMake variables should be passed
    over the command line or by using a CMake preset:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从r23版本开始，NDK提供了自己的CMake工具链文件，位于`<NDK_ROOT>/build/cmake/android.toolchain.cmake`，可以像任何常规的工具链文件一样使用。NDK还包括所有必要的工具，以支持基于Clang的工具链，因此通常不需要定义其他工具。要控制目标平台，应通过命令行或使用CMake预设传递以下CMake变量：
- en: '`ANDROID_ABI`: Specifies the `armeabi-v7a`, `arm64-v8a`, `x86`, and `x86_64`.
    This should always be set when cross-compiling for Android.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_ABI`：指定`armeabi-v7a`、`arm64-v8a`、`x86`和`x86_64`。在为Android进行交叉编译时，这个变量应该始终设置。'
- en: '`ANDROID_ARM_NEON`: Enables NEON support for `armeabi-v7a`. This variable does
    not affect other ABI versions. When using an NDK above version r21, NEON support
    is enabled by default, and this rarely needs to be disabled.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_ARM_NEON`：为`armeabi-v7a`启用NEON支持。该变量不会影响其他ABI版本。使用r21版本以上的NDK时，默认启用NEON支持，通常不需要禁用它。'
- en: '`ANDROID_ARM_MODE`: Specifies whether to generate ARM or Thumb instructions
    for `armeabi-v7a`. Valid values are either `thumb` or `arm`. This variable does
    not affect other ABI versions.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_ARM_MODE`：指定是否为`armeabi-v7a`生成ARM或Thumb指令。有效值为`thumb`或`arm`。该变量不会影响其他ABI版本。'
- en: '`ANDROID_LD`: Decides whether the default linker or the experimental `lld`
    from `llvm` should be used. Valid values are `default` or `lld`, but this variable
    is usually omitted for production builds because of the experimental state of
    `lld`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_LD`：决定使用默认的链接器还是来自`llvm`的实验性`lld`。有效的值为`default`或`lld`，但由于`lld`处于实验阶段，这个变量通常在生产构建中被省略。'
- en: '`ANDROID_PLATFORM`: Specifies the minimum `$API_LEVEL`, `android-$API_LEVEL`,
    or `android-$API_LETTER` format, where `$API_LEVEL` is a number and `$API_LETTER`
    is the version code of the platform. `ANDROID_NATIVE_API_LEVEL` is a variable
    alias for this. While it is not strictly necessary to set the API level, this
    is usually done.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_PLATFORM`：指定最低的`$API_LEVEL`，`android-$API_LEVEL`，或`android-$API_LETTER`格式，其中`$API_LEVEL`是一个数字，`$API_LETTER`是平台的版本代码。`ANDROID_NATIVE_API_LEVEL`是该变量的别名。虽然设置API级别并非严格必要，但通常会进行设置。'
- en: '`ANDROID_STL`: Specifies which `c++_static` (which is the default), `c++_shared`,
    `none`, or `system`. Either `c++_shared` or `c++_static` are needed for modern
    C++ support. The `system` library only provides `new` and `delete` and C++ wrappers
    for the C library headers, while `none` provides no STL support at all.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID_STL`：指定使用哪种`c++_static`（默认值）、`c++_shared`、`none`或`system`。现代C++支持需要使用`c++_shared`或`c++_static`。`system`库仅提供`new`和`delete`以及C库头文件的C++封装，而`none`则完全不提供STL支持。'
- en: 'A call to CMake to configure an Android build could look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 调用CMake来配置Android构建的命令可能如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This call would specify a build that requires API level 23 or higher, which
    corresponds to Android 6.0 or higher for a 32-bit ARM **central processing** **unit**
    (**CPU**).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将指定需要API级别23或更高的构建，这对应于Android 6.0或更高版本的32位ARM **中央处理** **单元** (**CPU**)。
- en: An alternative to using the toolchain provided by the NDK is to point CMake
    to the location of the Android NDK, which is the recommended way with NDKs newer
    than version r23\. The configuration of the target platform then happens with
    the respective CMake variables. By setting the `CMAKE_SYSTEM_NAME` variable to
    `android` and the `CMAKE_ANDROID_NDK` variable to the location of the Android
    NDK, CMake is told to use the NDK. This can either happen over the command line
    or in a toolchain file. Alternatively, if the `ANDROID_NDK_ROOT` or `ANDROID_NDK`
    *environment variables* are set, they will be used as the value for `CMAKE_ANDROID_NDK`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the NDK in this way, the configuration is defined instead of the
    `CMAKE_` equivalent of the variables used when invoking the toolchain file of
    the NDK directly, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_ANDROID_API` or `CMAKE_SYSTEM_VERSION` is used to specify the minimum
    API level to build for'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_ANDROID_ARCH_ABI` is used to indicate which ABI mode to use'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_ANDROID_STL_TYPE` specifies which STL to be used'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample toolchain file to configure CMake with the Android NDK might look
    like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When cross-compiling for Android using Visual Studio generators, CMake requires
    either *NVIDIA Nsight Tegra Visual Studio Edition* or *Visual Studio tools for
    Android*, which uses the Android NDK. When using Visual Studio to build Android
    binaries, the built-in support for CMake’s Android NDK can be used by setting
    the `CMAKE_ANDROID_NDK` variable to the location of the NDK.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling native code for Android has become much easier with the recent
    versions of the NDK and the CMake versions from 3.20\. Another special case for
    cross-compiling is when targeting Apple’s iOS, tvOS, or watchOS.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling for iOS, tvOS, or watchOS
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recommended way to cross-compile for Apple’s iPhone, Apple TV, or Apple
    watches is to use the Xcode generator. Apple is quite restrictive in what you
    can use to build apps for these devices, so using macOS or a **virtual machine**
    (**VM**) running macOS is needed. While using Makefiles or Ninja files is possible,
    they require much more in-depth knowledge of the Apple ecosystem to be configured
    correctly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'To cross-compile for any of these devices, the Apple device SDK is needed,
    and the `CMAKE_SYSTEM_NAME` variable is set to `iOS`, `tvOS`, or `watchOS`, as
    in the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For reasonably modern SDKs and a CMake version of 3.14 or higher, this is usually
    all that is needed. By default, the latest device SDK available on the system
    is used, but different SDKs can be selected by setting the `CMAKE_OSX_SYSROOT`
    variable to the path of the SDK if needed. The minimum target platform version
    can be specified with the `CMAKE_OSX_DEPLOYMENT_TARGET` variable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'When cross-compiling for iPhone, Apple TV, or Apple Watches, the target can
    either be the real devices or the device simulator that comes with different SDKs.
    However, Xcode has built-in support to switch this during the build part, so CMake
    does not have to be run twice. CMake uses the `xcodebuild` command-line tool internally
    if the Xcode generator is selected, which supports the `-sdk` option to select
    the desired SDK. When building through CMake, this option can be passed like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will pass the `-sdk` option with the specified value to `xcodebuild`. The
    allowed values are `iphoneos` or `iphonesimulator` for iOS, `appletvos` or `appletvsimulator`
    for Apple TV devices, and `watchos` or `watchsimulator` for Apple Watches.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Apple-embedded platforms require the mandatory signing of certain build artifacts.
    For the Xcode generator, the development team `CMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM`
    cache variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: When building for Apple-embedded devices, the simulators come in handy to test
    code without the need to deploy to the devices each time. In this case, the testing
    is best done through Xcode or `xcodebuild` itself, but for other platforms, cross-compiled
    code can be tested through CMake and CTest directly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Testing cross-compiled binaries
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to effortlessly cross-compile binaries for different architectures
    adds much convenience to the developer workflows of the people involved, but often,
    these workflows do not stop at building the binaries and also include running
    tests. If the software also compiles on the host toolchain and the tests are generic
    enough, running tests on the host might be the easiest way to test the software,
    although it might cost you some time when switching the toolchains and rebuilding
    frequently. If this is not possible or too time-consuming, one alternative is,
    of course, to run any tests on the real target hardware, but depending on the
    availability of the hardware and the effort of setting up the tests on the hardware,
    this might also be rather cumbersome. Therefore, often, a practicable middle way
    is to run tests inside an emulator for the target platform if this is available.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To define an emulator to run tests, the `CROSSCOMPILING_EMULATOR` target property
    is used. It can either be set for individual targets or globally by setting the
    `CMAKE_CROSSCOMPILING_EMULATOR` cache variable, which contains a semicolon-separated
    list of the command and arguments to run the emulator. If set globally, the command
    will be prefixed to all commands specified in `add_test()`, `add_custom_command()`,
    and `add_custom_target()`, and it will be used to run any executables generated
    by the `try_run()` commands. This means that all custom commands that are used
    for a build must be accessible and runnable inside the emulator as well. The `CROSSCOMPILING_EMULATOR`
    property does not necessarily have to be an actual emulator – it can be any arbitrary
    program, such as a script that copies the binaries to a target machine and executes
    it there.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting `CMAKE_CROSSCOMPILING_EMULATOR` should either happen over a toolchain
    file, the command line, or a configured prefix. An example toolchain file used
    to cross-compile C++ code for ARM, using the popular open source emulator *QEMU*
    to run the tests, could look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In addition to setting the information of the target system and the toolchain
    to cross-compile the last line in the example, it sets the `emulator` command
    to `qemu-arm -L /path/to/arm/sysroot`. Let’s assume a `CMakeLists.txt` file contains
    a test defined like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When CTest is run instead of running `exampleExe` directly, the `test` command
    is transformed to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running tests in an emulator can speed up developer workflows quite a bit, as
    it might eliminate the need to switch between the host toolchain and the target
    toolchain and does not require the build artifacts to be moved to the target hardware
    for each superficial test. Using emulators like this also comes in handy for **continuous
    integration** (**CI**) builds where it might be hard to build on the real target
    hardware.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: A trick regarding `CMAKE_CROSSCOMPILING_EMULATOR` is that it also can be used
    to temporarily wrap tests in a diagnostic utility, such as *valgrind* or similar
    diagnostic tools. As running the specified emulator executable is not dependent
    on the `CMAKE_CROSSCOMPILING` variable that indicates whether a project is cross-compiled
    or not, a common pitfall with this workaround is that setting the `CMAKE_CROSSCOMPILING_EMULATOR`
    variable will impact the `try_run()` command, often used to test for supported
    features of the toolchain or any dependencies, and because a diagnostic utility
    might cause a compiler test to fail, it might be necessary to run it on an already
    cached build where any results of `try_run()` are already cached. Because of this,
    using the `CMAKE_CROSSCOMPILING_EMULATOR` variable to run diagnostic utilities
    should not be done permanently but, rather, in a specific development situation,
    when hunting defects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we mentioned CMake’s `try_run()` command, which, along with
    the closely related `try_compile()` command, is used to check for the availability
    of certain features in the compiler or the toolchain. In the next section, we
    will take a closer look at the two commands and feature-testing toolchains.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Testing a toolchain for supported features
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When CMake is run for the first time on a project tree, it performs various
    tests for compiler and language features. Any call to `project()` or `enable_language()`
    will trigger testing again, but the results may be already cached from a previous
    run. Caching is also the reason why switching toolchains on an existing build
    is not recommended.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in this section, CMake can check for quite a few features out
    of the box. Most of the checks will internally use the `try_compile()` command
    to perform these tests. This command essentially builds a small binary with the
    toolchain that is either detected or supplied by the user. All relevant global
    variables such as `CMAKE_<LANG>_FLAGS` will be forwarded to `try_compile()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Closely related to `try_complie()` is the `try_run()` command, which internally
    calls `try_compile()` and, if that succeeds, will try to run the program. For
    regular compiler checks, `try_run()` is not used, and any calls to it are usually
    defined in the project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'To write custom checks, rather than invoking `try_compile()` and `try_run()`
    directly, it is recommended to use the `CheckSourceCompiles` or `CheckSourceRuns`
    modules and the respective functions’ `check_source_compiles()` and `check_source_runs()`
    commands, which have been available since CMake 3.19\. In most cases, they will
    suffice to produce the necessary information without the need for more complicated
    handling of `try_compile()` or `try_run()`. The signatures of the two commands
    are very similar, as we can see here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `<lang>` parameter specifies one of the languages supported by Cmake, such
    as `C` or `CXX` for C++. `<code>` is the code as a string to be linked as an executable,
    so it must contain a `main()` function. The result of the compilation will be
    stored as a Boolean value in the `<resultVar>` cache variable. If `FAIL_REGEX`
    is provided for `check_source_compiles`, the output of the compilation will be
    checked against the expressions supplied. The code will be saved in a temporary
    file with the extension matching the language selected; if the file has an extension
    other than the default, it can be specified by the `SRC_EXT` option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also language-specific versions of the modules called `Check<LANG>SourceCompiles`
    and `Check<LANG>SourceRuns` that provide the respective commands, as illustrated
    in the following example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s assume that there is a C++ project that could either use the atomic functionality
    of the standard library or, if this is not supported, fall back to a different
    implementation. A compiler check for this might look like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After including the module, the `check_source_compiles()` function is called
    with a small program that uses the functionality to be checked. If the code compiles
    successfully, `HAS_STD_ATOMIC` will be set to `true`; otherwise, it will be set
    to `false`. The test is executed during the configuration of the project and will
    print a status message like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The result will be cached so that any subsequent run of CMake will not perform
    the test again. In a lot of cases, checking whether a program compiles already
    gives enough information about a certain feature of a toolchain, but sometimes,
    the underlying program has to be run to obtain the required information. To do
    this, `check_source_runs()` is analogous to `check_source_compiles()`. One caveat
    of `check_source_runs()` is this – if `CMAKE_CROSSCOMPILING` is set but no emulator
    command is set, then the test will only compile the test but not run it unless
    `CMAKE_CROSSCOMPILING_EMULATOR` is set.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of variables in the form of `CMAKE_REQUIRED_` to control
    how the checks compile the code. Note that these variables lack the language-specific
    part, which needs special care if working on projects that run tests for different
    languages. An explanation of some of these variables is provided here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_FLAGS` is used to pass additional flags to the compiler after
    any flags specified in the `CMAKE_<LANG>_FLAGS` or `CMAKE_<LANG>_FLAGS_<CONFIG>`
    variable.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_DEFINITIONS` specifies a number of compiler definitions of
    the form `-DFOO=bar`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_INCLUDES` specifies a list of directories to search for additional
    headers.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_LIBRARIES` specifies a list of libraries to add when linking
    programs. These can be the filenames of the libraries or imported CMake targets.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_LINK_OPTIONS` is a list of additional linker flags.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_QUIET` can be set to `true` to suppress any status messages
    from the checks.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In situations where the checks need to be isolated from each other, the `CMakePushCheckState`
    modules provide the `cmake_push_check_state()`, `cmake_pop_check_state()`, and
    `cmake_reset_check_state()` functions to store the configuration, restore a previous
    configuration, and reset the configuration, as illustrated in the following example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Underlying the commands to check compilation or run the test program are the
    more complicated `try_compile()` and `try_run()` commands, respectively. While
    available for use, they are mainly intended for internal use, and thus we refer
    to the official documentation of the commands instead of explaining them here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Checking compiler features by compiling and running programs is a very versatile
    approach to checking for toolchain features. Some checks are so common that CMake
    provides dedicated modules and functions for them.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Common checks for toolchain and language features
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For some of the most common feature checks, such as checking whether a compiler
    flag is supported or if a header file exists, CMake provides its own modules for
    convenience. Since CMake 3.19, the general modules that take the language as an
    argument exist, but the corresponding `Check<LANG>...` language-specific modules
    can still be used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'A very basic test to check whether a compiler for a certain language is available
    is done using the `CheckLanguage` module. It can be used to check whether a compiler
    for a certain language is available if the `CMAKE_<LANG>_COMPILER` variable is
    not set. An example to check whether Fortran is available could look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the check succeeds, the corresponding `CMAKE_<LANG>_COMPILER` variable is
    set. If the variable was set before the check, it has no effect.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '`CheckCompilerFlag` provides the `check_compiler_flag()` function to check
    whether the current compiler supports a certain flag. Internally, a very simple
    program will be compiled, and the output will be parsed for a diagnostic message.
    The check assumes that any compiler flags already present in `CMAKE_<LANG>_FLAGS`
    will run successfully through; otherwise, the `check_compiler_flag()` function
    will always fail. The following example checks whether the C++ compiler supports
    the `-``Wall` flag:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the `-Wall` flag is supported, the `WALL_FLAG_SUPPORTED` cache variable will
    be `true`; otherwise, it will be `false`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding module to check linker flags is called `CheckLinkerFlag`
    and works similarly to the check for compiler flags, but the linker flag will
    not be passed directly to the linker. As the linker will typically be invoked
    through the compiler, additional flags passed to the linker can use a prefix such
    as `-Wl` or `-Xlinker` to tell the compiler to pass the flag through. As this
    flag is compiler-specific, CMake provides the `LINKER:` prefix to automatically
    substitute the command. For example, to pass a flag to generate statistics about
    execution time and memory consumption to the linker, the following command would
    be used:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the linker supports the `-stats` flag, the `LINKER_STATS_FLAG_SUPPORTED`
    variable will be `true`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Other useful modules to check various things are the `CheckLibraryExists`, `CheckIncludeFile`,
    and `CheckIncludeFileCXX` modules, for checking whether a certain library or include
    file exists in certain locations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: CMake offers even more detailed checks that might be very specific to a project
    – for example, the `CheckSymbolExists` and `CheckSymbolExistsCXX` modules check
    whether a certain symbol exists either as a preprocessor definition, a variable,
    or a function. `CheckStructHasMember` will check whether a struct has a certain
    member, while `CheckTypeSize` can check the size of non-user types and the definition
    of C and C++ function prototypes with `CheckPrototypeDefinition`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, CMake offers quite a lot of checks, and the list of available
    checks will probably grow as CMake evolves. While checks are useful in certain
    situations, we should be careful not to carry the number of tests too far. The
    number and complexity of the checks will have quite an impact on the speed of
    the configuration step while sometimes not providing too much benefit. Having
    a lot of checks in a project could also suggest unnecessary complexity in it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Broad support for cross-compiling is one of the striking features of CMake.
    In this chapter, we looked at how to define a toolchain file for cross-compiling
    and how to use sysroots to use libraries for a different target platform. A special
    case of cross-compiling is Android and Apple mobile devices, which rely on their
    specific SDKs. With a brief excursion into using emulators or simulators for testing
    for other platforms, you now have all the essential information to start building
    quality software for various target platforms.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the chapter concerned itself with the advanced topic of testing
    toolchains for certain features. While most projects will not have to concern
    themselves with these details, they are nevertheless useful to know.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will discuss making CMake code reusable across multiple projects,
    without the need to rewrite everything again and again.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are toolchain files passed to CMake?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is usually defined in a toolchain file for cross-compiling?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a staging directory in the context of a sysroot?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can an emulator be passed to CMake for testing?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What triggers the detection of compiler features?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the configuration context for compiler checks be stored and restored?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the effect of the `CMAKE_CROSSCOMPILING` variable on compiler checks?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you fully clear the build directory when switching toolchains and
    not just delete the cache?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Toolchain files are passed either by the `--toolchain` command-line flag, the
    `CMAKE_TOOLCHAIN_FILE` variable, or with the `toolchainFile` option in a CMake
    preset.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Usually, the following things are done in a toolchain file for cross-compiling:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the target system and architecture
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Providing paths to any tools needed to build the software
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting default flags for the compiler and linkers
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pointing to the sysroot and possibly any staging directory if cross-compiling
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting hints for the search order for any `find_` commands of CMake
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The staging directory is set with the `CMAKE_STAGING_PREFIX` variable and is
    used as a place to install any built artifacts if the sysroot should not be modified.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The emulator command is passed as a semicolon-separated list in the `CMAKE_CROSSCOMPILING_EMULATOR`
    variable.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any call to `project()` or `enable_language()` in a project will trigger the
    detection of the features.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration context for compiler checks can be stored with `cmake_push_check_state()`
    and restored to a previous state with `cmake_pop_check_state()`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `CMAKE_CROSSCOMPILING` is set, any call to `try_run()` will compile the test
    but not run it, unless an emulator command is set.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build directories should be fully cleared because the temporary artifacts for
    compiler checks might not be rebuilt properly when just deleting the cache.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
