- en: 2 CMake Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing in CMake Language is a bit tricky. When you read a listfile for the
    first time - you may be under the impression that language there is so simple
    that it doesn’t require any special training or preparation. This approach is
    very often turned into a practical attempt to introduce changes and experiment
    with code without thorough understanding how it works. We, programmers are usually
    very busy and are overly keen to tackle these situations by learning in practice,
    guessing and so on. That "technique" of solving technical problems is called *voodoo
    programming*.
  prefs: []
  type: TYPE_NORMAL
- en: CMake offers this a bit unfortunate simplicity which creates an illusion that
    everything is as it should. After we have completed our small addition, a fix,
    a hack or "a quickie" - we realize that something isn't quite working. Time spent
    on debugging is often longer than actually studying the subject a bit better.
    Luckily this isn't our fate - because the chapter in front of us covers vast majority
    of this critical knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll not only understand the building blocks of CMake language: comments,
    commands, variables, and control structures, but we''ll also marry all of them
    with some background information on clean, modern CMake. You see: CMake puts you
    in a bit of a unique position: on one hand you perform a role of a build engineer.
    You need to understand all the intricacies of compilers, platforms and everything
    in-between. On the other: you''re a developer - you''re writing code that generates
    a buildsystem. Writing good code is hard and requires thinking on many levels
    at the same time: it should work, be easy to read, easy to reason about, extend
    and maintain. That''s exactly what we''re going to talk about here.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we'll introduce some of the most useful and common commands. Ones that
    aren't used that often you'll find in *the Appendix* (complete reference for String,
    List and File manipulation commands).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of CMake Syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Control Structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp](https://github.com/PacktPublishing/Modern-CMake-for-Cpp)
  prefs: []
  type: TYPE_NORMAL
- en: Basics of CMake Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Composing CMake code is very much like writing in any other imperative language:
    lines are executed from top to bottom, from left to right, occasionally stepping
    into an included file or called function. Depending on the mode (See *Chapter
    1 - Command Line*) the execution begins from root file of the source tree (`CMakeLists.txt`)
    or a `.cmake` script file that was passed as an argument to `cmake`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discussed in the previous chapter, scripts support the majority of CMake
    language (with the exclusion of project-related functionality). As such they''re
    great for an early practice of syntax itself and that''s why we''ll be using them
    here. After becoming comfortable writing basic listfiles - we''ll start preparing
    actual project files (in the next chapter). As a reminder - scripts can be run
    with following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmake -P script.cmake`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CMake supports 7-bit ASCII text files for portability across all platforms.
    You can use both `\n` or `\r\n` line endings. UTF-8 with optional Byte Order Markers
    is supported in CMake above 3.0 and UTF-16 in CMake above 3.2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Everything in a CMake listfile is either a command invocation or a comment.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two kinds of comments: single-line comments, and bracket (multiline)
    comments, just like in C++. But unlike in C++, bracket comments can be nested.
    Let me show you the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline comments get their name from their symbol, they start with an opening
    square bracket, any number of equal signs and another bracket: `[=[`. To close
    a bracket comment **use the same amount** of equal signs, and reverse the brackets
    like so: `]=]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepending opening bracket tokens with `#` is optional, and allows for quick
    uncommenting multiline comment by adding another `#` to first line of bracket
    comment like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's a nifty trick, but when and how to use comments in our CMake file? Since
    writing listfiles is essentially programming it is a good idea to bring best coding
    practices to them as well. Code following such practices is often called "clean"
    - it's a term coined over the years by software development gurus like Robert
    C. Martin, Martin Fowler and many other authors. What's considered helpful and
    harmful is often heavily disputed and as you guessed - comments come up as a subject
    more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything should be judged on a case-by-case basis, but generally agreed upon
    guideline says, that good comments provide at least one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Information** untangling complexities like regex patterns or formatting strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intent**, unobvious from implementation or interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clarification**, explaining concepts that can''t be easily refactored or
    changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning of consequences**, especially around code that can break other things'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amplification** underlining importance of idea that is hard to express in
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legal clauses**. A necessary evil, usually not a domain of a programmer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you can, avoid a comment, replace it with better naming, refactor or correct
    your code. If you possibly can, avoid the comments that are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mandated**, added for completeness, but not really important'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redundant**, repeating what is already clearly written in code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Misleading**, outdated or incorrect, as they didn''t follow code changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Journal**, noting what has been changed and when (use VCS for this)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dividers**, marking sections or otherwise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing elegant code without comments is hard, but it improves experience of
    the reader. Since we spend more time on reading than writing - we should insist
    on readable code rather than one quick to write. I recommend checking out *further
    reading* section at the end of the chapter for some good references on clean code.
    If you're interested in comments in particular - you'll find a link to one of
    my many YouTube videos touching on this subject in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Command Invocations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Time for some action! Invoking commands is the bread and butter of CMake listfiles.
    To execute a command, you must provide its name and parentheses in which you may
    enclose a whitespace separated list of **command arguments**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: An example of a command](img/file5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: An example of a command'
  prefs: []
  type: TYPE_NORMAL
- en: Command names aren't case sensitive, but there is a convention in CMake community
    to use `snake_case` in names (lower-case words joined with underscores). You can
    also define your own commands - we'll cover this in the *Control Structures* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What's especially striking in comparison to C++ is the fact that **command invocations
    in CMake are not expressions**. You can't provide another command as an argument
    to a called command, as *everything* between the parentheses is interpreted as
    an argument for that command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more outraging is the fact that CMake commands don''t require semicolons
    at the end of invocation. This may be because on each line of source can contain
    up to **one command invocation** followed by an optional single-line comment.
    Alternatively, entire line has to be part of bracket comment. So again, these
    are only allowed formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting a command after a bracket comment is not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After removing comments, whitespace and empty lines - we get a list of command
    invocations. This creates an interesting perspective: CMake syntax is really simple,
    but is that enough? How do we even work with variables? Or how to direct the flow
    of the execution?'
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake provides commands for above and much more. To make things easier we''ll
    be introducing the relevant commands as we move through different subjects, they
    can be grouped in three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting Commands are available always, they change the state of command processor,
    access variables, affect other commands and environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Commands are available in projects, they manipulate project state and
    build targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CTest Commands are available in CTest scripts, they manage testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll cover most useful scripting commands in this chapter (as they are also
    useful in projects). Project and CTest commands will be discussed in following
    chapters, as we introduce concepts of build targets (*Chapter 3,* *Setting up
    your first CMake project* ) and testing frameworks (*Chapter 8,* *Testing Frameworks*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtually every command relies on other elements of the language to be useful:
    variables, conditional statements, and first and foremost: the command line arguments.
    Let''s see how we should use them.'
  prefs: []
  type: TYPE_NORMAL
- en: Command Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many commands require whitespace-separated arguments to parametrize how they
    behave. As you saw in Figure 2.1 - there's something weird happening with the
    quotes around the arguments. Some arguments have quotes, others don't - what's
    up with that?
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, the only type recognized by CMake is a string. This is why
    every command expects zero or more strings for its arguments. But plain, static
    strings aren''t very useful, especially when we can''t nest command invocations.
    Here''s where arguments come into play: CMake will evaluate every argument to
    static string and then pass them into the command. Evaluating means string interpolation
    or simply: substituting parts of string with another value. This can mean replacing
    the *escape sequences*, expansion of **variable references** (also called variable
    interpolation) and unpacking of lists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the context we might want to enable such evaluation as needed
    and for that reason CMake offers three types of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Bracket Arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoted Arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unquoted Arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each type offers different level of evaluation and has a few small quirks about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Bracket Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bracket arguments aren't evaluated because they are used to **pass multiline
    strings verbatim**, as a single argument to commands. That means it will include
    whitespace like tabs and newlines.
  prefs: []
  type: TYPE_NORMAL
- en: 'These arguments are structured exactly like comments: opened with `[=[` and
    closed with `]=]` token, where the count of equal signs in tokens has to match
    (skipping equal sign is fine too). The only difference from comments is - that
    you can''t nest bracketed arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the exemplary use of such argument with `message()` command, which
    prints all passed arguments on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/01-arguments/bracket.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In above example we can see different forms of bracket argument. First one
    skips equal sign. Note, how putting closing tags in separate line is visible as
    empty line in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Second form is useful when we're passing a text containing double brackets `]]`(highlighted),
    so they won't be interpreted as a closure of the argument.
  prefs: []
  type: TYPE_NORMAL
- en: Such bracket arguments have limited use - typically to contain longer blocks
    of text. In most cases we'll need something more dynamic, like quoted arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Quoted Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Second type of arguments resembles a regular *C++ string*: they group together
    multiple characters including whitespace and they will expand *escape sequences*.
    Like *C++ strings* - they are opened, and closed with a double quote character
    `"`, and to use a literal quote - you have to escape it with a backslash: `\"`.
    Other well-known escape sequences are supported as well: `\\` denotes a literal
    backslash, `\t` is a tab character, `\n` is a newline, `\r` is a carriage return.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where similarities with *C++ strings* end. In contrast, Quoted Arguments
    can span multiple lines and they will interpolate variable references. Think of
    them as having a built-in `sprintf` from *C* or `std::format` from *C++20*. To
    insert a variable reference to your argument, wrap the name of the variable in
    a token like so: `${name}`. We''ll talk more about variable references in the
    *Variables* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try these arguments in action:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/01-arguments/quoted.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Can you guess how many lines will be in output of above script?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's right - we have one escaped quote character, escaped newline and a literal
    newline - all of them will be printed in the output. We also accessed a built-in
    variable `CMAKE_VERSION`, which we can see correctly interpolated at the last
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Unquoted Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last type of arguments is definitely a bit rare in programming world. We
    got used to the fact that strings have to be delimited in one way or another:
    using single quotes, double quotes or backticks. CMake deviates from this convention
    and introduces unquoted arguments. One might argue that dropping delimiters is
    easier to read, just like skipping semicolons. Is that true? I''ll let you form
    your own opinion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unquoted Arguments are evaluating both *escape sequences* and variable references.
    Be careful with semicolon `;` though: it is treated here as a delimiter. CMake
    will split the argument containing it into multiple arguments. If you need to
    use it - escape it with backslash (`\;`). This is how CMake manages lists. I''ll
    explain that in detail in the *List* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find that these arguments are the most perplexing to work with, so
    here''s visual help to clarify how such arguments are partitioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Escape sequences cause separate tokens to be interpreted as a
    single argument](img/file6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Escape sequences cause separate tokens to be interpreted as a single
    argument'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does it matter if a value is passed as a single argument or many?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Some CMake commands will work on arguments consuming them one by one. If your
    arguments get accidentally separated - you'll get hard to debug errors.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Unquoted arguments cannot contain unescaped quotes `"`, hashes `#` and backslashes
    `\`. And if that''s not enough rules: parentheses `()` are allowed only if they
    form correct, matching pairs. That is: you''ll start with an opening parenthesis
    and close it before closing the command argument list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the examples of all of above rules:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/01-arguments/unquoted.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What will be the output of above?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Even as simple command like `message()` is very particular about separated
    unquoted arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Space in **a single argument** was correctly printed when it was explicitly
    escaped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However **twoarguments** and **threeseparatearguments** were "glued" together
    - since `message()` doesn't add any spaces on its own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we understand how to deal with complexities and peculiarity of CMake
    arguments - we are ready to tackle the next interesting subject: working with
    all kinds of variables in CMake.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables in CMake are a surprisingly complex subject. Not only there are three
    categories of variables: normal, cache and environment variables, but they also
    reside on different scopes with specific rules on how one scope affect the other.
    Very often poor understanding of all these rules is a source of bugs and headaches.
    I recommend you study this section with care and make sure you know all concepts
    before moving on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with key facts about variables in CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names are case-sensitive and can be built with almost any character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All variables are stored internally as strings, even if some commands can interpret
    them as values of other types (even lists!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic variable manipulation commands are `set()` and `unset()` but there are
    other commands that can affect variables, like `string()` and `list()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set a variable we simply call `set()` providing its name and the value:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/02-variables/set.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you see use of bracket and quoted arguments allows for spaces in variable
    name. However, when referencing later it we have to escape whitespace with backslash
    `\`. For that reason, it is recommended to use only alphanumeric characters, `-`
    and `_` in variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also avoid reserved names (upper, lower, or mixed case) that begin with: `CMAKE_`,
    `_CMAKE_`, underscore `_` followed by name of any CMake Command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`set()` command accepts a plain text name of variable as first argument but
    `message()` uses a variable reference wrapped in `${}` syntax. What would happen
    if we were to provide variable wrapped in `${}` syntax to the `set()` command?
    To answer that we''ll need to understand variable references better.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To unset a variable we can use `unset()`, like so: `unset(MyString1)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I already mentioned references briefly when in *Command Arguments* section
    - as they''re evaluated for Quoted and Unquoted arguments. And we learned that
    to create a reference to defined variable we need to use the `${}` syntax like
    so: `message(${MyString1})`.'
  prefs: []
  type: TYPE_NORMAL
- en: On evaluation CMake will traverse the scope stack (I'll explain that in a second)
    and replace `${MyString1}` with a value or an empty string if no variable is found
    (no errors are reported). This process is called variable evaluation, expansion
    or interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such interpolation is done in inside-out fashion, this means two things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if a following reference is encountered: `${MyOuter${MyInner}}`. CMake
    will try to evaluate `MyInner` first, rather than searching for a variable named
    `MyOuter${MyInner}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second: if `MyInner` variable was successfully expanded - CMake will repeat
    expansion process until no further expansion is possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s consider an example with following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MyInner` with a value `Hello`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyOuter` with a value `${My`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'and we call command: `message("${MyOuter}Inner} World")` the output we''ll
    receive will be `Hello World,` and that is because `${MyOuter}` was replaced with
    a literal value `${My`, which combined with top-level `Inner}` creates another
    variable reference: `${MyInner}`.'
  prefs: []
  type: TYPE_NORMAL
- en: CMake will perform this expansion to the full extent, and only then pass resulting
    values as arguments to the command. This is why when we'd call `set(${MyInner}
    "Hi")` - we won't be actually changing the `MyInner` variable, but instead we'll
    change the `Hello` variable. CMake expands `${MyInner}` to `Hello`, and passes
    that string as first argument to the `set()` command along with new value `Hi`.
    Very often this is not what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable references are a bit peculiar in how they work when it comes to variable
    categories, but in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${}` syntax is used to reference normal *or cache variables*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ENV{}` syntax is used to reference environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$CACHE{}` syntax is used to reference cache variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's right, with `${}` you might get a value from one category or the other,
    I'll explain that in the *Scope* section. But first let's introduce other categories
    of variables, so we understand clearly what they are.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember that you can pass arguments to scripts through command line after a
    `--` token.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Values will be in `CMAKE_ARGV<n>` and count of passed arguments in `CMAKE_ARGC`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using the Environment Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the least complicated category of variables. CMake makes a copy of variables
    which were in the environment used to start the `cmake` process and makes them
    available in a single, global scope. To reference these variables, use the `$ENV{<name>}`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: CMake also allows you to `set()` and `unset()` these variables, but changes
    will be only made to local copy in the running `cmake` process, not the actual
    system environment and these changes won't be visible to subsequent runs of builds
    or tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify or create a variable use `set(ENV{<variable>} <value>)` command like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To clear an environment variable use `unset(ENV{<variable>})` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few environment variables that affect CMake behavior, control the
    build and CTest. CXX is one of them - it specifies what executable will be used
    for compiling C++ files. We''ll cover them as they will become relevant. Full
    list is available in the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html)'
  prefs: []
  type: TYPE_NORMAL
- en: If you use ENV variables as arguments to your commands, the values will be interpolated
    during the generation of buildsystem. This means that they will get baked into
    the build tree and changing the environment for build stage won't have any effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take for example following project file:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/03-environment/CMakeLists.txt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Above project has two steps: it will print `myenv` environment variable during
    the configuration, and it will add a build step through `add_custom_target()`
    that echoes the same variable as part of the build process. We can test what happens
    with a bash script that uses one value for configuration stage and another for
    build stage:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/03-environment/build.sh
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running above shows clearly, that value set during the configuration is persisted
    in the generated buildsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the Cache Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first mentioned cache variables when discussing command line options for
    `cmake` in *Chapter 1*. Essentially - they're persisted variables stored in `CMakeCache.txt`
    file in your build tree. They contain information gathered during the project
    configuration stage - both from the system (path to compilers, linkers, tools;
    and other), and from the user through GUI. Cache variables are not available in
    scripts (since there's no `CMakeCache.txt`), they only exist in projects.
  prefs: []
  type: TYPE_NORMAL
- en: Cache variables can be referenced with the `$CACHE{<name>}` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set cache variable use `set()` with following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(<variable> <value> CACHE <type> <docstring> [FORCE])`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you see there are some new required arguments (in comparison to `set()`
    for normal variables) also introduce some first keywords: `CACHE` and `FORCE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying `CACHE` as a `set()` argument means that we intend to change what
    was provided during configuration stage and imposes a requirement to provide variable
    `<type>` and `docstring`. This is because these variables are configurable by
    user and GUI needs to know how to display it. Following types are accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BOOL` - Boolean ON/OFF value. GUI will show a checkbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILEPATH` - Path to a file on disk. GUI will open a file dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATH` - Path to a directory on disk. GUI will open a directory dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STRING` - A line of text. GUI offers a text field or a drop-down selection
    if the `STRINGS` cache entry property is set (this can be done with `set_property()`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTERNAL` - A line of text. GUI skips internal entries. They may be used to
    store variables persistently across runs. Use of this type implies FORCE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<doctring>` is simply a label that will be displayed by the GUI next to the
    field to provide more detail about this setting to the user. It is required even
    for `INTERNAL` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting Cache variables follows the rules as environmental variables to some
    extent: values are overwritten only for the current execution of CMake. Take look
    at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Above call has no permanent effect if variable exists in cache. However, if
    value didn''t exist in cache or an optional `FORCE` argument was specified - the
    value will be persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the cache variables has some unobvious implication. That is: any normal
    variable with the same name will be removed. We''ll find out why in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder - cache variables can be managed from command line as well, check
    the appropriate section in *Chapter 1*.
  prefs: []
  type: TYPE_NORMAL
- en: How to correctly use the Variable Scope in CMake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variable scope is probably the hardest part of the whole concept. Maybe because
    we're so accustomed how things are done in more advanced languages that support
    namespaces and scope operators. CMake doesn't have those mechanisms so it deals
    with this issue in its own, a bit specific way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to clarify: variable scopes as a general concept are meant to separate
    different layers of abstraction such that when a user defined function is called
    - variables set in that function are local to it. These local variables aren''t
    affecting the global scope even if the names of local variables are exactly the
    same as global ones. If explicitly needed, function should have read/write access
    to global variables as well. This separation of variables (or scope) has to work
    on many levels - when one function calls another, the same separation rules apply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake supports two kinds of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Scope**: When custom functions defined with `function()` are executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directory Scope**: When a `CMakeLists.txt` listfile in a nested directory
    is executed from `add_subdirectory()` command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll cover above commands later in the book, first we need to know how the
    concept of variable scope is implemented. When a nested scope is created, CMake
    simply fills it with copies of all variables from the current scope. Subsequent
    commands will affect these copies. But as soon as the nested scope is completed
    - all copies are deleted and the original, parent scope is restored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: Parent scope sets variable `VAR` to `ONE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested scope starts, `VAR` is printed to console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VAR` is set to `TWO`, `VAR` is printed to console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested scope ends, `VAR` is printed to console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The console''s output will look like this: `ONE`, `TWO`, `ONE`. This is because
    the copied variable `VAR` is discarded after nested scope ends.'
  prefs: []
  type: TYPE_NORMAL
- en: How scope works in CMake has interesting implications that aren't that common
    in other languages. If you `unset()` a variable created in the parent scope while
    executing in a nested scope - it will disappear but only in the nested scope.
    When nested scope is completed - the variable is restored to its previous value.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to behavior of variable referencing, and the `${}` syntax. Whenever
    we try to access the normal variable CMake will reach to the variables of current
    scope and if variable with such name is defined - it will return its value. So
    far so good. However, when CMake can't find a variable with that name (it didn't
    exist, or was `unset()`) **- it will reach to the cache variables and return a
    value from there if a match is found**.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a possible gotcha, if we have a nested scope calling `unset()`. Depending
    on where we reference that variable: in the inner or the outer scope we''ll be
    accessing the cache or the original value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what we can do if we really need to change the variable in calling, parent
    scope? CMake has a `PARENT_SCOPE` flag you can add a the end of `set()` and `unset()`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That workaround is a bit limited, as it doesn't allow accessing variables more
    than one level up. Another thing worth noting is the fact that using `PARENT_SCOPE`
    doesn't change variables in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how variable scope works in practice and consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/04-scope/CMakeLists.txt
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We set global variable `V` to `1` and then call the `Outer` function, set `V`
    to `2`, call the `Inner` function and set `V` to `3`. After every step we print
    the variable to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As we explained previously: as we go deeper into the functions - the variable
    values are copied to the nested scope, but as we exit the scope - their original
    value is restored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What would the output be if we changed `set()` command of `Inner` function
    to operate on parent scope: `set(V 3 PARENT_SCOPE)`?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We affected the scope of the `Outer` function, but not the `Inner` scope or
    the global scope!
  prefs: []
  type: TYPE_NORMAL
- en: CMake documentation also mentions that CMake Scripts bind variables in one directory
    scope (which is a bit redundant, since the command effectively creating a directory
    scope, `add_subdirectory()` isn't allowed in scripts).
  prefs: []
  type: TYPE_NORMAL
- en: Since all variables are stored as strings, CMake has to use a bit more creative
    approach to more complex data structures like lists.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To store a list CMake concatenates all elements into a string with a semicolon
    as a delimiter as follows: `a;list;of;5;elements`. You can escape a semicolon
    in an element with a backslash like so: `a\;single\;element`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a list we can use the `set()` command: `set(myList a list of five
    elements)`. Because how lists are stored, the following commands will have exactly
    the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(myList "a;list;of;five;elements")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(myList a list "of;five;elements")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CMake automatically unpacks lists in Unquoted Arguments. Passing an unquoted
    `myList` reference like so: `message("the list is:" ${myList})` would cause the
    `message()` command to receive 6 arguments: `"the list is:", "a", "list", "of",
    "five", "elements"`. The output of course would be printed without any additional
    spaces between arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see - this is a very simple mechanism and should be taken with grain
    of salt.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake offers a `list()` command that provides multitude of subcommands to read,
    search, modify and order lists. Here''s a short summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time we don't really need to use lists in our projects. However,
    if you find yourself in that rare case where this concept would be convenient
    - you'll find a more in-depth reference of the `list()` command in the *Appendix*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to work with lists and variables of all kinds - let's shift
    our focus to control of execution flow and learn about Control Structures available
    in CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Control Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMake language wouldn''t be complete without Control Structures! Like everything
    else - they are provided in form of a command and they come in three categories:
    conditional blocks, loops and command definitions. Control structures are executed
    in scripts and during the build system generation for projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The only conditional block supported in CMake is the humble `if()`. Every such
    block has to be closed with `endif()` command and may have any number of `elseif()`
    commands and one optional `else()` command in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Exactly like in many other imperative languages, if-block controls which sets
    of commands will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: if the `<condition>` specified in arguments to the `if()` command is met - the
    first section will be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise CMake will execute commands in section belonging to the first `elseif()`
    command in this block that has met its `<condition>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no such commands - CMake will check if `else()` command is provided
    and execute any commands in that section of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If none of the above conditions is met - execution continues after the `endif()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provided `<condition>` is evaluated according to a very simple syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Condition Syntax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The same syntax is valid for `if()`, `elseif()` and `while()` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`if()` conditions supports `NOT`, `AND` and `OR` logical operators as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOT <condition>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<condition> AND <condition>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<condition> OR <condition>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, nesting of the conditions is possible with matching pairs of parentheses
    `()`. Like all decent languages, CMake respects the order of evaluation and starts
    from innermost parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(<condition>) AND (<condition> OR (<condition>))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation of a string and a variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For legacy reasons (because the variable reference `${}` syntax wasn''t always
    around), CMake will try to evaluate unquoted arguments as if they would be variable
    references. In other words: using a plain variable name `VAR` inside a condition
    is equal to writing `${VAR}`. Here''s an example for you to consider, and a gotcha:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`if()` condition works in a bit convoluted way here: first it will evaluate
    `${VAR2}` to `VAR1`, which is a recognized variable and is in turn evaluated to
    `FALSE` string. **Strings are considered Boolean true only if they equal any of
    following constants** (comparisons are case insensitive):'
  prefs: []
  type: TYPE_NORMAL
- en: '`ON`, `Y`, `YES`, `TRUE`'
  prefs: []
  type: TYPE_NORMAL
- en: a non-zero number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This brings us to a conclusion that condition in above example will be evaluated
    to false.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, here''s another catch: what would be the evaluation of an condition
    with an unquoted argument with a name of variable containing value like `BAR`?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'According to all we said so far - it would be false, since the string `BAR`
    doesn''t meet the criteria of Boolean true. That''s unfortunately not the case,
    because **CMake makes an exception when it comes to unquoted variable references**.
    Yes, an explicit `if("BAR")` would be considered a Boolean false, but since that
    same value is stored in a variable. But CMake will only evaluate `if(FOO)` to
    false only if it is any of following constants (comparisons are case insensitive):'
  prefs: []
  type: TYPE_NORMAL
- en: '`OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string ending with `-NOTFOUND`
  prefs: []
  type: TYPE_NORMAL
- en: an empty string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So simply asking for an undefined variable will be evaluated to **false**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But defining a variable beforehand changes situation and the condition is evaluated
    to **true**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you think that behavior of unquoted arguments is confusing - wrap variable
    references in quoted arguments: `if ("${FOO}")`. This will cause argument evaluation
    before it is passed into the `if()` command and behavior will be consistent with
    evaluation of strings.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In other words - CMake assumes that user is asking if variable is defined (and
    is not explicitly false). Luckily, we can explicitly check that fact (and not
    worry about value inside):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Comparing values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Comparison operations are supported with following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EQUAL`, `LESS`, `LESS_EQUAL`, `GREATER`, `GREATER_EQUAL`'
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be used to compare numeric values like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'CMake''s documentation states that if one of the operands is not a number -
    the value will be false. But practical experiments show that comparison of strings
    starting with a number work correctly: `if (20 EQUALS "20 GB")`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Compare software versions following the `major[.minor[.patch[.tweak]]]` format
    by adding a `VERSION_` prefix to any of the operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Omitted components are treated as zero and non-integer version component truncate
    the compared string at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'For lexicographical string comparisons we need to prepend an operator with
    `STR` prefix (note the lack of the underscore):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we often find out - that simply is not enough, fortunately CMake also supports
    POSIX regex matching (documentation hints at ERE flavor, but no support of character
    classes is mentioned). Use `MATCHES` operator like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<VARIABLE|STRING> MATCHES <regex>`'
  prefs: []
  type: TYPE_NORMAL
- en: Any matched groups are captured in CMAKE_MATCH_<n> variables.
  prefs: []
  type: TYPE_NORMAL
- en: Simple checks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already mentioned one simple check `DEFINED` but there are others that simply
    return true if a simple condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check if:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a value is in a list: `<VARIABLE|STRING> IN_LIST <VARIABLE>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a command is available for invocation: `COMMAND <command-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a CMake policy exists: `POLICY <policy-id>` (covered in *Chapter 3*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a CTest test was added with `add_test()`: `TEST <test-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'and if a build target is defined: `TARGET <target-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll get to build targets in *Chapter 4, Working with targets*, for now let's
    just say that targets are logical units of build process in project created with
    `add_executable()`, `add_library()`, or `add_custom_target()` command that has
    already been invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the filesystem
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'CMake provides many ways of working with files. We seldom need to manipulate
    them directly and we''d rather use more of a high-level approach. This book will
    provide a short reference of file-related commands in the *Appendix*. But most
    often only following operators will be needed (behavior is well-defined only for
    full paths):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check if file or directory exists: `EXISTS <path-to-file-or-directory>`It resolves
    symbolic links (returns true if the target of the symbolic link exists).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check which file is newer: `<file1> IS_NEWER_THAN <file2>`True if file1 is
    newer (or equal) than file2 or if one of the two files doesn’t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check if path is a directory: `IS_DIRECTORY path-to-directory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check if path is a symbolic link: `IS_SYMLINK file-name`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check if path is absolute: `IS_ABSOLUTE path`'
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Loops in CMake are fairly straightforward, we can use either `while()` or `foreach()`
    to repeatedly execute the same set of commands. Both of these commands support
    loop control mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`break()` stops the execution of remaining block and breaks from enclosing
    loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue()` stops the execution of current iteration and starts at the top
    of the next one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The loop block is opened with `while()` and closed with `endwhile()` commands.
    Any enclosed commands will be executed as long as the `<condition>` provided in
    `while()` is true. Syntax for phrasing the condition is the same as for the `if()`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You probably guessed that with some additional variables - the while loop can
    replace a for loop. Actually it's way easier to use a `forach()` loop for that
    - let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Foreach
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Foreach block comes in a few variants that execute enclosed commands for each
    value. Like other blocks it has opening and closing commands: `foreach()` and
    `endforeach()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplest form of foreach is meant to provide a C++-style for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: CMake will iterate from 0 to `<max>` (including). If we need more control, we
    can use second variant, providing `<min>`, `<max>` and optionally `<step>`. All
    arguments must be nonnegative integers. Also `<min>` has to be smaller than `<max>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `foreach()` shows its true colors when it is working with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake will take items from all provided `<lists>` followed by all explicitly
    stated `<items>` and store them in `<loop variable>` executing `<commands>` for
    every item one by one. You can choose to provide only lists, only items or both:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/06-loops/foreach.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Which will print
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use a short version (skipping the `IN`) for the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Since version 3.17 `foreach()` has learned how to `ZIP_LISTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Zipping lists means simply iterating through multiple lists and working on
    respective items with the same index. Let''s look at example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/06-loops/foreach.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake will create `num_<N>` variables, one for each list provided, which it
    will fill with item from each list. You can pass multiple `<loop_var>`s (one for
    every list) - each list will use a separate variable to store its items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If count of items differs between lists - CMake won't define variables for shorter
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: That's all when it comes to loops.
  prefs: []
  type: TYPE_NORMAL
- en: Command Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to define your own command: by using `macro()` or `function()`
    commands. Easiest way to explain the differences between them is comparing them
    to C-style preprocessor macros and actual C++ functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`macro()` works more like a find-and-replace instruction rather than actual
    subroutine call like `function()` with its own entry on a call stack. This means
    that calling `return()` in a macro will return to the calling statement one level
    higher than it would for a function (possibly terminating the execution if we''re
    already in a top scope).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only `function()` creates a separate scope for local variables. `macro()` works
    in the calling scope - which may lead to confusing results. Let's talk about details
    in next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both methods accept arguments which you can name and reference inside command
    block. Additionally, CMake allows you to access arguments passed in command call
    with following references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${ARGC}` - count of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${ARGV}` - list of all arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${ARG0}`, `${ARG1}`, `${ARG2}`… - value of argument at specific index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${ARGN}` - list of arguments passed past the last expected arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing numeric argument with index outside `ARGC` bounds is undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to define a command with named arguments - every call has to pass
    all of them or it will be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Macro
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Defining a macro is similar to any other block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: After such declaration we may execute our macro by calling its name (function
    calls are case-insensitive).
  prefs: []
  type: TYPE_NORMAL
- en: 'Following example explains all the problems with variable scope in macros:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/08-definitions/macro.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output from this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened? Despite explicitly setting `myVar` to `new value` - it didn''t
    affect the output for `message("argument: ${myVar}")`! This is because arguments
    passed to macros aren''t treated as real variables but rather as constant find-and-replace
    instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand - the variable `myVar` in global scope got changed from `first
    value` to `new value`. Such behavior is called a side effect and is considered
    a bad practice, since it's hard to tell which variables might get affected by
    such macro without reading it.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using functions whenever you can. Likely it will save you a lot
    of headaches.
  prefs: []
  type: TYPE_NORMAL
- en: Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To declare command as a function, follow this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Function requires a name and optionally accepts list of required arguments.
    As mentioned before - functions open their own scope. You can call `set()` providing
    one of named arguments of function and change will be local to the function (unless
    `PARENT_SCOPE` is specified, as we discussed in the *Variables: Scope* section).'
  prefs: []
  type: TYPE_NORMAL
- en: Functions follow the rules of call stack, enabling returning to calling scope
    with `return()` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake sets following variables for each function (available since version 3.17):'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_FUNCTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_FUNCTION_LIST_DIR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_FUNCTION_LIST_FILE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_FUNCTION_LIST_LINE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at functions in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/08-definitions/function.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Prints this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the general syntax and concept of functions is very similar
    to macros but this time - it actually works.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural paradigm in CMake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's imagine for a second that we want to write a CMake code like we would
    write a program in C++. We'll have a `CMakeLists.txt` listfile that will call
    three defined commands which may call defined commands of their own.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: A procedural call graph](img/file7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A procedural call graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing in such procedural style is a bit of a problem in CMake: you are required
    to provide command definitions you''re planning to use ahead of time. CMake parser
    will not have it any other way. Your code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: What a nightmare! Everything is reversed! This code is very difficult to read
    as the most miniscule details are at the top of the file. A correctly structured
    code lists the most general steps in first subroutine, and then provides a bit
    more detailed subroutines and pushes the most detailed steps to the very end of
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are solutions to this problem: moving command definitions to other files,
    partitioning scope across directories. But there is also one that is simple and
    elegant: declaring an entry-point macro at the top and calling it at the very
    end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: With this approach our code is written with gradually narrowing scope and because
    we're not actually calling the `main()` macro until the very end - CMake won't
    complain about execution of undefined commands!
  prefs: []
  type: TYPE_NORMAL
- en: 'One last question remains: why use macro over a recommended function? In this
    case it''s good to have unrestricted access to global variables and since we''re
    not passing any arguments to main - we don''t need to worry about the usual caveats.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll find a simple example of this concept in the `chapter-02/09-procedural/CMakeLists.txt`
    listfile.
  prefs: []
  type: TYPE_NORMAL
- en: A word on naming
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Naming is famously hard in software development but nevertheless very important
    to maintain solution that is easy to read and understand. When it comes to CMake
    scripts and projects all the rules of clean code apply as they would to normal
    software development solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Follow consistent naming style (`snake_case` is accepted standard in the CMake
    community).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use short but meaningful names (avoid `func()`, `f()` and such).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid puns and cleverness in your naming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use pronounceable, searchable names that don't require mental mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to properly invoke the commands with correct syntax, let's
    find which commands will be the most beneficial to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: Useful Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CMake offers many, many scripting commands with allow you to work with variables
    and environment. Some of them are covered extensively in the *Appendix*: `list()`,
    `string()`, `file()` (to avoid slowing us down on our road to projects). Others,
    like `find_...()` fit better in chapters that talk about managing dependencies.
    In this section we''ll shortly cover the most useful commands for scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: message()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We already know and love our trusty `message()` command that prints text to
    standard output. However there''s a lot more to it than meets the eye. By providing
    a `MODE` argument you can customize the style of the output and in case of an
    error stop the execution of the code: `message(<MODE> "text")`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recognized modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FATAL_ERROR` - stops processing and generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEND_ERROR` - continue processing, but skip generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING` - continue processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTHOR_WARNING` - CMake Warning (dev), continue processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEPRECATION` - works accordingly if variable `CMAKE_ERROR_DEPRECATED` or `CMAKE_WARN_DEPRECATED`
    is enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOTICE` or (none) - message printed to stderr to attract user’s attention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATUS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VERBOSE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRACE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following example stops execution after first message:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/10-useful/message_error.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Messages will be printed depending on current log-level (`STATUS` by default).
    We discussed how to change it previous chapter, in the *Options: Debugging & Tracing*
    section. I have then promised to talk about debugging with `CMAKE_MESSAGE_CONTEXT`
    - let''s get to it. Since then, we acquired three important pieces to this puzzle:
    lists, scope and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we enable a command line flag `cmake --log-context`, our messages will
    be decorated with dot-separated context stored in `CMAKE_MESSAGE_CONTEXT` list.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: chapter02/10-useful/message_context.cmake
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Output of above script will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Initial scope of function is copied from the parent scope (which has already
    one item in the list: `top`). First command in `foo` adds new item with function
    name `foo` to `CMAKE_MESSAGE_CONTEXT`. The message is printed and function scope
    ends, discarding the local, copied variables, and previous scope (without `foo`)
    is restored.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach is useful with many nested functions in very complex projects.
    Hopefully, you won't ever need it but I thought it is a really good example of
    how function scope works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another cool trick with `message()` is to add indentation to `CMAKE_MESSAGE_INDENT`
    list (exactly the same way as with `CMAKE_MESSAGE_CONTEXT`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Output from our scripts can then look a bit cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since CMake doesn't offer any real debugger with breakpoints or other tools
    - ability to produce clean log messages comes very handy when things don't go
    exactly as planned.
  prefs: []
  type: TYPE_NORMAL
- en: include()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can partition our CMake code into separate files to keep things ordered
    and… well separate. Then we can reference them from our parent listfile by calling
    `include()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If we provide a filename (path with a `.cmake` extension) - CMake will try to
    open and execute it. Note that no nested, separate scope will be created, so any
    changes to variables done in that file will affect the calling scope.
  prefs: []
  type: TYPE_NORMAL
- en: CMake will raise an error if file doesn't exist unless we specify that it is
    `OPTIONAL`. If we need to know if include was successful - we can provide a `RESULT_VARIABLE`
    keyword with a name of variable. It will be filled with a full path to included
    file on success or `NOTFOUND` on failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running in script mode any relative paths will be resolved from current
    working directory. To force searching in relation to the script itself provide
    an absolute path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If we don't provide a path but a name of a module (without `.cmake` or otherwise),
    CMake will try to find a module and include it. CMake will search for the file
    with name `<module>.cmake` in `CMAKE_MODULE_PATH` and then in the CMake module
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: include_guard()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we include files that have side effects, we might want to restrict them
    to only be included once. This is where `include_guard([DIRECTORY|GLOBAL])` comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Put `include_guard()` at the top of included file. When CMake encounters it
    for the first time - it will make a note of this fact in the current scope. If
    file gets included again (maybe because we don't control all files in our project)
    - it won't be processed any further.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to protect against inclusion in scopes that aren’t nested within
    each other - we should provide `DIRECTORY` or `GLOBAL` arguments. As names suggest
    - `DIRECTORY` guard will apply within current directory and below and `GLOBAL`
    applies to the whole build.
  prefs: []
  type: TYPE_NORMAL
- en: file()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To give you a hint of what you can do with CMake scripts - let''s take a quick
    glance at the most useful variants of file manipulation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In short, the `file()` command will let you read, write, transfer files, work
    with the filesystem, file locks, paths and archives; all in a system-independent
    manner. See the *Appendix* for details.
  prefs: []
  type: TYPE_NORMAL
- en: execute_process()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every now and then you''ll need to resort to tools available in the system
    (after all CMake is primarily a buildsystem generator). CMake offers a command
    for this purpose: you can use `execute_process()` to run other processes and collect
    their output. This command is a great fit for scripts, and can also be used in
    projects during the configuration stage. Here''s the general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake will use the API of operating system to create a child process (so shell
    operators like: `&&`, `||`, and `>` won''t work). However, you can still chain
    commands and pass output of one to another simply by providing the `COMMAND <cmd>
    <arguments>` arguments more than once.'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally you may use a `TIMEOUT <seconds>` to terminate process if it hasn't
    finished the task within the limit, and set the `WORKING_DIRECTORY <directory>`
    as you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exit codes of all tasks can be collected to a list by providing `RESULTS_VARIABLE
    <variable>` arguments. If you''re only interested in result of last executed command
    use the singular form: `RESULT_VARIABLE <variable>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To collect the output CMake provides two arguments: `OUTPUT_VARIABLE` and `ERROR_VARIABLE`,
    used in similar fashion. If you like to merge both `stdout` and `stderr` - use
    the same variable for both arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, that when writing projects for other users - you should make sure
    that the command you're planning to use is available on platforms you claim to
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter opened the door to actual programming with CMake - you're now able
    to write great, informative comments; invoke built-in commands and you understand
    how to correctly provide all kinds of arguments to them. This knowledge alone
    will help you understand a bit peculiar syntax of CMake listfiles you may have
    seen in other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we covered variables in CMake: how to reference, set and unset normal,
    cache and environment variables. We dove deep into how directory and function
    scopes work and what are the issues (and their workarounds) of nested scopes.'
  prefs: []
  type: TYPE_NORMAL
- en: We also covered lists and control structures. We discussed syntax of a condition,
    its logical operations, evaluation of unquoted arguments, strings and variables.
    We learned how to compare values, do simple checks and examine the state of the
    files in the system. This allows us to write conditional blocks and while loops.
    And while loops are the subject - we also grasped the syntax of the foreach.
  prefs: []
  type: TYPE_NORMAL
- en: I'm sure that knowing how to define your own commands with macro and function
    statements will help you write cleaner code in more procedural style. We also
    shared a few hints how to structure our code better and come up with more readable
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Finally - we were formally introduced to message() and its multiple log levels.
    We also studied how to partition and include listfiles and discovered a few other
    useful commands. I feel confident that with this material we are ready to tackle
    next chapter and write our first project in CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information you can refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean Code: A Handbook of Agile Software Craftsmanship (Robert C. Martin) [https://amzn.to/3cm69DD](https://amzn.to/3cm69DD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refactoring: Improving the Design of Existing Code (Martin Fowler) [https://amzn.to/3cmWk8o](https://amzn.to/3cmWk8o)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which comments in your code ARE GOOD? (Rafał Świdzinski) [https://youtu.be/4t9bpo0THb8](https://youtu.be/4t9bpo0THb8)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'StackOverflow - CMake syntax to set and use variables: [https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables](https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
