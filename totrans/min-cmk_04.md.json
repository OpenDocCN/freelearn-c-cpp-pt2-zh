["```cpp\ninclude(FetchContent)\nFetchContent_Declare(\n  timer_lib\n  GIT_REPOSITORY https://github.com/pr0g/timer_lib.git\n  GIT_TAG v1.0)\nFetchContent_MakeAvailable(timer_lib)\ntarget_link_libraries(${PROJECT_NAME} PRIVATE timer_lib)\n```", "```cpp\ninclude(FetchContent)\n```", "```cpp\ncd ch3/part-1\ncode CMakeHelpers.cmake\n```", "```cpp\nfunction(list_cmake_variables)\n  get_cmake_property(variable_names VARIABLES)\n  foreach(variable_name ${variable_names})\n    message(STATUS \"${variable_name}=${${variable_name}}\")\n  endforeach()\nendfunction()\n```", "```cpp\n...\nproject(example-project)\ninclude(CMakeHelpers.cmake)\n...\nlist_cmake_variables()\n```", "```cpp\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n```", "```cpp\nFetchContent_Declare(\n  timer_lib\n  GIT_REPOSITORY https://github.com/pr0g/timer_lib.git\n  GIT_TAG v1.0)\n```", "```cpp\nFetchContent_Declare(\n  CoolTimingLibrary\n  GIT_REPOSITORY https://github.com/pr0g/timer_lib.git\n  GIT_TAG v1.0)\nFetchContent_MakeAvailable(googletest-distribution, and the targets to depend on are gtest and gtest_main. For our purposes, naming the dependency in the context of our project as GoogleTest is very convenient and helps improve readability.\n\t\t\tThe next argument, `GIT_REPOSITORY`, is where to find and download the code. `GIT_REPOSITORY` is just one choice; there are several including `SVN_REPOSITORY` (Subversion), `HG_REPOSITORY` (Mercurial), and `URL` (ZIP file). For open source projects, Git is by far the most popular, but you have alternatives to Git, including but not limited to the preceding list of options.\n\t\t\tFetchContent and ExternalProject_Add\n\t\t\tIn this book, we’re explicitly covering `FetchContent` before `ExternalProject_Add` as it’s much easier to get to grips with initially (`ExternalProject_Add` is a useful command we’ll cover in more detail in [*Chapter 6*](B21152_06.xhtml#_idTextAnchor152), *Installing Dependencies and ExternalProject_Add*). Something to be aware of is that internally, `FetchContent` is implemented on top of `ExternalProject_Add`, so a lot of the configuration options are the same between the two. If you’re looking for more details about `FetchContent`, start with [https://cmake.org/cmake/help/latest/module/FetchContent.html](https://cmake.org/cmake/help/latest/module/FetchContent.html), but it can also be helpful to consult [https://cmake.org/cmake/help/latest/module/ExternalProject.html](https://cmake.org/cmake/help/latest/module/ExternalProject.html). This covers details such as download, and directory options shared between both `FetchContent` and `ExternalProject_Add`.\n\t\t\tUsing libraries from GitHub\n\t\t\tTo find the Git repository path referenced in the preceding subsection (where the project is hosted, in this case, GitHub), navigate to the project page ([https://github.com/pr0g/timer_lib](https://github.com/pr0g/timer_lib)), and then click the green **Code** dropdown toward the top right of the page:\n\t\t\t![Figure 3.1: GitHub UI for cloning a repository](img/B21152_03_1.jpg)\n\n\t\t\tFigure 3.1: GitHub UI for cloning a repository\n\t\t\tReturning to the `FetchContent_Declare` command, after `GIT_REPOSITORY`, we follow up with the `GIT_TAG` argument. `GIT_TAG` is flexible and supports a range of different identifiers. The first and perhaps most obvious is a **Git tag** (the identifier used in the examples presented so far). These are friendly names for Git commits and can signpost versions or releases of a project. To find available Git tags on GitHub, from the project page, click the **Tags** UI option toward the middle of the screen:\n\t\t\t![Figure 3.2: GitHub project page tags link](img/B21152_03_2.jpg)\n\n\t\t\tFigure 3.2: GitHub project page tags link\n\t\t\tThere you’ll see a list of tags (see *Figure 3**.3*). You can usually just note down the most recent one and add that after the `GIT_TAG` argument in your `FetchContent` command. If you need to depend on a particular version of the library, it’s possible to look back through the available tags and select the version you need:\n\t\t\t![Figure 3.3: GitHub tags list view](img/B21152_03_3.jpg)\n\n\t\t\tFigure 3.3: GitHub tags list view\n\t\t\tIf you are concerned that a Git tag may be removed in the future (which can sometimes happen), you can instead use the commit that’s referenced and add a comment after it in your `FetchContent_Declare` command, showing the tag it corresponds to:\n\n```", "```cpp\n\n\t\t\tIf a convenient tag is not available, the next best choice is to reference a specific commit hash. Looking at *Figure 3**.3*, we can see that the commit hash listed is `2d72171` (remember, a tag is just a friendly name for a commit). If we want to grab the most recent commit, we can find this from the GitHub project page by clicking the **Commits** link at the center-right of the screen:\n\t\t\t![Figure 3.4: GitHub project page commits link](img/B21152_03_4.jpg)\n\n\t\t\tFigure 3.4: GitHub project page commits link\n\t\t\tThis will list all commits chronologically, with the most recent commits appearing first. Clicking the **Copy** icon (*Figure 3**.5*) will copy the full commit SHA (hash) to the clipboard (don’t worry if you don’t know what this is; it’s just a unique reference to that commit):\n\t\t\t![Figure 3.5: GitHub copy commit SHA UI](img/B21152_03_5.jpg)\n\n\t\t\tFigure 3.5: GitHub copy commit SHA UI\n\t\t\tWe can then paste the content of our clipboard after `GIT_TAG` in our `FetchContent` command:\n\n```", "```cpp\n\n\t\t\tUsing branch names\n\t\t\tThere is one more type of argument that can be passed to `GIT_TAG`, and that is the branch name of your dependency. If `GIT_TAG` is omitted entirely, then CMake will default to the branch behavior, looking for a branch called `master` (most open source projects are moving away from this name and instead opting for `main`, used throughout this book, or `trunk`). It is generally not advisable to use a branch name because you lose the ability to maintain exact snapshots of your project history.\n\t\t\tIf your project depends on the `main` branch of `timer_lib`, and `timer_lib` is under active development, then in six months if you want to jump back to an earlier commit in your project and build it, there’s a very good chance your code will fail to compile. This is because it’ll be using the most recent version of `timer_lib`, not the one from six months ago.\n\t\t\tThis can be a huge pain. Depending on the rate of change, it can be hard to work out which commit your project would have been using at the time. There may be rare circumstances where setting `GIT_TAG` to a branch name makes sense. For example, when working in a development branch, it might be useful to temporarily set a branch name on `GIT_TAG` to make getting the most up-to-date changes from a dependency quicker (without having to remember to update the commit SHA every few days).\n\t\t\tIt’s important to remember to ensure your library has fixed `GIT_TAG` to a commit hash, or possibly a tag, for reliable, reproducible builds when you merge your changes back to your main branch (either by rebasing or squashing in Git parlance). You will thank yourself later when you inevitably have to use `git-bisect` to track down some horrendous bug.\n\t\t\tUsing local libraries with FetchContent\n\t\t\tBefore we discuss using the dependency we’ve introduced with `FetchContent`, there’s one other useful way to work with it. If you are developing an application and a library at the same time, and they are both closely related, it can be tedious to keep the application in sync when making small incremental changes to the library. You need to commit your changes, push them to the remote repository, and then pull the changes down again in the application project. A better approach is to tell `FetchContent` to look directly at that source folder instead of downloading the dependency and storing it locally (inside the `build/_deps` folder). This can be achieved by setting `SOURCE_DIR`.\n\t\t\tWe can write the following:\n\n```", "```cpp\n\n\t\t\tCMake will then use this new path as the source directory, and we can easily make changes there. We will see them reflected in our application immediately when we build it. This path can either be absolute or relative from the build folder of the main application.\n\t\t\tTo help illustrate this, let’s look at one concrete example. Let’s take the folder structure of the *Minimal CMake* GitHub repository and create `timer-lib` in the same directory:\n\n```", "```cpp\n\n\t\t\tTo reference the local `timer-lib` library, we can write the following in `ch3/part-1/CMakeLists.txt`:\n\n```", "```cpp\n\n\t\t\tNotice that we used four instances of `../`, as the path is relative to our project’s build folder (`CMAKE_CURRENT_BINARY_DIR`), not its source folder (`CMAKE_CURRENT_SOURCE_DIR`). Essentially, we are targeting `ch3/part-1/build`, not `ch3/part-1`. We could also use `${CMAKE_CURRENT_SOURCE_DIR}/../../../timer-lib` to make the path relative to our project’s source directory if we prefer. If figuring out the relative path is proving difficult, it’s also fine to use an absolute path as a short-term workaround to get things working.\n\t\t\tThis is meant as a temporary convenience and isn’t something to push to your main branch, but it can be particularly useful when iterating on functionality that may have been extracted to a separate project. It’s also important to note that `SOURCE_DIR` can be used in combination with a download method (e.g., `GIT_REPOSITORY`) to override the default location where the source code will be downloaded.\n\t\t\tMaking the dependency available\n\t\t\tNow that we have described how to retrieve the dependency’s source (using `FetchContent_Declare`), we can instruct CMake to add it to our project and make the dependency ready to use:\n\n```", "```cpp\n\n\t\t\t`FetchContent_MakeAvailable` will make the content of our dependency available to the rest of our `CMakeLists.txt` file. The CMake documentation calls this `timer_lib`), but as discussed earlier, we might have brought in other CMake utility scripts we’d like to use.\n\t\t\tMultiple dependencies can be listed in the `FetchContent_MakeAvailable` command (separated by a space), and all `FetchContent_Declare` statements must come before the call to `FetchContent_MakeAvailable`:\n\n```", "```cpp\n\n\t\t\tSomething to be aware of about `FetchContent_MakeAvailable` is that it is actually an abstraction over several lower-level CMake commands (`FetchContent_GetProperties`, `FetchContent_Populate`, etc.). These allow more fine-grain control over the dependency, but in the majority of cases, they are not required. `FetchContent_MakeAvailable` is usually more than sufficient and much simpler to use. The CMake documentation recommends using `FetchContent_MakeAvailable` unless there is a good reason not to.\n\t\t\tLinking to the dependencies\n\t\t\tWith targets now available for our dependency, the last step is to link against them:\n\n```", "```cpp\n\n\t\t\tWhen used with a CMake target as shown in the preceding code snippet, `target_link_libraries` is a deceptively powerful command. There is quite a bit going on that CMake is taking care of for us. As the library we’re depending on is using CMake, it has already described what the `include` paths are and where to find the library file itself. This might seem like a small thing, but doing this by hand is a tedious and error-prone process.\n\t\t\tIf we were depending on a library we’d built outside of CMake (without using find modules, a topic covered in [*Chapter 7*](B21152_07.xhtml#_idTextAnchor170), *Adding Install Support for Your Libraries*), we would have to manually specify the include paths, library path, and library in the following manner:\n\n```", "```cpp\n\n\t\t\tSome details have been omitted in the preceding example, but the sentiment is much the same. If you visit the book’s GitHub repository ([https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)) and navigate to `ch3/part-3`, you can see a full example (both `x86_64` and `arm64` architectures are supported, to override the architecture, set `MC_ARCH` when configuring).\n\t\t\tThis approach is sometimes necessary (especially if a library we’re depending on isn’t using CMake and creating a find module file is too much overhead for what’s needed). Building separately and updating all individual library files can be tiresome and does not scale well if you’re using many dependencies and updating them regularly.\n\t\t\tAnother example is also included in `ch3/part-4`, which shows the use of `add_subdirectory` (it is necessary to navigate to `ch3/part-4/third-party` and run `git clone https://github.com/pr0g/timer_lib.git` to download the library before configuring the project from `ch3/part-4`; see `ch3/part-4/README.md` for details). This has the advantage of relying on the CMake target again (so we get all the `include` directories and library paths for free), but it suffers from the problem mentioned at the start of the chapter, where code from other projects can get mixed up in our source tree.\n\t\t\tWe’ll stick with the `FetchContent` approach for the rest of this chapter, and with `timer_lib` now added to `target_link_libraries`, we’re ready to start using the dependency in our project.\n\t\t\tSetting options on dependencies\n\t\t\tWhen bringing in dependencies, there are often situations where we want to customize exactly what gets built. One of the most common examples is whether to build unit tests or not. Usually, libraries will provide an option to build the tests, with the default set to either `on` or `off` (this is something we’ll cover in more detail in [*Chapter 4*](B21152_04.xhtml#_idTextAnchor086), *Creating Libraries* *for FetchContent*).\n\t\t\tTo understand this in a bit more detail, let’s continue to evolve our sample project, the `Game of Life` implementation introduced in [*Chapter 2*](B21152_02.xhtml#_idTextAnchor032), *Hello CMake!*.\n\t\t\tWe are going to bring in another library in addition to `timer_lib` called `as-c-math`. This is a linear algebra math library intended for use in 3D applications and games. It also includes a set of 2D operations, which will help to refine our `Game of` `Life` implementation.\n\t\t\tTo introduce the new library, let’s use the now-familiar `FetchContent_Declare` command to describe where to find it:\n\n```", "```cpp\n\n\t\t\tWe can then add it to the `FetchContent_MakeAvailable` command along with `timer_lib`:\n\n```", "```cpp\ntarget_link_libraries(${PROJECT_NAME} PRIVATE timer_lib ch3/part-5, you can see a version of the project with the changes we have listed. Simply run cmake -B build (with your choice of generator; we’ll stick with Ninja Multi-Config) and then cmake --build build:\n\n```", "```cpp\n\n\t\t\tThere’s one thing you might spot in the output:\n\n```", "```cpp\n\n\t\t\tIt looks like we’re inadvertently building the unit tests for `as-c-math`. If you navigate to `build/_deps/as-c-math-build/Debug` and run `as-c-math-test`, sure enough, you’ll see that the tests run. In our case, this is a waste of resources, as we’re unlikely to be making changes to the library and would hope that the test suite is already passing.\n\t\t\tThe good news is that there’s a way to disable this right after our `FetchContent_Declare` command. If we navigate to the `CMakeLists.txt` file for `as-c-math` (which will have been downloaded for us in `build/_deps/as-c-math-src`), at the top of the file we can see this command:\n\n```", "```cpp\n\n\t\t\tThis is a CMake variable used to decide whether we should build the test target or not. Scrolling a little further down, we can see the following:\n\n```", "```cpp\n\n\t\t\tIt is generally good practice when creating libraries to segment any additional utilities such as tests, coverage, and documentation from the main build so users can choose to opt in to what they want to use. The good news is that we can set the `AS_MATH_ENABLE_TEST` variable from our project.\n\t\t\tIn this case, we know that we don’t want to build the tests, and we also want to hide this property from users of our library as it’s an implementation detail. We can do this by adding a `set` command right after the `FetchContent_Declare` command for `as-c-math`:\n\n```", "```cpp\n\n\t\t\tFor a full example of the preceding step, see `ch3/part-6/CMakeLists.txt`.\n\t\t\tIn a perfect world, it would be simpler if we could just write `set(AS_MATH_ENABLE_TEST OFF)`, but the extra arguments are important to add as a best practice. The reasons why we must add them relate to the CMake cache.\n\t\t\tThe previously mentioned `option(AS_MATH_ENABLE_TEST \"Enable testing\" ON)` command is essentially syntactic sugar for the following:\n\n```", "```cpp\n\n\t\t\tWhat this does is add the variable to the CMake cache (stored in `build/CMakeCache.txt`). This keeps track of a bunch of settings and variables so CMake doesn’t have to recalculate them on every run. It is also used to allow variables to be edited by users using the CMake GUI or `ccmake` (`ccmake` is a command-line tool for manually editing cache variables; it is only available on macOS and Linux).\n\t\t\tWhen we override a variable, we first pass the name (`AS_MATH_ENABLE_TEST`), then the value (`OFF`), and then we pass `CACHE` to indicate that this value should be updated in the cache. To clarify, if we leave things as they are in `ch3/part5` and look inside `CMakeCache.txt`, we’ll see the following:\n\n```", "```cpp\n\n\t\t\tThese are listed under the `EXTERNAL cache entries` section. If we now add `set(AS_MATH_ENABLE_TEST OFF)` to our `CMakeLists.txt` file, tests will be disabled, but the cache entry will be left over with the earlier value. This could cause problems depending on the scope of where `AS_MATH_ENABLE_TEST` is defined in our `CMakeLists.txt` file.\n\t\t\tAnother thing to note is if you do a fresh configure with just `set(AS_MATH_ENABLE_TEST OFF)` added to your `CMakeLists.txt` file, then the value suppresses the variable from ever ending up in the cache. This inconsistency can lead to esoteric problems between new and old builds and so is best avoided. It also means that the value can never be overridden from the command line (if you did want to briefly enable tests, passing `cmake -B build -D AS_MATH_ENABLE_TEST=ON` would have no effect).\n\t\t\tThe final two arguments (`BOOL` and `\"Enable testing\"`) are required by CMake cache variables. CMake will complain if you don’t provide these:\n\n```", "```cpp\n\n\t\t\tAs mentioned, the type shows the kind of value to be stored (`BOOL` in our case for `option`), and the `ccmake`.\n\t\t\tWhen using the full form of `set` mentioned above, when querying `build/CMakeCache.txt`, we can see that the `as-c-math` variables have been updated to look like this:\n\n```", "```cpp\n\n\t\t\tThese will not appear in the CMake GUI or `ccmake` but can still be overridden with `-DAS_MATH_ENABLE_TEST=ON` from the command line if needed.\n\t\t\tIn short, when enabling or disabling features for dependencies exposed in their `CMakeLists.txt` file, prefer `set(<variable> <value> CACHE <type> <docstring>)` to the shorter alternative. Make sure to also set these values between the `FetchContent_Declare` and `FetchContent_MakeAvailable` commands for a given dependency. Do all this and you shouldn’t run into any issues.\n\t\t\tUpdating our application\n\t\t\tWith `as-c-math` added to our `CMakeLists.txt` file (see `ch3/part-7/CMakeLists.txt`), we can now include the library in our project. We simply add `#include <as-ops.h>` at the top of `main.c` (notice the use of angle brackets (`<>`) to indicate that this is an external dependency. Quotation marks (`\"\"`) also work, but using `<>` has the advantage of advertising to the reader that this file is outside the main project).\n\t\t\tIf we review `main.c`, we can see it’s changed quite significantly. Instead of thinking of the board as a table with rows and columns, the logic has been updated to treat it as a grid with `x` and `y` coordinates. This is to make things a little more idiomatic when it comes to integration with the math library, but the transition can be a little jarring as the ordering of elements has changed. We traditionally write rows, then columns (`r, c`), which is the vertical position first, then horizontal. With `x` and `y` coordinates, we traditionally write `x` then `y` (`x, y`), with `x` being the horizontal position and `y` being vertical. Right now, the top left of the board is still `(0, 0)`, with `y` growing downward, but this might change in the future. These implementation details are outside the focus of this book but are included for completeness. Don’t worry too much about the changes; the good news is that when running `ch3/part7`, things look identical to how they did before.\n\t\t\tAs we can see, what often happens with projects is that when new code is added, we decide how best to structure it after the fact. This is where CMake helps us break things up and provide reusable components.\n\t\t\tSummary\n\t\t\tFantastic work making it to this point; there was a lot to take in. In this chapter, we covered what `FetchContent` is and why you might want to use it. We touched on how to extract useful functionality in your `CMakeLists.txt` file and then walked through the `FetchContent_Declare` and `FetchContent_MakeAvailable` commands in detail. We saw where to find commits and tags for projects on GitHub, and then how to use `FetchContent` to bring in a simple dependency to enhance our app. We then looked at how to link to our dependency (along with a few alternative approaches) to ensure we could use the code in our project. Finally, we covered how to override settings exposed by dependencies in our `CMakeLists.txt` file and discussed a small update to our *Game of* *Life* application.\n\t\t\tThis is another significant achievement under your belt. Being able to effectively understand and use `FetchContent` is an incredibly valuable skill. It unlocks a wealth of software (open source or otherwise) for easy integration with your application.\n\t\t\tNow that we have the knowledge to consume libraries, the next step is learning how to create our own. In the next chapter, we’ll look at breaking out the core of our `Game of Life` application into a library that we can consume in our application and understand exactly what’s needed to make a CMake project consumable by `FetchContent`.\n\n```", "```cpp\n\n```"]