- en: Detecting the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with platform-dependent source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with compiler-dependent source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering the host processor architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering the host processor instruction set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling vectorization for the Eigen library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although CMake is cross-platform and in our projects we strive for the source
    code to be portable across platforms, operating systems, and compilers, sometimes
    the source code is not fully portable; for example, when using vendor-dependent
    extensions, we may find it necessary to configure and/or build code slightly differently
    depending on the platform. This is particularly relevant for legacy code or when
    cross-compiling, a topic we will return to in [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml),
    *Alternative Generators and Cross-compilation*. It can also be advantageous to
    know the processor instruction set to optimize performance for a specific target
    platform. This chapter presents recipes to detect such environments and provides
    recommendations for how to implement such solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the operating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-01).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: CMake is a set of cross-platform tools. Nevertheless, it can be very useful
    to know on which operating system (OS) the configuration or build step is executed.
    Such OS discovery can be used either to tweak CMake code for a particular OS,
    to enable conditional compilation depending on the OS, or to use compiler-specific
    extensions if available or necessary. In this recipe, we will demonstrate how
    to use CMake to detect the OS with an example that does not require compilation
    of any source code. For simplicity, we will only consider the configuration step.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will demonstrate OS discovery with a very simple `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define the minimum CMake version and project name. Note that our language
    requirement is `NONE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we wish to print a custom message depending on the detected OS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before testing it out, first examine the preceding code block and consider what
    behavior you expect on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to test it out and configure the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Of the CMake output, one line is interesting here – on a Linux system, this
    is the line of interest (on other systems, the output will hopefully be different):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake correctly defines `CMAKE_SYSTEM_NAME` for the target OS and therefore
    there is typically no need to use custom commands, tools, or scripts to query
    this information. The value of this variable can then be used to implement OS-specific
    conditionals and workarounds. On systems that have the `uname` command, this variable
    is set to the output of `uname -s`. The variable is set to "Darwin" on macOS.
    On Linux and Windows, it evaluates to "Linux" and "Windows", respectively. We
    now know how to execute a specific CMake code on a certain OS if we need to. Of
    course, we should try to minimize such customization in order to simplify migration
    to new platforms.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize trouble when moving from one platform to another, you should avoid
    using Shell commands directly and also avoid explicit path delimiters (forward
    slashes on Linux and macOS and backward slashes on Windows). Only use forward
    slashes in CMake code as path delimiters and CMake will automatically translate
    them for the OS environment in question.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with platform-dependent source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-02)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we should avoid platform-dependent source code, but sometimes we have
    no choice – particularly when we are given code to configure and compile that
    we have not written ourselves. In this recipe, we will demonstrate how to use
    CMake to conditionally compile source code depending on the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this example, we will modify the `hello-world.cpp` example code from [Chapter
    1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml), *From a Simple Executable to Libraries*,
    Recipe 1, *Compiling a single source file into an executable*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us build a corresponding `CMakeLists.txt` instance, which will enable us
    to conditionally compile the source code based on the target OS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first set the minimum CMake version, project name, and supported language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the executable and its corresponding source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we let the preprocessor know the system name by defining the following
    target compile definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before continuing, first examine the preceding expressions and consider what
    behavior you expect on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to test it out and to configure the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: On a Windows system, you will see `Hello from Windows!`; other operating systems
    will yield different outputs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The interesting part in the `hello-world.cpp` example is the conditional compilation
    based on the preprocessor definitions `IS_WINDOWS`, `IS_LINUX`, or `IS_MACOS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These definitions are defined at configure time by CMake in `CMakeLists.txt` by
    using `target_compile_definitions` before being passed on to the preprocessor.
    We could have achieved a more compact expression without repeating `if-endif` statements
    and we will demonstrate this refactoring in the next recipe. We could also have
    joined the `if-endif` statements into one `if-elseif-elseif-endif` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we should point out that we could have set the definitions using `add_definitions(-DIS_LINUX)`
    (of course, adjusting the definition according to the platform in question) instead
    of using `target_compile_definitions`. The disadvantage of using `add_definitions`
    is that it modifies compile definitions for the entire project, whereas `target_compile_definitions`
    gives us the possibility to restrict both the scope of the definitions to a specific
    target, as well as to restrict visibility of these definitions by using the `PRIVATE`,
    `PUBLIC`, or `INTERFACE` qualifiers. These qualifiers have the same meaning they
    had for compiler flags, as we have seen already in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries,* Recipe 8, *Controlling compiler flags*:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `PRIVATE` qualifier, compile definitions will only be applied to the
    given target and not by other targets consuming it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `INTERFACE` qualifier, compile definitions on a given target will only
    be applied to targets consuming it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `PUBLIC` qualifier, compile definitions will be applied to the given
    target and all other targets consuming it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize platform-dependent source code in your project to make porting easier.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with compiler-dependent source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-03)
    and has a C++ and a Fortran example. The recipe is valid with CMake version 3.5
    (and higher) and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe is similar to the previous one in the sense that we will use CMake
    to accommodate the compilation of conditional source code that is dependent on
    the environment: in this case, it will be dependent on the chosen compiler. Again,
    for the sake of portability, this is a situation that we try to avoid when writing
    new code, but it is also a situation that we are almost guaranteed to meet sooner
    or later, especially when using legacy code or when dealing with compiler-dependent
    tooling, such as sanitizers. From the recipes of this and the previous chapter,
    we have all the ingredients to achieve this. Nevertheless, it will be useful to
    discuss the problem of dealing with compiler-dependent source code since we will
    have the chance to introduce some new aspects of CMake.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will start out with an example in C++, and later we will
    demonstrate a Fortran example and attempt to refactor and simplify the CMake code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider the following `hello-world.cpp` source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also use a corresponding Fortran example (`hello-world.F90`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We shall start out with the C++ example before moving on to the Fortran example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CMakeLists.txt` file, we define the now familiar minimum version, project
    name, and supported language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the executable target and its corresponding source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we let the preprocessor know about the compiler name and vendor by defining
    the following target compile definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous recipes have trained our eyes and now we can already anticipate
    the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you use a different compiler vendor, then this example code will provide
    a different greeting.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statements in the `CMakeLists.txt` file in the preceding example and
    the previous recipe seem repetitive, and as programmers, we do not like to repeat
    ourselves. Can we express this more compactly? Indeed we can! For this, let us
    turn to the Fortran example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CMakeLists.txt` file of the Fortran example, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to adapt the language to Fortran:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the executable and its corresponding source file; in this case,
    with an uppercase `.F90` suffix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we let the preprocessor know very compactly about the compiler vendor
    by defining the following target compile definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The remaining behavior of the Fortran example is the same as in the C++ example.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preprocessor definitions are defined at configure time by CMake in `CMakeLists.txt`
    and are passed on to the preprocessor. The Fortran example contains a very compact
    expression where we use the `CMAKE_Fortran_COMPILER_ID` variable to construct
    the preprocessor definition using `target_compile_definitions`. To accommodate
    this, we had to change the case of "Intel" from `IS_INTEL_CXX_COMPILER` to `IS_Intel_FORTRAN_COMPILER`.
    We could achieve the same for C or C++ by using the corresponding `CMAKE_C_COMPILER_ID` and
    `CMAKE_CXX_COMPILER_ID` variables. Please do note, however, that `CMAKE_<LANG>_COMPILER_ID`
    *is not guaranteed* to be defined for all compilers or languages.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `.F90` suffix for Fortran code that is supposed to be preprocessed and
    use the `.f90` suffix for code that is not to be preprocessed.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the host processor architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-04)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The advent of 64-bit integer arithmetic in 1970s supercomputing and 64-bit addressing
    in the early 2000s for personal computers has widened the memory-addressing range,
    and significant resources have been invested into porting code that was hardcoded
    for 32-bit architectures to enable 64-bit addressing. A number of blog posts,
    such as [https://www.viva64.com/en/a/0004/](https://www.viva64.com/en/a/0004/),
    are devoted to discussing typical issues and solutions in porting C++ code to
    64-bit platforms. It is very much advisable to program in a way that avoids explicitly
    hardcoded limits, but you may be in a situation where you need to accommodate hardcoded
    limits in a code configured with CMake, and in this recipe, we wish to discuss
    options for detecting the host processor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following `arch-dependent.cpp` example source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let us turn to the CMake side. In the `CMakeLists.txt` file, we need to
    apply the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define the executable and its source file dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We check for the size of the `void` pointer type. This is defined in the `CMAKE_SIZEOF_VOID_P`
    CMake variable and will tell us whether the CPU is 32 or 64 bits. We let the user
    know about the detected size with a status message and set a preprocessor definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we let the preprocessor know about the host processor architecture by
    defining the following target compile definitions, at the same time printing status
    messages during configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We configure the project and note the status message (the precise message may
    of course change):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we build and execute the code (the actual output will depend on the
    host processor architecture):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CMake defines the `CMAKE_HOST_SYSTEM_PROCESSOR` variable to contain the name
    of the processor it is currently running on. This can be set to "i386", "i686",
    "x86_64", "AMD64", and such like, depending, of course, on the CPU at hand. `CMAKE_SIZEOF_VOID_P`
    is defined to hold the size of a pointer to the `void` type. We can query both
    at the CMake level in order to modify targets or target compile definitions. Using
    preprocessor definitions, we can branch source code compilation based on the detected
    host processor architecture. As discussed in previous recipes, such customization
    should be avoided when writing new code, but sometimes it is useful when working
    with legacy code or when cross-compiling, which is the subject of [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml),
    *Alternative Generators and Cross-compilation*.
  prefs: []
  type: TYPE_NORMAL
- en: Using `CMAKE_SIZEOF_VOID_P` is the only truly portable way of checking whether
    the CPU at hand has a 32- or 64-bit architecture.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to `CMAKE_HOST_SYSTEM_PROCESSOR`, CMake also defines the `CMAKE_SYSTEM_PROCESSOR`
    variable. Whereas the former contains the name of the CPU CMake is **currently
    running on**, the latter will contain the name of the CPU we are **currently building
    for**. This is a subtle difference that plays a very fundamental role when cross-compiling.
    We will see more about cross-compilation in [Chapter 13](ea785243-b9e8-4993-ac0d-1038f181b496.xhtml),
    *Alternative Generators and Cross-compilation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to letting CMake detect the host processor architecture is to
    use symbols defined within C or C++ and use CMake''s `try_run` function to build
    and attempt to execute the source code (see [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml), *Configure-time
    and Build-time Operations,* Recipe 8, *Probing execution*) that is branched by
    the preprocessor symbols. This returns well-defined errors that can be caught
    on the CMake side (this strategy is inspired by [https://github.com/axr/solar-cmake/blob/master/TargetArch.cmake](https://github.com/axr/solar-cmake/blob/master/TargetArch.cmake)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This strategy is also the recommended one for detecting the target processor
    architecture, where CMake does not seem to offer a portable intrinsic solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another alternative exists. It will only use CMake, doing away entirely
    with the preprocessor, at the expense of having a different source file for each
    case, which would then be set as the source file for the executable target `arch-dependent`
    using the `target_sources` CMake command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This approach will clearly require more work for an existing project, since
    the source files will need to be separated. Moreover, code duplication between
    the different source files might certainly become a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the host processor instruction set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-05)
    and has a C++ example. The recipe is valid with CMake version 3.10 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to discover the host processor instruction
    set with the help of CMake. This functionality has been added to CMake relatively
    recently and requires CMake 3.10 or later. The detected host system information
    can be used to either set corresponding compiler flags or to implement optional
    compilation of sources or source code generation depending on the host system.
    In this recipe, our goal will be to detect the host system information, pass it
    to the C++ source code using preprocessor definitions, and print the information
    to the output.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our example C++ source file (`processor-info.cpp`) consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This file includes `config.h`, which we will generate from `config.h.in`, given
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use CMake to fill the definitions in `config.h` with sensible values
    for our platform and to compile our sample source file into an executable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the minimum CMake version, project name, and project language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the target executable, its source file, and include directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We then go on to query the host system information for a number of keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined the corresponding variables, we configure `config.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to configure, build, and test the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The output will of course vary depending on the processor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `foreach` loop in `CMakeLists.txt` queries values for a number of keys and
    defines corresponding variables. The core function of this recipe is `cmake_host_system_information`,
    which queries system information of the host system on which CMake runs. This
    function can be invoked with multiple keys in one function call, but in this case,
    we have used one function call per key. We then use these variables to configure
    the placeholders in `config.h.in` and generate `config.h` . This configuration
    is done with the `configure_file` command. Finally, `config.h` is included in
    `processor-info.cpp`, and once compiled, it will print the values to the screen.
    We will revisit this approach in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml), *Configure-time
    and Build-time Operations*, and [Chapter 6](48392b14-6669-412e-909a-3185624a7ff2.xhtml),
    *Generating Source Code*.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a more fine-grained processor instruction set detection, consider this module: [https://github.com/VcDevel/Vc/blob/master/cmake/OptimizeForArchitecture.cmake](https://github.com/VcDevel/Vc/blob/master/cmake/OptimizeForArchitecture.cmake).
    We would also like to note that, sometimes, the host building the code may not
    be the same as the host running the code. This is often the case on compute clusters
    where the login node architecture may differ from the architecture found on compute
    nodes. One way to solve this is to submit the configuration and compilation as
    a computation step and deploy it to the compute nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We have not used all keys available in `cmake_host_system_information`. For
    this, please consult [https://cmake.org/cmake/help/latest/command/cmake_host_system_information.html](https://cmake.org/cmake/help/latest/command/cmake_host_system_information.html).
  prefs: []
  type: TYPE_NORMAL
- en: Enabling vectorization for the Eigen library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-02/recipe-06)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The vector capabilities of modern processor architectures can dramatically enhance
    the performance of your code. This is particularly the case for certain classes
    of operations, and linear algebra is foremost among these. This recipe will show
    how to enable vectorization to speed up a simple executable using the Eigen C++
    library for linear algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the Eigen C++ template library for linear algebra and show how
    to set up compiler flags to enable vectorization. The source code for this recipe
    the `linear-algebra.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We expect vectorization to speed up the execution of the dot product operation
    in `simple_function`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the documentation of the Eigen library, it is sufficient to set
    the appropriate compiler flag to enable the generation of vectorized code. Let
    us look at `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C++11 project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we wish to use the Eigen library, we need to find its header files on
    the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the `CheckCXXCompilerFlag.cmake` standard module file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We check that the `-march=native` compiler flag works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative `-xHost` compiler flag is also checked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We set an empty variable, `_CXX_FLAGS`, to hold the one compiler flag that
    was found to work among the two we just checked. If we see `_march_native_works`,
    we set`_CXX_FLAGS` to `-march=native`. If we see `_xhost_works`, we set`_CXX_FLAGS`
    to `-xHost`. If none of them worked, we will leave `_CXX_FLAGS` empty and vectorization
    will be disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison, we also define an executable target for the unoptimized version
    where we do not use the preceding optimization flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we define an optimized version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us compare the two executables—first we configure (in this case, `-march=native_works`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let us compile and compare timings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most modern processors provide vector instruction sets. Carefully crafted code
    can exploit these and achieve enhanced performance with respect to non-vectorized
    code. The Eigen library has been written with vectorization explicitly in mind
    since linear algebra operations can greatly benefit from it. All we need to do
    is instruct the compiler to inspect the processor for us and generate the native
    set of instructions for the current architecture. Different compiler vendors use
    different flags to achieve this: the GNU compiler implements this by means of
    the `-march=native` flag, whereas the Intel compiler uses the `-xHost` flag. We
    then use the `check_cxx_compiler_flag` function offered by the `CheckCXXCompilerFlag.cmake`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts two arguments: the first one is the compiler flag to
    check, the second is a variable for storing the result, `true` or `false`, of
    the check. If the check is positive, we add the working flag to the `_CXX_FLAGS`
    variable, which will then be used to set the compiler flags for our executable
    target.'
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe could be combined with the previous recipe; processor capabilities
    could be queried using `cmake_host_system_information`.
  prefs: []
  type: TYPE_NORMAL
