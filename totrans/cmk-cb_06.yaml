- en: Configure-time and Build-time Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using platform-independent file operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a custom command at configure time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running a custom command at build time: I. Using `add_custom_command`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running a custom command at build time: II. Using `add_custom_target`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running custom commands for specific targets at build time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probing compilation and linking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probing compiler flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Probing execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-tuning configuration and compilation with generator expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to perform custom operations at configure
    time and build time.  Let us briefly recall the notion of *times* as related to
    the workflow of a project managed by CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CMake time** or **configure time**: This is when CMake is running and processing
    the `CMakeLists.txt` files in your project.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generation time**: This is when the files for the native build tool, such
    as Makefiles or Visual Studio project files, are generated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build time**: This is when the native build tools are invoked on the platform-
    and tool-native build scripts previously generated by CMake. At this point, the
    compiler will be invoked and the targets (executables and libraries) will be built
    in a specific build directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CTest time** or **test time**: When we run the test suite to check whether
    the targets perform as intended.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CDash time** or **report time:** When the results of testing the project
    are uploaded to a dashboard to be shared with other developers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Install-time**: When the targets, source files, executables, and libraries
    are installed from the build directory to an install location.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CPack time** or **packaging time**: When we package our project for distribution,
    either as source code or binary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Package install time**: When the newly minted package is installed system-wide.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The complete workflow and the corresponding times are depicted in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d8d214c-69fb-43b4-8769-20a5770453bb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter is concerned with customizing the behavior at configure time and
    build time. We will learn how to use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`execute_process` to execute arbitrary processes from within CMake and retrieve
    their outputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_custom_target` to create targets that will execute custom commands'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_custom_command` to specify commands that have to be executed to generate
    files or at specific build events of other targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using platform-independent file operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-01)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: When building some projects, we may need to interact with the host platform
    filesystem. The interaction with the files might be simply checking whether a
    file exists, creating a new file to store temporary information, creating or extracting
    an archive, and so forth. With CMake, we are not only able to generate the build
    system on different platforms, we are also able to perform these operations without
    complicated logic to abstract away the different operating systems. This recipe
    will show how to extract a previously downloaded archive in a portable way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will show how to extract the archive bundling the Eigen library and use the
    extracted source files to compile our project. In this recipe, we will reuse the
    linear algebra example `linear-algebra.cpp` from [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml),
    *Detecting External Libraries and Programs*, Recipe 7, *Detecting the Eigen library*.
    The recipe also assumes that the archive containing the source code for Eigen
    has been downloaded in the same directory as the project itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project needs to unpack the Eigen archive and set the include directories
    for the target accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first declare a C++11 project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a custom target to our build system. The custom target will extract
    the archive inside the build directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We add an executable target for our source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the compilation of our source file depends on the Eigen header files,
    we need to explicitly specify the dependency of the executable target on the custom
    target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can specify which include directories we need to compile our source
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us take a closer look at the invocation of `add_custom_target`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are introducing a target called `unpack-eigen` into our build system. The
    target will always be executed since we passed the `ALL` argument. The `COMMAND`
    argument lets you specify what commands to execute. In this example, we wish to
    extract the archive and rename the extracted directory to `eigen-3.3.4`. This
    is achieved with these two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${CMAKE_COMMAND} -E tar xzf ${CMAKE_CURRENT_SOURCE_DIR}/eigen-eigen-5a0156e40feb.tar.gz`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`${CMAKE_COMMAND} -E rename eigen-eigen-5a0156e40feb eigen-3.3.4`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice how we are calling the CMake command itself, with the `-E` flag, to
    execute the actual work. For many common operations, CMake implements an interface
    common to all the operating systems it runs on. This allows the build system generation
    to be largely independent of the specific platform. The next argument in the `add_custom_target`
    command is the working directory, which in our example corresponds to the build
    directory: `CMAKE_CURRENT_BINARY_DIR`. The last argument, `COMMENT`,  is used
    to specify what message CMake should print out when executing the custom target.'
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command `add_custom_target` can be used whenever a series of custom commands
    with no output has to be executed during the build. As we have shown in this recipe,
    the custom target can be specified as a dependency of other targets in the project.
    Moreover, custom targets can also depend on other targets, thus offering the possibility
    to set up the order of execution in our build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `-E` flag to CMake, we can run many common operations in an operating
    system-agnostic fashion. The full list on the specific operating system can be
    obtained by running `cmake -E` or `cmake -E help`. For example, this is the summary
    of commands on a Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running a custom command at configure time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Running CMake generates the build system, thus specifying what commands the
    native build tools will have to execute to get your project built, and in which
    order. We have already seen how CMake runs many subtasks at configure time in
    order to find out the working compiler and necessary dependencies. In this recipe,
    we will discuss how to run custom commands at configure time by using the `execute_process`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already shown the use of `execute_process` when trying to find the
    NumPy Python module in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml),
    *Detecting External Libraries and Programs*, Recipe 3, *Detecting Python modules
    and packages*. In this example, we will use the `execute_process` command to find
    out whether a particular Python module (in this case, Python CFFI) is present,
    and if it is, we will discover its version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this simple example, we will not require any language support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will require the Python interpreter to execute a short Python snippet, and
    for this we discover the interpreter using `find_package`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then invoke `execute_process` to run a short Python snippet; we will discuss
    this command in more detail in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'An example configuration yields the following (assuming the Python CFFI package
    is installed in the corresponding Python environment):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `execute_process` command will spawn one or more child processes from within
    the currently executing CMake process, thus providing a powerful and convenient
    way of running arbitrary commands when configuring your project. It is possible
    to execute more than one command within one invocation of `execute_process`. Notice,
    however, that the output of each command will be piped into the next. The command
    accepts a number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKING_DIRECTORY` lets you specify in which directory the commands should
    be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RESULT_VARIABLE` will contain the result of running the processes. This is
    either an integer to signal successful execution or a string with the error condition
    incurred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OUTPUT_VARIABLE` and `ERROR_VARIABLE` will contain the standard output and
    standard error of the executed commands. Keep in mind that since the outputs of
    commands are piped, only the standard output of the last command will be saved
    into `OUTPUT_VARIABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INPUT_FILE`, `OUTPUT_FILE`, and `ERROR_FILE` specify filenames for the standard
    input and standard output of the last command, and the standard error for all
    commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By setting `OUTPUT_QUIET` and `ERROR_QUIET`, CMake will silently ignore the
    standard output and the standard error, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any trailing whitespace in the standard output and standard error for the running
    commands can be stripped by setting `OUTPUT_STRIP_TRAILING_WHITESPACE` and `ERROR_STRIP_TRAILING_WHITESPACE`,
    respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these explanations, we can return to our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The command checks the output of `python -c "import cffi; print(cffi.__version__)"`.
    If the module is not found, `_stderr` will contain `ModuleNotFoundError`, which
    we check for in the if-statement, and in this case we would print `Module cffi
    not found`. If the import is successful, the Python code will print the version
    of the module, which is piped into `_stdout` so that we can print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we have only printed the result, but in a real project we could
    warn, abort the configuration, or set variables that could be queried to toggle
    certain configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: It would be an interesting exercise to extend the code example to multiple Python
    modules, such as Cython, avoiding code repetition. One option could be to loop
    over the module names using `foreach`; another approach could be to abstract the
    code into a function or macro. We will discuss such abstractions in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml),
    *Structuring Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*, we will use Python CFFI and Cython, and the present recipe can serve
    as a useful and reusable code snippet to detect whether these packages are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running a custom command at build time: I. Using add_custom_command'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-03)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build targets for your projects might depend on the results of commands that
    can only be executed at build time, after the build system generation has been
    completed. CMake offers three options to execute custom commands at build time:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `add_custom_command` to generate output files to be compiled within a
    target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `add_custom_target` to execute commands with no output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `add_custom_command` to execute commands with no output, before or after
    a target has been built.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These three options enforce specific semantics and are not interchangeable.
    The next three recipes will clarify their use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will reuse the C++ example from [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 4, *Detecting the BLAS and LAPACK math
    libraries*, to illustrate the use of the first variant of `add_custom_command`.
    In that code sample, we probed for existing BLAS and LAPACK libraries and compiled
    a tiny C++ wrapper library to call the Fortran implementation of the linear algebra
    routines we needed.
  prefs: []
  type: TYPE_NORMAL
- en: We will split the code into two portions. The source file for `linear-algebra.cpp` is
    unchanged compared to [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 4, *Detecting the BLAS and LAPACK math
    libraries*, and will include headers from the linear algebra wrappers library
    and link against the compiled library. The sources of the library will, however,
    be packaged into a zipped tar archive shipped alongside the example project. The
    archive will be extracted at build time and the linear algebra wrapper library
    compiled before the executable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `CMakeLists.txt` will have to contain a custom command to extract the sources
    for the linear algebra wrapper library. Let us look at it in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a familiar definition of the minimum CMake version, project name,
    and supported language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We pick the C++11 standard, as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is then time to look for the BLAS and LAPACK libraries on our system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a variable, `wrap_BLAS_LAPACK_sources`, to hold the names of the
    source files contained in the `wrap_BLAS_LAPACK.tar.gz` archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the custom command to extract the `wrap_BLAS_LAPACK.tar.gz` archive
    and update the timestamps of the extracted files. Notice that the contents of
    the `wrap_BLAS_LAPACK_sources` variable are the expected outputs of the custom
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a library target whose sources are the freshly extracted files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `linear-algebra` executable target is added. This executable target
    links against the wrapper library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can configure, build, and execute the example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us have a closer look at the invocation of `add_custom_command`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`add_custom_command` adds rules to targets so that they know how to generate
    the output by executing the commands.  *Any target* declared within the same directory
    of `add_custom_command`, that is, in the same `CMakeLists.txt`, and that uses
    *any file* in the output as its source file, will be given a rule to generate
    those files at build time. Dependencies between targets and custom commands are
    thus automatically handled at build system generation, while the actual generation
    of source files happens at build time.'
  prefs: []
  type: TYPE_NORMAL
- en: In our specific case, the outputs are the sources contained in the zipped tar
    archive. To retrieve and use those files, the archive will have to be extracted
    at build time. This is achieved by using the CMake command itself with the `-E`
    flag, to achieve platform independence. The next command updates the timestamps
    of the extracted files. We do this to make sure we are not dealing with stale
    source files. `WORKING_DIRECTORY` specifies where to execute the commands. In
    our case, this is `CMAKE_CURRENT_BINARY_DIR`, which is the build directory currently
    being processed. The argument to the `DEPENDS` keyword lists dependencies to the
    custom command. In our case, the zipped tar archive is a dependency. The `COMMENT`
    field will be used by CMake to print status messages at build  time. Finally,
    `VERBATIM` tells CMake to generate the right command for the specific generator
    and platform, thus ensuring full platform independence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us also have a closer look at the way the library with the wrappers is
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We declare a library target with no sources. This is because we then use `target_sources`
    to populate the sources of the target. This achieves the very important task of
    letting dependents on this target know what include directories and header files
    they need, in order to successfully use the library. The C++ source files are
    `PRIVATE` to the target, and hence only used in building the library. The header
    files are `PUBLIC` because both the target and its dependents will need to use
    them to successfully compile. The include directories are specified using `target_include_directories` with `wrap_BLAS_LAPACK` declared
    as `INTERFACE`, since only dependents on the `math` target will need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This form of the `add_custom_command` has two limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It will only be valid if all of the targets depending on its output are specified
    in the same `CMakeLists.txt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the same output as `add_custom_command` for different, independent targets
    might re-execute the custom commands rule. This may cause conflicts and should
    be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second limitation can be avoided by carefully introducing dependencies with
    `add_dependencies`, but the proper approach to circumvent both would be to use
    the `add_custom_target` command, as we will detail in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running a custom command at build time: II. Using add_custom_target'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-04)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the previous recipe, `add_custom_command` has some limitations
    that can be circumvented by using `add_custom_target`. This CMake command will
    introduce new targets in the build system. These targets, in turn, execute commands
    that do not return an output, in contrast to `add_custom_command`. The commands `add_custom_target`
    and `add_custom_command` can be combined. With this, the custom target can be
    specified in a directory different than the one where its dependents are, and
    this can be very helpful when designing a modular CMake infrastructure for your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will reuse the source code sample from the previous recipe.
    We will, however, modify the layout of the sources slightly. In particular, instead
    of storing the zipped tar archive in the top-level directory, we will place it
    inside a subdirectory called `deps`. This subdirectory contains its own `CMakeLists.txt`,
    which will be included by the main `CMakeLists.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the main `CMakeLists.txt` and later move to `deps/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we declare a C++11 project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we move on to `deps/CMakeLists.txt`. This is achieved with the
    `add_subdirectory` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `deps/CMakeLists.txt`, we first locate the necessary libraries (BLAS
    and LAPACK):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we collect the contents of the tarball archive into a variable, `MATH_SRCS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Having listed the sources that are to be extracted, we define a custom target
    and a custom command. This combination extracts the archive in `${CMAKE_CURRENT_BINARY_DIR}`.
    However, here we are in a different scope and refer to `deps/CMakeLists.txt`,
    and therefore the tarball will be extracted into a `deps` subdirectory below the
    main project build directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add our `math` library as a target and specify corresponding sources,
    include directories, and link libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the execution of the commands in `deps/CMakeLists.txt` is done, we move
    back to the parent scope, define the executable target, and link it against the
    `math` library that we have defined one directory below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `add_custom_target`, users can execute custom commands within targets.
    This is subtly different from the `add_custom_command` recipe we have discussed
    previously. The target added by `add_custom_target` has no output and is thus
    always executed. It is thus possible to introduce a custom target in subdirectories,
    and still be able to refer to it in the top-level `CMakeLists.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have extracted an archive of source files using a combination
    of `add_custom_target` and `add_custom_command`.  These source files were later
    used to compile a library that we managed to link against in a different (parent)
    directory scope. In the construction of the `CMakeLists.txt` files, we briefly
    commented that the tarball is extracted under `deps`, one subdirectory below the
    build directory of the project. This is because in CMake, the structure of the
    build tree mimics the hierarchy of the source tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'A remarkable detail in this recipe, which we should discuss, is the curious
    fact that we have marked the math library sources as `PRIVATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Although these sources are `PRIVATE`, we compiled `linear-algebra.cpp` in the
    parent scope and this source code includes `CxxBLAS.hpp` and `CxxLAPACK.hpp`.
    Why is `PRIVATE` used here, and how was it possible to compile `linear-algebra.cpp`
    and build the executable? Had we marked the header files as `PUBLIC`, CMake would
    have stopped at CMake time with an error, "Cannot find source file", since the
    to-be-generated (extracted) source files do not exist in the file tree yet.
  prefs: []
  type: TYPE_NORMAL
- en: This is a known limitation (see [https://gitlab.kitware.com/cmake/cmake/issues/14633](https://gitlab.kitware.com/cmake/cmake/issues/14633),
    as well as a related blog post: [https://samthursfield.wordpress.com/2015/11/21/cmake-dependencies-between-targets-and-files-and-custom-commands](https://samthursfield.wordpress.com/2015/11/21/cmake-dependencies-between-targets-and-files-and-custom-commands)).
    We have worked around this limitation by declaring the sources `PRIVATE`. By doing
    this, we did not get any file dependencies on non-existent sources at CMake time.
    However, the CMake built-in C/C++ file dependency scanner picked them up at build
    time and the sources compiled and linked.
  prefs: []
  type: TYPE_NORMAL
- en: Running custom commands for specific targets at build time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-05)
    and has a Fortran example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to use the second signature of `add_custom_command`
    to perform custom operations without output. This is useful to perform certain
    operations right before or right after a specific target is built or linked. Since
    the custom commands are only executed if the target itself has to be built, we
    achieve target-level control over their execution. We will demonstrate this with
    an example where we print the link line of a target right before it is built,
    and then we measure the static size allocation of the compiled executable right
    after it has been compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will work with the following example Fortran code (`example.f90`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The fact that this is Fortran code does not matter much for the discussion that
    will follow, but we have chosen Fortran since there is a lot of legacy Fortran
    code out there where static size allocations are an issue.
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we define an array holding 20,000,000 double precision floats,
    and we expect this array to occupy 160 MB of memory. What we have done here is
    not recommended programming practice, since in general this memory will be consumed
    independently of whether it is used in the code. A much better approach would
    have been to allocate the array dynamically only when it is needed and deallocate
    it right afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code fills the array with random numbers and computes their sum
    - this was done to make sure that the array is really used and the compiler does
    not optimize the allocation away. We will measure the size of static allocation
    of the example binary with a Python script (`static-size.py`) wrapping around
    the `size` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To print the link line, we will use a second Python helper script (`echo-file.py`)
    to print the contents of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us have a look at our `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first declare a Fortran project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This example depends on the Python interpreter so that we can execute the helper
    scripts in a portable fashion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we default to the `"Release"` build type so that CMake adds
    optimization flags so that we have something to print later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define the executable target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a custom command to print the link line before the `example`
    target is linked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define a custom command to print the static size of the executable
    after it has been successfully built:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us test it out. Observe the printed link line and static size of executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once a library or executable target has been declared, one can latch additional
    commands onto the target by using `add_custom_command`. As we have seen, these
    commands will be executed at specific times, contextually to the execution of
    the target they are attached to. CMake understands the following options for the
    execution order of custom commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PRE_BUILD`: For commands to be executed before any other rules pertaining
    to the target are executed. This is however only supported for Visual Studio 7
    or later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRE_LINK`: With this option, commands are executed after the target has been
    compiled but before the linker or archiver are invoked. Using `PRE_BUILD` with
    generators other than Visual Studio 7 or later will be interpreted as `PRE_LINK`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST_BUILD`: As already explained, the commands will be run after all the
    rules for the given target have been executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we have bolted on two custom commands to the executable target.
    The `PRE_LINK` command prints the content of `${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/example.dir/link.txt`
    to the screen. This file contains the link command and in our example, the link
    line turned out to be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We have used a Python wrapper for this to not depend on shell commands, which
    might not be portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second step, the `POST_BUILD` custom command called the Python helper
    script `static-size.py` with the generator expression `$<TARGET_FILE:example>`
    as argument. CMake will expand the generator expression to the target file path
    at *generation time*, that is, when the build system is generated. The Python
    script `static-size.py` in turn uses the size command to obtain the size of static
    allocation of the executable file, converts it to MB, and prints the result. In
    our case, we obtained the expected 160 MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Probing compilation and linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-06) and
    has a C++ example. The recipe is valid with CMake version 3.9 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows. The code repository also contains
    an example compatible with CMake 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common operations during build system generation is to assess
    what kind of system we are trying to build our project on. That means trying to
    find out which functionality works and which does not, and adapting the compilation
    of our project accordingly, either by signaling that dependencies are unmet or
    by enabling proper workarounds in our codebase. The next few recipes will show
    how to perform these operations with CMake. In particular, we will consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to make sure that specific code snippets compile successfully into executables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to make sure that the compiler understands desired flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to make sure that specific code snippets compile successfully into *running
    executables*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will show how to use the `check_<lang>_source_compiles` function from
    the corresponding `Check<LANG>SourceCompiles.cmake` standard module, in order
    to assess whether the given compiler can compile a predefined code snippet into
    an executable. The command can help you ascertain whether:'
  prefs: []
  type: TYPE_NORMAL
- en: Your compiler supports desired features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The linker works properly and understands specific flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include directories and libraries found using `find_package` are usable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will show how to detect the task loop feature of the OpenMP
    4.5 standard for its use in a C++ executable. We will use a sample C++ source
    file to probe whether the compiler supports such a feature. CMake offers an additional
    command,  `try_compile`, to probe compilation. This recipe will show how to use
    both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the CMake command-line interface to get documentation about specific
    modules (`cmake --help-module <module-name>`) and commands (`cmake --help-command
    <command-name>`). In our example, `cmake --help-module CheckCXXSourceCompiles`
    will output the documentation for the `check_cxx_source_compiles` function to
    screen, while `cmake --help-command try_compile` will do the same for the `try_compile`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use both `try_compile` and `check_cxx_source_compiles` and compare
    how the two commands work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a C++11 project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We find OpenMP support for the compiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If OpenMP was found, we move forward and probe whether the desired feature
    is available. To this end, we set a scratch directory. This will be used by `try_compile`
    to generate its intermediate files. We place this inside the if-clause introduced
    in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We call `try_compile` to generate a small project to attempt compiling the
    source file `taskloop.cpp`. Success or failure will be saved into the `omp_taskloop_test_1` variable.
    We need to set appropriate compiler flags, include directories, and link libraries
    for this small sample compilation. Since we are using the *imported target* `OpenMP::OpenMP_CXX`,
    this is simply done by setting the `LINK_LIBRARIES` option to `try_compile`. If
    compilation succeeds, then the task loop feature is available and we print a message
    for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `check_cxx_source_compiles` function, we need to include the `CheckCXXSourceCompiles.cmake`
    module file. This is distributed with CMake, alongside similar files for C (`CheckCSourceCompiles.cmake`)
    and Fortran (`CheckFortranSourceCompiles.cmake`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We copy the contents of the source file we are attempting to compile and link
    into a CMake variable by reading its contents with the `file(READ ...)` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We set `CMAKE_REQUIRED_LIBRARIES`. This is needed for the correct invocation
    of the compiler in the next step. Note the use of the *imported* `OpenMP::OpenMP_CXX`
    target, which will set also the proper compiler flags and include directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We invoke the `check_cxx_source_compiles` function with our code snippet. The
    result of the check will be saved into the `omp_taskloop_test_2` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We unset the variables defined before calling `check_cxx_source_compiles` and
    print a message to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we test the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both `try_compile` and `check_cxx_source_compiles` will compile and link a
    source file into an executable. If those operations succeed, then the output variable,
    `omp_task_loop_test_1` for the former and `omp_task_loop_test_2` for the latter,
    will be set to `TRUE`. The way this task is achieved is slightly different between
    the two commands, however. The `check_<lang>_source_compiles` family of commands
    is a simplified wrapper to the `try_compile` command. As such, it offers a minimal
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: The code snippet to be compiled has to be passed in as a CMake variable. Most
    of the time this means that files have to be read in using `file(READ ...)`, as
    we have done in our example. The snippet is then saved to a file in the `CMakeFiles/CMakeTmp`
    subdirectory of the build directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fine-tuning compilation and linking has to be done by setting the following
    CMake variables before calling the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_FLAGS` to set the compiler flags'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_DEFINITIONS` to set preprocessor macros'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_INCLUDES` to set the list of include directories'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_LIBRARIES` to set the list of libraries to link into the executable'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These variables have to be manually unset after calling the `check_<lang>_compiles_function`,
    to guarantee that further uses of the same variables does not have spurious contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OpenMP imported targets were introduced with CMake 3.9, but the current recipe
    can also be made to work with earlier versions of CMake by manually setting the
    required flags and libraries for `check_cxx_source_compiles` as: `set(CMAKE_REQUIRED_FLAGS
    ${OpenMP_CXX_FLAGS})` and `set(CMAKE_REQUIRED_LIBRARIES ${OpenMP_CXX_LIBRARIES})`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Fortran, CMake assumes the sample snippet to be in fixed-form
    format, which might not always be the case. To overcome false negatives, one needs
    to set the `-ffree-form` compiler flag for `check_fortran_source_compiles`. This
    can be achieved with `set(CMAKE_REQUIRED_FLAGS "-ffree-form")`.
  prefs: []
  type: TYPE_NORMAL
- en: This minimal interface reflects the fact that the test compilation is carried
    out by generating and executing build and link commands directly within the CMake
    invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command `try_compile` offers a more complete interface and two different
    modes of operation:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one takes a full-fledged CMake project as input and will configure,
    build, and link it based on its `CMakeLists.txt`. This mode of operation offers
    more flexibility, since the project to be compiled can be arbitrarily complex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second one, which we have used, where a source file is provided together
    with configuration options for include directories, link libraries, and compiler
    flags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`try_compile` is thus based on invoking CMake on a project, either one where
    the `CMakeLists.txt` is already existing (in the first mode of operation) or one
    where the file is generated on the fly based on the arguments passed to the `try_compile`.'
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checks of the type outlined in this recipe are not always bulletproof and can
    generate both false positives and false negatives. As an example, you can try
    to comment out the lines containing `CMAKE_REQUIRED_LIBRARIES` and the example
    will still report "Success". The reason for this is that OpenMP pragmas will then
    be ignored by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: What should you do when you suspect that a wrong result is being returned? The
    `CMakeOutput.log` and `CMakeError.log `files in the `CMakeFiles` subdirectory of
    the build directory offer clues as to what went wrong. They report the standard
    output and standard error for operations run by CMake. If you suspect false positives,
    you should check the former, by searching for the variable set to hold the result
    of the compilation check. If you suspect false negatives, you should check the
    latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging `try_compile` will require some care. CMake erases all files generated
    by that command, even if the check was unsuccessful. Fortunately, `--debug-trycompile` will
    prevent CMake from cleaning up. If there are multiple calls to `try_compile` in
    your code, you will only be able to debug them one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: Run CMake once, without `--debug-trycompile`. All `try_compile` commands will
    be run and their execution directories and files cleaned up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Erase the variable holding the result of the check from the CMake cache. The
    cache is saved into the `CMakeCache.txt` file. To clear the contents of a variable,
    you can use the `-U` CLI switch followed by the name of the variable, which will
    be interpreted as a globbing expression and may thus use `*` and `?`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Run CMake once more, with `--debug-trycompile`. Only the check for which the
    cache was cleared up will be rerun. Its execution directories and files will not
    be cleaned up this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`try_compile` offers more flexibility and a cleaner interface, especially when
    the code to be compiled is not a short snippet of code. We recommend to use `check_<lang>_source_compiles`
    whenever a small, self-contained snippet of code that does not need extensive
    configuration has to be test-compiled. In all other cases, `try_compile` is to
    be considered a superior alternative.'
  prefs: []
  type: TYPE_NORMAL
- en: Probing compiler flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-07)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Setting compiler flags is critical to make sure that your code is compiled correctly.
    Different compiler vendors implement different flags for similar tasks. Even different
    compiler versions from the same vendor might present slight differences in the
    available flags. Sometimes, new flags are introduced that are extremely convenient
    to use for debugging or optimization purposes. In this recipe, we will show how
    to check that certain flags are available for the selected compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sanitizers (refer to [https://github.com/google/sanitizers](https://github.com/google/sanitizers))
    have become incredibly useful tools for static and dynamic code analysis. By simply
    recompiling your code with the appropriate flags and linking against the necessary
    libraries, you can investigate and debug problems related to memory errors (address
    sanitizer), uninitialized reads (memory sanitizer), thread safety (thread sanitizer),
    and undefined behavior (undefined behavior sanitizer). Compared to similar analysis
    tools, sanitizers typically introduce a much smaller performance penalty and tend
    to give more detailed information on the problems detected. The drawback is that
    your code, and possibly parts of your toolchain, need to be recompiled with the
    additional flags.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will set up a project to compile code with the different
    sanitizers activated and show how to check that the correct compiler flags are
    available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sanitizers have been available for a while with the Clang compiler and were
    later also introduced into the GCC toolset. They were designed for use with C
    and C++ programs, but recent versions of Fortran will understand the same flags
    and produce correctly instrumented libraries and executables. This recipe will
    however focus on a C++ example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we first declare a C++11 project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a list, `CXX_BASIC_FLAGS`, containing the compiler flags to be always
    used when building the project, `-g3` and `-O1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the CMake module `CheckCXXCompilerFlag.cmake`. A similar module
    is available also for C (`CheckCCompilerFlag.cmake`) and Fortran (`CheckFortranCompilerFlag.cmake`,
    since CMake 3.3):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare an `ASAN_FLAGS` variable, which holds the flags needed to activate
    the address sanitizer, and set the `CMAKE_REQUIRED_FLAGS` variable, used internally
    by the `check_cxx_compiler_flag` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We call `check_cxx_compiler_flag` to ensure that the compiler understands the
    flags in the `ASAN_FLAGS` variable. After calling the function, we unset `CMAKE_REQUIRED_FLAGS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If the compiler understands the options, we transform the variable into a list
    by replacing the spaces with semicolons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We add an executable target for our code sample with the address sanitizer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the compiler flags for the executable to contain the basic and address
    sanitizer flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the address sanitizer flags also to the set of flags used by
    the linker. This closes the `if(asan_works)` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The full recipe source code also shows how to compile and link sample executables
    for the thread, memory, and undefined behavior sanitizers. These are not discussed
    in detail here, since we use the same pattern for the compiler flag checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom CMake module for finding support for sanitizers on your system is
    available on GitHub: [https://github.com/arsenm/sanitizers-cmake](https://github.com/arsenm/sanitizers-cmake).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `check_<lang>_compiler_flag` functions are simply wrappers around the `check_<lang>_source_compiles`
    function, which we discussed in the previous recipe. These wrappers provide a
    shortcut for the common use case where it is not important to check whether a
    specific code snippet compiles, but whether the compiler understands a set of
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler flags for sanitizers are a special case, in that they also need to
    be passed on to the linker. To achieve this with the `check_<lang>_compiler_flag`
    functions, we need to set the `CMAKE_REQUIRED_FLAGS` variable prior to the call.
    The flags passed as the first argument would otherwise only be used in the call
    to the compiler, resulting in a false negative.
  prefs: []
  type: TYPE_NORMAL
- en: One more point to notice in the current recipe is the use of string variables
    and lists to set compiler flags. Using string variables with the `target_compile_options`
    and `target_link_libraries` functions will result in a compiler and/or linker
    error. CMake will pass these options quoted, resulting in parsing errors. This
    justifies the need to express these options in terms of lists and the ensuing
    string manipulations, to replace spaces in string variables with semicolons. We
    recall, in fact, that lists in CMake are semicolon-separated strings.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will revisit and generalize the pattern for testing and setting compiler
    flags in [Chapter 7](b655f271-d579-4d7f-aaf4-cd2188f0a1b5.xhtml), *Structuring
    Projects*, Recipe 3, *Writing a function to test and set compiler flags*.
  prefs: []
  type: TYPE_NORMAL
- en: Probing execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-08)
    and has a C/C++ example. The recipe is valid with CMake version 3.6 (and higher)
    and has been tested on GNU/Linux and macOS. The code repository also contains
    an example compatible with CMake 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: We have so far shown how to check that a given source snippet can be compiled
    by the chosen compiler and how to make sure that the desired compiler and linker
    flags are available. This recipe will show how to check whether a code snippet
    can be compiled, linked, and run on the current system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code sample for this recipe is a slight variation of [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 9, *Detecting external libraries: I.
    Using* `pkg-config`. There, we showed how to find the ZeroMQ library on your system
    and link it into a C program. In this recipe, we will check that a small C program
    using the system UUID library on GNU/Linux can actually run, before generating
    the actual C++ program.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We wish to check whether the UUID system library on GNU/Linux can be linked
    against, before embarking on building our own C++ project. This can be achieved
    with the following series of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by declaring a mixed C and C++11 program. This is needed since the
    test code snippet we want to compile and run is in the C language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to find the UUID library on our system. This is achieved by using `pkg-config`.
    We ask for the search to return a CMake imported target using the `IMPORTED_TARGET`
    argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we include the `CheckCSourceRuns.cmake` module. There is a similar `CheckCXXSourceRuns.cmake`
    module for C++. No such module is available for the Fortran language as of CMake
    3.11, however:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare an `_test_uuid` variable containing the C code snippet to compile
    and run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the `CMAKE_REQUIRED_LIBRARIES` variable to fine-tune the call to
    the `check_c_source_runs` function. Next, we issue a call to `check_c_source_runs` with
    the test snippet as the first argument and the `_runs` variable as the second
    argument, to hold the result of the check performed. We also unset the `CMAKE_REQUIRED_LIBRARIES`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If the check did not succeed, either because the snippet didn''t compile or
    because it didn''t run, we stop the configuration with a fatal error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we move on and add the C++ executable as a target and link against
    UUID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `check_<lang>_source_runs` functions for C and C++ operate with the same
    general principles as `check_<lang>_source_compiles`, but add an extra step where
    the produced executable is actually run. As for `check_<lang>_source_compiles`,
    the execution of  `check_<lang>_source_runs` can be directed by the following
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_FLAGS` to set the compiler flags'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_DEFINITIONS` to set preprocessor macros'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_INCLUDES` to set the list of include directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_REQUIRED_LIBRARIES` to set the list of libraries to link into the executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we used the imported target as produced by `pkg_search_module`, it was
    only necessary to set `CMAKE_REQUIRES_LIBRARIES` to `PkgConfig::UUID`, to also
    get the include directories correctly set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as `check_<lang>_source_compiles` is a wrapper to `try_compile`, `check_<lang>_source_runs`
    is a wrapper to another, more powerful command in CMake: `try_run`. It is thus
    possible to write a `CheckFortranSourceRuns.cmake` module that offers the same
    functionality as the C and C++ modules by appropriately wrapping `try_run`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`pkg_search_module` learned how to define imported targets only with CMake
    3.6, but the current recipe can be made to work also with earlier versions of
    CMake by manually setting the required include directories and libraries for `check_c_source_runs`
    as follows: `set(CMAKE_REQUIRED_INCLUDES ${UUID_INCLUDE_DIRS})` and `set(CMAKE_REQUIRED_LIBRARIES
    ${UUID_LIBRARIES})`.'
  prefs: []
  type: TYPE_NORMAL
- en: Fine-tuning configuration and compilation with generator expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-09)
    and has a C++ example. The recipe is valid with CMake version 3.9 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: CMake offers a domain-specific language to describe how to configure and build
    a project. It is natural that variables describing particular conditions are introduced
    and conditional statements based on this are included in `CMakeLists.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will revisit generator expressions, which we used throughout
    [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running
    Tests*, to compactly refer to explicit test executable paths. Generator expressions
    offer a powerful and compact pattern for logical and informational expressions
    that are evaluated during build system generation and produce information specific
    to each build configuration. In other words, generator expressions are useful
    to refer to information that is only known at generation time, but not known or
    difficult to know at configure time; this is particularly the case for filenames,
    file locations, and library file suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will employ generator expressions to conditionally set a
    preprocessor definition and conditionally link to a message passing interface
    (MPI) library and allow us to build the same source code either sequentially or
    using MPI parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use an imported target to link to MPI, which is only
    available starting with CMake 3.9\. However, the generator expression aspect is
    transferable to CMake 3.0 or later versions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will compile the following example source code (`example.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The code contains preprocessor statements (`#ifdef HAVE_MPI` ... `#else` ...
    `#endif`) so that we can compile either a sequential or a parallel executable
    with the same source code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When composing the `CMakeLists.txt` file, we will reuse some of the building
    blocks we encountered in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, Recipe 6, *Detecting the MPI parallel environment*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C++11 project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we introduce an option, `USE_MPI`, to select MPI parallelization and
    set it `ON` by default. If it is `ON`, we use `find_package` to locate the MPI
    environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the executable target and conditionally set the corresponding
    library dependency (`MPI::MPI_CXX`) and preprocessor definition (`HAVE_MPI`),
    which we will explain in a moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If MPI is found, we also print the `INTERFACE_LINK_LIBRARIES` exported by `FindMPI.cmake`
    to demonstrate the very handy `cmake_print_properties()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us first configure the code with the default MPI paralellization switched
    `ON`. Observe the output from `cmake_print_properties()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We compile and run the parallel example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us step one directory up, create a new build directory, and this time
    build the sequential version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The build system for a project is generated by CMake in two phases: a configuration
    phase, where `CMakeLists.txt` is parsed, and a generation phase, where the build
    environment is actually generated. Generator expressions are evaluated in this
    second phase and can be used to tweak the build system with information that can
    only be known at generation time. Generator expressions are thus particularly
    useful when cross-compiling, where some of the information is only available after
    the `CMakeLists.txt` has been parsed, or in multi-configuration projects, where
    the build system is generated at once for all the different configurations the
    project can have, such as `Debug` and `Release`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we will use generator expressions to conditionally set a link
    dependency and compile definition. For this, we can focus on these two expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If `MPI_FOUND` is true, then `$<BOOL:${MPI_FOUND}>` will evaluate to 1\. In
    this case, `$<$<BOOL:${MPI_FOUND}>:MPI::MPI_CXX>` will evaluate to `MPI::MPI_CXX`
    and the second generator expression will evaluate to `HAVE_MPI`. If we set `USE_MPI`
    to `OFF`, `MPI_FOUND` is false and both generator expressions evaluate to empty
    strings, and thus no link dependency is introduced and no preprocessor definition
    is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have achieved the same effect by introducing an if-statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This solution is a bit less compact but possibly a bit more readable. We can
    often re-express if-statements using generator expressions and the choice is often
    a matter of taste. However, generator expressions particularly shine when we need
    to access or manipulate explicit file paths, since these can be difficult to construct
    using variables and if-clauses, and in this case we clearly favor generator expressions
    for readability. This was the case in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests*, where we used generator expressions to resolve the file path
    of a particular target. We will also appreciate generator expressions in [Chapter
    11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml), *Packaging Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CMake offers three types of generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: Logical expressions, with the basic pattern `$<condition:outcome>`. The basic
    conditions are `0` for false and `1` for true, but any Boolean can be used as
    a condition, provided that the correct keywords are used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Informational expression, with the basic pattern `$<information>` or `$<information:input>`.
    These expressions evaluate to some build system information, for example, include
    directories, target properties, and so forth. The input parameter to these expressions
    might be the name of a target, as in the expression `$<TARGET_PROPERTY:tgt,prop>`,
    where the information obtained will be the `prop` property on the `tgt` target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output expressions, with the basic pattern `$<operation>` or `$<operation:input>`.
    These expressions generate an output, possibly based on some input parameters.
    Their output can be used directly inside CMake commands or combined with other
    generator expressions. For example, `-I$<JOIN:$<TARGET_PROPERTY:INCLUDE_DIRECTORIES>,
    -I>` will generate a string containing the include directories for the target
    being processed, each prependend by `-I`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a full list of generator expressions, please consult [https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html).
  prefs: []
  type: TYPE_NORMAL
