- en: Detecting External Libraries and Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the Python interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the Python library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting Python modules and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the BLAS and LAPACK math libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the OpenMP parallel environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the MPI parallel environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the Eigen library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting the Boost libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detecting external libraries: I. Using `pkg-config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detecting external libraries: II. Writing a find-module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Projects often depend on other projects and libraries. This chapter demonstrates
    how to detect external libraries, frameworks, and projects and how to link to
    these. CMake has a rather extensive set of prepackaged modules to detect the most
    commonly used libraries and programs, such as Python and Boost, for example. You
    can get a list of existing modules using `cmake --help-module-list`. However,
    not all libraries and programs are covered and from time to time you will have
    to provide your own detection scripts. In this chapter, we will discuss the necessary
    tools and discover the find family of CMake commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find_file` to find a full path to a named file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_library` to find a library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_package` to find and load settings from an external project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_path` to find a directory containing the named file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find_program` to find a program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `--help-command` command-line switch to print the documentation
    for any of the CMake built-in commands to screen.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the Python interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-01).
    The recipe is valid with CMake version 3.5 (and higher) and has been tested on
    GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Python is a very popular dynamic language. Many projects package tools written
    in Python together with their main programs and libraries, or use Python scripts
    in the configuration or build process. In such cases, it is important to ensure
    that the runtime dependency on the Python interpreter is also satisfied. This
    recipe will show how to detect and use the Python interpreter at the configuration
    step. We will introduce the `find_package` command, which will be used throughout
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build up the `CMakeLists.txt` file step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start out by defining the minimum CMake version and project name. Note that
    for this example we will not need any language support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the `find_package` command to find the Python interpreter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we execute a Python command and capture its output and return value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we print the return value and the output of the Python command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can examine the output of the configuration step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`find_package` is a wrapper command for CMake modules written for discovering
    and setting up packages. These modules contain CMake commands to identify packages
    in standard locations on the system. The files for the CMake modules are called
    `Find<name>.cmake` and the commands they contain will be run internally when a
    call to `find_package(<name>)` is issued.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to actually discovering the requested package on your system, find
    modules also set up a handful of useful variables, reflecting what was actually
    found, which you can use in your own `CMakeLists.txt`. In the case of the Python
    interpreter, the relevant module is `FindPythonInterp.cmake`, which is shipped
    with CMake, and sets the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PYTHONINTERP_FOUND`, a Boolean signaling whether the interpreter was found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PYTHON_EXECUTABLE`, the path to the executable for the Python interpreter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PYTHON_VERSION_STRING`, the full version of the Python interpreter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PYTHON_VERSION_MAJOR`, the major version of the Python interpreter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PYTHON_VERSION_MINOR`, the minor version of the Python interpreter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PYTHON_VERSION_PATCH`, the patch number of the Python interpreter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to force CMake to look for specific versions of a package. For
    example, use this to request any version of the Python interpreter greater or
    equal to 2.7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to enforce that dependencies are satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, CMake will abort configuration if no suitable executable for the
    Python interpreter is found in the usual lookup locations.
  prefs: []
  type: TYPE_NORMAL
- en: CMake has modules for finding many widespread software packages. We recommend
    to always search the CMake online documentation for existing `Find<package>.cmake`
    modules and to read their documentation before using them. The documentation for
    the `find_package` command can be found at [https://cmake.org/cmake/help/v3.5/command/find_package.html](https://cmake.org/cmake/help/v3.5/command/find_package.html).
    A good alternative to online documentation is to browse CMake module sources in [https://github.com/Kitware/CMake/tree/master/Modules](https://github.com/Kitware/CMake/tree/master/Modules)
    - their headers document the variables that a module uses, as well as the variables
    set by the module that can be used in your `CMakeLists.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, packages are not installed in standard locations and CMake might
    fail to locate them correctly. It is possible to tell CMake to look into certain
    specific locations to find certain software using the CLI switch `-D` to pass
    the appropriate option. In the case of the Python interpreter, you may configure
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will correctly identify the Python executable in the non-standard `/custom/location/python` installation
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Every package is different and the `Find<package>.cmake` modules try to take
    that into account and offer a unified interface for detection. When a package
    that is installed on the system cannot be found by CMake, we recommend you read
    the documentation for the corresponding detection module to understand how to
    instruct CMake correctly. You can browse the documentation directly in the terminal,
    in this case using `cmake --help-module FindPythonInterp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Independently of detecting packages, we would like to mention a handy helper
    module for printing variables. In this recipe, we have used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A handy alternative for debugging is to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For more documentation on convenience macros for printing properties and variables,
    see [https://cmake.org/cmake/help/v3.5/module/CMakePrintHelpers.html](https://cmake.org/cmake/help/v3.5/module/CMakePrintHelpers.html).
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the Python library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-02)
    and has a C example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of Python tools to analyze and manipulate output from compiled programs
    is nowadays widespread. However, there are also other, more powerful ways of combining
    an interpreted language such as Python with compiled languages such as C or C++.
    One way is to *extend* Python by providing new types and new functionalities on
    these types *via* C or C++ modules, compiled into shared libraries. This will
    be the topic of recipes in [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language
    Projects*. Another approach is to *embed* the Python interpreter into a C or C++
    program. Both approaches require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A working version of the Python interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The availability of the Python header file `Python.h`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python runtime library `libpython`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three components have to be pinned to the exact same version. We have demonstrated
    how to find the Python interpreter; in this recipe, we will show how to find the
    two missing ingredients for a successful embedding.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use a simple example of Python embedding into a C program that can
    be found on the Python documentation pages. The source file is called `hello-embedded-python.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code samples will initialize an instance of the Python interpreter within
    the program and print the date using the `time` Python module.
  prefs: []
  type: TYPE_NORMAL
- en: The embedding sample code can be found online in the Python documentation pages
    at [https://docs.python.org/2/extending/embedding.html](https://docs.python.org/2/extending/embedding.html)
    and [https://docs.python.org/3/extending/embedding.html](https://docs.python.org/3/extending/embedding.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the steps to follow in our `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first block contains the minimum CMake version, project name, and required
    language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe we enforce the use of the C99 standard for C. This is not strictly
    required for linking with Python, but is something you might want to have in place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the Python interpreter. This is now a required dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the Python header and library. The appropriate module is called `FindPythonLibs.cmake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We add an executable target which uses the `hello-embedded-python.c` source
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The executable includes the `Python.h` header file. Thus, the include directories
    for this target have to include the Python include directory, accessible from
    the `PYTHON_INCLUDE_DIRS` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we link the executable to the Python library, accessible *via* the
    `PYTHON_LIBRARIES` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to run the configuration step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we execute the build step and run the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FindPythonLibs.cmake` module will look in standard locations for the Python
    header and library. Since these are required dependencies of our project, configuration
    will stop with an error if these are not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we explicitly asked CMake to detect the installation of the Python
    executable. This is to ensure that executable, header, and library all have a
    matching version. This is paramount to ensure that there are no mismatches between
    versions that could cause crashes at runtime. We have achieved this by using `PYTHON_VERSION_MAJOR`
    and `PYTHON_VERSION_MINOR`, defined in `FindPythonInterp.cmake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `EXACT` keyword, we have constrained CMake to detect a particular,
    and in this case matching, version of the Python include files and libraries.
    For an even closer match, we could have used the precise `PYTHON_VERSION_STRING`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do we make sure that the Python header and libraries are correctly located
    even when they are not in a standard installation directory? For the Python interpreter,
    it is possible to force CMake to look in specific directories by passing the `PYTHON_LIBRARY`
    and `PYTHON_INCLUDE_DIR` options *via* the `-D` option to the CLI. These options
    specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PYTHON_LIBRARY`, the path to the Python library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PYTHON_INCLUDE_DIR`, the path to where `Python.h` is located'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures that the desired version of Python will be picked up.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it is necessary to pass `-D PYTHON_EXECUTABLE`, `-D PYTHON_LIBRARY`,
    and `-D PYTHON_INCLUDE_DIR` to the CMake CLI in order to locate all necessary
    components and pin them down to the exact same version.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It might be very difficult to exactly pin the Python interpreter and its development
    components to be of the exact same version. This is especially true for those
    cases where they are installed in non-standard locations or there is more than
    one version of each installed on your system. New Python detection modules have
    been added to CMake in its version 3.12 that are aimed at solving this vexing
    problem. The detection portion of our `CMakeLists.txt` would also be greatly simplified
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We encourage you to read the documentation for the new module at: [https://cmake.org/cmake/help/v3.12/module/FindPython.html](https://cmake.org/cmake/help/v3.12/module/FindPython.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Python modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-03)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, we showed how to detect the Python interpreter and how
    to compile a simple C program, embedding the Python interpreter. Both are fundamental
    tasks to get you off the ground when combining Python and a compiled language.
    Often, your code will depend on specific Python modules, be they Python tools,
    compiled programs embedding Python, or libraries extending it. For example, NumPy
    has become very popular in the scientific community for problems involving matrix
    algebra. In projects that depend on Python modules or packages, it is important
    to make sure that the dependency on these Python modules is satisfied. This recipe
    will show how to probe the user's environment to find specific Python modules
    and packages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will try a slightly more involved embedding example in a C++ program. The
    example is again taken from the Python online documentation ([https://docs.python.org/3.5/extending/embedding.html#pure-embedding](https://docs.python.org/3.5/extending/embedding.html#pure-embedding))
    and shows how to execute functions from a user-defined Python module by calling
    the compiled C++ executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python 3 example code (`Py3-pure-embedding.cpp`) contains the following
    source code (see [https://docs.python.org/2/extending/embedding.html#pure-embedding](https://docs.python.org/2/extending/embedding.html#pure-embedding)
    for the corresponding Python 2 equivalent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python code that we wish to embed (`use_numpy.py`) uses NumPy to set up
    a matrix with all matrix elements set to 1.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we wish to be able to check whether NumPy is available
    using CMake. We will first need to make sure that the Python interpreter, headers,
    and libraries are all available on our system. We will then move on to make sure
    that NumPy is available:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the minimum CMake version, project name, language, and C++
    standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding the interpreter, headers, and libraries is achieved exactly as in the
    previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Properly packaged Python modules are aware of their installation location and
    version. This can be probed by executing a minimal Python script. We can execute
    this step *within* our `CMakeLists.txt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_numpy_status` variable will be an integer if NumPy was found or a string
    with some error message otherwise, whereas `_numpy_location` will contain the
    path to the NumPy module. If NumPy is found, we save its location to a new variable
    simply called `NumPy`. Notice that the new variable is cached; this means that
    CMake creates a persistent variable that can be later modified by the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to check the version of the module. Once again, we deploy
    some Python magic in our `CMakeLists.txt`, saving the version into a `_numpy_version`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we let the `FindPackageHandleStandardArgs` CMake package set up the
    `NumPy_FOUND` variable and output status information in the correct format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all dependencies have been correctly found, we can compile the executable
    and link it to the Python libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to make sure that `use_numpy.py` is available in the build directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test the detection and embedding of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three new CMake commands in this recipe: `execute_process` and `add_custom_command`,
    which are always available, and `find_package_handle_standard_args`, which requires
    `include(FindPackageHandleStandardArgs)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `execute_process` command will execute one or more commands as child processes
    to the currently issued CMake command. The return value for the last child process
    will be saved into the variable passed as an argument to `RESULT_VARIABLE`, while
    the contents of the standard output and standard error pipes will be saved into
    the variables passed as arguments to `OUTPUT_VARIABLE` and `ERROR_VARIABLE`. `execute_process`
    allows us to execute arbitrary commands and use their results to infer the configuration
    of our system. In our case, we first use it to make sure that NumPy is available
    and then to obtain the version of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find_package_handle_standard_args` command provides the standard tool
    for handling common operations related to finding programs and libraries installed
    on a given system. The version-related options, `REQUIRED` and `EXACT`, are all
    correctly handled without further CMake code when referring to this command. The
    additional options `QUIET` and `COMPONENTS`, which we will meet shortly, are also
    handled under the hood by this CMake command. In this recipe, we have used the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will set the variable to signal that the module was found (`NumPy_FOUND`)
    when all required variables are set to valid file paths (`NumPy`). It will also
    set the version to the passed version variable (` _numpy_version`) and print out
    status messages for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the present recipe, we have not used these variables further. What we could
    have done is to stop the configuration if `NumPy_FOUND` was returned as `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should comment on the section of the code that copies `use_numpy.py`
    to the build directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We could have achieved the copying with a `file(COPY ...)` command. Here, we
    opted to use `add_custom_command` to make sure that the file gets copied every
    time it changes, not only the first time we run the configuration. We will return
    to `add_custom_command` in more detail in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)*,
    Configure-time and Build-time Operations*. Note also the `target_sources` command,
    which adds the dependency to `${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py`; this
    was done to make sure that building the `pure-embedding` target triggers the preceding
    custom command.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the BLAS and LAPACK math libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-04)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many numerical codes rely heavily on matrix and vector operations. Think for
    example of matrix-vector and matrix-matrix products, the solution of linear system
    of equations, the calculation of eigenvalues and eigenvectors or singular-value
    decompositions. These operations might be so ubiquitous in the code base or might
    have to be run on such large data sets that the availability of efficient implementations
    becomes an absolute necessity in your code. Fortunately, there are libraries just
    for that: the basic linear algebra subprograms (BLAS) and the linear algebra package
    (LAPACK) offer *standard* APIs for many tasks involving linear algebraic manipulations.
    Different vendors provide different implementations, but all of them share the
    same API. While the actual programming languages for the underlying implementation
    of the math libraries varied over time (Fortran, C, Assembly), the remaining historical
    trace is the Fortran calling convention. Our task in this recipe will be to link
    against these libraries and show how to seamlessly work with a library written
    in a different language, considering the above-mentioned calling convention.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate the detection and linking of math libraries, we wish to compile
    a C++ program that takes the dimension of a matrix as command-line input, generates
    a random square matrix **A**, a random vector **b** and solves the ensuing linear
    systems of equations: **Ax** = **b**. In addition, we will scale the random vector **b** by
    a random factor. The subroutines we need to use are `DSCAL` from BLAS, to perform
    the scaling and `DGESV` from LAPACK to find the solution of the linear system
    of equations. The listing for the example C++ code contains (`linear-algebra.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We are using the random library, introduced in C++11, to generate a random distribution
    between -1.0 and 1.0\. `C_DSCAL` and `C_DGESV` are interfaces to the BLAS and
    LAPACK libraries, respectively, taking care of the name mangling in order to call
    these functions from a different programming language. This is done in the following
    interface files in combination with a CMake module which we will discuss further
    below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file `CxxBLAS.hpp` wraps the BLAS routine with `extern "C"` linkage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding implementation file `CxxBLAS.cpp` contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The files `CxxLAPACK.hpp` and `CxxLAPACK.cpp` perform corresponding translations
    for the LAPACK calls.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The corresponding `CMakeLists.txt` contains the following building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the minimum CMake version, the project name and supported languages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We require the C++11 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we verify whether Fortran and C/C++ compilers work together and generate
    the header file which will take care of name mangling. Both functions are provided
    by the `FortranCInterface` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We then ask CMake to find BLAS and LAPACK. These are required dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add a library with our sources for the BLAS and LAPACK wrappers and
    link against `LAPACK_LIBRARIES` which brings in also `BLAS_LIBRARIES`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the include directories and link libraries for this target are declared
    as `PUBLIC` and therefore any additional target depending on the math library
    will also set these directories in its include directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we add an executable target and link to `math`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the configuration step we can focus on the relevant output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we build and test the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FindBLAS.cmake` and `FindLAPACK.cmake` will look in standard locations for
    libraries offering the standard BLAS and LAPACK APIs. For the former, the module
    will look for the Fortran implementation of the `SGEMM` function, for single-precision
    matrix-matrix products for general matrices. For the latter, the module searches
    for the Fortran implementation of the `CHEEV` function, for the calculation of
    eigenvalues and eigenvectors of complex, Hermitian matrices. These lookups are
    carried out internally by compiling a small program calling these functions and
    trying to link against the candidate libraries. If that fails, it signals that
    a compliant library is not available on the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Every compiler performs name-mangling of symbols when generating machine code
    and unfortunately conventions for this operation are not universal, but compiler-dependent.
    To overcome this difficulty, we have used the `FortranCInterface` module ([https://cmake.org/cmake/help/v3.5/module/FortranCInterface.html](https://cmake.org/cmake/help/v3.5/module/FortranCInterface.html))
    to both verify that the Fortran and C/C++ compilers work together and to generate
    a Fortran-C interface header `fc_mangle.h` which is compatible with the compiler
    in question. The generated `fc_mangle.h` must then be included in the interface
    header files `CxxBLAS.hpp` and `CxxLAPACK.hpp`. We had to add C and Fortran support
    to the list of `LANGUAGES` in order to use `FortranCInterface`. Of course we could
    have defined own preprocessor definitions instead, however at the price of limited
    portability.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the interoperability of Fortran and C more closely in [Chapter
    9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, many implementations of BLAS and LAPACK already ship with a thin C
    layer wrapper around the Fortran subroutines. These wrappers have been standardized
    over the years and are called CBLAS and LAPACKE.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many numerical codes rely heavily on matrix algebra operations and it is important
    to correctly link against high-performance implementations of the BLAS and LAPACK
    APIs. There is a large variability in the way vendors package their libraries
    for different architectures and parallel environments. `FindBLAS.cmake` and `FindLAPACK.cmake`
    will most likely not be able to locate an existing library in all possible cases.
    If that happens, you can explicitly set the libraries from the CLI *via* the `-D`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the OpenMP parallel environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05)
    and has a C++ and Fortran example. The recipe is valid with CMake version 3.9
    (and higher) and has been tested on GNU/Linux, macOS, and Windows. In [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05),
    we also provide examples compatible with CMake 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: Today, basically any computer on the market is a multi-core machine and for
    programs focusing on performance, we may have to focus on these multi-core CPUs
    and use concurrency in our programming models. OpenMP is the standard for shared-memory
    parallelism on multi-core CPUs. Existing programs often do not need to be radically
    modified or rewritten in order to benefit from OpenMP parallelization. Once the
    performance-critical sections in the code are identified, for example using a
    profiling tool, the programmer can add preprocessor directives that will instruct
    the compiler to generate parallel code for those regions.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show how to compile a program containing OpenMP directives,
    provided we use an OpenMP-aware compiler. Many Fortran, C, and C++ compilers exist
    that can take advantage of OpenMP parallelism. CMake provides very good support
    for OpenMP in combination with C, C++, or Fortran for relatively recent versions
    of CMake. This recipe will show you how to detect and link to OpenMP using imported
    targets for simple C++ and Fortran programs when using CMake 3.9 or above.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the Linux distribution, the Clang compiler may not have OpenMP
    support in its default version. This recipe **will not work** on macOS unless
    a separate libomp installation ([https://iscinumpy.gitlab.io/post/omp-on-high-sierra/](https://iscinumpy.gitlab.io/post/omp-on-high-sierra/))
    or a non-Apple version of Clang (e.g., provided by Conda) or the GNU compilers
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C and C++ programs can access OpenMP functionality by including the `omp.h` header
    file and by linking to the correct library. The compiler will generate parallel
    code according to preprocessor directives preceding the performance-critical sections.
    In this recipe, we will build the following example source code (`example.cpp`).
    This code sums integers from 1 to *N,* where *N* is given as a command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In Fortran, one needs to use the `omp_lib` module and link to the correct library.
    Use of parallel directives is once again possible in code comments preceding the
    performance-critical sections. The corresponding `example.F90` contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `CMakeLists.txt` for the C++ and Fortran examples will follow a template
    that is largely similar between the two languages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both define a minimum CMake version, project name, and language (`CXX` or `Fortran`;
    we will show the C++ version):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For the C++ example, we require the C++11 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Both call `find_package` to search for OpenMP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the executable target and link to the imported target provided
    by the `FindOpenMP` module (in the Fortran case, we link against `OpenMP::OpenMP_Fortran`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can configure and build the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us first test it out in parallel (in this example using four cores):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison, we can rerun the example with the number of OpenMP threads
    set to 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our simple example seems to work: the code compiled and linked, and we observe
    a speed-up when running on multiple cores. The fact that the speed-up is not a
    perfect multiple of `OMP_NUM_THREADS` is not our concern in this recipe, since
    we focus on the CMake aspect of a project which requires OpenMP. We have found
    linking to OpenMP to be extremely compact thanks to imported targets provided
    by a reasonably modern `FindOpenMP` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not have to worry about compile flags or about include directories -
    these settings and dependencies are encoded in the definition of the library `OpenMP::OpenMP_CXX`
    which is of the `IMPORTED` type. As we mentioned in Recipe 3, *Building and linking
    static and shared libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries*, `IMPORTED` libraries are pseudo-targets
    that fully encode usage requirements for dependencies outside our own project.
    To use OpenMP one needs to set compiler flags, include directories, and link libraries.
    All of these are set as properties on the `OpenMP::OpenMP_CXX` target and transitively
    applied to our `example` target simply by using the `target_link_libraries` command.
    This makes using libraries within our CMake scripts exceedingly easy. We can print
    the properties of interface with the `cmake_print_properties` command, offered
    by the `CMakePrintHelpers.cmake` standard module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that all properties of interest have the prefix `INTERFACE_`, because these
    properties usage requirements for any target wanting to *interface* and use the
    OpenMP target.
  prefs: []
  type: TYPE_NORMAL
- en: 'For CMake versions below 3.9, we would have to do a bit more work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For CMake versions below 3.5, we might need to explicitly define compile flags
    for a Fortran project.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we have discussed C++ and Fortran, but the arguments and approach
    are valid also for a C project.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the MPI parallel environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06)
    and has a C++ and C example. The recipe is valid with CMake version 3.9 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows. In [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06),
    we also provide a C example compatible with CMake 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative and often complementary approach to OpenMP shared-memory parallelism
    is the Message Passing Interface (MPI), which has become the *de facto* standard
    for modeling a program executing in parallel on a distributed memory system. Although
    modern MPI implementations allow shared-memory parallelism as well, a typical
    approach in high-performance computing is to use OpenMP within a compute node
    combined with MPI across compute nodes. The implementation of the MPI standard
    consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Header files and Fortran 90 modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiler wrappers, which invoke the compiler that was used to build the MPI
    library with additional command-line arguments to take care of include directories
    and libraries. Usually, the available compiler wrappers are `mpic++`/`mpiCC`/`mpicxx`
    for C++, `mpicc` for C, and `mpifort` for Fortran.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'MPI launcher: This is the program you should call to launch a parallel execution
    of your compiled code. Its name is implementation-dependent and it is usually
    one of the following: `mpirun`, `mpiexec`, or `orterun`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe will show how to find a suitable MPI implementation on your system
    in order to compile a simple MPI "Hello, World" program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example code (`hello-mpi.cpp`, downloaded from [http://www.mpitutorial.com](http://www.mpitutorial.com)),
    which we will compile in this recipe, will initialize the MPI library, have every
    process print its name, and eventually finalize the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we set out to find the MPI implementation: library, header
    files, compiler wrappers, and launcher. To do so, we will leverage the `FindMPI.cmake`
    standard CMake module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the minimum CMake version, project name, supported language,
    and language standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call `find_package` to locate the MPI implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the executable name and, source, and similarly to the previous recipe,
    link against the imported target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us configure and build the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute this program in parallel, we use the `mpirun` launcher (in this
    case, using two tasks):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that the compiler wrapper is a thin layer around the compiler used
    to build the MPI library. Under the hood, it will call the same compiler and augment
    it with additional arguments, such as include paths and libraries, needed to successfully
    build a parallel program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which flags does the wrapper actually apply when compiling and linking a source
    file? We can probe this using the `--showme` option to the compiler wrapper. To
    find out the compiler flags we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas to find out the linker flags we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly to the previous OpenMP recipe, we have found the linking to MPI to
    be extremely compact thanks to the imported targets provided by a reasonably modern `FindMPI` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We did not have to worry about compile flags or about include directories -
    these settings and dependencies are already encoded as `INTERFACE`-type properties
    in the `IMPORTED` target provided by CMake.
  prefs: []
  type: TYPE_NORMAL
- en: 'And as discussed in the previous recipe, for CMake versions below 3.9, we would
    have to do a bit more work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we have discussed C++, but the arguments and approach are equally
    valid for a C or Fortran project.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the Eigen library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07)
    and has a C++ example. The recipe is valid with CMake version 3.9 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows. In [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07),
    we also provide a C++ example compatible with CMake 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: The BLAS library offers a standardized interface for common operations involving
    matrices and vectors. This interface was however standardized with the Fortran
    language in mind. While we have shown how these libraries can be used more or
    less directly from C++, it may be desirable to have a higher-level interface in
    modern C++ programs.
  prefs: []
  type: TYPE_NORMAL
- en: The header-only Eigen library uses template programming to offer such an interface.
    Its matrix and vector types are intuitive to use and even provide type checking
    at compile time, to ensure that incompatible matrix dimensions are not mixed.
    Dense and sparse matrix operations, such as matrix-matrix products, solvers for
    linear systems, and eigenvalue problems, are also implemented using expression
    templates for efficiency. From version 3.3, Eigen can be linked to the BLAS and
    LAPACK libraries, which provides the flexibility to offload certain operations
    to the implementation given in these libraries for additional performance.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to find the Eigen library and to instruct it to use
    OpenMP parallelization and offload some of the work to the BLAS library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will compile a program that allocates a random square matrix
    and vector of dimension passed from the command line. We will then solve the linear
    system **Ax**=**b** using LU decomposition. We will use the following source code
    (`linear-algebra.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Matrix-vector multiplications and LU decompositions are implemented in Eigen,
    but can optionally be offloaded to the BLAS and LAPACK libraries. In this recipe,
    we only consider offloading to the BLAS library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, we will find the Eigen and BLAS libraries, as well as OpenMP,
    and instruct Eigen to use OpenMP parallelization and to offload part of the linear
    algebra work to the BLAS library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first declare the minimum CMake version, project name, and use of the C++11
    language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We also ask for OpenMP, since Eigen can make use of shared-memory parallelism
    for dense operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We search for Eigen by calling `find_package` in `CONFIG` mode (we will discuss
    this in the next section):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'If Eigen was found, we print out a helpful status message. Notice that we are
    using the `Eigen3::Eigen` target. As we have learnt in the previous two recipes,
    this is an `IMPORTED` target, offered by the native CMake scripts distributed
    with Eigen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare an executable target for our source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We then find BLAS. Notice that the dependency is now not required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'If BLAS is found, we set the corresponding compile definition and link libraries
    for the executable target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we link to the imported `Eigen3::Eigen` and `OpenMP::OpenMP_CXX` targets.
    This is enough to set all the necessary compile and link flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to configure the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we compile and test the code. Observe that the binary uses, in this
    case, four available threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eigen provides native CMake support, which makes it easy to set up a C++ project
    using it. Starting from version 3.3, Eigen ships CMake modules that export the
    appropriate target, `Eigen3::Eigen`, which we have used here.
  prefs: []
  type: TYPE_NORMAL
- en: You will have noticed the `CONFIG` option to the `find_package` command. This
    signals to CMake that the package search will not proceed through a `FindEigen3.cmake`
    module, but rather through the `Eigen3Config.cmake`, `Eigen3ConfigVersion.cmake`,
    and `Eigen3Targets.cmake` files provided by the Eigen3 package in the standard
    location, `<installation-prefix>/share/eigen3/cmake`. This package location mode
    is called "Config" mode and is more versatile than the `Find<package>.cmake` approach
    we have been using so far. For more information about "Module" mode versus "Config"
    mode, please consult the official documentation at [https://cmake.org/cmake/help/v3.5/command/find_package.html](https://cmake.org/cmake/help/v3.5/command/find_package.html).
  prefs: []
  type: TYPE_NORMAL
- en: Also note that while the Eigen3, BLAS, and OpenMP dependencies were declared
    as `PUBLIC` dependencies, the `EIGEN_USE_BLAS` compile definition was declared
    as `PRIVATE`. Instead of linking the executable directly, we could collect the
    library dependencies in a separate library target. Using the `PUBLIC`/`PRIVATE`
    keywords, we can then adjust the visibility of the corresponding flags and definitions
    to dependents of the library target.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CMake will look for config modules in a predefined hierarchy of locations.
    First off is `CMAKE_PREFIX_PATH`, while `<package>_DIR` is the next search path.
    Thus, if Eigen3 was installed in a non-standard location, we can use two alternatives
    to tell CMake where to look for it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By passing the installation prefix for Eigen3 as `CMAKE_PREFIX_PATH`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing the location of the configuration files as `Eigen3_DIR`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Detecting the Boost libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-08](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-08)
    and has a C++ example. The recipe is valid with CMake version 3.5 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The Boost libraries are a collection of general-purpose C++ libraries. These
    libraries provide a lot of functionality that may be indispensable in a modern
    C++ project, but which is not yet available through the C++ standard. For example,
    Boost provides components for metaprogramming, handling optional arguments, and
    filesystem manipulations, among others. Many of these libraries have later been
    adopted by the C++11, C++14, and C++17 standards, but many Boost components are
    still the libraries of choice for code bases that have to keep compatibility with
    older compilers.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to detect and link against some components of
    the Boost libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code we will compile is one of the examples for the filesystem library
    provided by Boost to interact with the filesystem. This library is conveniently
    cross-platform and abstracts the differences between operating systems and filesystems
    into a coherent, high-level API. The following example code (`path-info.cpp`)
    will accept a path as an argument and print a report about its components to the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boost consists of many different libraries and these can be used almost independently
    from each other. Internally, CMake represents this library collection as a collection
    of components. The `FindBoost.cmake` module can search not only for the full installation
    of the library collection but also for particular components and their dependencies
    within the collection, if any. We will build up the corresponding `CMakeLists.txt`
    step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first declare the minimum CMake version, project name, language, and enforce
    the use of the C++11 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use `find_package` to search for Boost. The dependency on Boost is
    mandatory, hence the `REQUIRED` argument. Since we only need the filesystem component
    in this example, we pass that as an argument after the `COMPONENTS` keyword to
    `find_package`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We add an executable target, to compile the example source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we link the target to the Boost library component. Since the dependency
    is declared `PUBLIC`, targets depending on our target will pick up the dependency
    automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FindBoost.cmake` module, which is used in this recipe, will try to locate
    the Boost libraries in standard system installation directories. Since we link
    to the imported `Boost::filesystem` target, CMake will automatically set the include
    directories and adjust the compile and link flags. In case the Boost libraries
    are installed in a non-standard location, one can pass the root of the Boost installation
    at configuration time using the `BOOST_ROOT` variable in order to point CMake
    to also search the non-standard path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, one can pass both the `BOOST_INCLUDEDIR` and `BOOST_LIBRARYDIR`
    variables for the directories containing headers and libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Detecting external libraries: I. Using pkg-config'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09)
    and has a C example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows (using MSYS Makefiles). In [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09),
    we also provide an example compatible with CMake 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have so far discussed two ways of detecting external dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: Using find-modules shipped with CMake. This is generally reliable and well tested.
    However, not all packages have a find-module in the official release of CMake.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `<package>Config.cmake`, `<package>ConfigVersion.cmake`, and `<package>Targets.cmake` files
    provided by the package vendor and installed alongside the package itself in standard
    locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What if a certain dependency provides neither a find-module nor vendor-packaged
    CMake files? In this case, we are left with two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Rely on the `pkg-config` utility to discover packages on the system. This relies
    on the package vendors distributing metadata about their packages in `.pc` configuration
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write our own find-package module for the dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we will show how to leverage `pkg-config` from within CMake
    to locate the ZeroMQ messaging library. The next recipe, *Detecting external libraries:
    II. Writing a find-module*, will show how to write your own basic find-module
    for ZeroMQ.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code we will build is an example from the ZeroMQ manual at [http://zguide.zeromq.org/page:all](http://zguide.zeromq.org/page:all).
    It consists of two source files, `hwserver.c`, and `hwclient.c`,  which will be
    built into two separate executables. When executed, they will print the familiar
    "Hello, World" message.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a C project and we will use the C99 standard. We will build the `CMakeLists.txt`
    file step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C project and enforce compliance with the C99 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We look for `pkg-config`, using its find-module shipped with CMake. Notice
    the `QUIET` argument passed to `find_package`. CMake will print messages only
    if the required `pkg-config` is not found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'When `pkg-config` is found, we will have access to the `pkg_search_module`
    function to search for any library or program that ships a package configuration
    `.pc` file. In our case, we look for the ZeroMQ library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'A status message is printed, in case the ZeroMQ library was found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add the two executable targets and link against the `IMPORTED`
    target for ZeroMQ. This will set include directories and link libraries automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can configure and build the example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In one terminal, start the server, which will respond with a message similar
    to this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in another terminal start the client, which will print the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once `pkg-config` is found, CMake will provide two functions to wrap the functionality
    offered by this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pkg_check_modules`, to find all modules (libraries and/or programs) in the
    passed list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pkg_search_module`, to find the first working module in the passed list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These functions accept the `REQUIRED` and `QUIET` arguments, as `find_package`
    does. In more detail, our call to `pkg_search_module` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the first argument is the prefix that will be used to name the target
    that is storing the result of the search for the ZeroMQ library: `PkgConfig::ZeroMQ`.
    Notice that we need to pass different options for the names of the library on
    the system: `libzeromq`, `libzmq`, and `lib0mq`. This is due to the fact that
    different operating systems and package managers can choose different names for
    the same package.'
  prefs: []
  type: TYPE_NORMAL
- en: The `pkg_check_modules` and `pkg_search_module` functions gained the `IMPORTED_TARGET`
    option and the functionality to also define an imported target in CMake 3.6\.
    Prior to this version of CMake, only the variables `ZeroMQ_INCLUDE_DIRS`, for
    the include directories, and `ZeroMQ_LIBRARIES`, for the link libraries, would
    have been defined for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Detecting external libraries: II. Writing a find-module'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-10](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-10)
    and has a C example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe complements the previous recipe, *Detecting external libraries:
    I. Using pkg-config*. We will show how to write a basic find-module to locate
    the ZeroMQ messaging library on your system so that the detection of the library
    can be made to work on non-Unix operating systems. We will reuse the same server-client
    sample code.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a C project and we will use the C99 standard. We will build the `CMakeLists.txt`
    file step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C project and enforce compliance with the C99 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We append the current source directory, `CMAKE_CURRENT_SOURCE_DIR`, to the
    list of paths where CMake will look for modules, `CMAKE_MODULE_PATH`. This is
    where our own `FindZeroMQ.cmake` module is located:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'We will discuss `FindZeroMQ.cmake` later, but now that the `FindZeroMQ.cmake`
    module is available, we search for the library. This is a required dependency
    for our project. Since we did not use the `QUIET` option to `find_package`, status
    messages will be printed automatically when the library is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We proceed to add the `hwserver` executable target. The include directories
    and link libraries are specified using the `ZeroMQ_INCLUDE_DIRS` and `ZeroMQ_LIBRARIES`
    variables set by the successful `find_package` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we do the same for the `hwclient` executable target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The main `CMakeLists.txt` for this recipe differs from the one used in the previous
    recipe in the use of the `FindZeroMQ.cmake` module. This module searches for the
    ZeroMQ header files and libraries using the `find_path` and `find_library` CMake
    built-in commands and sets relevant variables using the `find_package_handle_standard_args`,
    as we did in Recipe 3, *Detecting Python modules and packages*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `FindZeroMQ.cmake`, we first check whether the `ZeroMQ_ROOT` CMake variable
    was set by the user. This variable can be used to guide detection of the ZeroMQ
    library to a non-standard installation directory. The user might have set `ZeroMQ_ROOT`
    as an environment variable and we also check for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We then search for the location of the `zmq.h` header file on the system. This
    is based on the `_ZeroMQ_ROOT` variable and uses the `find_path` CMake command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'If the header file was successfully found, `ZeroMQ_INCLUDE_DIRS` is set to
    its location. We proceed to find the version of the ZeroMQ library available,
    using string manipulations and regular expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We then prepare the `ZeroMQ_VERSION` variable for the `find_package_handle_standard_args`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `find_library` command to search for the `ZeroMQ` library. Here,
    we need to make a distinction between Unix-based and Windows platforms, since
    the naming conventions for libraries are different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we include the standard `FindPackageHandleStandardArgs.cmake` module
    and invoke the corresponding CMake command. If all required variables are found
    and the version matches, then the `ZeroMQ_FOUND` variable is set to `TRUE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The `FindZeroMQ.cmake` module we just described has been adapted from [https://github.com/zeromq/azmq/blob/master/config/FindZeroMQ.cmake](https://github.com/zeromq/azmq/blob/master/config/FindZeroMQ.cmake).
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Find-modules typically follow a specific pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the user provided a custom location for the desired package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use commands from the `find_` family to search for known required components
    of the required package, that is, header files, libraries, executables, and so
    forth. We have used `find_path` to find the full path to a header file and `find_library` to
    find a library. CMake also offers `find_file`, `find_program`, and `find_package`.
    These commands have the following general signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<VAR>` will hold the result of the search, if successful, or `<VAR>-NOTFOUND`
    if unsuccessful. `NAMES` and `PATHS` are names for the file CMake should look
    for and paths where the search should be directed, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the results of this preliminary search, a version number is extracted.
    In our example, the ZeroMQ header file contains the library version, which can
    be extracted with string operations and regular expressions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `find_package_handle_standard_args` command is invoked. This will
    handle the standard `REQUIRED`, `QUIET`, and version arguments to the `find_package`
    command, additionally setting the `ZeroMQ_FOUND` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The full documentation for any CMake command can be obtained from the command
    line. For example, `cmake --help-command find_file` will output the manual page
    for the `find_file` command. For the manual page of CMake standard modules, use
    the `--help-module` CLI switch. For example, `cmake --help-module FindPackageHandleStandardArgs`
    will output to screen the manual page for the `FindPackageHandleStandardArgs.cmake`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To summarize, when discovering packages there are four available routes:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the CMake files `<package>Config.cmake`, `<package>ConfigVersion.cmake`,
    and `<package>Targets.cmake` provided by the package vendor and installed alongside
    the package itself in standard locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a find-module for the desired package, whether shipped by CMake or a third
    party.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resort to `pkg-config`, as shown in this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If none of these are viable, write your own find-module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The four alternative routes have been ranked by relevance, but each approach
    has its challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Not all package vendors provide CMake discovery files, but it is becoming more
    common. This is due to the fact that exporting CMake targets makes it very easy
    for third-party code to consume additional dependencies imposed by libraries and/or
    programs that it depends on.
  prefs: []
  type: TYPE_NORMAL
- en: Find-modules have been the workhorse of dependency location in CMake since the
    very beginning. However, most of them still rely on setting variables consumed
    by the dependent, such as `Boost_INCLUDE_DIRS`, `PYTHON_INTERPRETER`, and so forth.
    This approach makes it difficult to redistribute your own package for third-parties
    and ensure that your dependencies are consistently met.
  prefs: []
  type: TYPE_NORMAL
- en: The approach using `pkg-config` can work very well since it has become a *de
    facto* standard for Unix-based systems. For this reason, however, it is not a
    fully cross-platform approach. Moreover, as the CMake documentation states, in
    some cases, the user can accidentally override package detection and lead `pkg-config`
    to supply incorrect information.
  prefs: []
  type: TYPE_NORMAL
- en: The very last resort is then to write your own find-module CMake script, as
    we have done in this recipe. This is doable and relies on the `FindPackageHandleStandardArgs.cmake`
    module we briefly discussed. However, writing a fully comprehensive find-module
    is far from trivial; there are many corner cases that are hard to discover, and
    we have shown an example of that when looking for the ZeroMQ library files on
    Unix and Windows platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'These concerns and difficulties are very well-known to all software developers,
    as witnessed by the lively discussions on the CMake mailing list: [https://cmake.org/pipermail/cmake/2018-May/067556.html](https://cmake.org/pipermail/cmake/2018-May/067556.html). `pkg-config`
    is accepted among Unix package developers, but it cannot be easily ported to not-Unix
    platforms. CMake configuration files are powerful, but not all software developers
    are familiar with the CMake syntax. The Common Package Specification project is
    a very recent attempt at unifying the `pkg-config` and CMake configuration files
    approaches for package discovery. You can find more information on the project''s
    website: [https://mwoehlke.github.io/cps/](https://mwoehlke.github.io/cps/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml), *Writing an Installer*,
    we will discuss how to make your own package discoverable to third-party applications
    by using the first route outlined in the previous discussion: providing your own
    CMake discovery files alongside your project.'
  prefs: []
  type: TYPE_NORMAL
