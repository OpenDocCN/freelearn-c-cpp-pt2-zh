- en: The Superbuild Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the superbuild pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing dependencies with a superbuild: I. The Boost libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing dependencies with a superbuild: II. The FFTW library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing dependencies with a superbuild: III. The Google Test framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your project as a superbuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every project has to deal with dependencies and CMake makes it relatively easy
    to find out whether these dependencies are present on the system where we configure
    our project. [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*, showed how to find dependencies installed on
    the system and we have used that same pattern so far. However, if dependencies
    are not satisfied, the most we can achieve is fail the configuration and alert
    the user of the reasons for such a failure. However, with CMake it is possible
    to organize our projects such that dependencies can be automatically fetched and
    built if they are not found on the system. This chapter will present and analyze
    the `ExternalProject.cmake` and `FetchContent.cmake` standard modules and their
    use in the *superbuild pattern*. The former allows us to retrieve the dependencies
    of our project at *build time* and has been a part of CMake for a long time. The
    latter module was added in version 3.11 of CMake and allows us to retrieve dependencies
    at *configure time*. With the superbuild pattern, we can effectively leverage
    CMake as an advanced package manager: within your project you will handle dependencies
    in the same manner, whether already available on the system or whether they need
    to be built from scratch. The next five recipes will walk you through the pattern
    and show how it can be used to fetch and build virtually any dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: Both modules are extensively documented online. For `ExternalProject.cmake`,
    we refer the reader to [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html).
    For `FetchContent.cmake`, we refer the reader to [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using the superbuild pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-01) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will introduce the superbuild pattern with a very simple example.
    We will show how to use the `ExternalProject_Add` command to build a simple "Hello,
    World" program.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will build the "Hello, World" executable from the following source
    code (`hello-world.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The project is structured as follows, with a root `CMakeLists.txt`, and a `src/CMakeLists.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us first look at `CMakeLists.txt` in the root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C++11 project, with a minimum required CMake version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the `EP_BASE` directory property for the current and any underlying
    directories. This will be discussed shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the `ExternalProject.cmake` standard module. This module provides
    the `ExternalProject_Add` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code for our "Hello, World" example is added as an external project
    by invoking the `ExternalProject_Add` function. The name of the external project
    is `recipe-01_core`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the source directory for the external project using the `SOURCE_DIR`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `src` subdirectory contains a full-fledged CMake project. To configure
    and build it, we pass the appropriate CMake options to the external project *via*
    the `CMAKE_ARGS` option. In our case, we only need to pass the C++ compiler and
    the requirements for the C++ standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also set the C++ compiler flags. These are passed using the `CMAKE_CACHE_ARGS`
    option to the `ExternalProject_Add` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We configure the external project so that it is always built:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The install step will not execute any actions (we will revisit installation
    in Recipe 4, *Installing a superbuild*, in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer):*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now move on to `src/CMakeLists.txt`. Since we are adding our "Hello,
    World" sources as an external project, this is a full-fledged `CMakeLists.txt`
    file for a standalone project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, here we declare a minimum required CMake version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a C++ project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add an executable target, `hello-world`, from the `hello-world.cpp`
    source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuring and building our project is done as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of the build directory is now slightly more complex. In particular,
    we notice the `subprojects` folder with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`recipe-01_core` has been built into a subdirectory of `build/subprojects`, called
    `Build/recipe-01_core`, which is the `EP_BASE` we have set.'
  prefs: []
  type: TYPE_NORMAL
- en: The `hello-world` executable has been created under `Build/recipe-01_core`.
    The additional subfolders `tmp/recipe-01_core` and `Stamp/recipe-01_core` contain
    temporary files, such as the CMake cache script `recipe-01_core-cache-.cmake`,
    and the stamp files for the various steps CMake has performed to build the external
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ExternalProject_Add` command can be used to add sources from third parties.
    Our first example, however, shows how to manage our own project as an assembly
    of different CMake projects. In this example, both the root and the leaf `CMakeLists.txt`
    declared a CMake project, that is, both of them used the `project` command.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExternalProject_Add` has many options that can be used to fine-tune all aspects
    of the configuration and compilation of external projects. These options can be
    classified into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directory** options: These are used to tune the structure of the source and
    build directories for the external project. In our case, we used the `SOURCE_DIR`
    option to let CMake know that the sources are available in the `${CMAKE_CURRENT_LIST_DIR}/src`
    folder and thus should not be fetched from somewhere else. The directories for
    building the project and storing temporary files can also be specified in this
    class of options or as directory properties. We have followed the latter route
    by setting the `EP_BASE` directory property. CMake will set up all directories
    for the various subprojects with the following layout:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Download** options: The code for the external project might have to be downloaded
    from an online repository or resource. Options in this class let you control all
    aspects of this step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update** and **Patch** options: This class of options can be used to define
    how to update the sources for the external project or how to apply patches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure** options: By default, CMake assumes that the external project
    is itself configured using CMake. As the following recipes will show, we are however
    not limited to this case. If the external project is a CMake project, `ExternalProject_Add`
    will call the CMake executable and pass options to it. For our current example,
    we passed configuration arguments *via* the `CMAKE_ARGS` and `CMAKE_CACHE_ARGS`
    options. The former are passed directly as a command line argument, whereas the
    latter are passed *via* a CMake script file. In our example, the script file is
    in `build/subprojects/tmp/recipe-01_core/recipe-01_core-cache-.cmake`. The configuration
    would then look like this example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Build** options: This class of options can be used to tweak the actual compilation
    of the external project. Our example used the `BUILD_ALWAYS` option to ensure
    that the external project is always freshly built.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Install** options: These are options to configure how the external project
    should be installed. Our example left `INSTALL_COMMAND` empty and we will discuss
    installation with CMake in more detail in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test** options: It is always a good idea to run tests for any piece of software
    that is built from sources. This class of options to `ExternalProject_Add` is
    here for this purpose. Our example did not use these options, as the "Hello, World"
    example didn''t have any tests, but in Recipe 5, *Managing your project as a superbuild*,
    we will trigger a test step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExternalProject.cmake` defines the command `ExternalProject_Get_Property`
    which, as the name suggests, is useful to retrieve properties of external projects.
    The properties on external projects are set when first invoking the `ExternalProject_Add`
    command. For example, retrieving the arguments to be passed to CMake when configuring
    `recipe-01_core` can be achieved with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete list of options to `ExternalProject_Add` can be found in the CMake
    documentation: [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add)'
  prefs: []
  type: TYPE_NORMAL
- en: There is more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will explore in detail the flexibility of the `ExternalProject_Add` command
    in the following recipes. Sometimes, however, the external project we want to
    use might require additional, non-standard steps to be performed. For this reason,
    the `ExternalProject.cmake` module defines the following additional commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExternalProject_Add_Step`. Once an external project has been added, this command
    allows to latch additional commands on it as custom steps. See also: [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_step](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_step)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ExternalProject_Add_StepTargets`. Lets you define steps, for example the build
    and test steps, in any external project as separate targets. This means that one
    can trigger these steps separately from the full external project and allows fine-grained
    control over complex dependencies within your project. See also: [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_steptargets](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_steptargets)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ExternalProject_Add_StepDependencies`. Sometimes steps for an external project
    might depend on targets outside it and this command is designed to take care of
    these cases. See also: [https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_stepdependencies](https://cmake.org/cmake/help/v3.5/module/ExternalProject.html#command:externalproject_add_stepdependencies)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Managing dependencies with a superbuild: I. The Boost libraries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-02) and
    has a C++ example. The recipe is valid with CMake version 3.5 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles and Ninja.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Boost libraries provide a rich C++ programming infrastructure and are popular
    among C++ developers. We have already shown how to find the Boost libraries on
    our system in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml), *Detecting
    External Libraries and Programs*. Sometimes, however, the version of Boost required
    by your project might not be available on the system. This recipe will show how
    to leverage the superbuild pattern to ship your code with the confidence that
    a missing dependency will not stop the configuration. We will reuse the code example
    from Recipe 8, *Detecting the Boost libraries*, in [Chapter 3](b290655b-ba55-46bf-80cf-9e65eab8a394.xhtml),
    *Detecting External Libraries and Programs*, but reorganize it in the form of
    a superbuild. This will be the layout of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that there are four `CMakeLists.txt` files in the project source
    tree. The following section will walk you through these.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin with the root `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C++11 project as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the `EP_BASE` directory property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the `STAGED_INSTALL_PREFIX` variable. This directory will be used to
    install the dependencies within our build tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our project needs the filesystem and system components of the Boost libraries.
    We declare a list variable to hold this information and also set the minimum required
    version of Boost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `external/upstream` subdirectory, which will in turn add the `external/upstream/boost`
    subdirectory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we include the `ExternalProject.cmake` standard CMake module. This defines,
    among others, the `ExternalProject_Add` command, which is the key to orchestrating
    superbuilds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our project resides under the `src` subdirectory and we add it as an external
    project. We pass CMake options using `CMAKE_ARGS` and `CMAKE_CACHE_ARGS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now look at the `CMakeLists.txt` in `external/upstream`. This file simply
    adds the `boost` folder as an additional directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` in `external/upstream/boost` describes the operations
    needed to satisfy the dependency on Boost. Our goal is simple, if the desired
    version is not installed, download the source archive and build it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we attempt to find the Boost components needed for the minimum
    required version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If these are found, we add an interface library, `boost_external`. This is
    a dummy target, needed to properly handle build order in our superbuild:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If `find_package` was not successful or we are forcing the superbuild, we need
    to set up a local build of Boost and for this, we enter the else-section of the
    previous conditional:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since these libraries do not use CMake, we need to prepare the arguments for
    their native build toolchain. First, we set the compiler to be used for Boost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We prepare the list of libraries to be built based on the required components.
    We define some list variables: `_build_byproducts`, to contain the absolute path
    to the libraries that will be built; `_b2_select_libraries`, to contain the list
    of libraries we want to build; and `_bootstrap_select_libraries`, which is a string
    with the same contents in a different format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the Boost project as an external project. First of all, we specify
    the download URL and the checksum in the **Download** options class. `DOWNLOAD_NO_PROGRESS`
    is set to `1` to suppress printing download progress information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set **Update/Patch** and **Configure** options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The Build options are set using the `BUILD_COMMAND` directive. `BUILD_IN_SOURCE`
    is set to `1` to signal that building will happen within the source directory.
    Moreover, we set `LOG_BUILD` to `1` to log ouput from the build script to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The Install options are set using the `INSTALL_COMMAND` directive. Note the
    use of the `LOG_INSTALL` option to also log the install step to file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we list our libraries as `BUILD_BYPRODUCTS` and close the `ExternalProject_Add`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We set some variables useful for directing the detection of the newly installed
    Boost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The final action performed in the else-branch of the conditional is to unset
    all internal variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let us look at `src/CMakeLists.txt`. This file describes a standalone
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C++ project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The project depends on Boost and we invoke `find_package`. The configuration
    of the project from the root `CMakeLists.txt` guarantees that the dependency is
    always satisfied, either by using Boost pre-installed on the system or the ones
    we built as a subproject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We add our example executable target, describing its link libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The use of imported targets, while neat, is not guaranteed to work for arbitrary
    Boost and CMake version combinations. This is because the CMake `FindBoost.cmake`
    module creates the imported targets by hand, so if the Boost version was unknown
    at the time of the CMake release, there will be `Boost_LIBRARIES` and `Boost_INCLUDE_DIRS`,
    but no imported targets (see also [https://stackoverflow.com/questions/42123509/cmake-finds-boost-but-the-imported-targets-not-available-for-boost-version](https://stackoverflow.com/questions/42123509/cmake-finds-boost-but-the-imported-targets-not-available-for-boost-version)).
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe shows how the superbuild pattern can be harnessed to muster the
    dependencies of your project. Let us take another look at the layout of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We have introduced four `CMakeLists.txt` files in the project source tree:'
  prefs: []
  type: TYPE_NORMAL
- en: The root `CMakeLists.txt` will coordinate the superbuild.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file in `external/upstream` will lead us to the `boost` leaf directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`external/upstream/boost/CMakeLists.txt` will take care of the Boost dependency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `CMakeLists.txt` under `src` will build our example code, which
    depends on Boost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us start start the discussion with the `external/upstream/boost/CMakeLists.txt`
    file. Boost uses its own build system and hence we need to be slightly more verbose
    in our `ExternalProject_Add` to get everything set up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: We keep the default values for the **Directory** options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Download** step will download an archive of the desired version of Boost
    from their online server. We therefore set up the `URL` and the `URL_HASH`. The
    latter is needed to check the integrity of the downloaded archive. Since we do
    not wish to see a progress report of the download, we also set the `DOWNLOAD_NO_PROGRESS`
    option to true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Update** step is left blank. If anything needs rebuilding, we do not want
    to download Boost once again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Configure** step will use the native configuration tool provided by Boost
    in `CONFIGURE_COMMAND`. Since we want the superbuild to be cross-platform, we
    use the `<SOURCE_DIR>` variable to refer to the location for the unpacked sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The **Build** options declare an *in-source* build, by setting the `BUILD_IN_SOURCE`
    option to true. `BUILD_COMMAND` uses the Boost native build tool, `b2`. Since
    we will be doing an in-source build, we use again the `<SOURCE_DIR>` variable
    to refer to the location of the unpacked sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then move on to the **Install** options. Boost manages installation using
    the same native build tool. In fact, the build and installation commands could
    easily be collapsed into one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Output** logging options `LOG_BUILD` and `LOG_INSTALL` direct `ExternalProject_Add`
    to write log files for the build and installation operations, instead of outputting
    to screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `BUILD_BYPRODUCTS` option lets `ExternalProject_Add` keep track
    of the freshly built Boost libraries in subsequent builds, even though their modification
    times might not get updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once Boost has been built, the `${STAGED_INSTALL_PREFIX}/boost` folder in the
    build directory will contain our desired libraries. We need to pass this information
    down to our project, whose build system is generated in `src/CMakeLists.txt`.
    To achieve this goal, we pass two additional `CMAKE_CACHE_ARGS` in the `ExternalProject_Add`
    in the root `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_INCLUDE_PATH`: The path where CMake will look for C/C++ headers'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CMAKE_LIBRARY_PATH`: The path where CMake will look for libraries'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By setting these variables to our freshly built installation of Boost, we ensure
    that the dependency will be properly picked up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the `CMAKE_DISABLE_FIND_PACKAGE_Boost` to `ON` when configuring the
    project will skip detection of the Boost libraries and always perform the superbuild.
    See the documentation: [https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing dependencies with a superbuild: II. The FFTW library'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-03) and
    has a C example. The recipe is valid with CMake version 3.5 (and higher) and has
    been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The superbuild pattern can be used to manage fairly complex dependencies, for
    projects in all the languages supported by CMake. As demonstrated in the previous
    recipe, it is not necessary for the various subprojects to managed by CMake as
    well. In contrast to the previous recipe, the external subproject in this recipe
    will be a CMake project and will show how to download, build, and install the
    FFTW library using a superbuild. FFTW is a Fast Fourier Transform library, freely
    available at [http://www.fftw.org.](http://www.fftw.org/)
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The directory layout for this recipe shows the now familiar structure for a
    superbuild:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The code for our project, `fftw_example.c`, is located in the `src` subdirectory
    and will calculate the Fourier transform of a function defined in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us start from the root `CMakeLists.txt`. This file puts together the whole
    superbuild process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C99 project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous recipe, we set the `EP_BASE` directory property and the
    staging installation prefix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency on FFTW is checked in the `external/upstream` subdirectory and
    we proceed to add this subdirectory to the build system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the `ExternalProject.cmake` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the `recipe-03_core` external project. The sources for this project
    are in the `${CMAKE_CURRENT_LIST_DIR}/src` folder. The project is set up to pick
    the correct FFTW library using the `FFTW3_DIR` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `external/upstream` subdirectory also contains a `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, we add the `fftw3` folder as another subdirectory in the build
    system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` in `external/upstream/fftw3` takes care of our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we attempt to find the FFTW3 library on the system. Note that we used
    the `CONFIG` argument to `find_package`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If the library was found we can use the imported target, `FFTW3::fftw3`, to
    link against it. We print a message to our users showing where the library is
    located. We add a dummy `INTERFACE` library, `fftw3_external`. This is needed
    to properly fix dependency trees between subprojects in the superbuild:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If CMake was unable to locate a pre-installed version of FFTW, we enter the
    else-branch of the conditional, in which we download, build, and install it using
    `ExternalProject_Add`. The name of the external project is `fftw3_external`. The `fftw3_external` project
    will be downloaded from the official online archive. The integrity of the download
    will be checked using the MD5 checksum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We disable progress printing for the download and define the update command
    to be empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Configuration, building, and installation output will be logged to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the installation prefix for the `fftw3_external` project to the `STAGED_INSTALL_PREFIX`
    directory previously defined and turn off building the test suite for FFTW3:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are building on Windows, we set the `WITH_OUR_MALLOC` preprocessor option by
    means of a generator expression and close the `ExternalProject_Add` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the `FFTW3_DIR` variable and cache it. This variable will
    be used by CMake as a search directory for the exported `FFTW3::fftw3` target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` in the `src` folder is fairly compact:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also in this file, we declare a C project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We call `find_package` to detect the FFTW library. Once again, we are using
    the `CONFIG` detection mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `fftw_example.c` source file to the executable target `fftw_example`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We set link libraries for our executable target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrated how to download, build, and install an external project
    whose build system is managed by CMake. In contrast to the previous recipe, where
    a custom build system had to be used, this superbuild setup is rather compact.
    It is important to note the use of the `CONFIG` option to the `find_package` command;
    this tells CMake to first look for a `FFTW3Config.cmake` file in order to locate
    the FFTW3 library. Such a file exports the library as a target to be picked up
    by third-party projects. The target contains the version, configuration, and location
    of the library, that is, complete information on how the target was configured
    and built. In case the library is not installed on the system, we need to tell
    CMake where the `FFTW3Config.cmake` file is located. This can be done by setting
    the `FFTW3_DIR` variable. This was the very last step in the `external/upstream/fftw3/CMakeLists.txt`
    file, where, by using the `GNUInstallDirs.cmake` module, we set `FFTW3_DIR` as
    a cache variable to be picked up later on in the superbuild.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the `CMAKE_DISABLE_FIND_PACKAGE_FFTW3` to `ON` when configuring the
    project will skip detection of the FFTW library and always perform the superbuild.
    See the documentation: [https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html](https://cmake.org/cmake/help/v3.5/variable/CMAKE_DISABLE_FIND_PACKAGE_PackageName.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing dependencies with a superbuild: III. The Google Test framework'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-04),
    and has a C++ example. The recipe is valid with CMake version 3.11 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows. The code repository also
    contains an example compatible with CMake 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating and Running
    Tests*, Recipe 3, *Defining a unit test and linking against Google Test*, we implemented unit
    testing using the Google Test framework and fetched the Google Test sources at
    configure time using the relatively new `FetchContent` module (available since
    CMake 3.11). In this chapter, we will revisit this recipe, focus less on the testing
    aspect, and dive a bit deeper into `FetchContent`, which provides a compact and
    versatile module to assemble project dependencies at configure time. For additional
    insight and for CMake below 3.11, we will also discuss how to emulate `FetchContent`
    using `ExternalProject_Add` *at configure time*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will build and test the same source files, `main.cpp`, `sum_integers.cpp`, `sum_integers.hpp`,
    and `test.cpp`, as in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml),
    *Creating and Running Tests*, Recipe 3, *Defining a unit test and linking against
    Google Test*. We will download all required Google Test sources at configure time
    using `FetchContent` or `ExternalProject_Add` and in this recipe only focus on
    the fetching of dependencies at configure time, not so much on the actual source
    code and its unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will only focus on how to fetch the Google Test sources
    to build the `gtest_main` target. For a discussion on how this target is used
    to test the example sources, we refer the reader to [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml),
    *Creating and Running Tests*, Recipe 3, *Defining a unit test and linking against
    Google Test*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first include the `FetchContent` module, which will provide the functions
    that we will require to declare, query, and populate the dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we declare the content - its name, repository location, and the precise
    version to fetch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We then query whether the content has already been fetched/populated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous function call defines `googletest_POPULATED`. If the content is
    not yet populated, we fetch the content and configure the subproject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the content is fetched at configure time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following build directory tree. The Google Test sources
    are now in place to be processed by CMake and provide the required target(s):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `FetchContent` module enables populating content at configure time. In
    our case, we have fetched a Git repository with a well defined Git tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FetchContent` module supports fetching content *via* any method supported
    by the `ExternalProject` module - in other words, *via* Subversion, Mercurial,
    CVS, or HTTP(S). The content name "googletest" was our choice and with this we
    will be able to reference the content when querying its properties, when populating
    directories, and later also when configuring the subproject. Before populating
    the project, we checked whether the content was already fetched, otherwise `FetchContent_Populate()` would
    have thrown an error if it was called more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Only then did we configure the subdirectory, which we can reference with the
    `googletest_SOURCE_DIR` and `googletest_BINARY_DIR` variables. They were set by
    `FetchContent_Populate(googletest)` and constructed based on the project name
    we gave when declaring the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FetchContent` module has a number of options (see [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html))
    and here we can show one: how to change the default path into which the external
    project will be placed. Previously, we saw that by default the content is saved
    to `${CMAKE_BINARY_DIR}/_deps`. We can change this location by setting `FETCHCONTENT_BASE_DIR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`FetchContent` has become a standard part of CMake in its 3.11 version. In
    the following code, we will try to emulate `FetchContent` using `ExternalProject_Add` at
    *configure time*. This will not only be practical for older CMake versions, it
    will hopefully also give us more insight into what is happening underneath the `FetchContent`
    layer and provide an interesting alternative to the typical build-time fetching
    of projects included using `ExternalProject_Add`. Our goal will be to write a
    `fetch_git_repo` macro and place it in `fetch_git_repo.cmake` so that we can fetch
    the content like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This feels similar to the use of `FetchContent`. Under the hood, we will use `ExternalProject_Add`.
    Let us now lift the hood and inspect the definition of `fetch_git_repo` in `fetch_git_repo.cmake`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro receives the project name, download root, Git repository URL, and
    a Git tag. The macro defines `${_project_name}_SOURCE_DIR` and `${_project_name}_BINARY_DIR`,
    and we use a macro instead of a function since `${_project_name}_SOURCE_DIR` and
    `${_project_name}_BINARY_DIR` need to survive the scope of `fetch_git_repo` because
    we use them later in the main scope to configure the subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `fetch_git_repo` macro, we wish to use `ExternalProject_Add` to
    fetch the external project at *configure time* and we achieve this with a trick
    in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we configure `fetch_at_configure_step.in`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Using `configure_file`, we generate a `CMakeLists.txt` file in which the previous
    placeholders are replaced by values defined in `fetch_git_repo.cmake`. Note that
    the previous `ExternalProject_Add` command is constructed to only fetch, not to configure,
    build, install, or test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we trigger the `ExternalProject_Add` at configure time (from the perspective
    of the root project) using a configure step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Third and final trick triggers a configure-time build step in `fetch_git_repo.cmake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: One nice aspect of this solution is that since the external dependency is not
    configured by `ExternalProject_Add`, we do not need to channel any configuration
    settings to the project *via* the `ExternalProject_Add` call. We can configure
    and build the module using `add_subdirectory` as if the external dependency was
    part of our project source tree. Brilliant disguise!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a detailed discussion of the available `FetchContent` options, please consult [https://cmake.org/cmake/help/v3.11/module/FetchContent.html](https://cmake.org/cmake/help/v3.11/module/FetchContent.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The configure time `ExternalProject_Add` solution is inspired by the work and
    blog post of Craig Scott: [https://crascit.com/2015/07/25/cmake-gtest/](https://crascit.com/2015/07/25/cmake-gtest/).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing your project as a superbuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-08/recipe-05)
    and has a C++ example. The recipe is valid with CMake version 3.6 (and higher)
    and has been tested on GNU/Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExternalProject` and `FetchContent` are two very powerful tools in your CMake
    arsenal. The previous recipes should have convinced you how versatile the superbuild
    approach is in managing projects with complex dependencies. We have so far shown
    how to use `ExternalProject` to handle the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sources stored within your source tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sources retrieved from archives available on online servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous recipe showed how to use `FetchContent` to handle dependencies
    available from open source Git repositories. This recipe will show how to use
    `ExternalProject` to the same effect. This last recipe will introduce an example
    that will be reused in Recipe 4, *Installing a superbuild*, in [Chapter 10](72e949cc-6881-4be1-9710-9ac706c14a4d.xhtml),
    *Writing an Installer*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source tree for this superbuild should now feel familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The root directory has a `CMakeLists.txt`, which we already know will orchestrate
    the superbuild. The leaf directories `src` and `external` host our own source
    code and the CMake directives needed to satisfy the dependency on the `message`
    library, which we will build in this example.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process of setting up a superbuild should by now feel familiar. Let us
    once again look at the necessary steps, starting with the root `CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a C++11 project with a same default build type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EP_BASE` directory property is set. This will fix the layout for all subprojects
    managed by `ExternalProject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We set `STAGED_INSTALL_PREFIX`. As before, this location will be used as the
    installation prefix within the build tree for the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `external/upstream` subdirectory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Our own project will also be managed by the superbuild and is hence added with
    `ExternalProject_Add`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMakeLists.txt` in `external/upstream` only contains one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Jumping into the `message` folder, we again see the usual commands for managing
    our dependency on the `message` library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we call `find_package` to find a suitable version of the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is found, we inform the user and add a dummy `INTERFACE` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is not found, we again inform the user and proceed with `ExternalProject_Add`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The project is hosted in a public Git repository and we use the `GIT_TAG` option
    to specify which branch to download. As before, we leave the `UPDATE_COMMAND`
    option empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The external project is configured and built using CMake. We pass on all the
    necessary build options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We decide to test the project after it has been installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not wish to see progress on downloads, nor information on configuring,
    building, and installing to be reported onscreen, and we close the `ExternalProject_Add`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the subproject is discoverable within the rest of the superbuild,
    we set the `message_DIR` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let us look at the `CMakeLists.txt` in the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we declare a C++11 project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This project requires the `message` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare an executable target and link it to the `message-shared` library
    provided by our dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe highlighted some new options to the `ExternalProject_Add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GIT_REPOSITORY`: This can be used to specify the URL of the repository containing
    the sources of our dependency. CMake can also use other version control systems,
    such as CVS (`CVS_REPOSITORY`), SVN (`SVN_REPOSITORY`), or Mercurial (`HG_REPOSITORY`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GIT_TAG`: By default, CMake will check out the default branch of the given
    repository. However, it is preferable to depend on a well-defined version that
    is known to be stable. This can be specified with this option, which can accept
    any identifier recognized by Git as "version" information, such as a Git commit
    SHA, a Git tag, or just a branch name. Similar options are also available for
    the other version control systems understood by CMake.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TEST_AFTER_INSTALL`: Most likely, your dependency has a test suite of its
    own and you might want to run the test suite to ensure that everything went smoothly
    during the superbuild. This option will run the tests right after the installation
    step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The additional **Test** options understood by `ExternalProject_Add` are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TEST_BEFORE_INSTALL`, which will run the test suite *before* the installation
    step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEST_EXCLUDE_FROM_MAIN`, with which we can remove the dependency on the main
    target of the external project from the test suite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options assume that the external project manages testing using CTest.
    If the external project does not use CTest to manage testing, we can set the `TEST_COMMAND`
    option to execute tests.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the superbuild pattern even for modules that are part of your own
    project comes at the cost of introducing an additional layer, re-declaring small
    CMake projects, and passing configuration settings explicitly through `ExternalProject_Add`.
    The benefit of introducing this additional layer is a clear separation of variable
    and target scopes, which can help to manage complexity, dependencies, and namespaces
    in projects consisting of several components, where these components can be internal
    or external, and composed together by CMake.
  prefs: []
  type: TYPE_NORMAL
