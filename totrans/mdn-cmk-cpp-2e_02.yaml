- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CMake Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing in the **CMake** **language** is trickier than one might expect. When
    you read a CMake listfile for the first time, you may be under the impression
    that the language in it is so simple that it can be just practiced without any
    theory. You may then attempt to introduce changes and experiment with the code
    without a thorough understanding of how it actually works. I wouldn’t blame you.
    We programmers are usually very busy, and build-related issues aren’t usually
    something that sounds exciting to invest lots of time in. In an effort to go fast,
    we tend to make gut-based changes hoping they just might do the trick. This approach
    to solving technical problems is called *voodoo programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CMake language appears trivial: after introducing our small extension,
    fix, hack, or one-liner, we suddenly realize that something isn’t working. Usually,
    the duration spent on debugging exceeds the time required for comprehending the
    topic itself. Luckily, this won’t be our fate because this chapter covers most
    of the critical knowledge needed to use the CMake language in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll not only learn about the building blocks of the CMake
    language – **comments**, **commands**, **variables**, and **control structures**
    – but we’ll also understand the necessary background and try out examples following
    the latest practices.
  prefs: []
  type: TYPE_NORMAL
- en: CMake puts you in a bit of a unique position. On one hand, you perform the role
    of a build engineer and must have a comprehensive grasp of compilers, platforms,
    and all related aspects. On the other hand, you’re a developer who writes the
    code that generates a buildsystem. Crafting high-quality code is a challenging
    task that demands a multifaceted approach. Not only must the code be functional
    and legible but it should also be easy to analyze, extend, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, we will present a selection of the most practical and frequently
    utilized commands in CMake. Commands that are also commonly used, but not to the
    same extent, will be placed in *Appendix*, *Miscellaneous Commands* (reference
    guides for the `string`, `list`, `file`, and `math` commands).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the CMake language syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding control structures in CMake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the frequently used commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch02](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch02).
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the examples provided in this book, always use the recommended commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure to replace the placeholders `<build tree>` and `<source tree>` with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the CMake language syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composing CMake code is very much like writing in any other imperative language:
    lines are executed from top to bottom and from left to right, occasionally stepping
    into an included file or a called function. The starting point of execution is
    determined by the mode (see the *Mastering the command line* section in *Chapter
    1*, *First Steps with CMake*), either from the root file of the source tree (`CMakeLists.txt`)
    or a `.cmake` script file provided as an argument to `cmake`.'
  prefs: []
  type: TYPE_NORMAL
- en: Since CMake scripts offer extensive support for the CMake language, except for
    project-related features, we will utilize them to practice CMake syntax in this
    chapter. Once we become proficient in composing simple listfiles, we can advance
    to creating actual project files, which we will cover in *Chapter 4*, *Setting
    Up Your First CMake Project*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, scripts can be run with the following command: `cmake -P script.cmake`.'
  prefs: []
  type: TYPE_NORMAL
- en: CMake supports **7-bit** **ASCII** text files for portability across all platforms.
    You can use both `\n` or `\r\n` line endings. CMake versions above 3.2 support
    **UTF-8** and **UTF-16** with optional **byte-order markers** (**BOMs**).
  prefs: []
  type: TYPE_NORMAL
- en: Everything in a CMake listfile is either a *comment* or a *command invocation*.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like in **C++**, there are two kinds of comments: *single-line* comments
    and *bracket* (multiline) comments. But unlike in C++, bracket comments can be
    nested. Single-line comments start with a hash sign, `#`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline bracket comments get their name from their symbol – they start with
    `#` followed by opening square bracket `[`, any number of equal signs `=` (which
    can also include 0), and another square bracket `[`. To close a bracket comment,
    use the same number of equal signs and reverse the brackets `]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can deactivate a multiline comment swiftly by adding another `#` to the
    initial line of the bracket comment, as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Knowing how to use comments is definitely useful, but it raises another question:
    when should we do it? Since writing listfiles is essentially programming, it is
    a good idea to bring our best coding practices to them as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Code that follows such practices is often called *clean code* – a term used
    over the years by software development gurus like Robert C. Martin, Martin Fowler,
    and many other authors.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is often a lot of controversy surrounding which practices are considered
    beneficial or detrimental, and as you might expect, comments have not been exempt
    from these debates. Everything should be judged on a case-by-case basis, but generally
    agreed-upon guidelines say that good comments provide at least one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Information**: They can untangle complexities such as regex patterns or formatting
    strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intent**: They can explain the intent of the code when it is not obvious
    from the implementation or interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clarification**: They can explain concepts that can’t be easily refactored
    or changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warnings of consequences**: They can provide warnings, especially around
    code that can break other things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amplification**: They can underline the importance of an idea that is hard
    to express in code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Legal clauses**: They can add this necessary evil, which is usually not the
    domain of a programmer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s best to avoid comments by applying better naming, refactoring or correcting
    your code. Omit comments that are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mandated**: These are added for completeness but they are not really important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redundant**: These repeat what is already clearly written in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Misleading**: These could be outdated or incorrect if they don’t follow code
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Journal**: These note what has been changed and when (use **Version Control
    Systems** (**VCS**) for this instead).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dividers**: These mark sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can, avoid adding comments, adopt better naming practices, and refactor
    or correct your code. Crafting elegant code is a challenging task but it enhances
    the reader’s experience. Since we spend more time reading code than composing
    it, we should always strive to write code that is easy to read, instead of just
    trying to finish it quickly. I recommend checking out the *Further reading* section
    at the end of this chapter for some good references on *clean code*. If you’re
    interested in comments, you’ll find a link to my YouTube video *Which comments
    in your code ARE GOOD?* touching on this subject in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Command invocations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time for some action! Invoking commands is the bread and butter of CMake listfiles.
    In order to run a command, you must specify its name followed by parentheses,
    in which you can enclose a list of **command arguments** separated by whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: An example of a command'
  prefs: []
  type: TYPE_NORMAL
- en: Command names aren’t case-sensitive, but there is a convention in the CMake
    community to use `snake_case` (that is, lowercase words joined with underscores).
    You can also define your own commands, which we’ll cover in the *Understanding
    control structures in CMake* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One significant difference between CMake and C++ is that command invocations
    in CMake are not expressions. This means that you cannot pass another command
    as an argument to a called command because *everything* inside the parentheses
    is treated as an argument for that specific command.
  prefs: []
  type: TYPE_NORMAL
- en: CMake commands are also not followed with semicolons. This is because each line
    of source code can only contain one command.
  prefs: []
  type: TYPE_NORMAL
- en: 'A command can be optionally followed by a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But not the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we said earlier, everything in a CMake listfile is either a *comment* or
    a *command* *invocation*. CMake syntax really is that simple, and for the most
    part, it’s a good thing. While there are some constraints (for instance, you can’t
    increment a counter variable using an expression), for the most part, these limitations
    are mostly acceptable because CMake is not intended to be a general-purpose language.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake provides commands to manipulate variables, direct the flow of execution,
    modify files, and much more. To make things easier, we will be introducing the
    relevant commands as we progress through different examples. These commands can
    be categorized into two groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scripting commands**: These are always available and they change the state
    of the command processor and access variables, and affect other commands and the
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project commands**: These are available in projects and they manipulate the
    project state and build targets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Virtually every command relies on other elements of the language in order to
    function: variables, conditional statements, and, most importantly, command-line
    arguments. Now, let’s explore how we can utilize them.'
  prefs: []
  type: TYPE_NORMAL
- en: Command arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of commands in CMake necessitate whitespace-separated arguments to
    configure their behavior. As demonstrated in *Figure 2.1*, the quotation marks
    used around the arguments can be quite peculiar. While certain arguments require
    quotes, others do not. What’s the reasoning behind this distinction?
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the only data type recognized by CMake is a `string`. This is
    why every command expects zero or more strings for its arguments. CMake will **evaluate**
    every argument to a static string and then pass them into the command. *Evaluating*
    means **string interpolation**, or substituting parts of a string with another
    value. This can mean replacing the **escape sequences,** expanding the **variable
    references** (also called *variable interpolation*), and unpacking **lists**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the context, we might want to enable such evaluation as needed.
    For that reason, CMake offers three types of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: Bracket arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoted arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unquoted arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every argument type in CMake has its own peculiarities and provides a distinct
    level of evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Bracket arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bracket arguments aren’t evaluated because they are used to pass multiline strings,
    verbatim, as a single argument to commands. This means that such an argument will
    include whitespace in the form of tabs and newlines.
  prefs: []
  type: TYPE_NORMAL
- en: Bracket arguments are formatted identically to comments. They are initiated
    with `[=[` and concluded with `]=]`, and the number of equal signs in both the
    opening and closing tokens must match (omitting equal signs is permissible as
    long as they match). The only difference from the comments is that bracket arguments
    cannot be nested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the use of such an argument with the `message()` command,
    which prints all passed arguments to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/01-arguments/bracket.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we can see different forms of bracket arguments.
    Note how putting closing tags on a separate line in the first call introduces
    an empty line in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The second form is useful when we’re passing text that contains double brackets
    (`]]`) (highlighted in the code snippet), as they won’t be interpreted as marking
    the end of the argument.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of bracket arguments have limited use – typically, they contain
    lengthier blocks of text with messages that are displayed to the user. In most
    cases, we’ll need something more dynamic, such as quoted arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Quoted arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Quoted arguments resemble a regular C++ string – these arguments group together
    multiple characters, including whitespace, and they will expand *escape sequences*.
    Like C++ strings, they are opened and closed with a double quote character, `"`,
    so to include a quote character within the output string, you have to escape it
    with a backslash, `\"`. Other well-known escape sequences are supported as well:
    `\\` denotes a literal backslash, `\t` is a tab character, `\n` is a newline,
    and `\r` is a carriage return.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the similarities with C++ strings end. Quoted arguments can span
    multiple lines, and they will interpolate variable references. Think of them as
    having a built-in `sprintf` function from **C** or a `std::format` function from
    **C++20**. To insert a variable reference to your argument, wrap the name of the
    variable in a token like so: `${name}`. We’ll talk more about variable references
    in the *Working with variables* section of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Can you guess how many lines will be in the output of the following script?
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/01-arguments/quoted.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That’s right – we have one escaped quote character, one newline escape sequence,
    and a literal newline. We also accessed a built-in `CMAKE_VERSION` variable, which
    we can see interpolated on the last line. Let’s take a look at how CMake treats
    arguments without quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Unquoted arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the programming world, we have gotten used to the fact that strings must
    be delimited in one form or another, for example, by using single quotes, double
    quotes, or a backslash. CMake deviates from this convention and introduces *unquoted
    arguments*. We might argue that dropping delimiters makes the code easier to read.
    Is that true? I’ll let you form your own opinion.
  prefs: []
  type: TYPE_NORMAL
- en: Unquoted arguments evaluate both *escape sequences* and *variable references*.
    However, be careful with semicolons `(;)` as, in CMake, semicolons are treated
    as *list* delimiters. If an argument contains a semicolon, CMake will split it
    into multiple arguments. If you need to use them, escape every semicolon with
    a backslash, `\;`. We’ll talk more about semicolons in the *Using lists* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may find that these arguments are the most perplexing to work with, so
    here’s an illustration to help clarify how these arguments are partitioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Escape sequences cause separate tokens to be interpreted as a single
    argument'
  prefs: []
  type: TYPE_NORMAL
- en: It’s always worth being careful with unquoted arguments. Some CMake commands
    require a specific number of arguments and ignore any overhead. If your arguments
    become accidentally separated, you’ll get hard-to-debug errors.
  prefs: []
  type: TYPE_NORMAL
- en: Unquoted arguments cannot contain unescaped *quotes (“), hashes (#), and backslashes
    (\). And if that’s not enough to remember, parentheses, `()`, are allowed only
    if they form correct, matching pairs. That is, you’ll start with an opening parenthesis
    and close it before closing the command argument list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples that demonstrate the rules we have discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/01-arguments/unquoted.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What will be the output of the preceding? Let’s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even a simple command such as `message()` is very particular about separated
    unquoted arguments. The space in `a single argument` was correctly printed when
    it was explicitly escaped. However, `twoarguments` and `threeseparatearguments`
    were *glued* together, since `message()` doesn’t add any spaces on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given all these complexities, when is it beneficial to use unquoted arguments?
    Some CMake commands allow optional arguments that are preceded by a keyword to
    signify that an optional argument will be provided. In such instances, using an
    unquoted argument for the keyword can make the code more legible. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this command, the `VERSION` keyword and the following argument `1.2.3` are
    optional. As you can see, both are left unquoted for readability. Note that keywords
    are case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to deal with the complexities and quirks of CMake
    arguments, we are ready to tackle the next interesting subject – working with
    all kinds of variables in CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Working with variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Variables** in CMake are a surprisingly complex subject. Not only are there
    three categories of variables – **normal**, **cache**, and **environment** – but
    they also reside in different **variable scopes**, with specific rules on how
    one *scope* affects the other. Very often, a poor understanding of these rules
    becomes a source of bugs and headaches. I recommend you study this section with
    care and make sure you understand all of the concepts before moving on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with some key facts about variables in CMake:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable names are case-sensitive and can include almost any character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All variables are stored internally as strings, even if some commands can interpret
    them as values of other data types (even *lists*!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic variable manipulation commands are `set()` and `unset()`, but there
    are other commands that can alter variable values, such as `string()` and `list()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a **normal variable**, we simply call `set()`, providing its name
    and the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/02-variables/set.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the use of brackets and quoted arguments allows for spaces to
    be included in the variable name. However, when referencing it later, we have
    to escape the whitespace with a backslash, `\`. For that reason, it is recommended
    to use only alphanumeric characters, dashes `(-)`, and underscores `(_)` in variable
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also avoid reserved names (in uppercase, lowercase, or mixed case) that begin
    with any of the following: `CMAKE_`, `_CMAKE_`, or an underscore, `_`, followed
    by the name of any CMake command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To unset a variable, we can use `unset()` in the following way: `unset(MyString1)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `set()` command accepts a plain text variable name as its first argument,
    but the `message()` command uses a variable reference wrapped in the `${}` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if we were to provide a variable wrapped in the `${}` syntax
    to the `set()` command?
  prefs: []
  type: TYPE_NORMAL
- en: To answer that, we’ll need to understand *variable references* better.
  prefs: []
  type: TYPE_NORMAL
- en: Variable references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I already mentioned references briefly in the *Command arguments* section,
    as they’re evaluated for quoted and unquoted arguments. We learned that to create
    a reference to a defined variable, we need to use the `${}` syntax, like so: `message(${MyString1})`.'
  prefs: []
  type: TYPE_NORMAL
- en: On evaluation, CMake will traverse the *variable scopes* from the innermost
    scope to the outermost scope and replace `${MyString1}` with a value, or an empty
    string if no variable is found (CMake won’t produce any error messages). This
    process is also called *variable evaluation*, *expansion*, or *interpolation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interpolation is performed in an inside-out manner, beginning from the innermost
    curly brace pair and moving outward. For example, if the ${MyOuter${MyInner}}
    reference is encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: CMake will try to evaluate `MyInner` first, rather than searching for a variable
    named `MyOuter${MyInner}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `MyInner` variable is successfully expanded, CMake will repeat the expansion
    process using the newly formed reference until no further expansion is possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid receiving unexpected outcomes, it is recommended to refrain from storing
    variable expansion tokens in variable values.
  prefs: []
  type: TYPE_NORMAL
- en: CMake will perform variable expansion to the full extent, and only after completion
    will it pass the resulting values as arguments to the command. This is why when
    we call `set(${MyInner} "Hi")`; we won’t actually be changing the `MyInner` variable,
    but instead, we’ll change the variable named after the value stored in `MyInner`.
    Very often, this is not what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable references are a bit peculiar in how they work when it comes to variable
    categories, but in general, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The `${}` syntax is used to reference *normal* or *cache* variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$ENV{}` syntax is used to reference *environment* variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$CACHE{}` syntax is used to reference *cache* variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That’s right, with `${}`, you might get a value from one category or the other:
    the *normal* variable will be used if it was set in the current scope, but if
    it wasn’t set, or was unset, CMake will use the *cache* variable with the same
    name. If there’s no such variable, the reference evaluates to an empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: CMake predefines a lot of built-in normal variables that serve different purposes.
    For example, you can pass command-line arguments to scripts after the `--` token
    and they will be stored in the `CMAKE_ARGV<n>` variables (the `CMAKE_ARGC` variable
    will contain the count).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s introduce other categories of variables so that we understand clearly
    what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Using environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the least complicated kind of variable. CMake makes a copy of the variables
    that were in the environment used to start the `cmake` process and makes them
    available in a single, global scope. To reference these variables, use the `$ENV{<name>}`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: CMake changes these variables, but changes will only be made to a local copy
    in the running `cmake` process and not the actual system environment; moreover,
    these changes won’t be visible to subsequent runs of builds or tests, so it is
    not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that there are a few environment variables that affect different aspects
    of CMake behavior. For example, the `CXX` variable specifies what executable will
    be used for compiling C++ files. We’ll cover environment variables, as they will
    become relevant to this book. A full list is available in the documentation: [https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html).'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to realize that if you use `ENV` variables as arguments to your
    commands, the values will be interpolated during the generation of the buildsystem.
    This means that they will get permanently baked into the build tree, and changing
    the environment for the build stage won’t have any effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take the following project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/03-environment/CMakeLists.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example has two steps: it will print the `myenv` environment
    variable during the configuration, and it will add a build stage through `add_custom_target()`,
    which echoes the same variable as part of the build process. We can test what
    happens with a bash script that uses one value for the configuration stage and
    another for the build stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/03-environment/build.sh**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code clearly shows that the value set during the configuration
    is persisted to the generated buildsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This concludes our discussion on environmental variables for the time being.
    Let us now move on to the final category of variables: cache variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Using cache variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first mentioned cache variables when discussing command-line options for
    `cmake` in *Chapter 1*, *First Steps with CMake*. Essentially, they’re persistent
    variables stored in a `CMakeCache.txt` file in your build tree. They contain information
    gathered during the *configuration stage* of your project. They originate from
    the system (path to compilers, linkers, tools, and others) and from the user,
    provided through the GUI or from the command line with the `-D` option. Again,
    cache variables are not available in *scripts*; they only exist in *projects*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache variables will be used if the `${<name>}` reference can’t find a normal
    variable defined in the current scope but a cache variable with the same name
    exists. However, they can also be explicitly referenced with the `$CACHE{<name>}`
    syntax and defined with a special form of the `set()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast to the `set()` command for *normal variables*, extra arguments
    are necessary for cache variables: `<type>` and `<docstring>`. This is because
    these variables can be configured by the user, and the GUI requires this information
    to display them appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following *types* are accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BOOL`: A Boolean on/off value. The GUI will show a checkbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FILEPATH`: A path to a file on a disk. The GUI will open a file dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATH`: A path to a directory on a disk. The GUI will open a directory dialog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STRING`: A line of text. The GUI offers a text field to be filled. It can
    be replaced by a drop-down control by calling `set_property(CACHE <variable> STRINGS
    <values>)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INTERNAL`: A line of text. The GUI skips internal entries. The internal entries
    may be used to store variables persistently across runs. Use of this type implicitly
    adds the `FORCE` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<doctring>` value is simply a label that will be displayed by the GUI next
    to the field to provide more detail about this setting to the user. It is required
    even for an `INTERNAL` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting cache variables in the code follows the same rules as environmental
    variables to some extent – values are overwritten only for the current execution
    of CMake. However, if the variable doesn’t exist in the cache file or an optional
    `FORCE` argument is specified, the value will be persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Similar to C++, CMake supports *variable scopes*, albeit implemented in a rather
    specific way.
  prefs: []
  type: TYPE_NORMAL
- en: How to correctly use variable scopes in CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Variable scope** is probably the strangest concept in the CMake language.
    This is maybe because we’re so accustomed to how it is implemented in general-purpose
    languages. We’re explaining this early because incorrect understanding of scopes
    is often a source of bugs that are difficult to find and fix.'
  prefs: []
  type: TYPE_NORMAL
- en: Just to clarify, variable scope as a general concept is meant to separate different
    layers of abstraction expressed with code. Scopes are nested inside one another
    in a tree-like fashion. The outermost scope (root) is called the **global scope**.
    Any scope can be called the **local scope**, to indicate the currently executed
    or discussed scope. Scopes create boundaries between variables, so that the *nested
    scope* can access variables defined in the *outer scope*, but not the other way
    around.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake has two kinds of variable scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File**: Used when blocks and custom functions are executed within a file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directory**: Used when the `add_subdirectory()` command is called to execute
    another `CMakeLists.txt` listfile in a nested directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional blocks, loop blocks, and macros don’t create separate scopes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, what’s so different about how a variable scope is implemented in CMake?
    When a *nested scope* is created, CMake simply fills it with copies of all the
    variables from the *outer scope*. Subsequent commands will affect these copies.
    But as soon as the execution of the *nested scope* is completed, all copies are
    deleted and the original variables from the *outer scope* are restored.
  prefs: []
  type: TYPE_NORMAL
- en: How the concept of scope works in CMake has interesting implications that aren’t
    that common in other languages. When executing in a nested scope, if you unset
    (`unset()`) a variable created in the *outer scope*, it will disappear, but only
    in the current *nested scope*, because the variable is a local copy. If you now
    reference this variable, CMake will determine that no such variable is defined,
    it will ignore the *outer scopes*, and continue searching through the cache variables
    (which are considered separate). That’s a possible gotcha.
  prefs: []
  type: TYPE_NORMAL
- en: '*File variable scopes* are opened using the `block()` and `function()` commands
    (but not `macro()`) and closed with the `endblock()` and `endfunction()` commands,
    respectively. We’ll cover functions in the *Command definitions* section of this
    chapter. For now, let’s see how variable scope works in practice with the simpler
    `block()` command (introduced in CMake 3.25).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/04-scope/scope.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We initially set the variable `V` to `1` in the *global scope*. After entering
    the outer and inner blocks, we immediately change them to `2` and `3`, respectively.
    We also print the variable upon entering and exiting each scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As explained previously, as we enter each *nested scope*, the variable values
    are temporarily copied from the *outer scope* but their original values are restored
    upon exiting. This is reflected in the last two lines of the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `block()` command can also propagate values to outer scopes (like C++ would
    do by default), but it has to be explicitly enabled with the `PROPAGATE` keyword.
    If we were to enable propagation for the inner block with `block(PROPAGATE V)`,
    the output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Again, we affected the scope of the outer block but not the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method for modifying a variable in the outer scope is to set the `PARENT_SCOPE`
    flag for the `set()` and `unset()` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That workaround is a bit limited, as it doesn’t allow accessing variables more
    than one level up. Another thing worth noting is the fact that using `PARENT_SCOPE`
    doesn’t change variables in the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to handle basic variables, let’s take a look at one special
    case: since all variables are stored as strings, CMake has to take a more creative
    approach to more complex data structures such as *lists*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To store a **list**, CMake concatenates all elements into a string, using a
    semicolon, `;`, as a delimiter: `a;list;of;5;elements`. You can escape a semicolon
    in an element with a backslash, like so: `a\;single\;element`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a list, we can use the `set()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of how lists are stored, the following commands will have exactly the
    same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake automatically unpacks lists in unquoted arguments. By passing an unquoted
    `myList` reference, we effectively send more arguments to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `message()` command will receive six arguments: “`the list is:`", “`a`",
    “`list`", “`of`", “`five`", and “`elements`". This may have unintended consequences,
    as the output will be printed without any additional spaces between the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a very simple mechanism, and it should be used carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake offers a `list()` command that provides a multitude of subcommands to
    read, search, modify, and order lists. Here’s a short summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, we don’t really need to use lists in our projects. However,
    if you find yourself in that rare case where this concept would be convenient,
    you’ll find a more in-depth reference of the `list()` command in *Appendix*, *Miscellaneous
    Commands*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to work with lists and variables of all kinds, let’s shift
    our focus to controlling the execution flow and learn about control structures
    available in CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding control structures in CMake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CMake language wouldn’t be complete without **control structures**! Like
    everything else, they are provided in the form of a command, and they come in
    three categories: **conditional blocks**, **loops**, and **command definitions**.
    Control structures are executed in scripts and during buildsystem generation for
    projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only conditional block supported in CMake is the humble `if()` command.
    All conditional blocks have to be closed with an `endif()` command, and they may
    have any number of `elseif()` commands and one optional `else()` command in this
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As in many other imperative languages, the `if()`-`endif()` block controls
    which sets of commands will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `<condition>` expression specified in the `if()` command is met, the
    first section will be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, CMake will execute commands in the section belonging to the first
    `elseif()` command in this block that has met its condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no such commands, CMake will check whether the `else()` command
    is provided and execute any commands in that section of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If none of the preceding conditions are met, the execution continues after the
    `endif()` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that no local *variable scope* is created in any of the conditional blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The provided `<condition>` expression is evaluated according to a very simple
    syntax – let’s learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for conditional commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same syntax is valid for `if()`, `elseif()`, and `while()` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `if()` conditions support the `NOT`, `AND`, and `OR` logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOT <condition>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<condition> AND <condition>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<condition> OR <condition>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, the nesting of conditions is possible with matching pairs of parentheses
    (`()`). As in all decent languages, the CMake language respects the order of evaluation
    and starts from the innermost parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The evaluation of a string and a variable
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For legacy reasons (because the variable reference (`${}`) syntax wasn’t always
    around), CMake will try to evaluate *unquoted arguments* as if they are *variable
    references*. In other words, using a plain variable name (for example, `QUX`)
    inside a condition is equal to writing `${QUX}`. Here’s an example for you to
    consider, and a gotcha:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `if()` condition works in a bit of a convoluted way here – first, it will
    evaluate `${QUX}` to `BAZ`, which is a recognized variable, and this in turn is
    evaluated to a string containing five characters spelling `FALSE`. Strings are
    considered *Boolean true* only if they equal any of the following constants (these
    comparisons are case-insensitive): `ON`, `Y`, `YES`, `TRUE`, or a *non-zero number*.'
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the conclusion that the condition in the preceding example
    will evaluate to *Boolean false*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, here’s another catch – what would be the evaluation of a condition
    with an unquoted argument with the name of a variable containing a value such
    as `BAR`? Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'According to what we have said so far, it would be `false`, as the `BAR` string
    doesn’t meet the criteria to evaluate to a *Boolean true* value. That’s unfortunately
    not the case, because CMake makes an exception when it comes to unquoted variable
    references. Unlike quoted arguments, `FOO` won’t be evaluated to `BAR` to produce
    an `if("BAR")` statement (which would be `false`). Instead, CMake will only evaluate
    `if(FOO)` to `false` if it is any of the following constants (these comparisons
    are case-insensitive):'
  prefs: []
  type: TYPE_NORMAL
- en: '`OFF`, `NO`, `FALSE`, `N`, `IGNORE`, or `NOTFOUND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string ending with `-NOTFOUND`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, simply asking for an undefined variable will be evaluated to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When a variable is defined beforehand, the scenario changes and the condition
    evaluates to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think that the recursive evaluation of unquoted `if()` arguments is
    confusing, wrap variable references in quoted arguments: `if("${`CORGE`}")`. This
    will result in argument evaluation before the provided argument is passed into
    the `if()` command, and the behavior will be consistent with the evaluation of
    strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, CMake assumes that the user passing a variable name to the
    `if()` command is asking whether the variable is defined with a value that does
    not evaluate to *Boolean false*. To explicitly check whether the variable is defined
    or not (and ignore its value), we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Comparing values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Comparison operations are supported with the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EQUAL`, `LESS`, `LESS_EQUAL`, `GREATER`, and `GREATER_EQUAL`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual comparison operators found in other languages do not work in CMake:
    `==`, `>`, `<`, `!=`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be used to compare numeric values, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can compare software versions following the `major[.minor[.patch[.tweak]]]`
    format by adding a `VERSION_` prefix to any of the operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Omitted components are treated as zeros, and non-integer version components
    truncate the compared string at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'For *lexicographic* string comparisons, we need to prepend an operator with
    the `STR` prefix (note the lack of an underscore):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We often need more advanced mechanisms than simple equality comparisons. Fortunately,
    CMake also supports **POSIX** **regex** matching (the CMake documentation hints
    at an **Extended Regular Expression** (**ERE**) flavor, but no support for specific
    regex character classes is mentioned). We can use the `MATCHES` operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Any matched groups are captured in `CMAKE_MATCH_<n>` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Simple checks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We already mentioned one simple check, `DEFINED`, but there are others that
    simply return `true` if a condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether a value is in a list: `<VARIABLE|STRING> IN_LIST <VARIABLE>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether a command is available for invocation in this version of CMake: `COMMAND
    <command-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether a CMake policy exists: `POLICY <policy-id>` (this is covered in *Chapter
    4*, *Setting Up Your First CMake Project* )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether a CTest test was added with `add_test()`: `TEST <test-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether a build target is defined: `TARGET <target-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll explore build targets in *Chapter 5*, *Working with Targets*, but for
    now, let’s just say that targets are logical units of a build process in a project
    created with `add_executable()`, `add_library()`, or `add_custom_target()` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the filesystem
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'CMake provides many ways of working with files. We rarely need to manipulate
    them directly, and normally, we’d rather use a high-level approach. For reference,
    this book will provide a short list of the file-related commands in the *Appendix*.
    But most often, only the following operators will be needed (behavior is well-defined
    only for absolute paths):'
  prefs: []
  type: TYPE_NORMAL
- en: '`EXISTS <path-to-file-or-directory>`: Checks if a file or directory exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This resolves symbolic links (it returns `true` if the target of the symbolic
    link exists).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<file1> IS_NEWER_THAN <file2>`: Checks which file is newer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This returns `true` if `file1` is newer than (or equal to) `file2` or if one
    of the two files doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '`IS_DIRECTORY path-to-directory`: Checks if a path is a directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IS_SYMLINK file-name`: Checks if a path is a symbolic link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IS_ABSOLUTE path`: Checks if a path is absolute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, since 3.24 CMake supports a simple path comparison check, that
    will collapse multiple path separators but won’t do any other normalization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For more advanced path manipulation, refer to the documentation on the `cmake_path()`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: This completes the syntax for conditional commands; the next control structure
    we’ll discuss is a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Loops in CMake are fairly straightforward – we can use either a `while()` loop
    or a `foreach()` loop to repeatedly execute the same set of commands. Both of
    these commands support loop control mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: The `break()` loop stops the execution of the remaining block and breaks from
    the enclosing loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `continue()` loop stops the execution of the current iteration and starts
    at the top of the next one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that no local *variable scope* is created in any of the loop blocks.
  prefs: []
  type: TYPE_NORMAL
- en: while()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The loop block is opened with a `while()` command and closed with an `endwhile()`
    command. Any enclosed commands will be executed as long as the `<condition>` expression
    provided in `while()` is `true`. The syntax for phrasing the condition is the
    same as for the `if()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You probably guessed that – with some additional variables – the `while` loop
    can replace a `for` loop. Actually, it’s way easier to use a `foreach()` loop
    for that – let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: foreach() loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several variations of the `foreach()` block, which execute the enclosed
    commands for each value in the given list. Like other blocks, it has opening and
    closing commands: `foreach()` and `endforeach()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest form of `foreach()` is meant to provide a C++-style `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake will iterate from `0` to `<max>` (inclusive). If we need more control,
    we can use the second variant, providing `<min>`, `<max>`, and, optionally, `<step>`.
    All arguments must be non-negative integers, and `<min>` has to be smaller than
    `<max>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `foreach()` shows its true colors when it is working with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'CMake will retrieve elements from one or more specified `<lists>` list variables,
    as well as a list of `<items>` values defined in-line, and put them in `<loop
    variable>`. Then, it will execute all commands for each item in the list. You
    can choose to provide only lists, only values, or both:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/06-loops/foreach.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use a short version (skipping the `IN` keyword) for the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Since version 3.17, `foreach()` has learned how to zip lists (`ZIP_LISTS`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of zipping lists involves iterating through multiple lists and
    operating on corresponding items that have the same index. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/06-loops/foreach.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: CMake will create a `num_<N>` variable for each list provided, which it will
    fill with items from each list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can pass multiple variable names (one for every list) and each list will
    use a separate variable to store its items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Both examples on `ZIP_LISTS` will produce the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the event that the item counts between lists vary, variables for the shorter
    lists will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that, as of version 3.21, the loop variables in `foreach()`
    are restricted to the local scope of the loop. This concludes our discussion on
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: Command definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to define your own command: you can use the `macro()` command
    or the `function()` command. The easiest way to explain the differences between
    these commands is by comparing them to *C-style preprocessor macros* and actual
    C++ functions:'
  prefs: []
  type: TYPE_NORMAL
- en: A `macro()` command works more like a find-and-replace instruction than an actual
    subroutine call such as `function()`. Contrary to functions, macros don’t create
    a separate entry on a call stack. This means that calling `return()` in a macro
    will return to the calling statement one level higher than it would for a function
    (possibly terminating the execution if we’re already in the top scope).
  prefs: []
  type: TYPE_NORMAL
- en: The `function()` command creates a *local scope* for its variables, unlike the
    `macro()` command, which works in the *variable scope* of the caller. This may
    lead to confusing results. Let’s talk about these details in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both methods of defining commands allow the defining of named arguments that
    can be referred to in the local scope of the defined command. Moreover, CMake
    offers the following variables for accessing call-related values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${ARGC}`: The count of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${ARGV}`: All arguments as list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${ARGV<index>}`: The value of an argument at a specific index (starting from
    0), regardless of whether this argument was expected or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${ARGN}`: A list of anonymous arguments that were passed by a caller after
    the last expected argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a numeric argument with an index outside of the `ARGC` bounds is an
    undefined behavior. To handle advanced scenarios (usually with an unknown number
    of arguments), you may be interested to read about `cmake_parse_arguments()` in
    the official documentation. If you decide to define a command with named arguments,
    every call has to pass all of them or it will be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Defining a macro is similar to any other block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: After this declaration, we may execute our macro by calling its name (function
    calls are case- insensitive).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, macros don’t create a separate entry on a call stack or a *variable
    scope*. The following example highlights some of the problems relating to this
    behavior in macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/08-definitions/macro.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output from this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened? Despite explicitly setting `myVar` to `new value`, it didn’t
    affect the output for `message("argument: ${myVar}")`! This is because arguments
    passed to macros aren’t treated as real variables but rather, as constant find-and-replace
    instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `myVar` variable in the global scope was changed from
    `first value` to `new value`. This behavior is a *side effect* and is considered
    a bad practice, as it’s impossible to tell which global variables will be changed
    by a macro without reading it. It is advisable to utilize functions whenever possible,
    as they are likely to prevent many issues.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a command as a function, follow this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: A function requires a name and optionally accepts a list of names of expected
    arguments. As mentioned before, functions create their own *variable scopes*.
    You can call `set()`, providing one of the named arguments of the function, and
    any change will be local to the function (unless `PARENT_SCOPE` is specified,
    as we discussed in the *How to correctly use variable scopes in CMake* section).
  prefs: []
  type: TYPE_NORMAL
- en: Functions follow the rules of the call stack, enabling returning to the calling
    scope with the `return()` command. Starting from CMake 3.25, the `return()` command
    allows an optional `PROPAGATE` keyword followed by a list of variable names. Its
    purpose is similar to the one in the `block()` command – it transfers the values
    of the specified variables from the *local scope* to the scope of the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake sets the following variables for each function (these have been available
    since version 3.17):'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_FUNCTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_FUNCTION_LIST_DIR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_FUNCTION_LIST_FILE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_CURRENT_FUNCTION_LIST_LINE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at these function variables in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/08-definitions/function.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this script with `cmake -P function.cmake` prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the general syntax and concept of the functions are very similar
    to macros but less susceptible to implicit errors.
  prefs: []
  type: TYPE_NORMAL
- en: The procedural paradigm in CMake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us suppose that we want to write CMake code similar to how we write a program
    in C++. We’ll make a `CMakeLists.txt` listfile that will call three defined commands
    that may call defined commands of their own. *Figure 2.3* illustrates that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19844_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A procedural call graph'
  prefs: []
  type: TYPE_NORMAL
- en: 'In CMake, writing in a procedural style can be problematic since you must provide
    command definitions before calling them. The CMake parser will not have it any
    other way. Your code could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What a nightmare! Everything is reversed! It will be very difficult to understand
    because the code with the lowest level of abstraction is at the beginning of the
    file. A correctly structured piece of code lists the most general steps in the
    first subroutine, after which it provides the slightly more detailed subroutines,
    and keeps the most detailed steps at the very end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are solutions to this problem, such as moving command definitions to
    other files and partitioning scopes across directories (scoped directories will
    be explained in detail in *Chapter 4*, *Setting Up Your First CMake Project* ).
    But there is also a simple and elegant approach – declaring an entry-point macro
    at the top of the file and calling it at the very end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, our code is written with a gradually narrowing scope, and
    because we’re not actually calling the `main()` macro until the very end, CMake
    won’t complain about the execution of undefined commands.
  prefs: []
  type: TYPE_NORMAL
- en: Why use a macro over a function in this case? It’s good to have unrestricted
    access to global variables, and since we’re not passing any arguments to `main()`,
    we don’t need to worry about the usual caveats.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find a simple example of this concept in the `ch02/09-procedural/CMakeLists.txt`
    listfile in the GitHub repository for this book.
  prefs: []
  type: TYPE_NORMAL
- en: A word on naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Naming is famously hard in software development, but nevertheless, it’s very
    important to maintain a solution that is easy to read and understand. When it
    comes to CMake scripts and projects, we should follow the rules of the *clean
    code* approach, as we would with any software development solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Follow a consistent naming style (`snake_case` is an accepted standard in the
    CMake community).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use short but meaningful names (for example, avoid `func()`, `f()`, and similar).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid puns and cleverness in your naming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use pronounceable, searchable names that don’t require mental mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to properly invoke the commands with the correct syntax,
    let’s explore which commands will be the most beneficial to us to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the frequently used commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CMake offers many scripting commands that allow you to work with variables
    and the environment. Some of them have been extensively covered in the *Appendix*:
    for example, `list()`, `string()`, and `file()`. Others, such as `find_file()`,
    `find_package()`, and `find_path()`, fit better in chapters that talk about their
    respective subjects. In this section, we will provide a brief overview of the
    common commands that are useful in most situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`message()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_guard()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute_process()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get to it.
  prefs: []
  type: TYPE_NORMAL
- en: The message() command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already know and love our trusty `message()` command, which prints text
    to standard output. However, there’s a lot more to it than meets the eye. By providing
    a `MODE` argument, you can customize the behavior of the command like so: `message(<MODE>
    "text to print")`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recognized modes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FATAL_ERROR`: This stops processing and generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEND_ERROR`: This continues processing but skips generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARNING`: This continues processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTHOR_WARNING`: A CMake warning. This continues processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEPRECATION`: This works accordingly if either of the `CMAKE_ERROR_DEPRECATED`
    or `CMAKE_WARN_DEPRECATED` variables are enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOTICE` or omitted mode (default): This prints a message to `stderr` to attract
    the user’s attention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STATUS`: This continues processing and is recommended for main messages to
    users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VERBOSE`: This continues processing and should be used for more detailed information
    that usually isn’t very necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG`: This continues processing and should contain any fine details that
    might be helpful when there’s an issue with a project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRACE`: This continues processing and is recommended to print messages during
    project development. Usually, these sorts of messages would be removed before
    publishing the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Picking the right mode is extra work, but it can save debugging time by coloring
    the output text based on the severity (since 3.21) or even stop the execution
    after declaring an irrecoverable error:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/10-useful/message_error.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Messages will be printed depending on the current log level (which is `STATUS`
    by default). We discussed how to change this in the previous chapter in the *Options
    for debugging and tracing* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 1*, *First Steps with CMake*, I mentioned debugging with `CMAKE_MESSAGE_CONTEXT`,
    and now it’s time to delve into it. In the meantime, we have gained insights into
    three crucial pieces of this subject: lists, scopes, and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In complex debugging scenarios, it can be extremely useful to indicate in which
    context the message is occurring. Consider the following output, where messages
    printed in the `foo` function have the appropriate prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ch02/10-useful/message_context.cmake**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we append the `top` to the context-tracking variable `CMAKE_MESSAGE_CONTEXT`,
    then we print the initial `` Before `foo` `` message, and the matching prefix
    `[top]` will be added to the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, upon entering the `foo()` function, we append a new context to the list
    named `foo` after the function it belongs to and output another message, which
    appears with the extended `[top.foo]` prefix in the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, after function execution has completed, we print the `` After `foo`
    `` message. The message is printed with the original `[foo]` scope. Why? Because
    of the *variable scope* rules: the changed `CMAKE_MESSAGE_CONTEXT` variable only
    lives until the end of the function scope, and is then restored to the original
    unchanged version.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another cool trick with `message()` is to add indentation to the `CMAKE_MESSAGE_INDENT`
    list (in exactly the same way as with `CMAKE_MESSAGE_CONTEXT`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from our scripts can then look a bit simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Since CMake doesn’t offer any real debugger with breakpoints or other tools,
    the ability to produce clean log messages comes in very handy when things don’t
    go exactly as planned.
  prefs: []
  type: TYPE_NORMAL
- en: The include() command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Partitioning code into different files to keep things ordered and, well, *separate*,
    is quite useful. Then, we can reference them from our parent listfile by calling
    `include()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If we provide a filename (a path with a `.cmake` extension), CMake will try
    to open and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that no nested, separate *variable scope* will be created, so any changes
    to variables made in that file will affect the calling scope.
  prefs: []
  type: TYPE_NORMAL
- en: CMake will raise an error if a file doesn’t exist unless we specify that it
    is optional with the `OPTIONAL` keyword. When we need to know whether `include()`
    was successful, we can provide a `RESULT_VARIABLE` keyword with the name of the
    variable. It will be filled with a full path to the included file on success or
    not found (`NOTFOUND`) on failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running in script mode, any relative paths will be resolved from the current
    working directory. To force searching in relation to the script itself, provide
    an absolute path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t provide a path but do provide the name of a module (without `.cmake`
    or otherwise), CMake will try to find a module and include it. CMake will search
    for a file with the name of `<module>.cmake` in `CMAKE_MODULE_PATH` and then in
    the CMake module directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As CMake walks the source tree and includes different listfiles, the following
    variables are set: `CMAKE_CURRENT_LIST_DIR`, `CMAKE_CURRENT_LIST_FILE`, `CMAKE_PARENT_LIST_FILE`,
    and `CMAKE_CURRENT_LIST_LINE`.'
  prefs: []
  type: TYPE_NORMAL
- en: The include_guard() command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we include files that have side effects, we might want to restrict them
    so that they’re only included once. This is where `include_guard([DIRECTORY|GLOBAL])`
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Put `include_guard()` at the top of the included file. When CMake encounters
    it for the first time, it will make a note of this fact in the current scope.
    If the file gets included again (maybe because we don’t control all the files
    in our project), it won’t be processed any further.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to protect against inclusion in unrelated function scopes that won’t
    share variables with each other, we should provide `DIRECTORY` or `GLOBAL` arguments.
    As the names suggest, the `DIRECTORY` keyword will apply the protection within
    the current directory and below it, and the `GLOBAL` keyword applies the protection
    to the whole build.
  prefs: []
  type: TYPE_NORMAL
- en: The file() command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To give you an idea of what you can do with CMake scripts, let’s take a quick
    look at the most useful variants of the file manipulation command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In short, the `file()` command will let you read, write, and transfer files
    and work with the filesystem, file locks, paths, and archives, all in a system-independent
    manner. Please see the *Appendix* for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The execute_process() command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every now and then, you’ll need to resort to using tools available in the system
    (after all, CMake is primarily a buildsystem generator). CMake offers a command
    for this purpose: you can use `execute_process()` to run other processes and collect
    their output. This command is a great fit for scripts and it can also be used
    in projects, but it **only works during the configuration stage**. Here’s the
    general form of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: CMake will use the API of the operating system to create a child process (so,
    shell operators such as `&&`, `||`, and `>` won’t work). However, you can still
    chain commands and pass the output of one to another simply by providing the `COMMAND
    <cmd> <arguments>` arguments more than once.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you may use a `TIMEOUT <seconds>` argument to terminate the process
    if it hasn’t finished the task within the required limit, and you can set the
    `WORKING_DIRECTORY <directory>` as you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exit codes of all tasks can be collected in a list by providing `RESULTS_VARIABLE
    <variable>` arguments. If you’re only interested in the result of the last executed
    command, use the singular form: `RESULT_VARIABLE <variable>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To collect the output, CMake provides two arguments: `OUTPUT_VARIABLE` and
    `ERROR_VARIABLE` (which are used in a similar fashion). If you would like to merge
    both `stdout` and `stderr`, use the same variable for both arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when writing projects for other users, you should make sure that
    the command you’re planning to use is available on the platforms you claim to
    support.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter opened the door to actual programming with CMake – you’re now able
    to write great, informative comments and utilize built-in commands, and you understand
    how to correctly provide all kinds of arguments to them. This knowledge alone
    will help you understand the unusual syntax of CMake listfiles that you might
    have seen in projects created by others. We have covered variables in CMake –
    specifically, how to reference, set, and unset *normal*, *cache*, and *environment
    variables*. We delved into how file and directory *variable scopes* work, how
    to create them, and what issues we might encounter and how to solve them. We also
    covered lists and control structures. We examined the syntax of conditions, their
    logical operations, the evaluation of unquoted arguments, as well as strings and
    variables. We learned how to compare values, do simple checks, and examine the
    state of the files in the system. This allows us to write conditional blocks and
    `while` loops; while we were talking about loops, we also grasped the syntax of
    `foreach` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to define custom commands using macro and function statements
    will undoubtedly facilitate cleaner, more procedural code. We also discussed strategies
    for improving code structure and creating more readable names.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we formally introduced the `message()` command and its multiple log
    levels. We also studied how to partition and include listfiles, and we discovered
    a few other useful commands. With this information, we are well prepared to take
    on the next chapter, *Chapter 3*, *Using CMake in Popular IDEs*.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean Code: A Handbook of Agile Software Craftsmanship (Robert C. Martin):
    [https://amzn.to/3cm69DD](https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882?&linkCode=sl1&tag=smoku-21&linkId=2bce0992e1e138154bfec781f28805ce&language=en_GB&ref_=as_li_ss_tl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refactoring: Improving the Design of Existing Code (Martin Fowler): [https://amzn.to/3cmWk8o](https://amzn.to/3cmWk8o)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Which comments in your code ARE GOOD? (Rafał Świdzinski): [https://youtu.be/4t9bpo0THb8](https://youtu.be/4t9bpo0THb8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What’s the CMake syntax to set and use variables? (StackOverflow): [https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables](https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code94081075213645359.png)'
  prefs: []
  type: TYPE_IMG
