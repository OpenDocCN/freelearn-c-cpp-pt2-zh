["```cpp\n.\n├── CMakeLists.txt\n├── array\n│   ├── array.c\n│   └── array.h\n├── build\n│   └── ...\n└── main.c\n```", "```cpp\n.\n├── CMakeLists.txt\n├── build\n│   └── ...\n├── include\n│   └── minimal-cmake\n│      └── array.h\n└── src\n   └── array.c\n```", "```cpp\n├── CMakeLists.txt\n├── build\n    └── ...\n└── array.h\n└── array.c\n```", "```cpp\n#include <minimal-cmake/array.h>\n```", "```cpp\n#include <array.h>\n```", "```cpp\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n// our implementation\n#ifdef __cplusplus\n}\n#endif // __cplusplus\n```", "```cpp\ncmake_minimum_required(VERSION 3.28)\nproject(mc-array LANGUAGES C)\nadd_library(${PROJECT_NAME})\ntarget_sources(${PROJECT_NAME} PRIVATE src/array.c)\ntarget_include_directories(\n  ${PROJECT_NAME} PUBLIC $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>)\ntarget_compile_features(${PROJECT_NAME} PRIVATE c_std_17)\n```", "```cpp\ncmake_minimum_required(VERSION 3.28)\nproject(mc-array LANGUAGES C)\n```", "```cpp\nadd_library(${PROJECT_NAME})\n```", "```cpp\noption(BUILD_SHARED_LIBS \"Build shared libraries\" OFF)\n```", "```cpp\nadd_library(${PROJECT_NAME} STATIC can be a good approach. If you’re creating a library that will be built and installed separately from the main application (something we’ll cover in *Chapter 7*, *Adding Install Support for Your Libraries*), giving a user the flexibility to decide to use either static or shared is a nice feature. Unfortunately, BUILD_SHARED_LIBS doesn’t play nicely when composing multiple libraries using FetchContent. Luckily for us, there is a workaround that builds on the topics we’ve covered here. We’ll cover this a little later in the chapter.\n\t\t\tNext up, we have `target_sources`, which has been updated to reference the new location of `array.c`:\n\n```", "```cpp\ntarget_include_directories(\n  ${PROJECT_NAME} PUBLIC \n  $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>)\n```", "```cpp\ntarget_include_directories(\n  ${PROJECT_NAME} PUBLIC\n  ${CMAKE_CURRENT_SOURCE_DIR}/include)\n```", "```cpp\n.\n├── include\n    └── minimal-cmake\n        └── array.h\n```", "```cpp\n$<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n```", "```cpp\n-- Configuring done (8.7s)\n-- Generating done (0.0s)\n```", "```cpp\nfile(GENERATE OUTPUT <filename> CONTENT \"$<...>\")\n```", "```cpp\ntarget_include_directories(\n  ${PROJECT_NAME} PUBLIC \n  $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n  $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)\n```", "```cpp\ntarget_compile_features(${PROJECT_NAME} PRIVATE c_std_17)\n```", "```cpp\n...\nFetchContent_Declare(\n  minimal-cmake-array\n  GIT_REPOSITORY https://github.com/PacktPublishing/Minimal-CMake.git\n  GIT_TAG 2b5ca4e58a967b27674a62f22ece4f846bc0aa78\n  SOURCE_SUBDIR ch4/part-1/lib/array) # look just in array folder\nFetchContent_MakeAvailable(timer_lib as-c-math minimal-cmake-array)\ntarget_link_libraries(\n  ${PROJECT_NAME} PRIVATE timer_lib as-c-math CMakeLists.txt file to a new app folder, with the array library moving to a new lib folder. The folder structure now looks like this:\n\n```", "```cpp\n\n\t\t\tThis means we need to run our CMake configure and build commands (`cmake -B build` and `cmake --build build`) from `part-<n>/app`, instead of `part-<n>` (you could also use the `-S` option and pass the source folder explicitly, as discussed in [*Chapter 2*](B21152_02.xhtml#_idTextAnchor032), *Hello, CMake!* if preferred).\n\t\t\tA complete example is presented in `ch4/part-1/app` to show how everything fits together. A small detail to note is the use of `SOURCE_SUBDIR` in the `FetchContent_Declare` command. This lets us specify a subdirectory in the repository as the root to use for `FetchContent`. As we’ve extracted our `array` type to a library in the *Minimal CMake* repository, we can treat that folder as the root of the CMake project (for completeness, the full repository will be downloaded, but only the files specified under `SOURCE_SUBDIR` will be used in the build).\n\t\t\tWe can also use `SOURCE_DIR` and a relative path, which can be useful when we’re working on the library and application together. This would look like the following:\n\n```", "```cpp\n\n\t\t\tThis means any changes to `array` will immediately be reflected in the main application. Just remember to pick a commit for the library when you’re committing your changes to make it easier to go back to earlier points in your project history for reproducible builds.\n\t\t\tMoving Game of Life to a library\n\t\t\tWe started by extracting the `array` type from our application as it was a simpler piece of functionality to start with. At this point, we’d like to pull out the core *Game of Life* logic to a separate library. We’re going to make it possible to build it as either a static or shared library, in preparation for potentially integrating it with other languages in the future. This will require us to provide an interface and move the functionality to separate files.\n\t\t\tTo prepare for our *Game of Life* code being used as a shared library, we’ll keep the concrete implementation of the *Game of Life* board hidden and expose functionality through a series of functions. The interface looks as follows:\n\n```", "```cpp\n\n\t\t\tThis is a C-style interface where we forward declare the Game of Life board type (`mc_gol_board_t`) and provide create and destroy functions to manage the lifetime. By hiding concrete types, we make it easier to integrate our library with other languages in the future and avoid potential **application binary interface** (**ABI**) incompatibilities across different compilers (such as layout, padding, or alignment). Function interfaces also help with encapsulation and backward compatibility.\n\t\t\tWith our interface defined, we can follow the same approach that we did with `array` and create a static library encapsulating our Game of Life implementation. If you review `ch4/part-2/lib/gol`, you’ll see the updated structure. We’ve also been able to move `as-c-math` and `mc-array` so that they’re private dependencies of the new *Game of Life* library (`mc-gol`) and remove them from the main app’s `CMakeLists.txt` file. To disambiguate the application and library, we’ll also rename our app to `minimal-cmake_game-of-life_console`.\n\t\t\tWith this in place, we can focus on the changes necessary to make this a shared library.\n\t\t\tMaking Game of Life a shared library\n\t\t\tWe will start by working through the changes between `ch4/part-2` and `ch4/part-3` to see what updates are needed to make `mc_gol` a shared library. The focus will be `ch4/part-3/lib/gol/CMakeLists.txt`, but we’ll also need to update `ch4/part-3/lib/gol/include/minimal-cmake-gol/gol.h` and `ch4/part-3/app/CMakeLists.txt`.\n\t\t\tVisual Studio Code – Compare Active File With...\n\t\t\tThis is a quick reminder to use the Visual Studio Code feature known as `ch4/part-2/lib/gol/CMakeLists.txt` and `ch4/part-3/lib/gol/CMakeLists.txt`). The `diff` view makes the changes clear without needing to switch back and forth.\n\t\t\tThe first difference is the addition of a new `option` command for `mc-gol`:\n\n```", "```cpp\n\n\t\t\tThe CMake `option` command allows the library user to compile `mc-gol` as either `STATIC` or `SHARED` (it defaults to `OFF` to match the CMake default of static libraries). The `option` name is also prefixed with `MC_GOL` to help with readability and reduce the chance of name collisions in other projects.\n\t\t\tWe’ve refrained from using `BUILD_SHARED_LIBS` in this case because using this would apply to all libraries we’re building (including `mc-array` and `as-c-math`). We would like those libraries to be compiled statically as normal and only allow `mc-gol` to be explicitly compiled as a shared library.\n\t\t\tIf we were only building our library and linking to external dependencies that had already been built, `BUILD_SHARED_LIBS` would work well, but this isn’t what we want when composing libraries with `FetchContent`.\n\t\t\tTo support only building `mc-gol` as `SHARED`, we need a little more logic before the `add_library` command:\n\n```", "```cpp\n\n\t\t\tHere, we introduce a new CMake variable called `MC_GOL_LIB_TYPE`, which we default to `STATIC`. Only if the `MC_GOL_SHARED` option is turned on do we set it to `SHARED`. We then pass this CMake variable to the `add_library` command to decide the library type:\n\n```", "```cpp\n\n\t\t\tWe’ll skip over the change to `target_include_directories` for now as it’s a side effect of what we’ll talk about next.\n\t\t\tHere, we’re focusing on making our library cross-platform. To ensure our shared library works consistently across macOS, Windows, and Linux, we need to take some extra steps to support this. With the preceding change, if we try to build and run our project on Windows with `MC_GOL_SHARED` set to `ON` (`cmake -B build -DMC_GOL_SHARED=ON`), our application will fail to link. This is because Windows requires symbols from a shared library (in our case, functions) to be explicitly exported; otherwise, they are hidden, and they’re only available internally to the library. This contrasts with macOS and Linux, where all symbols are usually exported by default.\n\t\t\tTo work around this, we must explicitly annotate the functions we want to make available to other applications with special compiler directives. These are different across Windows and macOS/Linux (Visual Studio versus GCC/Clang). Fortunately, CMake provides an incredibly useful feature called `generate_export_header` that provides a cross-platform solution for us. To use it, add the following to your `CMakeLists.txt` file:\n\n```", "```cpp\n\n\t\t\tFirst, we bring in the `GenerateExportHeader` module, which provides the `generate_export_header` command, and then we call it while providing the project name and a base name for the library (`mc_gol`). This will create a file called `mc_gol_export.h` in the `mc-gol` build folder.\n\t\t\tThis briefly brings us back to the change to `target_include_directories` we skipped over earlier. To ensure our header (`gol.h`) can include `mc_gol_export.h`, we need to ensure it is added to the target’s include path. To achieve this, we’ll add `${CMAKE_CURRENT_BINARY_DIR}` to `target_include_directories`.\n\t\t\tThis can be done in one of two ways. First, we can pass two generator expressions like so:\n\n```", "```cpp\n\n\t\t\tAlternatively, we can wrap the generator expression in quotes and pass the second directory as a list (separated by semicolons):\n\n```", "```cpp\n#    ifdef mc_gol_EXPORTS\n        /* We are building this library */\n#      define MC_GOL_EXPORT __declspec(dllexport)\n#    else\n        /* We are using this library */\n#      define MC_GOL_EXPORT __declspec(dllimport)\n#    endif\n```", "```cpp\ntarget_compile_definitions(\n  ${PROJECT_NAME}\n  PUBLIC $<$<NOT:$<BOOL:${MC_GOL_SHARED}>>:MC_GOL_STATIC_DEFINE, but only if we’re not building a shared library. This will guarantee that MC_GOL_EXPORT won’t be expanded when building as a static library (see ch4/part-5/lib/CMakeLists.txt for an example). This can be useful if you’re reusing a generated version of mc_gol_export.h that has MC_GOL_EXPORT set to something you don’t want. In our case, it’s not strictly necessary but it can be a good failsafe to keep in place.\n\t\t\tTo learn more about `GenerateExportHeader`, you can read the full documentation, which is available at [https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html](https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html).\n\t\t\tWith `mc_gol_export.h` created, and our `target_include_directories` command updated, all that remains is to annotate our symbols (in the case of `gol.h`, our functions) with `MC_GOL_EXPORT`. Here’s an example:\n\n```", "```cpp\n\n\t\t\tOn Windows, when `mc_gol` is built, the macro is substituted with `__declspec(dllexport)`, and when it’s later used as a dependency from our application, `MC_GOL_EXPORT` is substituted with `__declspec(dllimport)`.\n\t\t\tMaking things work on Windows\n\t\t\tWe’re nearly there! The last change we need to make is to our application’s `CMakeLists.txt` file (`ch4/part-3/app/CMakeLists.txt`) to ensure things work correctly on Windows.\n\t\t\tLet’s configure and build our project with `MC_GOL_SHARED` set to `ON`, like so:\n\n```", "```cpp\n\n\t\t\tAssuming Visual Studio is picked as the default generator (it being a multi-config generator, our executable will end up in the `Debug/` folder unless a different config is provided), we can try to run our application with the following command:\n\n```", "```cpp\n\n\t\t\tThe unwelcome news is this will fail on startup with the following error:\n\n```", "```cpp\n\n\t\t\tThe reason for this is that our application cannot find `mc-gol.dll` to load. This has happened because, on Windows, an application will search for a shared library (called a `PATH` environment variable. We haven’t told our executable where to search for `mc-gol.dll` or moved the DLL next to our executable, so it can’t find it.\n\t\t\tTo get things working, we could update the `PATH` variable from the terminal:\n\n```", "```cpp\n\n\t\t\tThis, however, is a tedious manual step and deals with absolute paths (not exactly portable). A much better idea is just to copy or move the DLL to the same folder as the executable.\n\t\t\tThere are two ways to do this in our example. The first is to update `RUNTIME_OUTPUT_DIRECTORY` of `mc_gol` to that of our current executable. In our application’s `CMakeLists.txt` file, we can add this line:\n\n```", "```cpp\n\n\t\t\tAs we’re building `mc-gol` ourselves, we can set properties on it as if we’d added the library locally. The preceding command will ensure `mc-gol.dll` will be written directly to `build\\Debug`, instead of `build\\_deps\\minimal-cmake-gol-build\\Debug`. This command also handles single and multi-config generators correctly (if we were to switch to the Ninja single-config generator, `mc-gol.dll` would end up in the `build\\` folder).\n\t\t\tAs a brief aside, it’s worth mentioning that `RUNTIME_OUTPUT_DIRECTORY` refers to `.dll` files on Windows (as well as executable files), but on macOS and Linux, it is `LIBRARY_OUTPUT_DIRECTORY`, which refers to `.dylib` (macOS) and `.so` (Linux) shared library files. This can be a little counterintuitive and will be important a little later when we return to `ch4/part4`.\n\t\t\tThe second way to copy `mc-gol.dll` to the same directory as our executable is to use a CMake custom command. Here is the one we’ll use:\n\n```", "```cpp\n\n\t\t\tThis sets up a custom command to run immediately after the build completes (`POST_BUILD`). The target the command is bound to is our application, and the command copies the target file (`$<TARGET_FILE:mc-gol>`) to the directory of our application’s target binary file (`$<TARGET_FILE_DIR:${PROJECT_NAME}>`). In this case, when `mc-gol.dll` is built, it is written to `build\\_deps\\minimal-cmake-gol-build\\Debug\\mc-gol.dll` first, after which it is copied to `build\\Debug` once our application (`minimal-cmake_game-of-life_console`) has finished building.\n\t\t\tOne advantage of this approach over using the `set_target_properties(... RUNTIME_OUTPUT_DIRECTORY` method is that this works for libraries outside the current build (for example, installed libraries found using `find_package`, something we’ll cover in [*Chapter 6*](B21152_06.xhtml#_idTextAnchor152), *Installing Dependencies and ExternalProject_Add*). This consistency is one reason to prefer this approach; however, it depends on the type of application you’re building. If you know the library will always be included in the main build using `FetchContent` or `add_subdirectory`, then sticking with setting `RUNTIME_OUTPUT_DIRECTORY` is a fine choice.\n\t\t\tMaking things relocatable on macOS and Linux\n\t\t\tWe spent a bit of time dealing with DLL loading issues on Windows, but both macOS and Linux also need some attention to work reliably across different locations. The reason we had to copy `mc-gol.dll` to the application folder on Windows was that our application wouldn’t start without it there. The good news is that on macOS and Linux, we don’t need to do that because when we build the project, our application will record the location of the shared library and know where to load it from.\n\t\t\tThis works great until we decide to move our library to another location. Suppose we want to zip up the contents of our project and share it with a friend, or just check it runs on another machine. If we try this as-is, chances are you’ll see the following error:\n\n```", "```cpp\n\n\t\t\tThis is because the absolute path of where the library was found when it was built is baked into our application. This means we can move our application (`minimal-cmake_game-of-life_console`), but if we move `mc-gol.dylib` (macOS) or `mc-gol.so` (Linux), things will break. Fortunately, there is a straightforward way to solve this.\n\t\t\tWhat we’re going to rely on is changing the `RPATH` (runtime search path) variable of our executable to include `@loader_path` (on macOS) and `$ORIGIN` (on Linux). This is effectively a way to refer to the application wherever it is on the filesystem. What this means is that just like on Windows, our application will search for the shared library in the folder it’s running from, so we simply need to copy the shared library (`.dylib`/`.so`) to the application folder. We only need to do this when we want to distribute the application, and we can either use `set_target_properties(... LIBRARY_OUTPUT_DIRECTORY)` or rely on the same method we used to copy the Windows `.dll` file to the same folder.\n\t\t\tTo change the `RPATH` variable, we can use the following CMake commands:\n\n```", "```cpp\nLoad command 16\n          cmd LC_RPATH\n      cmdsize 32\n         readelf on Linux:\n\n```", "```cpp\n#    ifdef mc_gol_EXPORTS\n        /* We are building this library */\n#      define MC_GOL_EXPORT\n__attribute__((visibility(\"default\")))\n#    else\n        /* We are using this library */\n#      define MC_GOL_EXPORT\n__attribute__((visibility(\"default\")))\n#    endif\n```", "```cpp\n#    ifdef mc_gol_EXPORTS\n        /* We are building this library */\n#      define MC_GOL_EXPORT\n#    else\n        /* We are using this library */\n#      define MC_GOL_EXPORT\n#    endif\n```", "```cpp\nset_target_properties(\n  ${PROJECT_NAME}\n  PROPERTIES C_VISIBILITY_PRESET hidden\n             VISIBILITY_INLINES_HIDDEN ON\n             C_STANDARD_REQUIRED ON\n             C_EXTENSIONS OFF)\n```", "```cpp\ncmake_minimum_required(VERSION 3.28)\nproject(mc-utils LANGUAGES C)\nadd_library(${PROJECT_NAME} INTERFACE)\ntarget_include_directories(\n  ${PROJECT_NAME}\n  INTERFACE $<BUILD_LOCAL_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include/>)\ntarget_compile_features(${PROJECT_NAME} INTERFACE c_std_17)\n```", "```cpp\nFetchContent_Declare(\n  minimal-cmake-utils\n  GIT_REPOSITORY <path/to/git-repo>\n  GIT_TAG <commit-hash>)\nFetchContent_MakeAvailable(minimal-cmake-utils)\ntarget_link_libraries(<main-app> PRIVATE mc-utils)\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```"]