["```cpp\ncmake -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake -S <SourceDir> -B\n  <BuildDir>\ncmake  --toolchain arm64.toolchain.cmake -S <SourceDir> -B <BuildDir>\n```", "```cpp\n{\n    \"name\": \"arm64-build-debug\",\n    \"generator\" : \"Ninja\",\n    \"displayName\": \"Arm 64 Debug\",\n    \"toolchainFile\": \"${sourceDir}/arm64.toolchain.cmake\",\n    \"cacheVariables\": {\n        \"CMAKE_BUILD_TYPE\": \"Debug\"\n    }\n},\n```", "```cpp\n-- The CXX compiler identification is GNU 9.3.0\n-- The C compiler identification is GNU 9.3.0\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: /usr/bin/arm-linux-gnueabihf-g++-\n  9 - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Check for working C compiler: /usr/bin/arm-linux-gnueabi-gcc-9 -\n  skipped\n-- Detecting C compile features\n-- Detecting C compile features - done\n```", "```cpp\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\nset(CMAKE_C_COMPILER /usr/bin/arm-linux-gnueabi-gcc-9)\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabihf-g++-9)\nset(CMAKE_C_FLAGS_INIT -pedantic)\nset(CMAKE_CXX_FLAGS_INIT -pedantic)\nset(CMAKE_SYSROOT /home/builder/raspi-sysroot/)\nset(CMAKE_STAGING_PREFIX /home/builder/raspi-sysroot-staging/)\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE BOTH)\n```", "```cpp\ncmake -G \"Visual Studio 2019\" -A Win32 -T host=x64\n```", "```cpp\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\nset(CMAKE_C_COMPILER /usr/bin/clang)\nset(CMAKE_C_COMPILER_TARGET arm-linux-gnueabihf)\nset(CMAKE_CXX_COMPILER /usr/bin/clang++)\nset(CMAKE_CXX_COMPILER_TARGET arm-linux-gnueabihf)\n```", "```cpp\ncmake -G \"Visual Studio 2019\" -A Win32 -T host=x64\n```", "```cpp\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR i686)\nset(CMAKE_C_COMPILER  gcc)\nset(CMAKE_CXX_COMPILER g++)\nset(CMAKE_C_FLAGS_INIT -m32)\nset(CMAKE_CXX_FLAGS_INIT -m32)\nset(CMAKE_EXE_LINKER_FLAGS_INIT -m32)\nset(CMAKE_SHARED_LINKER_FLAGS_INIT -m32)\nset(CMAKE_STATIC_LINKER_FLAGS_INIT -m32)\nset(CMAKE_MODULE_LINKER_FLAGS_INIT -m32)\n```", "```cpp\ncmake -S . -B build --toolchain <NDK_DIR>/build/cmake/android\n  .toolchain.cmake -DANDROID_ABI=armeabi-v7a -DANDROID_PLATFORM=23\n```", "```cpp\nset(CMAKE_SYSTEM_NAME Android)\nset(CMAKE_SYSTEM_VERSION 21)\nset(CMAKE_ANDROID_ARCH_ABI arm64-v8a)\nset(CMAKE_ANDROID_NDK /path/to/the/android-ndk-r23b)\nset(CMAKE_ANDROID_STL_TYPE c++_static)\n```", "```cpp\ncmake -S <SourceDir> -B <BuildDir> -G Xcode -DCMAKE_SYSTEM_NAME=iOS\n```", "```cpp\ncmake -build <BuildDir> -- -sdk <sdk>\n```", "```cpp\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\nset(CMAKE_SYSROOT /path/to/arm/sysroot/)\nset(CMAKE_CXX_COMPILER /usr/bin/clang++)\nset(CMAKE_CXX_COMPILER_TARGET arm-linux-gnueabihf)\nset(CMAKE_CROSSCOMPILING_EMULATOR \"qemu-arm;-L;${CMAKE_SYSROOT}\")\n```", "```cpp\nadd_test(NAME exampleTest COMMAND exampleExe)\n```", "```cpp\nqemu-arm \"-L\" \"/path/to/arm/sysroot/\" \"/path/to/build-dir/\n  exampleExe\"\n```", "```cpp\ncheck_source_compiles(<lang> <code> <resultVar>\n    [FAIL_REGEX <regex1> [<regex2>...]]  [SRC_EXT <extension>])\ncheck_source_runs(<lang> <code> <resultVar>\n[SRC_EXT <extension>])\n```", "```cpp\ninclude(CheckCSourceCompiles)\ncheck_c_source_compiles(code resultVar\n  [FAIL_REGEX regexes...]\n)\ninclude(CheckCXXSourceCompiles)\ncheck_cxx_source_compiles(code resultVar\n  [FAIL_REGEX regexes...]\n)\n```", "```cpp\ninclude(CheckSourceCompiles)\ncheck_source_compiles(CXX \"\n#include <atomic>\nint main(){\n    std::atomic<unsigned int> x;\n    x.fetch_add(1);\n    x.fetch_sub(1);\n}\" HAS_STD_ATOMIC)\n```", "```cpp\n[cmake] -- Performing Test HAS_STD_ATOMIC\n[cmake] -- Performing Test HAS_STD_ATOMIC - Success\n```", "```cpp\ninclude(CMakePushCheckState)\ncmake_push_check_state()\n# Push the state and clean it to start with a clean check state\ncmake_reset_check_state()\ninclude(CheckCompilerFlag)\ncheck_compiler_flag(CXX -Wall WALL_FLAG_SUPPORTED)\nif(WALL_FLAG_SUPPORTED)\n    set(CMAKE_REQUIRED_FLAGS -Wall)\n    # Preserve -Wall and add more things for extra checks\n    cmake_push_check_state()\n        set(CMAKE_REQUIRED_INCLUDES ${CMAKE_CURRENT_SOURCE_DIR}/include)\n        include(CheckSymbolExists)\n        check_symbol_exists(hello \"hello.hpp\" HAVE_HELLO_SYMBOL)\n    cmake_pop_check_state()\nendif()\n# restore all CMAKE_REQUIRED_VARIABLEs to original state\ncmake_pop_check_state()\n```", "```cpp\ninclude(CheckLanguage)\ncheck_language(Fortran)\nif(CMAKE_Fortran_COMPILER)\n   enable_language(Fortran)\nelse()\n   message(STATUS \"No Fortran support\")\nendif()\n```", "```cpp\ninclude(CheckCompilerFlag)\ncheck_compiler_flag(CXX -Wall WALL_FLAG_SUPPORTED)\n```", "```cpp\ninclude(CheckLinkerFlag)\ncheck_linker_flag(CXX LINKER:-stats LINKER_STATS_FLAG_SUPPORTED)\n```"]