- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing CMake in the Best Ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we got acquainted with CMake and learned about its
    fundamental concepts. Now, we are going to learn how to interact with it. Learning
    how to interact with CMake is essential. Before you dive into structuring your
    software project with CMake, you must first learn how to configure, build, and
    install the existing ones. This will enable you to interact with CMake projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will look into what CMake has to offer as an interface and inspect
    some of the popular IDE and editor integrations. This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using CMake via a command-line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `cmake-gui` and `ccmake` interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE and editor integrations (Visual Studio, **Visual Studio Code** (**VSCode**),
    and Qt Creator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we have a lot to cover, let’s not waste any time and get started with
    the technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before going further into detail, there are some requirements that need to
    be satisfied to follow the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The CMake Best Practices repository**: This is the main repository that contains
    all the exemplary content for the book. It is accessible online at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples in later chapters on packaging and dependency management use
    OpenSSL to illustrate how to work with third-party libraries. To install it, either
    use the package manager supplied by your operating system, such as `apt-get`,
    `chocolatey`, or `brew`, or download it from any of the links supplied in the
    OpenSSL wiki: [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries).
    OpenSSL was chosen because it is freely available for a wide variety of platforms
    and is easy to install.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CMake via a command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although CMake is quite well integrated into many IDEs and editors, it is essentially
    a **command-line** tool, so learning how to use CMake in the **command-line interface**
    (**CLI**) is essential to use it to its full potential. Using CMake through the
    command line also helps to understand the inner workings and concepts of CMake.
    In this section, we are going to learn how to perform the most basic CMake operations
    using the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interactions with the CMake CLI can be done by issuing the `cmake` command
    in your operating system’s terminal, assuming that CMake is installed and the
    `cmake` executable is included in your system’s `PATH` variable (or equivalent).
    You can verify that by issuing `cmake` in your terminal without any parameters,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Invoking the cmake command](img/B30947_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Invoking the cmake command
  prefs: []
  type: TYPE_NORMAL
- en: If your terminal is complaining about a missing command, then you should either
    install CMake (explained in [*Chapter 1*](B30947_01.xhtml#_idTextAnchor015), *Kickstarting
    CMake*) or make it discoverable by adding it to your system’s `PATH` variable.
    Consult your operating system’s guide about how to add a path to the system’s
    `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing CMake and adding it to the `PATH` variable (if required),
    you should test whether CMake is usable. The most basic command you can execute
    in the command line is `cmake --version`, which allows you to check CMake’s version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Checking for the CMake version in the terminal](img/B30947_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Checking for the CMake version in the terminal
  prefs: []
  type: TYPE_NORMAL
- en: CMake will output a version string in the form of `cmake version <maj.min.rev>`.
    You should see an output that contains the version number of the CMake you’ve
    installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the version does not match the installed one, then you probably have multiple
    installations of CMake on your system. Since this book contains examples written
    for CMake version 3.23 and above, it is recommended to have that issue fixed before
    going any further.
  prefs: []
  type: TYPE_NORMAL
- en: After installing CMake, you should install your build system and compiler as
    well. For Debian-like operating systems (for example, Debian and Ubuntu), this
    can be easily done by issuing the `sudo apt install build-essential` command.
    This package essentially contains `gcc`, `g++`, and `make`.
  prefs: []
  type: TYPE_NORMAL
- en: The CLI usage will be illustrated in the Ubuntu 22.04 environment. Apart from
    the minor edge cases, the usage is the same in other environments as well. Those
    edge cases will be mentioned as we go on.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of the CMake CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three basic things you should learn about using the CMake CLI are listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a CMake project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a CMake project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a CMake project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After learning the basics, you will be able to build and install any CMake project
    of your choice. Let’s get started with configuring.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a project via the CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To configure a CMake project via the command line, you can use the `cmake -G
    "Unix Makefiles" -S <project_root> -B <output_directory>` construct. The `-S`
    argument is used to specify the CMake project to be configured, whereas `-B` specifies
    the *configure* output directory. Lastly, the `-G` argument allows us to specify
    the generator that will be used for the build system generation. The result of
    the configuration process will be written to `<output_directory>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an illustration, let’s configure our book’s example project into the project
    root `build` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Cloning the example code repository](img/B30947_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Cloning the example code repository
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The project must already be present in your environment. If not, clone it via
    Git by issuing `git clone` `https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition.git`
    in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go into the `CMake-Best-Practices---2nd-Edition/chapter02/simple_example`
    directory and issue `cmake -G "Unix Makefiles" -S . -B ./build`, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Configuring the example code with CMake](img/B30947_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Configuring the example code with CMake
  prefs: []
  type: TYPE_NORMAL
- en: This command is like saying to CMake, *use the “Unix Makefiles” (-G “Unix Makefiles”)
    generator to generate a build system for the CMake project in the current directory
    (-S .) to the build (-B ./**build) directory*.
  prefs: []
  type: TYPE_NORMAL
- en: CMake will configure the project located in the current folder into the `build`
    folder. As we omitted the build type, CMake used the `Debug` build type (the default
    `CMAKE_BUILD_TYPE` value for the project).
  prefs: []
  type: TYPE_NORMAL
- en: In subsequent sections, we are going to learn about the fundamental settings
    that are used in the configure step.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the build type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CMake does not assume any build type by default. To set the build type, an additional
    variable named `CMAKE_BUILD_TYPE` must be supplied to the `configure` command.
    To supply additional variables, the variable must be prefixed with `-D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the `Release` build instead of `Debug`, add the `CMAKE_BUILD_TYPE` variable
    in the `configure` command, as mentioned previously: `cmake -G "Unix Makefiles"
    -` `-S . -``B ./build`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `CMAKE_BUILD_TYPE` variable only makes sense for single-configuration generators,
    such as Unix Makefiles and Ninja. In multiple-configuration generators, such as
    Visual Studio, build type is a build-time parameter instead of a configuration-time
    parameter. Thus, it cannot be configured by using the `CMAKE_BUILD_TYPE` parameter.
    See the *Installing a specific configuration (for multiple-configuration generators
    only)* section for how to change the build type in such generators.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the generator type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Depending on the environment, CMake attempts to select an appropriate generator
    by default. To specify a generator explicitly, the `-G` argument must be supplied
    with a valid generator name. For example, if you want to use Ninja as a build
    system instead of make, you can change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the command output shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Checking the CMake’s Ninja generator output](img/B30947_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Checking the CMake’s Ninja generator output
  prefs: []
  type: TYPE_NORMAL
- en: This will cause CMake to generate Ninja build files instead of Makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see all available generator types for your environment, issue the
    `cmake --help` command. Available generators will be listed at the end of the
    **Help text generators** section, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – List of available generators in help](img/B30947_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – List of available generators in help
  prefs: []
  type: TYPE_NORMAL
- en: The generator with an asterisk next to it is the default for the environment
    you’re currently in.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the compiler
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In CMake, the compilers to be used are specified on a per-language basis via
    the `CMAKE_<LANG>_COMPILER` variables. In order to change the compiler for a language,
    `CMAKE_<LANG>_COMPILER` must be supplied to the `Configure` command. For a C/C++
    project, the variables usually overridden are `CMAKE_C_COMPILER` (C compiler)
    and `CMAKE_CXX_COMPILER` (C++ compiler). Compiler flags are similarly controlled
    by the `CMAKE_<LANG>_FLAGS` variable. This variable can be used to hold configuration-independent
    compiler flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s try to use `g++-12` as a C++ compiler in an environment
    where it is not the default compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see `g++-12` is used instead of the system’s default compiler,
    `g++-11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Configuring the project using a different compiler (g++-10)](img/B30947_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Configuring the project using a different compiler (g++-10)
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the compiler specification, CMake prefers to use `g++-9` in this environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Configuring behavior without a compiler preference](img/B30947_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Configuring behavior without a compiler preference
  prefs: []
  type: TYPE_NORMAL
- en: Passing flags to the compiler
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To illustrate how to specify compiler flags, suppose that you want to enable
    all warnings and treat them as an error. These behaviors are controlled with the
    `-Wall` and `-Werror` compiler flags, respectively, in the `gcc` toolchain; thus,
    we need to pass these flags to the C++ compiler. The following code specifies
    how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the flags specified in the command (`-Wall` and `-Werror`) are passed
    into the compiler in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Passing flags to the C++ compiler](img/B30947_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Passing flags to the C++ compiler
  prefs: []
  type: TYPE_NORMAL
- en: 'Build flags can be customized for a per-build type by suffixing them with the
    capitalized build type string. There are four variables for four different build
    types, as listed next. They are useful for specifying build types depending on
    compiler flags. Flags specified in such variables are only valid when the configuration
    build type matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_<LANG>_FLAGS_DEBUG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_<LANG>_FLAGS_RELEASE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_<LANG>_FLAGS_RELWITHDEBINFO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_<LANG>_FLAGS_MINSIZEREL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the previous example, if you want to treat warnings as errors
    only in the `Release` builds, build-type-specific compiler flags allow you to
    do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that illustrates the usage of the build-type-specific compiler
    flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that an additional `CMAKE_CXX_FLAGS_RELEASE` parameter is present in
    the preceding command. The contents in this variable will only be passed to the
    compiler when the build type is `Release`. Since the build type is specified as
    `Debug`, we can see the `-fpermissive` flag is not present in the flags passed
    to the compiler, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Specifying flags based on build type; the –fpermissive flag
    is missing in the Debug build](img/B30947_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Specifying flags based on build type; the –fpermissive flag is
    missing in the Debug build
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 2**.10*, notice that the `-fpermissive` flag does not appear in
    the build command and the results of grep are empty. This confirms that the `CMAKE_CXX_FLAGS_RELEASE`
    variable is not used in the `Debug` build type. When the build type is specified
    as `Release`, we can see that the `-O3` flag is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this line, you are saying to CMake, configure the CMake project located in
    the current directory to the build/ folder using the “*Unix Makefiles*” generator.
    For all build types, pass the -*Wall and –Werror* flags to the compiler unconditionally.
    If the build type is Release, pass the -fpermissive flag as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of the command when the build type is set to `Release`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Specifying flags based on build type; the -fpermissive flag
    is present in the Release build](img/B30947_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Specifying flags based on build type; the -fpermissive flag is
    present in the Release build
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 2**.11*, we can confirm that the `-fpermissive` flag is passed to
    the compiler as well. Be aware that even though `RelWithDebInfo` and `MinSizeRel`
    are also release builds, they are separate from the `Release` build type, and
    so flags specified in the `CMAKE_<LANG>_FLAGS_RELEASE` variable will not apply
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: The shortcut – using CMake presets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using CMake over the command line offers quite a lot of configuration options,
    which gives a lot of control over the build process. However, it can also become
    quite hard to track all the different combinations of flags and arguments needed
    for the various configurations of a project. Before the introduction of *CMake
    presets* in CMake 3.21, keeping track of all the different flags needed to build
    a project could be quite a challenge. But luckily, CMake presets take away a lot
    of the tedious work here because almost all options that are passed to CMake over
    the command line can be represented in the presets as well. This is why they are
    a great way to preconfigure various combinations of CMake options. We will dive
    deeper into CMake presets in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible Build* *Environments*, but nowadays more and more projects
    come with presets pre-delivered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all available presets, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure a project with a preset call, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Once you are familiar with the basic options on how to configure CMake, we highly
    recommend using CMake presets to easily manage all different build configurations,
    compiler flags, and similar.
  prefs: []
  type: TYPE_NORMAL
- en: Listing cached variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can list all cached variables by issuing the `cmake -L ./build/` command
    (see *Figure 2**.12*). This, by default, does not show the advanced variables
    and help strings associated with each variable. To show them as well, use the
    `cmake -LAH ./build/` command instead.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – List of cached variables dumped by CMake](img/B30947_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – List of cached variables dumped by CMake
  prefs: []
  type: TYPE_NORMAL
- en: Building a configured project via the CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build the configured project, issue the `cmake --build ./``build` command.
  prefs: []
  type: TYPE_NORMAL
- en: This command tells CMake to *build the CMake project already configured in the*
    *build folder*.
  prefs: []
  type: TYPE_NORMAL
- en: You can also equivalently issue `cd build && make`. The benefit of using `cmake
    --build` is that it saves you from invoking build-system-specific commands. It
    is especially helpful when building CI pipelines or build scripts. In this way,
    you can change your build system generator without changing your build command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an example output for the `cmake --build ./build` command in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Building a configured project](img/B30947_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Building a configured project
  prefs: []
  type: TYPE_NORMAL
- en: Building in parallel
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also customize build-time details while issuing the build command. The
    most prominent build-time configuration is the number of jobs that will be used
    to build the project. To specify the job count, append `--parallel <job_count>`
    to your `cmake --``build` command.
  prefs: []
  type: TYPE_NORMAL
- en: To build in parallel, issue `cmake --build ./build --parallel 2`, where the
    number `2` specifies the job count. The recommended number of jobs for a build
    system is, at most, *one job per hardware thread*. In multi-core systems, it is
    also recommended to use at least one less than the available hardware thread count
    to not affect the system’s responsivity during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can usually use more than one job per hardware thread and get faster build
    times since the build process is mostly I/O bound, but your mileage may vary.
    Experiment and observe.
  prefs: []
  type: TYPE_NORMAL
- en: Also, some build systems, such as Ninja, will try to utilize as many hardware
    threads as are available in the system, so it is redundant to specify the job
    count for such build systems if your target is to use all hardware threads in
    your system. You can retrieve the hardware thread count by issuing the `nproc`
    command in Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good practice not to use fixed values for environment-dependent variables
    in the commands that are expected to be invoked in different environments, such
    as CI/CD scripts and build scripts. Here is an example `build` command that utilizes
    `nproc` to determine the number of parallel jobs dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s observe how different job counts affect the build time. We will use the
    `time` tool to measure how long each command invocation is. The environment details
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating system**: Ubuntu 22.04'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU**: 11th Gen Intel i19-11900H @2.5GHz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAM**: 32 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With one job (`--parallel 1`), the build time result would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Parallelized build time result with one job](img/B30947_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Parallelized build time result with one job
  prefs: []
  type: TYPE_NORMAL
- en: 'The build time result with two jobs (`--parallel 4`) would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Parallelized build time result with two jobs](img/B30947_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Parallelized build time result with two jobs
  prefs: []
  type: TYPE_NORMAL
- en: Even though invoked on a very simple project, we can clearly see how extra jobs
    help get faster build times.
  prefs: []
  type: TYPE_NORMAL
- en: Building specific targets only
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, CMake will build all available targets that are configured. Since
    building all the targets is not always desirable, CMake allows building a subset
    of targets via the `--target` sub-option. This sub-option may be specified multiple
    times, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command will limit the build scope to just the `ch2_framework_component1`
    and `ch2_framework_component2` targets. If these targets also depend on other
    targets, they will be built as well.
  prefs: []
  type: TYPE_NORMAL
- en: Removing previous build artifacts before the build
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you want to run a clean build, you may want to remove the artifacts from
    the previous run first. To do that, the `--clean-first` sub-option can be used.
    This sub-option will invoke a special target that cleans all the artifacts generated
    by the build process (makes clean).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you can do it for a build folder named `build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Debugging your build process
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we did in the *Passing flags to the compiler* section previously, you may
    want to inspect which commands are invoked with which arguments in the build process.
    The `--verbose` sub-command instructs CMake to invoke all build commands with
    verbose mode given that verbose mode is supported by the command. This enables
    us to investigate nasty compilation and linkage errors with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a folder named `build` in verbose mode, invoke `--build` as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Passing command-line arguments to the build tool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you ever need to pass arguments to the underlying build tool, you can append
    `--` at the end of the command and write the arguments that will be given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, `--trace` will be directly forwarded to the build tool,
    which is `make` in our case. This will cause `make` to print tracing information
    for each recipe built.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a project via the CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CMake natively allows the installation of artifacts to the environment, if desired.
    In order to do that, CMake code must be already using CMake `install()` instructions
    to specify what to install when `cmake --install` (or the build system equivalent)
    is invoked. The content of `chapter_2` is already configured in such a way as
    to illustrate the command.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn how to make CMake targets installable later in [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Packaging, Deploying, and Installing a* *CMake Project*.
  prefs: []
  type: TYPE_NORMAL
- en: The `cmake --install` command requires an already configured and built project.
    Configure and build the CMake project if you haven’t done it yet. Afterward, issue
    the `cmake --install <project_binary_dir>` command to install the CMake project.
    Since in our examples `build` is used as a project binary directory, `<project_binary_dir>`
    will be replaced with `build`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows an example of the `install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Installing a project](img/B30947_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Installing a project
  prefs: []
  type: TYPE_NORMAL
- en: The default installation directory varies between environments. For Unix-like
    environments, it defaults to `/usr/local`, whereas in a Windows environment, it
    defaults to `C:/Program Files`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the project must already be built before trying to install
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to install the project successfully, you must have the appropriate
    rights/permissions to write to the installation target directory.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the default installation path
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To change the default installation directory, you may specify the additional
    `--prefix` parameter, as shown here, to change the installation directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the contents of the `/tmp/example` folder after
    invoking `cmake --install` with the `/``tmp/example` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Installing a project to a different path](img/B30947_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Installing a project to a different path
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen here, the installation root is successfully changed to `/tmp/example`.
  prefs: []
  type: TYPE_NORMAL
- en: Stripping binaries while installing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the software world, build artifacts are usually bundled with some extra information,
    for example, a symbol table required for debugging. This information may not be
    necessary for executing the end product and may drastically increase binary sizes.
    If you’re looking to reduce your end product’s storage footprint, stripping binaries
    may be a good option. One additional benefit of stripping is that it makes it
    harder to reverse engineer binaries since essential symbol information is stripped
    away from the binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake’s `--install` command allows the stripping of binaries while installing
    the operation. It can be enabled by specifying an additional `--strip` option
    to the `--install` command, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, you can observe the size difference between unstripped
    and stripped binaries. Note that stripping static libraries has its own limitations
    and CMake does not perform it by default. You can see the size of the unstripped
    binaries in this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Artifact size (unstripped)](img/B30947_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Artifact size (unstripped)
  prefs: []
  type: TYPE_NORMAL
- en: 'With a stripped (`cmake –install build --strip`) binary, the size difference
    looks as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Artifact size (stripped)](img/B30947_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Artifact size (stripped)
  prefs: []
  type: TYPE_NORMAL
- en: Installing specific components only (component-based install)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the project is using CMake’s `COMPONENT` feature in the `install()` commands,
    you may install specific components by specifying their component names. The `COMPONENT`
    feature allows separating installation into sub-parts. To illustrate this functionality,
    the `chapter_2` example is structured into two components named `libraries` and
    `executables`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a specific component, an additional `--component` argument is needed
    along with the `cmake --``install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Installing a specific component only](img/B30947_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Installing a specific component only
  prefs: []
  type: TYPE_NORMAL
- en: Installing a specific configuration (for multiple-configuration generators only)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some of the generators support multiple configurations for the same build configuration
    (for example, Visual Studio). For that kind of generator, the `--install` option
    provides an additional `--config` argument to specify which configuration of binaries
    is intended to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, the command parameters used in the examples are pretty
    long and explicit. This is intentional. Explicitly specifying arguments allows
    us to get consistent results in each run, no matter which environment we’re running
    our commands in. For example, without the `-G` argument, CMake will default to
    the environment’s preferred build system generator, which may not be our intention.
    Our motto here is, *being explicit is almost always better than being implicit*.
    The former makes our intention clearer and naturally enables more future-proof
    and maintainable CMake code in CI systems/scripts as well.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the fundamentals of CMake command-line usage. Let’s continue
    to learn about the other available interface form – the graphical interface of
    CMake.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced configuration using CMake-GUI and ccmake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though they look different, most interfaces tend to do the same thing;
    thus, most of the things we have already covered in the previous section are also
    valid here. Remember, we are going to change our form of interaction, not the
    tool we’re actually interacting with.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further, check whether the `ccmake` command is available in
    your terminal. If not, verify your `PATH` variable is set correctly and check
    your installation as well.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use ccmake (CMake curses GUI)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ccmake` is a terminal-based `ncurses`.'
  prefs: []
  type: TYPE_NORMAL
- en: Since `ccmake` is not a part of the default CMake installation, it needs to
    be installed separately either over the package manager of your operating system
    or by downloading it from the CMake home page. Using `ccmake` is exactly the same
    as using CMake in a CLI, except it lacks the ability to invoke build and install
    steps. The main difference is that `ccmake` will show a terminal-based graphical
    interface for editing cached CMake variables interactively. This is a handy tool
    when you are experimenting with the settings. The status bar of `ccmake` will
    display a description for each setting and its possible values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using `ccmake`, use `ccmake` instead of `cmake` in the project configuration
    step. In our example, we will exactly replicate the CLI example we worked through
    previously in the *Configuring a project via the* *CLI* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows an example output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – ccmake main screen](img/B30947_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – ccmake main screen
  prefs: []
  type: TYPE_NORMAL
- en: After running the command, a terminal-based UI will appear. The initial page
    is the main page where CMake variables can be edited. `EMPTY CACHE` means no prior
    configuration has been made and the CMake cache file (`CmakeCache.txt`) is currently
    empty. To start editing variables, the project must be configured first. To configure,
    press the *C* key on the keyboard, as indicated in the `Keys:` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'After pressing the *C* key, the CMake configure step will be executed and the
    log output screen will be displayed with the configuration output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – ccmake log screen after configuration](img/B30947_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – ccmake log screen after configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'To close the log output screen and return to the main screen, press *E*. Upon
    return, you will notice that `EMPTY CACHE` is replaced with variable names in
    the `CMakeCache.txt` file. To select a variable, use the up and down arrow keys
    on your keyboard. The currently selected variable will be highlighted in white,
    as seen in the next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – ccmake main screen after configuration](img/B30947_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – ccmake main screen after configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the `CMAKE_BUILD_TYPE` variable is selected. On
    the right-hand side, the current value of the CMake variable is displayed. For
    `CMAKE_BUILD_TYPE`, it is empty right now. An asterisk next to the value of a
    variable means that the variable’s value has just changed with the prior configuration.
    You can either edit it by pressing the *Enter* key or delete it by pressing the
    *D* key on the keyboard. The following figure shows what the `ccmake` main screen
    looks like after changing the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – ccmake main screen after variable change](img/B30947_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – ccmake main screen after variable change
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set `CMAKE_BUILD_TYPE` to `Release` and configure again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – ccmake configuration output (Release)](img/B30947_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 – ccmake configuration output (Release)
  prefs: []
  type: TYPE_NORMAL
- en: We can observe that the build type is now set to `Release`. Return to the previous
    screen and save the changes by pressing the `g` (generate) button. The changes
    can be discarded by pressing the `q` (quit without generating) button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To edit other variables, such as `CMAKE_CXX_COMPILER` and `CMAKE_CXX_FLAGS`,
    advanced mode should be turned on. These variables are by default marked as advanced
    flags by calling the `mark_as_advanced()` CMake function; thus, they are hidden
    on graphical interfaces by default. On the main screen, press `t` to toggle to
    advanced mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – ccmake in advanced mode](img/B30947_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 – ccmake in advanced mode
  prefs: []
  type: TYPE_NORMAL
- en: 'After activating advanced mode, a whole new set of options becomes visible.
    You can observe and alter their values, just as normal variables. You may have
    noticed that a previously hidden variable named `CHAPTER2_BUILD_DRIVER_APPLICATION`
    is now present. This is a user-defined CMake variable. This variable is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `CHAPTER2_BUILD_DRIVER_APPLICATION` variable is defined as a cache variable
    with the Boolean type, having a default value of `true`. It is marked as advanced,
    which is why it was not present in non-advanced mode.
  prefs: []
  type: TYPE_NORMAL
- en: Using CMake via cmake-gui
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are the type of person who finds CLIs counter-intuitive, or you prefer
    the GUI over the CLI, CMake has a cross-platform GUI too. In contrast to `ccmake`,
    `cmake-gui` has more to offer, such as **Environment Editor** and **Regular**
    **Expression Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: The CMake GUI is not always part of the default CMake installation; depending
    on the operating system being used, it might need to be installed separately.
    Its main purpose is to allow a user to configure a CMake project. To launch `cmake-gui`,
    issue the `cmake-gui` command in your terminal. For Windows, it can also be located
    from the Start menu. If none of these methods work, go into your CMake installation
    path and it should be present in the `bin\` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are launching `cmake-gui` in a Windows environment and you intend to
    use the toolchain provided by Visual Studio, launch `cmake-gui` from the appropriate
    Native Tools Command Prompt of your IDE. If you have multiple versions of IDE,
    ensure that you are using the correct Native Tools Command Prompt. Otherwise,
    CMake may fail to discover the required tools, such as a compiler, or may find
    incorrect ones. Refer to [https://docs.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2019)
    for further information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the main window of the CMake GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – CMake GUI main window](img/B30947_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.27 – CMake GUI main window
  prefs: []
  type: TYPE_NORMAL
- en: 'The main screen of the CMake GUI essentially contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code path field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output path field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preset selection list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure** and **Generate** buttons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache variable list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the four essential things we are going to interact with. To start
    configuring a project, select the project’s root directory by clicking the **Browse
    Source…** button. Consequently, select an output directory for the project by
    clicking the **Browse Build…** button. This path will be the path for the generated
    output files by the selected generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the project contains CMake presets, the presets can be selected from the
    presets list. Any cache variables modified by the preset will then be shown in
    the cache variables list. In the following example, a preset that configures Clang
    13 as the compiler and **Debug** as the build type is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Selecting a preset from the CMake GUI](img/B30947_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.28 – Selecting a preset from the CMake GUI
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting source and output paths, click **Configure** to start configuring
    the selected project. The CMake GUI will let you choose details such as the generator
    to be used, platform selection (if supported by the generator), toolset, and compiler,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – CMake GUI generator selection screen](img/B30947_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.29 – CMake GUI generator selection screen
  prefs: []
  type: TYPE_NORMAL
- en: 'After filling in these details according to your environment, click **Finish**
    to continue. The CMake GUI will start configuring your project with the given
    details and report the output in the log section. Upon successful configuration,
    you should also see the cache variables in the cache variable list section as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30 – CMake GUI after configuration](img/B30947_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.30 – CMake GUI after configuration
  prefs: []
  type: TYPE_NORMAL
- en: If everything seems to be in order, press the `.sln` and `.cxxproj` along with
    other stuff. After generating the project, the `makefiles`), then generated files
    will be displayed instead. After that, you can use your IDE to build the project.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the generated project is just the generator’s artifact, and changes
    to the generated project files (`.sln`, `.cxxproj`) will not be saved and will
    be lost on the next generation. Don’t forget to re-generate project files when
    you make a change to the `CMakeLists.txt` files or edit a `CMakeCache.txt` file
    (either directly or indirectly). For the version-control aspect, you should treat
    generated project files as build artifacts and should not add them to version
    control. You can always obtain them from scratch by generating the project with
    an appropriate generator via CMake.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a project may require tweaking some cache variables, or you may
    decide to use a different build type, for example. To change any cache variables,
    click on the value of the desired cache variable; it should become editable. Depending
    on the variable type, a checkbox may be displayed instead of a string. If the
    desired variable is not visible on the list, it may be an *advanced* variable,
    which can only be visible when the `cmake-gui` in advanced mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.31 – cmake-gui in advanced mode](img/B30947_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.31 – cmake-gui in advanced mode
  prefs: []
  type: TYPE_NORMAL
- en: After tweaking any cache values, click **Configure** and then **Generate** to
    apply the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Another useful feature is the grouping feature, which allows the grouping of
    cache variables into their common prefix if there is one. Group names are determined
    by the first part of the variable name, up to the first underscore.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the most essential features of `cmake-gui`. Before moving on
    to other miscellaneous stuff, if you ever need to reload cache values or delete
    the cache and start from scratch, you can find the **Reload Cache** and **Delete
    Cache** menu items in the **File** menu.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CMake GUI comes with a handy environment variable editor that allows CRUD
    operations to be carried out on environment variables. To access it, simply click
    the **Environment…** button on the main screen. After clicking it, the **Environment
    Editor** window will pop up, as can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.32 – CMake GUI environment variable editor](img/B30947_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.32 – CMake GUI environment variable editor
  prefs: []
  type: TYPE_NORMAL
- en: The **Environment Editor** window contains a list of the environment variables
    present in the current environment. To edit an environment variable, double-click
    on the value field of the desired environment variable in the table. The window
    also allows adding and deleting information with the **Add Entry** and **Remove**
    **Entry** buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating regular expressions with CMake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have you ever wondered how a regular expression would be evaluated by CMake
    and what results it would give exactly? If so, you may have previously debugged
    it manually by printing out the regex match result variables with `message()`.
    What if I say there is a better way to do it? Let me introduce you to the **Regular
    Expression Explorer** tool of the CMake GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.33 – CMake GUI Regular Expression Explorer](img/B30947_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.33 – CMake GUI Regular Expression Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'This hidden gem allows you to debug regular expressions using CMake’s regex
    engine. It is located in the **Tools** menu with the name **Regular Expressions
    Explorer…**. Using it is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the expression into the **Regular** **Expression** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tool will check whether the expression is valid. If so, the **Valid** text
    on the screen will be green. It will turn red if CMake’s regex engine does not
    like the expression you’ve given.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter the test string into the **Input Text** field. The regular expression
    will be matched against this text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is any match, the **Match** word on the window will turn from red to
    green. The matching string will be printed in the **Complete** **Match** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On match, capture groups will be assigned to **Match 1**, **Match 2**, … **Match
    N**, respectively, if any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we’ve learned how to use CMake’s native graphical interfaces.
    We will continue learning about using CMake by taking a look into a selection
    of CMake’s IDE and editor integrations next.
  prefs: []
  type: TYPE_NORMAL
- en: Using CMake in Visual Studio, VSCode, and Qt Creator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being a common tool in software development, CMake has integrations with a wide
    variety of IDEs and source code editors. Using such integrations while using an
    IDE or editor is perhaps more convenient for the user. In this section, we will
    cover how CMake integrates with some popular IDEs and editors.
  prefs: []
  type: TYPE_NORMAL
- en: If you are expecting a guide about how to use an IDE or editor, this section
    is not going to be about that. The focus of this section is to investigate and
    learn about CMake integrations with such tools. This section assumes that you
    have existing experience with the IDE/editor you are going to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Visual Studio** was one of the latecomers to the party when supporting CMake.
    Unlike other popular IDEs, Visual Studio had no native support for CMake until
    the year 2017\. In that year, Microsoft decided to make a move and introduced
    built-in support for handling CMake projects, which was shipped with Visual Studio
    2017\. Since then, it has been a solid feature of the Visual Studio IDE.'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, obtain a copy of Visual Studio 2017 or later. For older versions
    of Visual Studio, the feature is completely absent. In our examples, we’ll be
    using Visual Studio 2022 Community Edition.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a CMake project from scratch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Visual Studio project creation feature is based on project templates. With
    Visual Studio 2017 and upward, project templates contain a CMake project template
    as well. We are going to learn how to use this template to create new CMake projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new CMake project with Visual Studio, click the **Create a new
    project** button on the welcome page. Alternatively, you can access it by clicking
    on **File** | **New** | **Project** on the main IDE window, or using the *Ctrl*
    + *Shift* + *N* (**New Project**) keyboard shortcut. The Visual Studio 2022 welcome
    screen looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.34 – Visual Studio 2022 welcome screen](img/B30947_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.34 – Visual Studio 2022 welcome screen
  prefs: []
  type: TYPE_NORMAL
- en: 'On the **Create a new project** screen, double-click on **CMake Project** in
    the project template list. You can filter project templates by using the search
    bar located at the top of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.35 – Visual Studio 2022 Create a new project screen](img/B30947_02_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.35 – Visual Studio 2022 Create a new project screen
  prefs: []
  type: TYPE_NORMAL
- en: After clicking `CMakeProject1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.36 – Visual Studio 2022 new project configuration screen](img/B30947_02_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.36 – Visual Studio 2022 new project configuration screen
  prefs: []
  type: TYPE_NORMAL
- en: 'After filling in the details, click `CMakeLists.txt` file, a C++ source file,
    and a C++ header file, named after the chosen project name. The newly created
    project’s layout can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.37 – First glance after creating a new CMake project with Visual
    Studio](img/B30947_02_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.37 – First glance after creating a new CMake project with Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: Opening an existing CMake project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To open an existing CMake project, go to `CMakeLists.txt` file of the project
    to be opened. The following figure shows what the **Open** menu looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.38 – CMake project Open menu](img/B30947_02_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.38 – CMake project Open menu
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how a CMake project can be configured and built.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and building a CMake project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build a CMake project in Visual Studio, go to `configure` step and generate
    the required build system files. After configuration, click **Build** | **Build
    All** to build the project. You can also trigger **Build All** by using the *F7*
    keyboard shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Visual Studio will automatically invoke `configure` whenever you save
    a `CMakeLists.txt` file, which is a part of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Executing common actions on a CMake target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visual Studio uses the *startup target* concept for target-requiring actions,
    such as build, debug, and launch. To set a CMake target as a startup target, use
    the **Select Startup Target** drop-down box located on the toolbar. Visual Studio
    will automatically populate this drop-down box with CMake targets on configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.39 – Startup target selection drop-down menu](img/B30947_02_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.39 – Startup target selection drop-down menu
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting a startup target, you can invoke actions such as debug, build,
    or launch just as always you do in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: To debug, first, click on **Debug** | **Startup Target**, then click **Debug**
    | **Start Debugging** or use the *F5* keyboard shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To start without debugging, click on **Start without debug** or use the *Ctrl*
    + *F5* keyboard shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To build, click on **Build**, click on **Build** | **Build <target>**, or use
    the *Ctrl* + *B*keyboard shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Button locations are shown in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.40 – Toolbar button locations](img/B30947_02_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.40 – Toolbar button locations
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ve covered the basics of the Visual Studio CMake integration.
    In the next section, we’ll continue to learn with another Microsoft product, VSCode.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VSCode is an open source code editor developed by Microsoft. It is not an IDE
    but can become powerful and have IDE-like features via extensions. The extensions
    market has a wide variety of additional content, from themes to language servers.
    You can find an extension for pretty much anything, which makes VSCode both powerful
    and liked by a wide audience. Unsurprisingly, VSCode has an official CMake extension
    too. This extension was originally developed by Colby Pike (also known as *vector-of-bool*)
    but it is now officially maintained by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to install the extension and perform
    basic CMake tasks using it.
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further, VSCode must already be installed in your environment.
    If not, visit [https://code.visualstudio.com/learn/get-started/basics](https://code.visualstudio.com/learn/get-started/basics)
    for details on downloading and installing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we will frequently access the Command Palette. It is strongly recommended
    to use it often to gain familiarity. For those asking *What the heck is the Command
    Palette?*, here is a screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.41 – VSCode Command Palette](img/B30947_02_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.41 – VSCode Command Palette
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, it is *that* thing. To be honest, I did not know it had a name until now.
    Shortcuts for accessing the Command Palette are *F1* and *Ctrl* + *Shift* + *P*.
    The Command Palette is the bread and butter of VSCode; it speeds up the VSCode
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing the extension is pretty straightforward. To install it by using
    a CLI, invoke the following command (replace `code` with `code-insiders` if you’re
    using the Insiders edition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can do the same in the VSCode GUI as well. Open VSCode and
    navigate to the `CMake Tools` into the extension search box and select **CMake
    Tools** from **Microsoft**. Be careful not to confuse it with the CMake extension.
    Press the **Install** button to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.42 – VSCode extensions marketplace](img/B30947_02_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.42 – VSCode extensions marketplace
  prefs: []
  type: TYPE_NORMAL
- en: After the installation is complete, the extension is ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Quick Start project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The VSCode CMake Tools extension offers a `cmake quick start`. Select **CMake:
    Quick Start** and press *Enter* on the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.43 – Command Palette – Locating CMake: Quick Start](img/B30947_02_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.43 – Command Palette – Locating CMake: Quick Start'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the extension will ask which kit to use. Select the one that is appropriate
    for your new project. Kits will be further discussed in the *Dealing with* *kits*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: After selecting a kit, you will be asked to input a project name. This will
    be the name of your top-level CMake project. Enter a name of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, a choice for example application code will be shown. In this choice,
    you will be asked to create an executable application project or a library project.
    Select one, and voilà! You’ve got yourself a working CMake project. Upon selection,
    the `CMakeLists.txt` and `main.cpp` files will be generated. The content of these
    files slightly varies between executable and library choices.
  prefs: []
  type: TYPE_NORMAL
- en: Opening an existing project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is nothing special about opening a CMake project in VSCode. Open the folder
    that contains the top-level `CMakeLists.txt` file of your project. The CMake Tools
    extension will automatically recognize this folder as a CMake project, and all
    CMake-related commands will become available on the VSCode Command Palette. Upon
    opening an existing project, you will be asked whether the project should be configured.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.44 – VSCode asking whether an existing project should be configured](img/B30947_02_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.44 – VSCode asking whether an existing project should be configured
  prefs: []
  type: TYPE_NORMAL
- en: If the project supports CMake presets, you will be automatically asked which
    preset to select. If the project does not support presets, then you will be asked
    to select a compiler toolchain, as explained in the *Dealing with kits* section
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.45 – Selecting a CMake preset in VSCode](img/B30947_02_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.45 – Selecting a CMake preset in VSCode
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we are ready to configure the project.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring, building, and cleaning a project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To configure a CMake project, select the **CMake: Configure** menu item from
    the Command Palette. To build the project, choose a build target by selecting
    the **CMake: Set Build Target** menu item from the Command Palette. This will
    let you choose what will be built when a build is invoked. Lastly, select **CMake:
    Build** to build the selected build target. To build a specific target without
    setting it as a build target, use the **CMake: Build Target** menu item.'
  prefs: []
  type: TYPE_NORMAL
- en: To clean build artifacts, use the `clean` target and remove any build artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To debug a target, choose a debug target by selecting the **CMake: Set Debug
    Target** menu item from the Command Palette. You’ll see the debuggable targets
    listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.46 – Debug target selection](img/B30947_02_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.46 – Debug target selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the target and select **CMake: Debug** (*Ctrl* + *F5*) from the Command
    Palette. The selected target will be started under the debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run the selected target without the debugger, select **CMake:
    Run Without Debugging** (*Shift* + *F5*) instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.47 – Executable Chapter1 target being debugged](img/B30947_02_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.47 – Executable Chapter1 target being debugged
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how we can provide arguments to the debugged
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to the debugged target
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The target you’re trying to debug might need command-line arguments. To pass
    command-line arguments to the debug target, open VSCode `settings.json` and append
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the `args` JSON array, you can place any number of arguments your target
    requires. These arguments will be passed to all future debug targets unconditionally.
    If you want to have fine-grained control over the arguments, it is better to define
    a `launch.json` file instead.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with kits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A kit in the CMake Tools extension represents a combination of tools that can
    be used to build the project; hence, the term *kit* is pretty much a synonym for
    the toolchain. Kits make it easier to work in a multi-compiler environment, allowing
    the user to choose which exact compiler to work with. Kits can be discovered automatically
    by the extension, read from toolchain files, or defined by the user manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see available kits for a project, select the **CMake: Select a Kit** menu
    item from the Command Palette (*F1* or *Ctrl* + *Shift* + *P*).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.48 – Kit selection list](img/B30947_02_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.48 – Kit selection list
  prefs: []
  type: TYPE_NORMAL
- en: The selected kit will be used to configure the CMake project, which means the
    tools that are defined in the kit will be used to compile the project. Kit selection
    will automatically trigger a CMake configuration.
  prefs: []
  type: TYPE_NORMAL
- en: By default, kits are scanned by the extension automatically. As a result, discovered
    toolchains are listed as options in the kit selection menu. If your toolchain
    is not displayed here, this means CMake Tools failed to discover it. In such a
    scenario, try to re-scan for kits first. If it is still missing, you can always
    define additional kits by adding them to the user-local `cmake-tools-kits.json
    (1)` file manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new kit is not usually necessary since the extension does a good job
    of discovering the toolchains. In the odd case of failure, there is a kit template
    here, which you can customize and append to the user-local `cmake-tools-kits.json`
    file to define a new kit. To open the user-local kits file, select the **CMake:
    Edit User-Local CMake Kits** menu item from the Command Palette:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In older versions of the CMake Tools extension, the `cmake-tools-kits.json`
    file may be named `cmake-kits.json` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if your kit name collides with an auto-generated name from
    CMake Tools, CMake Tools will override your entry on a scan. Thus, always give
    unique names to your kit definitions.
  prefs: []
  type: TYPE_NORMAL
- en: For further information about kits, refer to [https://github.com/microsoft/vscode-cmake-tools/blob/dev/gcampbell/KitCmakePath/docs/kits.md](https://github.com/microsoft/vscode-cmake-tools/blob/dev/gcampbell/KitCmakePath/docs/kits.md).
  prefs: []
  type: TYPE_NORMAL
- en: Qt Creator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Creator is another IDE that supports CMake projects. CMake support is decent,
    and the support comes out of the box without the need for any extra plugins. In
    this section, we are going to take a quick glance at Qt Creator’s CMake support.
  prefs: []
  type: TYPE_NORMAL
- en: As always, ensure that you have the IDE installed and configured properly in
    your environment first.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Creator version 5.0.1 is used in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Adding your CMake installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to use CMake with Qt Creator, the path to CMake must be defined in
    Qt Creator. To view and define CMake paths, navigate to **Edit** | **Preferences**
    | **CMake**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.49 – Qt Creator CMake path settings](img/B30947_02_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.49 – Qt Creator CMake path settings
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how CMake was installed, Qt Creator might be able to detect the
    correct version automatically. If this is not the case, it can be configured manually.
    To select which CMake executable to run in Qt Creator, select the desired entry
    and click the **Make** **Default** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new CMake executable, click **Add**. This will append a new entry
    into the **Manual** section and bring up a window to fill in the details for the
    new entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.50 – Adding a new CMake executable](img/B30947_02_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.50 – Adding a new CMake executable
  prefs: []
  type: TYPE_NORMAL
- en: 'The fields on this window are described in detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: A unique name to distinguish a new CMake executable entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmake`/`cmake.exe`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version**: The version of CMake (deduced by Qt Creator).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Help file**: An optional Qt Creator help file for the executable. This will
    allow CMake Help to appear upon pressing *F1*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMakeLists.txt` file changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After filling in the details, click **Apply** to add the new CMake executable
    into Qt Creator. Don’t forget to set it as default if you intend Qt Creator to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CMake project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a CMake project in Qt Creator follows the exact same steps as for regular
    project creation. Qt Creator does not treat CMake as an external build system
    generator. Instead, it lets its users choose between three build system generators,
    which are *qmake*, *cmake*, and *qbs*. Any type of Qt project can be started by
    any of these build system generators from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: To create a CMake project in Qt Creator, click **File** | **New File or Project...**
    (*Ctrl* + *N*) and choose the type of project from the **New File or Project**
    window. We’ll go with **Qt Widgets Application** for our example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.51 – Qt Creator New File or Project window](img/B30947_02_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.51 – Qt Creator New File or Project window
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon selection, the project creation wizard will appear. Fill in the details
    as desired. Select **CMake** in the **Define Build System** step, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.52 – Qt Creator new project wizard build system selection](img/B30947_02_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.52 – Qt Creator new project wizard build system selection
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! You’ve got yourself a Qt application with the CMake build system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a newly created CMake project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.53 – Generated CMake-based Qt widgets application project](img/B30947_02_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.53 – Generated CMake-based Qt widgets application project
  prefs: []
  type: TYPE_NORMAL
- en: Opening an existing CMake project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To open an existing CMake project with Qt Creator, go to the **File** | **Open
    File or Project...** (*Ctrl* + *O*) menu item. Select the top-level **CMakeLists.txt**
    file of the project, then click **Open**. Qt Creator will prompt you to choose
    a kit for your project. Select your preferred kits and then click on the **Configure
    Project** button. The project will be open and the CMake configure step will be
    run with the selected kits.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the *CMake Best Practices* project opened with Qt Creator is
    shown in this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.54 – A glance at the CMake Best Practices example project in Qt
    Creator](img/B30947_02_54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.54 – A glance at the CMake Best Practices example project in Qt Creator
  prefs: []
  type: TYPE_NORMAL
- en: After opening a CMake project for the first time, Qt Creator will create a file
    named `CMakeLists.txt.user` in the project’s root directory. This file contains
    Qt-specific details that cannot be stored in the `CMakeLists.txt` file, such as
    kit information and editor settings.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and building
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most scenarios (for example, project opening and saving changes to `CMakeLists.txt`),
    Qt Creator will run the CMake configuration automatically without having to run
    it manually. To run the CMake configuration manually, click on the **Build** |
    **Run CMake** menu item.
  prefs: []
  type: TYPE_NORMAL
- en: After configuration, press the hammer icon in the leftmost corner to build the
    project. Alternatively, the *Ctrl* + *B* keyboard shortcut can be used. This will
    build the whole CMake project. To build a specific CMake target only, use the
    locator next to the `cm` and then press the spacebar on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.55 – Qt Creator locator suggestions](img/B30947_02_55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.55 – Qt Creator locator suggestions
  prefs: []
  type: TYPE_NORMAL
- en: The locator will display CMake targets available to build. Select the desired
    target either by highlighting it and pressing *Enter* or clicking on it directly
    using the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.56 – Available CMake targets to build displayed on the locator](img/B30947_02_56.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.56 – Available CMake targets to build displayed on the locator
  prefs: []
  type: TYPE_NORMAL
- en: The selected CMake target (and, naturally, its dependencies) will be built.
  prefs: []
  type: TYPE_NORMAL
- en: Running and debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To run or debug a CMake target, press the kit selector button (the computer
    icon on the left navigation bar) and select the CMake target. Then, click either
    the run button (the *play icon* under the kit selector) to run or the debug button
    (the *play icon with a bug*) to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the kit selector menu content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.57 – Kit selector displaying CMake targets](img/B30947_02_57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.57 – Kit selector displaying CMake targets
  prefs: []
  type: TYPE_NORMAL
- en: Here, we conclude the basics of using CMake with Qt Creator. For more advanced
    topics, you can consult the resources given in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the fundamental methods of interacting with CMake,
    which are the CLI and the GUI. We also covered various IDE and editor integrations
    that are essential for a daily workflow. Using any kind of tool requires knowledge
    of how to interact with it. Learning ways of interaction allows us to better utilize
    the tool itself, and allows us to reach our goals easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be talking about the building blocks of a CMake
    project, which will enable you to create a well-structured, production-ready CMake
    project from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reinforce what you have learned in this chapter, try to answer the following
    questions. If you are having a hard time answering them, go back to the relevant
    section and re-visit the topic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Describe how a CMake project can be configured from the CLI into the build
    folder in the project’s root directory with each of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A different C++ compiler, located at `/usr/bin/clang++`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A Ninja generator
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `-Wall` compiler flag for the `Debug` build type
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Describe how the project previously configured in *Q1* can be built using CMake
    using the command line with each of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eight parallel jobs
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--trace` option in the Unix Makefiles generator
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe how the project previously built in *Q1* can be installed using CMake
    using the `directory/opt/project` command line?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming the `CMake-Best-Practices` project is already configured and built,
    which command must be invoked to only install the `ch2.libraries` component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an advanced variable in CMake?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmake –S . -B ./build -DCMAKE_CXX_COMPILER:STRING= "/``usr/bin/clang++ "`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmake –S . -B ./build -``G "Ninja"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmake –S . -B ./build -``DCMAKE_BUILD_FLAGS_DEBUG:STRING= "-Wall"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The project previously configured in Q1 can be built using CMake via the command
    line as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmake --build ./build --``parallel 8`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmake --build ./build --` `VERBOSE=1`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmake --install ./``build --prefix=/opt/project`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cmake --install ./build --``component ch2.libraries`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a CMake cache variable that is marked as *advanced* to make it hidden
    in GUIs via the `mark_as_advanced()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of guides and documents regarding the topics we have discussed
    in this chapter. You can find a non-exhaustive list of recommended material to
    read here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CMake CLI documentation: [https://cmake.org/cmake/help/latest/manual/cmake.1.html](https://cmake.org/cmake/help/latest/manual/cmake.1.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CMake projects in Visual Studio: [https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160](https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CMake support in Visual Studio: [https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/](https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CMake Tools extension for VSCode: [https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code/](https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VSCode CMake Tools documentation: [https://github.com/microsoft/vscode-cmake-tools/tree/main/docs#cmake-tools-for-visual-studio-code-documentation](https://github.com/microsoft/vscode-cmake-tools/tree/main/docs#cmake-tools-for-visual-studio-code-documentation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Debugging in VSCode: [https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt Creator locator guide: [https://doc.qt.io/qtcreator/creator-editor-locator.html](https://doc.qt.io/qtcreator/creator-editor-locator.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt Creator UI: [https://doc.qt.io/qtcreator/creator-quick-tour.html](https://doc.qt.io/qtcreator/creator-quick-tour.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
