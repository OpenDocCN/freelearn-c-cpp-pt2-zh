["```cpp\n# single-line comments start with a hash sign \"#\"\n# they can be placed on an empty line\nmessage(\"Hi\"); # or after a command like here.\n#[=[ \nbracket comment\n  #[[\n    nested bracket comment\n  #]]\n#]=]\n```", "```cpp\n##[=[ this is a single-line comment now\nno longer commented\n  #[[\n    still, a nested comment\n  #]]\n#]=] this is a single-line comment now\n```", "```cpp\ncommand(argument1 \"argument2\" argument3) # comment\n[[ \nmultiline comment ]] \n```", "```cpp\n[[ bracket \n]] command()\n```", "```cpp\nmessage([[multiline\nbracket\nargument\n]])\nmessage([==[\n  because we used two equal-signs \"==\"\n  following is still a single argument:\n  { \"petsArray\" = [[\"mouse\",\"cat\"],[\"dog\"]] }\n]==])\n```", "```cpp\n$ cmake -P chapter02/01-arguments/bracket.cmake\nmultiline\nbracket\nargument\n  because we used two equal-signs \"==\"\n  following is still a single argument:\n  { \"petsArray\" = [[\"mouse\",\"cat\"],[\"dog\"]] }\n```", "```cpp\nmessage(\"1\\. escape sequence: \\\" \\n in a quoted argument\")\nmessage(\"2\\. multi...\nline\")\nmessage(\"3\\. and a variable reference: ${CMAKE_VERSION}\")\n```", "```cpp\n$ cmake -P chapter02/01-arguments/quoted.cmake\n1\\. escape sequence: \"\n in a quoted argument\n2\\. multi...\nline\n3\\. and a variable reference: 3.16.3\n```", "```cpp\nmessage(a\\ single\\ argument)\nmessage(two arguments)\nmessage(three;separated;arguments)\nmessage(${CMAKE_VERSION})  # a variable reference\nmessage(()()())            # matching parentheses \n```", "```cpp\n$ cmake -P chapter02/01-arguments/unquoted.cmake\na single argument\ntwoarguments\nthreeseparatedarguments\n3.16.3\n()()() \n```", "```cpp\nset(MyString1 \"Text1\")\nset([[My String2]] \"Text2\")\nset(\"My String 3\" \"Text3\")\nmessage(${MyString1})\nmessage(${My\\ String2})\nmessage(${My\\ String\\ 3})\n```", "```cpp\nset(ENV{CXX} \"clang++\")\n```", "```cpp\nunset(ENV{VERBOSE})\n```", "```cpp\ncmake_minimum_required(VERSION 3.20.0)\nproject(Environment)\nmessage(\"generated with \" $ENV{myenv})\nadd_custom_target(EchoEnv ALL COMMAND echo \"myenv in build is\" $ENV{myenv})\n```", "```cpp\n#!/bin/bash\nexport myenv=first\necho myenv is now $myenv\ncmake -B build .\ncd build\nexport myenv=second\necho myenv is now $myenv\ncmake --build .\n```", "```cpp\n$ ./build.sh | grep -v \"\\-\\-\"\nmyenv is now first\ngenerated with first\nmyenv is now second\nScanning dependencies of target EchoEnv\nmyenv in build is first\nBuilt target EchoEnv\n```", "```cpp\nset(FOO \"BAR\" CACHE STRING \"interesting value\")\n```", "```cpp\nset(FOO \"BAR\" CACHE STRING \"interesting value\" FORCE)\n```", "```cpp\nset(MyVariable \"New Value\" PARENT_SCOPE)\nunset(MyVariable PARENT_SCOPE) \n```", "```cpp\nfunction(Inner)\n  message(\"  > Inner: ${V}\")\n  set(V 3)\n  message(\"  < Inner: ${V}\")\nendfunction()\nfunction(Outer)\n  message(\" > Outer: ${V}\")\n  set(V 2)\n  Inner()\n  message(\" < Outer: ${V}\")\nendfunction()\nset(V 1)\nmessage(\"> Global: ${V}\")\nOuter()\nmessage(\"< Global: ${V}\")\n```", "```cpp\n> Global: 1\n > Outer: 1\n  > Inner: 2\n  < Inner: 3\n < Outer: 2\n< Global: 1\n```", "```cpp\n> Global: 1\n > Outer: 1\n  > Inner: 2\n  < Inner: 2\n < Outer: 3\n< Global: 1\n```", "```cpp\nthe list is:alistoffiveelements\n```", "```cpp\nlist(LENGTH <list> <out-var>)\nlist(GET <list> <element index> [<index> ...] <out-var>)\nlist(JOIN <list> <glue> <out-var>)\nlist(SUBLIST <list> <begin> <length> <out-var>)\nlist(FIND <list> <value> <out-var>)\nlist(APPEND <list> [<element>...])\nlist(FILTER <list> {INCLUDE | EXCLUDE} REGEX <regex>)\nlist(INSERT <list> <index> [<element>...])\nlist(POP_BACK <list> [<out-var>...])\nlist(POP_FRONT <list> [<out-var>...])\nlist(PREPEND <list> [<element>...])\nlist(REMOVE_ITEM <list> <value>...)\nlist(REMOVE_AT <list> <index>...)\nlist(REMOVE_DUPLICATES <list>)\nlist(TRANSFORM <list> <ACTION> [...])\nlist(REVERSE <list>)\nlist(SORT <list> [...])\n```", "```cpp\nif(<condition>)\n  <commands>\nelseif(<condition>) # optional block, can be repeated\n  <commands>\nelse()              # optional block\n  <commands>\nendif()\n```", "```cpp\nset(VAR1 FALSE)\nset(VAR2 \"VAR1\")\nif(${VAR2})\n```", "```cpp\nset(FOO BAR)\nif(FOO)\n```", "```cpp\nif (FOO)\n```", "```cpp\nset(FOO \"FOO\")\nif (FOO)\n```", "```cpp\nif(DEFINED <name>)\nif(DEFINED CACHE{<name>})\nif(DEFINED ENV{<name>})\n```", "```cpp\nif (1 LESS 2) \n```", "```cpp\nif (1.3.4 VERSION_LESS_EQUAL 1.4)\n```", "```cpp\nif (\"A\" STREQUAL \"${B}\")\n```", "```cpp\nwhile(<condition>)\n  <commands>\nendwhile()\n```", "```cpp\nforeach(<loop_var> RANGE <max>)\n  <commands>\nendforeach()\n```", "```cpp\nforeach(<loop_var> RANGE <min> <max> [<step>])\n```", "```cpp\nforeach(<loop_variable> IN [LISTS <lists>] [ITEMS <items>])\n```", "```cpp\nset(MY_LIST 1 2 3)\nforeach(VAR IN LISTS MY_LIST ITEMS e f)\n  message(${VAR})\nendforeach()\n```", "```cpp\n1\n2\n3\ne\nf\n```", "```cpp\nforeach(VAR 1 2 3 e f)\n```", "```cpp\nforeach(<loop_var>... IN ZIP_LISTS <lists>)\n```", "```cpp\nset(L1 \"one;two;three;four\")\nset(L2 \"1;2;3;4;5\")\nforeach(num IN ZIP_LISTS L1 L2)\n    message(\"num_0=${num_0}, num_1=${num_1}\")\nendforeach()\n```", "```cpp\nforeach(word num IN ZIP_LISTS L1 L2)\n    message(\"word=${word}, num=${num}\")\n```", "```cpp\nmacro(<name> [<argument>…])\n  <commands>\nendmacro()\n```", "```cpp\nmacro(MyMacro myVar)\n  set(myVar \"new value\")\n  message(\"argument: ${myVar}\")\nendmacro()\nset(myVar \"first value\")\nmessage(\"myVar is now: ${myVar}\")\nMyMacro(\"called value\")\nmessage(\"myVar is now: ${myVar}\")\n```", "```cpp\n$ cmake -P chapter02/08-definitions/macro.cmake\nmyVar is now: first value\nargument: called value\nmyVar is now: new value\n```", "```cpp\nfunction(<name> [<argument>…])\n  <commands>\nendfunction()\n```", "```cpp\nfunction(MyFunction FirstArg)\n  message(\"Function: ${CMAKE_CURRENT_FUNCTION}\")\n  message(\"File: ${CMAKE_CURRENT_FUNCTION_LIST_FILE}\")\n  message(\"FirstArg: ${FirstArg}\")\n  set(FirstArg \"new value\")\n  message(\"FirstArg again: ${FirstArg}\")\n  message(\"ARGV0: ${ARGV0} ARGV1: ${ARGV1} ARGC: ${ARGC}\")\nendfunction()\nset(FirstArg \"first value\")\nMyFunction(\"Value1\" \"Value2\")\nmessage(\"FirstArg in global scope: ${FirstArg}\")\n```", "```cpp\nFunction: MyFunction\nFile: /home/root/chapter02/08-definitions/function.cmake\nFirstArg: Value1\nFirstArg again: new value\nARGV0: Value1 ARGV1: Value2 ARGC: 2\nFirstArg in global scope: first value\n```", "```cpp\ncmake_minimum_required(...)\nproject(Procedural)\nfunction(pull_shared_protobuf)\nfunction(setup_first_target)\nfunction(calculate_version)\nfunction(setup_second_target)\nfunction(setup_tests)\nsetup_first_target()\nsetup_second_target()\nsetup_tests()\n```", "```cpp\nmacro(main)\nfunction(...) # key steps\nfunction(...) # details\nfunction(...) # fine details\nmain()\n```", "```cpp\nmessage(FATAL_ERROR \"Stop processing\")\nmessage(\"Won't print this.\")\n```", "```cpp\nfunction(foo)\n  list(APPEND CMAKE_MESSAGE_CONTEXT \"foo\")\n  message(\"foo message\")\nendfunction()\nlist(APPEND CMAKE_MESSAGE_CONTEXT \"top\")\nmessage(\"Before `foo`\")\nfoo()\nmessage(\"After `foo`\")\n```", "```cpp\n$ cmake -P message_context.cmake --log-context\n[top] Before `foo`\n[top.foo] foo message\n[top] After `foo`\n```", "```cpp\nlist(APPEND CMAKE_MESSAGE_INDENT \"  \")\n```", "```cpp\nBefore `foo`\n  foo message\nAfter `foo`\n```", "```cpp\ninclude(<file|module> [OPTIONAL] [RESULT_VARIABLE <var>])\n```", "```cpp\ninclude(\"${CMAKE_CURRENT_LIST_DIR}/<filename>.cmake\") \n```", "```cpp\nfile(READ <filename> <out-var> [...])\nfile({WRITE | APPEND} <filename> <content>...)\nfile(DOWNLOAD <url> [<file>] [...])\n```", "```cpp\nexecute_process(COMMAND <cmd1> [<arguments>]… [OPTIONS])\n```"]