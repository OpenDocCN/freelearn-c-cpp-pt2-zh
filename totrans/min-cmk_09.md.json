["```cpp\nadd_library(${PROJECT_NAME} mc-gol in *Chapter 4*, *Creating Libraries for FetchContent*), and we won’t be providing install support for a shared library either (we’ll cover the differences later when looking at adding install support to our mc-gol library). We could have added STATIC at the outset, but making these gradual improvements over time is never a bad thing.\n\t\t\tNext, we include a CMake module we haven’t come across before called `GNUInstallDirs`.\n\n```", "```cpp\n\n\t\t\tThe `GNUInstallDirs` module provides variables for standard installation directories. Even though the name refers to `GNUInstallDirs` will give us a good standard directory structure on whatever platform we’re using. To learn more about `GNUInstallDirs`, please refer to [https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html](https://cmake.org/cmake/help/latest/module/GNUInstallDirs.html).\n\t\t\tThe next minor change is updating the `target_include_directories` command to handle providing the location of `.h` files for both the regular build (`BUILD_LOCAL_INTERFACE`) and when using the installed version of the library (`INSTALL_INTERFACE`):\n\n```", "```cpp\n$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR} variable here makes the relationship between the target_include_directories command and the later install command clearer.\n\t\t\tFor good measure, we add the `DEBUG_POSTFIX` property to our target to ensure both the `Debug` and `Release` versions of the library can be installed in the same directory without overwriting one another:\n\n```", "```cpp\ninstall(\n  TARGETS ${PROJECT_NAME}\n  EXPORT ${PROJECT_NAME}-config\n  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})\n```", "```cpp\nadd_library(dynamic-array STATIC)\n...\ninstall(\n  TARGETS dynamic-array\n  ...\n```", "```cpp\ncmake -B build -G \"Ninja Multi-Config\" -DCMAKE_INSTALL_PREFIX=install\ncmake --build build --target install\n```", "```cpp\n[2/3] Install the project...\n-- Install configuration: \"Debug\"\n-- Installing: .../array/install/lib/libmc-arrayd.a\n```", "```cpp\ninstall(\n  EXPORT ${PROJECT_NAME}-config\n  DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}\n  NAMESPACE minimal-cmake::)\n```", "```cpp\ninstall EXPORT given no DESTINATION!\n```", "```cpp\nDESTINATION ${CMAKE_INSTALL_LIBDIR}/EXPORT install command is NAMESPACE. This adds a prefix to the target to be exported to reduce the chance of naming collisions with other libraries. It’s also a standard convention to disambiguate imported targets from regular targets within a CMake project (something we touched on in *Chapter 6*, *Installing Dependencies* *and ExternalProject_Add*).\n\n```", "```cpp\n\n\t\t\tIf we now repeat the earlier commands (or just run `cmake --build build --target install` again), we’ll see the newly created config files be created and installed:\n\n```", "```cpp\n\n\t\t\tNote that we get two config files, one common one, and one specific to the configuration we built (this will be `Debug` by default). If we pass `--config Release` when building, a corresponding `mc-array-config-release.cmake` file is created:\n\n```", "```cpp\n\n\t\t\tThe preceding command will output:\n\n```", "```cpp\nadd_library(minimal-cmake::mc-array STATIC IMPORTED)\nset_target_properties(minimal-cmake::mc-array PROPERTIES\n  INTERFACE_INCLUDE_DIRECTORIES \"${_IMPORT_PREFIX}/include\")\n```", "```cpp\nset_property(TARGET minimal-cmake::mc-array APPEND PROPERTY IMPORTED_CONFIGURATIONS DEBUG)\nset_target_properties(minimal-cmake::mc-array PROPERTIES\n  IMPORTED_LINK_INTERFACE_LANGUAGES_DEBUG \"C\"\n  IMPORTED_LOCATION_DEBUG \"${_IMPORT_PREFIX}/lib/libmc-arrayd.a\")\n```", "```cpp\ninstall(DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/include/minimal-cmake/\n  DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/minimal-cmake)\n```", "```cpp\n...\n-- Installing: .../array/install/include/minimal-cmake\n-- Installing: .../array/install/include/minimal-cmake/array.h\n```", "```cpp\n.\n├── include\n│   └── minimal-cmake\n│       └── array.h\n└── lib\n     ├── cmake\n     │   └── mc-array\n     │       ├── mc-array-config-debug.cmake\n     │       ├── mc-array-config-release.cmake\n     │       └── mc-array-config.cmake\n     └── libmc-arrayd.a\n```", "```cpp\nfind_package(mc-array CONFIG REQUIRED)\n```", "```cpp\ntarget_link_libraries(\n  ${PROJECT_NAME} PRIVATE app folder’s CMakeLists.txt file. The last change needed is to update the CMAKE_PREFIX_PATH variable stored in the CMakePresets.json file to include the install path of where mc-array was installed. We could have installed the library to the same install folder as our previously installed dependencies, but installing it to a separate location and providing multiple paths can sometimes be useful. To provide more than one install path, separate each with a semicolon:\n\n```", "```cpp\ncmake --preset shared-ninja\ncmake --build build/shared-ninja --config Debug\n```", "```cpp\nCMake Error: install(EXPORT \"mc-gol-config\" ...) includes target \"mc-gol\" which requires target \"as-c-math\" that is not in any export set.\nCMake Error: install(EXPORT \"mc-gol-config\" ...) includes target \"mc-gol\" which requires target \"mc-array\" that is not in any export set.\nCMake Error: install(EXPORT \"mc-gol-config\" ...) includes target \"mc-gol\" which requires target \"mc-utils\" that is not in any export set.\n```", "```cpp\ntarget_link_libraries(\n  ${PROJECT_NAME} PRIVATE\n  $<BUILD_LOCAL_INTERFACE will ensure they are not treated as part of the export set and no further work is needed. This is the approach taken in ch7/part-3/lib/gol/CMakeLists.txt. The library is updated to search for mc-array in the installed location instead of using FetchContent and updates the target name to be game-of-life. The target_link_libraries command looks as follows:\n\n```", "```cpp\ninstall(\n  TARGETS game-of-life\n  EXPORT ${PROJECT_NAME}-config\n  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n  LIBRARY and RUNTIME along with the corresponding install locations will ensure the .dylib/.so files on macOS/Linux, and .dll files on Windows, are copied to the correct location when building and installing the library as shared.\n\t\t\tPublic nested dependencies\n\t\t\tWhen our nested dependencies are public, and are part of the interface of our library, there’s a little more work we need to do. To demonstrate this, we’re going to create a new library called `mc-draw`, found in `ch7/part-4/lib/draw`, that will provide some useful debug drawing functions using `bgfx` for reuse in other projects. It will also give us an example of how to export a nested dependency.\n\t\t\tThe overall shape of the `mc-draw` `CMakeLists.txt` file is remarkably like that of `mc-gol`. Both can be built as either static or shared libraries, and both now separate the project name from the target name (in the case of `mc-draw`, the target/library name is `draw`, with the `minimal-cmake` namespace).\n\t\t\tThe first significant difference is a subtle change to the `target_link_libraries` command:\n\n```", "```cpp\n\n\t\t\tWe’re keeping `minimal-cmake::dynamic-array` and `bgfx` as private dependencies (we could make `bgfx` public too, following the same approach as we’ll describe here, but as the windowed *Game of Life* application we’re building already depends on it, we don’t need to at this time). The main change is making `as-c-math` public. This makes the transitive dependency explicit, so any application using `minimal-cmake::draw` will also get `as-c-math` without also needing to depend on it separately.\n\t\t\tThe next change is an addition to the `install` `EXPORT` command:\n\n```", "```cpp\n@PACKAGE_INIT@\ninclude(CMakeFindDependencyMacro)\nfind_dependency(as-c-math)\ninclude(${CMAKE_CURRENT_LIST_DIR}/mc-draw-targets.cmake)\n```", "```cpp\nconfigure_package_config_file(\n  ${PROJECT_NAME}-config.cmake.in ${PROJECT_NAME}-config.cmake\n  INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME})\ninstall(FILES \n  \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config.cmake\"\n  INSTALL_DESTINATION. The following install command just copies the config file to the right location as part of the install process (notice how the values passed to INSTALL_DESTINATION and DESTINATION match).\n\t\t\t`configure_package_config_file` is used to ensure the config file is relocatable (it avoids the config file using hardcoded paths). For more information about `CMakePackageConfigHelpers`, please see [https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html).\n\t\t\tWith these changes made, we can now install our library and update our `CMakeLists.txt` application file. Looking at `ch7/part-4/app/CMakeLists.txt`, we can see we now have the obligatory `find_package` call to find the installed library:\n\n```", "```cpp\n\n\t\t\tThis is followed by an update to `target_link_libraries` to link against the new target (`minimal-cmake::draw`). The only other addition is to remember to copy the `.dll` file to the app build folder using the familiar `add_custom_command` and `copy_if_different` operation so our Windows builds work as expected.\n\t\t\tWhen trying to configure, if the `as-c-math` dependency cannot be found (this can be replicated by commenting out `find_dependency` in the `mc-draw-config.cmake.in` file before installing), then CMake will output an error resembling the following:\n\n```", "```cpp\ncmake --preset multi-ninja\ncmake --build build/multi-ninja\n./build/multi-ninja/Debug/minimal-cmake_game-of-life_window\n```", "```cpp\nfind_package(mc-draw CONFIG REQUIRED target_link_libraries:\n\n```", "```cpp\n\n\t\t\tTo understand how to achieve this, let’s review `ch7/part-5/lib/draw/CMakeLists.txt`. The key difference is instead of creating a single library with `add_library` called `draw`, we instead create three libraries called `vertex`, `line`, and `quad` in a nearly identical way (it’s completely possible to create utility functions to remove some of the boilerplate, but for simplicity, the examples omit this to avoid any potentially confusing abstractions).\n\t\t\tEach library (or component) has its own `<component>-config.cmake` file, just as we had with the top-level package. This is the mechanism by which we create the components we refer to in the `find_package` command. Fortunately, we don’t have to create each of these ourselves, but we do need to update our existing `mc-draw-config.cmake.in` file.\n\t\t\tBefore we do so, the first target we need to talk about is `vertex`. This is depended on by both `quad` and `line` (it appears in their `target_link_libraries` command). It is now responsible for exporting the `as-c-math` dependency, so, the approach we took before of creating a `*-targets.cmake` file goes to `vertex` (we now have a `vertex-config.cmake.in` file with the earlier logic, referring internally to `vertex-targets.cmake` instead of `mc-draw-targets.cmake`). The top-level package config template file, `mc-draw-config.cmake.in`, has been updated to the following:\n\n```", "```cpp\n\n\t\t\tAfter the required `@PACKAGE_INIT@` string, we provide a variable holding all the available components provided by the package. What follows is then a check to ensure the components requested from `find_package` are in our list of supported components. Say a user tries to request a component that does not exist, for example:\n\n```", "```cpp\n\n\t\t\tThen, they will see the following error message:\n\n```", "```cpp\n\n\t\t\tThis kind of error message is helpful to let a user know whether they’ve mistyped a component or are trying to use one that does not exist.\n\t\t\tOne other important detail to note is we do not need to have a component map directly to a single target as we’ve done so previously, with an individual component for `vertex`, `quad`, and `line`. In a larger package, we may choose to create a `geometry` component that contains all the geometric libraries in our application (e.g., `vertex`, `quad`, `line`, `circle`, etc.). For a simple example showing this technique, see [https://github.com/pr0g/cmake-examples/tree/main/examples/more/components](https://github.com/pr0g/cmake-examples/tree/main/examples/more/components), which shows grouping multiple libraries under a single component (two libraries, `hello` and `hey`, are made part of the `greetings` component, with `goodbye` made part of the `farewells` component).\n\t\t\tCOMPONENT versus COMPONENTS\n\t\t\tThere is unfortunately another keyword in CMake called `COMPONENT` that also happens to be part of the `install` command. It bears no relation to the `COMPONENTS` keyword that’s part of `find_package`. It is used to split install artifacts based on how the library/package is to be used (`Runtime` and `Development` are commonly suggested components to separate runtime and development functionality, for example). We haven’t covered the `COMPONENT` keyword in the context of the `install` command, but to learn more about how to use it, see the CMake install documentation ([https://cmake.org/cmake/help/latest/command/install.html](https://cmake.org/cmake/help/latest/command/install.html)) and CMake `install` command documentation ([https://cmake.org/cmake/help/latest/manual/cmake.1.html#install-a-project](https://cmake.org/cmake/help/latest/manual/cmake.1.html#install-a-project)) (`cmake --install <build> --``component <comp>`).\n\t\t\tWhether you decide to use components or not will very much depend on the type and size of the library you’re building. One example of a library that relies heavily on components is the `s3`, `ec2`, etc.).\n\t\t\tSupporting different versions of a library\n\t\t\tBack in [*Chapter 2*](B21152_02.xhtml#_idTextAnchor032), *Hello, CMake!*, when we introduced the `project` command, we touched on the `VERSION` parameter, but haven’t yet had the opportunity to see how to apply it, and why it’s useful. In this section, we’ll show how to add a version to our `mc-draw` library and how to request the correct version from our `find_package` command.\n\t\t\tVersioning for libraries is important for us to know what functionality and interface the library we’re currently using provides. Versioning is used to manage change, and, most importantly, handle API updates that may cause breaking changes. The software industry has largely adopted `<Major>.<Minor>.<Patch>` format (e.g., `1.45.23`) where numbers further to the left represent a more notable change. For a full introduction, see [https://semver.org/](https://semver.org/). Luckily, CMake supports this format, so it’s easy to integrate into our project.\n\t\t\tIf we look at `ch7/part-6/lib/draw/CMakeLists.txt`, we can see the changes needed to add version support by reviewing the differences between it and the corresponding file in `part-5`. The first change is adding `VERSION` to our project command:\n\n```", "```cpp\nwrite_basic_package_version_file( \n  \"${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}/${PROJECT_NAME}-config-version.cmake\"\n  VERSION ${PROJECT_VERSION}\n  COMPATIBILITY SameMajorVersion)\n```", "```cpp\nfind_package(mc-draw 3.5.4 (even if the major versions match), things will fail (the version requested must always be the same or lower than the installed library). By using SameMajorVersion, if we request 2.0, things will fail; the following is an example showing the expected output:\n\n```", "```cpp\nfind_path(\n  mc-gol_INCLUDE_DIR minimal-cmake-gol PATHS ${mc-gol_PATH}/include)\n```", "```cpp\nfind_library(\n  mc-gol_LIBRARY\n  NAMES game-of-life game-of-lifed\n  PATHS ${mc-gol_PATH}/lib)\n```", "```cpp\nif(mc-gol_FOUND AND NOT TARGET minimal-cmake::game-of-life)\n  add_library(minimal-cmake::game-of-life UNKNOWN IMPORTED)\n  set_target_properties(\n    minimal-cmake::game-of-life\n    PROPERTIES\n      IMPORTED_LOCATION \"${mc-gol_LIBRARY}\"\n      INTERFACE_INCLUDE_DIRECTORIES \"${mc-gol_INCLUDE_DIR}\")\nendif()\n```", "```cpp\n  ...\n  \"CMAKE_MODULE_PATH\": \"${sourceDir}/../cmake\",\n  \"mc-gol_PATH\": \"${sourceDir}/../lib/gol/install\"\n}\n```", "```cpp\nfind_package(mc-gol cmake --preset multi-config will display:\n\n```", "```cpp\n\n\t\t\tIt’s likely there won’t be a need to write find module files often, but they can be incredibly helpful in a pinch. It’s much preferable to have CMake do the arduous work of generating and installing config files for us, but if that isn’t a possibility, find modules provide a useful workaround.\n\t\t\tSummary\n\t\t\tThree cheers for making it to the end of this chapter. Installing is not an easy concept to master, and this is without a doubt the trickiest part of CMake we’ve covered so far. In this chapter, we covered adding simple install support to a static library and then differentiating our package name from the installed library. We then looked at adding install support to a library with private dependencies and how to handle public dependencies as well. Next, we covered splitting up a library or package into components and then looked at how to provide robust versioning support. We closed by reviewing how to create a find module file to integrate libraries built outside of the CMake ecosystem. We also continued to improve and refine our *Game of* *Life* application.\n\t\t\tIn the next chapter, we’re going to return to streamlining our setup yet again. Right now, we’re back to having to perform a lot of manual installs, which can become tedious, so we’ll look at improving this with the help of `ExternalProject_Add`. To improve things further, we’ll turn to what are often referred to as **super builds**, to neatly combine building our external dependencies and main project in one step. Finally, we’ll look at installing our application and will get things ready for packaging.\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```", "```cpp\n\n```"]