["```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-01 LANGUAGES NONE)\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\n```", "```cpp\nexecute_process(\n  COMMAND\n    ${PYTHON_EXECUTABLE} \"-c\" \"print('Hello, world!')\"\n  RESULT_VARIABLE _status\n  OUTPUT_VARIABLE _hello_world\n  ERROR_QUIET\n  OUTPUT_STRIP_TRAILING_WHITESPACE\n  )\n```", "```cpp\nmessage(STATUS \"RESULT_VARIABLE is: ${_status}\")\nmessage(STATUS \"OUTPUT_VARIABLE is: ${_hello_world}\")\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n\n-- Found PythonInterp: /usr/bin/python (found version \"3.6.5\") \n-- RESULT_VARIABLE is: 0\n-- OUTPUT_VARIABLE is: Hello, world!\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/user/cmake-cookbook/chapter-03/recipe-01/example/build\n```", "```cpp\nfind_package(PythonInterp 2.7)\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\n```", "```cpp\n$ cmake -D PYTHON_EXECUTABLE=/custom/location/python ..\n```", "```cpp\nmessage(STATUS \"RESULT_VARIABLE is: ${_status}\")\nmessage(STATUS \"OUTPUT_VARIABLE is: ${_hello_world}\")\n```", "```cpp\ninclude(CMakePrintHelpers)\ncmake_print_variables(_status _hello_world)\n```", "```cpp\n-- _status=\"0\" ; _hello_world=\"Hello, world!\"\n```", "```cpp\n#include <Python.h>\n\nint main(int argc, char *argv[]) {\n  Py_SetProgramName(argv[0]); /* optional but recommended */\n  Py_Initialize();\n  PyRun_SimpleString(\"from time import time,ctime\\n\"\n                     \"print 'Today is',ctime(time())\\n\");\n  Py_Finalize();\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-02 LANGUAGES C)\n```", "```cpp\nset(CMAKE_C_STANDARD 99)\nset(CMAKE_C_EXTENSIONS OFF)\nset(CMAKE_C_STANDARD_REQUIRED ON)\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\n```", "```cpp\nfind_package(PythonLibs ${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} EXACT REQUIRED)\n```", "```cpp\nadd_executable(hello-embedded-python hello-embedded-python.c)\n```", "```cpp\ntarget_include_directories(hello-embedded-python\n  PRIVATE\n    ${PYTHON_INCLUDE_DIRS}\n  )\n```", "```cpp\ntarget_link_libraries(hello-embedded-python\n  PRIVATE\n    ${PYTHON_LIBRARIES}\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n\n...\n-- Found PythonInterp: /usr/bin/python (found version \"3.6.5\") \n-- Found PythonLibs: /usr/lib/libpython3.6m.so (found suitable exact version \"3.6.5\")\n```", "```cpp\n$ cmake --build .\n$ ./hello-embedded-python\n\nToday is Thu Jun 7 22:26:02 2018\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\nfind_package(PythonLibs ${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} EXACT REQUIRED)\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\nfind_package(PythonLibs ${PYTHON_VERSION_STRING} EXACT REQUIRED)\n```", "```cpp\nfind_package(Python COMPONENTS Interpreter Development REQUIRED)\n```", "```cpp\n#include <Python.h>\n\nint main(int argc, char *argv[]) {\n  PyObject *pName, *pModule, *pDict, *pFunc;\n  PyObject *pArgs, *pValue;\n  int i;\n\n  if (argc < 3) {\n    fprintf(stderr, \"Usage: pure-embedding pythonfile funcname [args]\\n\");\n    return 1;\n  }\n\n  Py_Initialize();\n\n  PyRun_SimpleString(\"import sys\");\n  PyRun_SimpleString(\"sys.path.append(\\\".\\\")\");\n\n  pName = PyUnicode_DecodeFSDefault(argv[1]);\n  /* Error checking of pName left out */\n\n  pModule = PyImport_Import(pName);\n  Py_DECREF(pName);\n\n  if (pModule != NULL) {\n    pFunc = PyObject_GetAttrString(pModule, argv[2]);\n    /* pFunc is a new reference */\n\n    if (pFunc && PyCallable_Check(pFunc)) {\n      pArgs = PyTuple_New(argc - 3);\n      for (i = 0; i < argc - 3; ++i) {\n        pValue = PyLong_FromLong(atoi(argv[i + 3]));\n        if (!pValue) {\n          Py_DECREF(pArgs);\n          Py_DECREF(pModule);\n          fprintf(stderr, \"Cannot convert argument\\n\");\n          return 1;\n        }\n        /* pValue reference stolen here: */\n        PyTuple_SetItem(pArgs, i, pValue);\n      }\n      pValue = PyObject_CallObject(pFunc, pArgs);\n      Py_DECREF(pArgs);\n      if (pValue != NULL) {\n        printf(\"Result of call: %ld\\n\", PyLong_AsLong(pValue));\n        Py_DECREF(pValue);\n      } else {\n        Py_DECREF(pFunc);\n        Py_DECREF(pModule);\n        PyErr_Print();\n        fprintf(stderr, \"Call failed\\n\");\n        return 1;\n      }\n    } else {\n      if (PyErr_Occurred())\n        PyErr_Print();\n      fprintf(stderr, \"Cannot find function \\\"%s\\\"\\n\", argv[2]);\n    }\n    Py_XDECREF(pFunc);\n    Py_DECREF(pModule);\n  } else {\n    PyErr_Print();\n    fprintf(stderr, \"Failed to load \\\"%s\\\"\\n\", argv[1]);\n    return 1;\n  }\n  Py_Finalize();\n  return 0;\n}\n```", "```cpp\nimport numpy as np\n\ndef print_ones(rows, cols):\n\n    A = np.ones(shape=(rows, cols), dtype=float)\n    print(A)\n\n    # we return the number of elements to verify\n    # that the C++ code is able to receive return values\n    num_elements = rows*cols\n    return(num_elements)\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-03 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\nfind_package(PythonInterp REQUIRED)\nfind_package(PythonLibs ${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR} EXACT REQUIRED)\n```", "```cpp\nexecute_process(\n  COMMAND\n    ${PYTHON_EXECUTABLE} \"-c\" \"import re, numpy; print(re.compile('/__init__.py.*').sub('',numpy.__file__))\"\n  RESULT_VARIABLE _numpy_status\n  OUTPUT_VARIABLE _numpy_location\n  ERROR_QUIET\n  OUTPUT_STRIP_TRAILING_WHITESPACE\n  )\n```", "```cpp\nif(NOT _numpy_status)\n  set(NumPy ${_numpy_location} CACHE STRING \"Location of NumPy\")\nendif()\n```", "```cpp\nexecute_process(\n  COMMAND\n    ${PYTHON_EXECUTABLE} \"-c\" \"import numpy; print(numpy.__version__)\"\n  OUTPUT_VARIABLE _numpy_version\n  ERROR_QUIET\n  OUTPUT_STRIP_TRAILING_WHITESPACE\n  )\n```", "```cpp\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(NumPy\n  FOUND_VAR NumPy_FOUND\n  REQUIRED_VARS NumPy\n  VERSION_VAR _numpy_version\n  )\n```", "```cpp\nadd_executable(pure-embedding \"\")\n\ntarget_sources(pure-embedding\n  PRIVATE\n    Py${PYTHON_VERSION_MAJOR}-pure-embedding.cpp\n  )\n\ntarget_include_directories(pure-embedding\n  PRIVATE\n    ${PYTHON_INCLUDE_DIRS}\n  )\n\ntarget_link_libraries(pure-embedding\n  PRIVATE\n    ${PYTHON_LIBRARIES}\n  )\n```", "```cpp\nadd_custom_command(\n  OUTPUT\n    ${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py\n  COMMAND\n    ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_CURRENT_SOURCE_DIR}/use_numpy.py\n                                          ${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py\n  DEPENDS\n    ${CMAKE_CURRENT_SOURCE_DIR}/use_numpy.py\n  )\n\n# make sure building pure-embedding triggers the above custom command\ntarget_sources(pure-embedding\n  PRIVATE\n    ${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n\n-- ...\n-- Found PythonInterp: /usr/bin/python (found version \"3.6.5\") \n-- Found PythonLibs: /usr/lib/libpython3.6m.so (found suitable exact version \"3.6.5\") \n-- Found NumPy: /usr/lib/python3.6/site-packages/numpy (found version \"1.14.3\")\n\n$ cmake --build .\n$ ./pure-embedding use_numpy print_ones 2 3\n\n[[1\\. 1\\. 1.]\n [1\\. 1\\. 1.]]\nResult of call: 6\n```", "```cpp\ninclude(FindPackageHandleStandardArgs)\nfind_package_handle_standard_args(NumPy\n  FOUND_VAR NumPy_FOUND\n  REQUIRED_VARS NumPy\n  VERSION_VAR _numpy_version\n  )\n```", "```cpp\n-- Found NumPy: /usr/lib/python3.6/site-packages/numpy (found version \"1.14.3\")\n```", "```cpp\nadd_custom_command(\n  OUTPUT\n    ${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py\n  COMMAND\n    ${CMAKE_COMMAND} -E copy_if_different ${CMAKE_CURRENT_SOURCE_DIR}/use_numpy.py\n                                          ${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py\n  DEPENDS\n    ${CMAKE_CURRENT_SOURCE_DIR}/use_numpy.py\n  )\n\ntarget_sources(pure-embedding\n  PRIVATE\n    ${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py\n  )\n```", "```cpp\n#include \"CxxBLAS.hpp\"\n#include \"CxxLAPACK.hpp\"\n\n#include <iostream>\n#include <random>\n#include <vector>\n\nint main(int argc, char **argv) {\n  if (argc != 2) {\n    std::cout << \"Usage: ./linear-algebra dim\" << std::endl;\n    return EXIT_FAILURE;\n  }\n\n  // Generate a uniform distribution of real number between -1.0 and 1.0\n  std::random_device rd;\n  std::mt19937 mt(rd());\n  std::uniform_real_distribution<double> dist(-1.0, 1.0);\n\n  // Allocate matrices and right-hand side vector\n  int dim = std::atoi(argv[1]);\n  std::vector<double> A(dim * dim);\n  std::vector<double> b(dim);\n  std::vector<int> ipiv(dim);\n  // Fill matrix and RHS with random numbers between -1.0 and 1.0\n  for (int r = 0; r < dim; r++) {\n    for (int c = 0; c < dim; c++) {\n      A[r + c * dim] = dist(mt);\n    }\n    b[r] = dist(mt);\n  }\n\n  // Scale RHS vector by a random number between -1.0 and 1.0\n  C_DSCAL(dim, dist(mt), b.data(), 1);\n  std::cout << \"C_DSCAL done\" << std::endl;\n\n  // Save matrix and RHS\n  std::vector<double> A1(A);\n  std::vector<double> b1(b);\n\n  int info;\n  info = C_DGESV(dim, 1, A.data(), dim, ipiv.data(), b.data(), dim);\n  std::cout << \"C_DGESV done\" << std::endl;\n  std::cout << \"info is \" << info << std::endl;\n\n  double eps = 0.0;\n  for (int i = 0; i < dim; ++i) {\n    double sum = 0.0;\n    for (int j = 0; j < dim; ++j)\n      sum += A1[i + j * dim] * b[j];\n    eps += std::abs(b1[i] - sum);\n  }\n  std::cout << \"check is \" << eps << std::endl;\n\n  return 0;\n}\n```", "```cpp\n#pragma once\n\n#include \"fc_mangle.h\"\n\n#include <cstddef>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nextern void DSCAL(int *n, double *alpha, double *vec, int *inc);\n\n#ifdef __cplusplus\n}\n#endif\n\nvoid C_DSCAL(size_t length, double alpha, double *vec, int inc);\n```", "```cpp\n#include \"CxxBLAS.hpp\"\n\n#include <climits>\n\n// see http://www.netlib.no/netlib/blas/dscal.f\nvoid C_DSCAL(size_t length, double alpha, double *vec, int inc) {\n  int big_blocks = (int)(length / INT_MAX);\n  int small_size = (int)(length % INT_MAX);\n  for (int block = 0; block <= big_blocks; block++) {\n    double *vec_s = &vec[block * inc * (size_t)INT_MAX];\n    signed int length_s = (block == big_blocks) ? small_size : INT_MAX;\n    ::DSCAL(&length_s, &alpha, vec_s, &inc);\n  }\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-04 LANGUAGES CXX C Fortran)\n```", "```cpp\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\ninclude(FortranCInterface)\n\nFortranCInterface_VERIFY(CXX)\n\nFortranCInterface_HEADER(\n fc_mangle.h\n MACRO_NAMESPACE \"FC_\"\n SYMBOLS DSCAL DGESV\n )\n```", "```cpp\nfind_package(BLAS REQUIRED)\nfind_package(LAPACK REQUIRED)\n```", "```cpp\nadd_library(math \"\")\n\ntarget_sources(math\n  PRIVATE\n    CxxBLAS.cpp\n    CxxLAPACK.cpp\n  )\n\ntarget_include_directories(math\n  PUBLIC\n    ${CMAKE_CURRENT_SOURCE_DIR}\n    ${CMAKE_CURRENT_BINARY_DIR}\n  )\n\ntarget_link_libraries(math\n  PUBLIC\n    ${LAPACK_LIBRARIES}\n  )\n```", "```cpp\nadd_executable(linear-algebra \"\")\n\ntarget_sources(linear-algebra\n  PRIVATE\n    linear-algebra.cpp\n  )\n\ntarget_link_libraries(linear-algebra\n  PRIVATE\n    math\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n\n...\n-- Detecting Fortran/C Interface\n-- Detecting Fortran/C Interface - Found GLOBAL and MODULE mangling\n-- Verifying Fortran/C Compiler Compatibility\n-- Verifying Fortran/C Compiler Compatibility - Success\n...\n-- Found BLAS: /usr/lib/libblas.so \n...\n-- A library with LAPACK API found.\n...\n```", "```cpp\n$ cmake --build .\n$ ./linear-algebra 1000\n\nC_DSCAL done\nC_DGESV done\ninfo is 0\ncheck is 1.54284e-10\n```", "```cpp\n#include <iostream>\n#include <omp.h>\n#include <string>\n\nint main(int argc, char *argv[]) {\n  std::cout << \"number of available processors: \" << omp_get_num_procs()\n            << std::endl;\n  std::cout << \"number of threads: \" << omp_get_max_threads() << std::endl;\n\n  auto n = std::stol(argv[1]);\n  std::cout << \"we will form sum of numbers from 1 to \" << n << std::endl;\n\n  // start timer\n  auto t0 = omp_get_wtime();\n\n  auto s = 0LL;\n#pragma omp parallel for reduction(+ : s)\n  for (auto i = 1; i <= n; i++) {\n    s += i;\n  }\n\n  // stop timer\n  auto t1 = omp_get_wtime();\n\n  std::cout << \"sum: \" << s << std::endl;\n  std::cout << \"elapsed wall clock time: \" << t1 - t0 << \" seconds\" << std::endl;\n\n  return 0;\n}\n```", "```cpp\nprogram example\n\n  use omp_lib\n\n  implicit none\n\n  integer(8) :: i, n, s\n  character(len=32) :: arg\n  real(8) :: t0, t1\n\n  print *, \"number of available processors:\", omp_get_num_procs()\n  print *, \"number of threads:\", omp_get_max_threads()\n\n  call get_command_argument(1, arg)\n  read(arg , *) n\n\n  print *, \"we will form sum of numbers from 1 to\", n\n\n  ! start timer\n  t0 = omp_get_wtime()\n\n  s = 0\n!$omp parallel do reduction(+:s)\n  do i = 1, n\n    s = s + i\n  end do\n\n  ! stop timer\n  t1 = omp_get_wtime()\n\n  print *, \"sum:\", s\n  print *, \"elapsed wall clock time (seconds):\", t1 - t0\n\nend program\n```", "```cpp\ncmake_minimum_required(VERSION 3.9 FATAL_ERROR)\n\nproject(recipe-05 LANGUAGES CXX)\n```", "```cpp\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\nfind_package(OpenMP REQUIRED)\n```", "```cpp\nadd_executable(example example.cpp)\n\ntarget_link_libraries(example\n  PUBLIC\n    OpenMP::OpenMP_CXX\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build .\n```", "```cpp\n$ ./example 1000000000\n\nnumber of available processors: 4\nnumber of threads: 4\nwe will form sum of numbers from 1 to 1000000000\nsum: 500000000500000000\nelapsed wall clock time: 1.08343 seconds\n```", "```cpp\n$ env OMP_NUM_THREADS=1 ./example 1000000000\n\nnumber of available processors: 4\nnumber of threads: 1\nwe will form sum of numbers from 1 to 1000000000\nsum: 500000000500000000\nelapsed wall clock time: 2.96427 seconds\n```", "```cpp\ntarget_link_libraries(example\n  PUBLIC\n    OpenMP::OpenMP_CXX\n  )\n```", "```cpp\ninclude(CMakePrintHelpers)\ncmake_print_properties(\n  TARGETS\n    OpenMP::OpenMP_CXX\n  PROPERTIES\n    INTERFACE_COMPILE_OPTIONS\n    INTERFACE_INCLUDE_DIRECTORIES\n    INTERFACE_LINK_LIBRARIES\n  )\n```", "```cpp\nadd_executable(example example.cpp)\n\ntarget_compile_options(example\n  PUBLIC\n    ${OpenMP_CXX_FLAGS}\n  )\n\nset_target_properties(example\n  PROPERTIES\n    LINK_FLAGS ${OpenMP_CXX_FLAGS}\n  )\n```", "```cpp\n#include <iostream>\n\n#include <mpi.h>\n\nint main(int argc, char **argv) {\n  // Initialize the MPI environment. The two arguments to MPI Init are not\n  // currently used by MPI implementations, but are there in case future\n  // implementations might need the arguments.\n  MPI_Init(NULL, NULL);\n\n  // Get the number of processes\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n\n  // Get the rank of the process\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n  // Get the name of the processor\n  char processor_name[MPI_MAX_PROCESSOR_NAME];\n  int name_len;\n  MPI_Get_processor_name(processor_name, &name_len);\n\n  // Print off a hello world message\n  std::cout << \"Hello world from processor \" << processor_name << \", rank \"\n            << world_rank << \" out of \" << world_size << \" processors\" << std::endl;\n\n  // Finalize the MPI environment. No more MPI calls can be made after this\n  MPI_Finalize();\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.9 FATAL_ERROR)\n\nproject(recipe-06 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\nfind_package(MPI REQUIRED)\n```", "```cpp\nadd_executable(hello-mpi hello-mpi.cpp)\n\ntarget_link_libraries(hello-mpi\n  PUBLIC\n    MPI::MPI_CXX\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake -D CMAKE_CXX_COMPILER=mpicxx ..\n\n-- ...\n-- Found MPI_CXX: /usr/lib/openmpi/libmpi_cxx.so (found version \"3.1\") \n```", "```cpp\n-- Found MPI: TRUE (found version \"3.1\")\n-- ...\n\n$ cmake --build .\n```", "```cpp\n$ mpirun -np 2 ./hello-mpi\n\nHello world from processor larry, rank 1 out of 2 processors\nHello world from processor larry, rank 0 out of 2 processors\n```", "```cpp\n$ mpicxx --showme:compile\n\n-pthread\n```", "```cpp\n$ mpicxx --showme:link\n\n-pthread -Wl,-rpath -Wl,/usr/lib/openmpi -Wl,--enable-new-dtags -L/usr/lib/openmpi -lmpi_cxx -lmpi\n```", "```cpp\ntarget_link_libraries(hello-mpi\n  PUBLIC\n    MPI::MPI_CXX\n )\n```", "```cpp\nadd_executable(hello-mpi hello-mpi.c)\n\ntarget_compile_options(hello-mpi\n  PUBLIC\n    ${MPI_CXX_COMPILE_FLAGS}\n  )\n\ntarget_include_directories(hello-mpi\n  PUBLIC\n    ${MPI_CXX_INCLUDE_PATH}\n  )\n\ntarget_link_libraries(hello-mpi\n  PUBLIC\n    ${MPI_CXX_LIBRARIES}\n  )\n```", "```cpp\n#include <chrono>\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#include <Eigen/Dense>\n\nint main(int argc, char **argv) {\n  if (argc != 2) {\n    std::cout << \"Usage: ./linear-algebra dim\" << std::endl;\n    return EXIT_FAILURE;\n  }\n\n  std::chrono::time_point<std::chrono::system_clock> start, end;\n  std::chrono::duration<double> elapsed_seconds;\n  std::time_t end_time;\n\n  std::cout << \"Number of threads used by Eigen: \" << Eigen::nbThreads()\n            << std::endl;\n\n  // Allocate matrices and right-hand side vector\n  start = std::chrono::system_clock::now();\n  int dim = std::atoi(argv[1]);\n  Eigen::MatrixXd A = Eigen::MatrixXd::Random(dim, dim);\n  Eigen::VectorXd b = Eigen::VectorXd::Random(dim);\n  end = std::chrono::system_clock::now();\n\n  // Report times\n  elapsed_seconds = end - start;\n  end_time = std::chrono::system_clock::to_time_t(end);\n  std::cout << \"matrices allocated and initialized \"\n            << std::put_time(std::localtime(&end_time), \"%a %b %d %Y   \n%r\\n\")\n            << \"elapsed time: \" << elapsed_seconds.count() << \"s\\n\";\n\n  start = std::chrono::system_clock::now();\n  // Save matrix and RHS\n  Eigen::MatrixXd A1 = A;\n  Eigen::VectorXd b1 = b;\n  end = std::chrono::system_clock::now();\n  end_time = std::chrono::system_clock::to_time_t(end);\n  std::cout << \"Scaling done, A and b saved \"\n            << std::put_time(std::localtime(&end_time), \"%a %b %d %Y %r\\n\")\n            << \"elapsed time: \" << elapsed_seconds.count() << \"s\\n\";\n\n  start = std::chrono::system_clock::now();\n  Eigen::VectorXd x = A.lu().solve(b);\n  end = std::chrono::system_clock::now();\n\n  // Report times\n  elapsed_seconds = end - start;\n  end_time = std::chrono::system_clock::to_time_t(end);\n\n  double relative_error = (A * x - b).norm() / b.norm();\n\n  std::cout << \"Linear system solver done \"\n            << std::put_time(std::localtime(&end_time), \"%a %b %d %Y %r\\n\")\n            << \"elapsed time: \" << elapsed_seconds.count() << \"s\\n\";\n  std::cout << \"relative error is \" << relative_error << std::endl;\n\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.9 FATAL_ERROR)\n\nproject(recipe-07 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\nfind_package(OpenMP REQUIRED)\n```", "```cpp\nfind_package(Eigen3 3.3 REQUIRED CONFIG)\n```", "```cpp\nif(TARGET Eigen3::Eigen)\n  message(STATUS \"Eigen3 v${EIGEN3_VERSION_STRING} found in ${EIGEN3_INCLUDE_DIR}\")\nendif()\n```", "```cpp\nadd_executable(linear-algebra linear-algebra.cpp)\n```", "```cpp\nfind_package(BLAS)\n```", "```cpp\nif(BLAS_FOUND)\n  message(STATUS \"Eigen will use some subroutines from BLAS.\")\n  message(STATUS \"See: http://eigen.tuxfamily.org/dox-devel/TopicUsingBlasLapack.html\")\n  target_compile_definitions(linear-algebra\n    PRIVATE\n      EIGEN_USE_BLAS\n    )\n  target_link_libraries(linear-algebra\n    PUBLIC\n      ${BLAS_LIBRARIES}\n    )\nelse()\n  message(STATUS \"BLAS not found. Using Eigen own functions\")\nendif()\n```", "```cpp\ntarget_link_libraries(linear-algebra\n  PUBLIC\n    Eigen3::Eigen\n    OpenMP::OpenMP_CXX\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n\n-- ...\n-- Found OpenMP_CXX: -fopenmp (found version \"4.5\") \n-- Found OpenMP: TRUE (found version \"4.5\") \n-- Eigen3 v3.3.4 found in /usr/include/eigen3\n-- ...\n-- Found BLAS: /usr/lib/libblas.so \n-- Eigen will use some subroutines from BLAS.\n-- See: http://eigen.tuxfamily.org/dox-devel/TopicUsingBlasLapack.html\n```", "```cpp\n$ cmake --build .\n$ ./linear-algebra 1000\n\nNumber of threads used by Eigen: 4\nmatrices allocated and initialized Sun Jun 17 2018 11:04:20 AM\nelapsed time: 0.0492328s\nScaling done, A and b saved Sun Jun 17 2018 11:04:20 AM\nelapsed time: 0.0492328s\nLinear system solver done Sun Jun 17 2018 11:04:20 AM\nelapsed time: 0.483142s\nrelative error is 4.21946e-13\n```", "```cpp\n$ cmake -D CMAKE_PREFIX_PATH=<installation-prefix> ..\n```", "```cpp\n$ cmake -D Eigen3_DIR=<installation-prefix>/share/eigen3/cmake/\n```", "```cpp\n#include <iostream>\n\n#include <boost/filesystem.hpp>\n\nusing namespace std;\nusing namespace boost::filesystem;\n\nconst char *say_what(bool b) { return b ? \"true\" : \"false\"; }\n\nint main(int argc, char *argv[]) {\n  if (argc < 2) {\n    cout\n        << \"Usage: path_info path-element [path-element...]\\n\"\n           \"Composes a path via operator/= from one or more path-element arguments\\n\"\n           \"Example: path_info foo/bar baz\\n\"\n#ifdef BOOST_POSIX_API\n           \" would report info about the composed path foo/bar/baz\\n\";\n#else // BOOST_WINDOWS_API\n           \" would report info about the composed path foo/bar\\\\baz\\n\";\n#endif\n    return 1;\n  }\n\n  path p;\n  for (; argc > 1; --argc, ++argv)\n    p /= argv[1]; // compose path p from the command line arguments\n\n  cout << \"\\ncomposed path:\\n\";\n  cout << \" operator<<()---------: \" << p << \"\\n\";\n  cout << \" make_preferred()-----: \" << p.make_preferred() << \"\\n\";\n\n  cout << \"\\nelements:\\n\";\n  for (auto element : p)\n    cout << \" \" << element << '\\n';\n\n  cout << \"\\nobservers, native format:\" << endl;\n#ifdef BOOST_POSIX_API\n  cout << \" native()-------------: \" << p.native() << endl;\n  cout << \" c_str()--------------: \" << p.c_str() << endl;\n#else // BOOST_WINDOWS_API\n  wcout << L\" native()-------------: \" << p.native() << endl;\n  wcout << L\" c_str()--------------: \" << p.c_str() << endl;\n#endif\n  cout << \" string()-------------: \" << p.string() << endl;\n  wcout << L\" wstring()------------: \" << p.wstring() << endl;\n\n  cout << \"\\nobservers, generic format:\\n\";\n  cout << \" generic_string()-----: \" << p.generic_string() << endl;\n  wcout << L\" generic_wstring()----: \" << p.generic_wstring() << endl;\n\n  cout << \"\\ndecomposition:\\n\";\n  cout << \" root_name()----------: \" << p.root_name() << '\\n';\n  cout << \" root_directory()-----: \" << p.root_directory() << '\\n';\n  cout << \" root_path()----------: \" << p.root_path() << '\\n';\n  cout << \" relative_path()------: \" << p.relative_path() << '\\n';\n  cout << \" parent_path()--------: \" << p.parent_path() << '\\n';\n  cout << \" filename()-----------: \" << p.filename() << '\\n';\n  cout << \" stem()---------------: \" << p.stem() << '\\n';\n  cout << \" extension()----------: \" << p.extension() << '\\n';\n\n  cout << \"\\nquery:\\n\";\n  cout << \" empty()--------------: \" << say_what(p.empty()) << '\\n';\n  cout << \" is_absolute()--------: \" << say_what(p.is_absolute()) << \n  '\\n';\n  cout << \" has_root_name()------: \" << say_what(p.has_root_name()) << \n  '\\n';\n  cout << \" has_root_directory()-: \" << say_what(p.has_root_directory()) << '\\n';\n  cout << \" has_root_path()------: \" << say_what(p.has_root_path()) << \n  '\\n';\n  cout << \" has_relative_path()--: \" << say_what(p.has_relative_path()) << '\\n';\n  cout << \" has_parent_path()----: \" << say_what(p.has_parent_path()) << '\\n';\n  cout << \" has_filename()-------: \" << say_what(p.has_filename()) << \n  '\\n';\n  cout << \" has_stem()-----------: \" << say_what(p.has_stem()) << '\\n';\n  cout << \" has_extension()------: \" << say_what(p.has_extension()) <<  \n  '\\n';\n\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-08 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\nfind_package(Boost 1.54 REQUIRED COMPONENTS filesystem)\n```", "```cpp\nadd_executable(path-info path-info.cpp)\n```", "```cpp\ntarget_link_libraries(path-info\n  PUBLIC\n    Boost::filesystem\n  )\n```", "```cpp\n$ cmake -D BOOST_ROOT=/custom/boost/\n```", "```cpp\n$ cmake -D BOOST_INCLUDEDIR=/custom/boost/include -D BOOST_LIBRARYDIR=/custom/boost/lib\n```", "```cpp\ncmake_minimum_required(VERSION 3.6 FATAL_ERROR)\n\nproject(recipe-09 LANGUAGES C)\n\nset(CMAKE_C_STANDARD 99)\nset(CMAKE_C_EXTENSIONS OFF)\nset(CMAKE_C_STANDARD_REQUIRED ON)\n```", "```cpp\nfind_package(PkgConfig REQUIRED QUIET)\n```", "```cpp\npkg_search_module(\n  ZeroMQ\n  REQUIRED\n    libzeromq libzmq lib0mq\n  IMPORTED_TARGET\n  )\n```", "```cpp\nif(TARGET PkgConfig::ZeroMQ)\n  message(STATUS \"Found ZeroMQ\")\nendif()\n```", "```cpp\nadd_executable(hwserver hwserver.c)\n\ntarget_link_libraries(hwserver PkgConfig::ZeroMQ)\n\nadd_executable(hwclient hwclient.c)\n\ntarget_link_libraries(hwclient PkgConfig::ZeroMQ)\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build .\n```", "```cpp\nCurrent 0MQ version is 4.2.2\n```", "```cpp\nConnecting to hello world server…\nSending Hello 0…\nReceived World 0\nSending Hello 1…\nReceived World 1\nSending Hello 2…\n...\n```", "```cpp\npkg_search_module(\n  ZeroMQ\n  REQUIRED\n    libzeromq libzmq lib0mq\n  IMPORTED_TARGET\n  )\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-10 LANGUAGES C)\n\nset(CMAKE_C_STANDARD 99)\nset(CMAKE_C_EXTENSIONS OFF)\nset(CMAKE_C_STANDARD_REQUIRED ON)\n```", "```cpp\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR})\n```", "```cpp\nfind_package(ZeroMQ REQUIRED)\n```", "```cpp\nadd_executable(hwserver hwserver.c)\n\ntarget_include_directories(hwserver\n  PRIVATE\n    ${ZeroMQ_INCLUDE_DIRS}\n  )\n\ntarget_link_libraries(hwserver\n  PRIVATE\n    ${ZeroMQ_LIBRARIES}\n  )\n```", "```cpp\nadd_executable(hwclient hwclient.c)\n\ntarget_include_directories(hwclient\n  PRIVATE\n    ${ZeroMQ_INCLUDE_DIRS}\n  )\n\ntarget_link_libraries(hwclient\n  PRIVATE\n    ${ZeroMQ_LIBRARIES}\n  )\n```", "```cpp\nif(NOT ZeroMQ_ROOT)\n  set(ZeroMQ_ROOT \"$ENV{ZeroMQ_ROOT}\")\nendif()\n```", "```cpp\nif(NOT ZeroMQ_ROOT)\n  find_path(_ZeroMQ_ROOT NAMES include/zmq.h)\nelse()\n  set(_ZeroMQ_ROOT \"${ZeroMQ_ROOT}\")\nendif()\n\nfind_path(ZeroMQ_INCLUDE_DIRS NAMES zmq.h HINTS ${_ZeroMQ_ROOT}/include)\n```", "```cpp\nset(_ZeroMQ_H ${ZeroMQ_INCLUDE_DIRS}/zmq.h)\n\nfunction(_zmqver_EXTRACT _ZeroMQ_VER_COMPONENT _ZeroMQ_VER_OUTPUT)\n  set(CMAKE_MATCH_1 \"0\")\n  set(_ZeroMQ_expr \"^[ \\\\t]*#define[ \\\\t]+${_ZeroMQ_VER_COMPONENT}[ \\\\t]+([0-9]+)$\")\n  file(STRINGS \"${_ZeroMQ_H}\" _ZeroMQ_ver REGEX \"${_ZeroMQ_expr}\")\n  string(REGEX MATCH \"${_ZeroMQ_expr}\" ZeroMQ_ver \"${_ZeroMQ_ver}\")\n  set(${_ZeroMQ_VER_OUTPUT} \"${CMAKE_MATCH_1}\" PARENT_SCOPE)\nendfunction()\n\n_zmqver_EXTRACT(\"ZMQ_VERSION_MAJOR\" ZeroMQ_VERSION_MAJOR)\n_zmqver_EXTRACT(\"ZMQ_VERSION_MINOR\" ZeroMQ_VERSION_MINOR)\n_zmqver_EXTRACT(\"ZMQ_VERSION_PATCH\" ZeroMQ_VERSION_PATCH)\n```", "```cpp\nif(ZeroMQ_FIND_VERSION_COUNT GREATER 2)\n  set(ZeroMQ_VERSION \"${ZeroMQ_VERSION_MAJOR}.${ZeroMQ_VERSION_MINOR}.${ZeroMQ_VERSION_PATCH}\")\nelse()\n  set(ZeroMQ_VERSION \"${ZeroMQ_VERSION_MAJOR}.${ZeroMQ_VERSION_MINOR}\")\nendif()\n```", "```cpp\nif(NOT ${CMAKE_C_PLATFORM_ID} STREQUAL \"Windows\")\n  find_library(ZeroMQ_LIBRARIES \n      NAMES \n        zmq \n      HINTS \n        ${_ZeroMQ_ROOT}/lib\n        ${_ZeroMQ_ROOT}/lib/x86_64-linux-gnu\n      )\nelse()\n  find_library(ZeroMQ_LIBRARIES\n      NAMES\n        libzmq\n        \"libzmq-mt-${ZeroMQ_VERSION_MAJOR}_${ZeroMQ_VERSION_MINOR}_${ZeroMQ_VERSION_PATCH}\"\n        \"libzmq-${CMAKE_VS_PLATFORM_TOOLSET}-mt-${ZeroMQ_VERSION_MAJOR}_${ZeroMQ_VERSION_MINOR}_${ZeroMQ_VERSION_PATCH}\"\n        libzmq_d\n        \"libzmq-mt-gd-${ZeroMQ_VERSION_MAJOR}_${ZeroMQ_VERSION_MINOR}_${ZeroMQ_VERSION_PATCH}\"\n        \"libzmq-${CMAKE_VS_PLATFORM_TOOLSET}-mt-gd-${ZeroMQ_VERSION_MAJOR}_${ZeroMQ_VERSION_MINOR}_${ZeroMQ_VERSION_PATCH}\"\n      HINTS\n        ${_ZeroMQ_ROOT}/lib\n      )\nendif()\n```", "```cpp\ninclude(FindPackageHandleStandardArgs)\n\nfind_package_handle_standard_args(ZeroMQ\n  FOUND_VAR\n    ZeroMQ_FOUND\n  REQUIRED_VARS\n```", "```cpp\n    ZeroMQ_INCLUDE_DIRS\n    ZeroMQ_LIBRARIES\n  VERSION_VAR\n    ZeroMQ_VERSION\n  )\n```", "```cpp\nfind_path(<VAR> NAMES name PATHS paths)\n```"]