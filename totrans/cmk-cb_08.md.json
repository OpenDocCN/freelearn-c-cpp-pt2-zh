["```cpp\n.\n├── CMakeLists.txt\n├── src\n│   ├── CMakeLists.txt\n│   ├── main.cpp\n│   ├── sum_integers.cpp\n│   └── sum_integers.hpp\n└── tests\n    ├── catch.hpp\n    ├── CMakeLists.txt\n    └── test.cpp\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-01 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\ninclude(GNUInstallDirs)\n\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\n```", "```cpp\nadd_subdirectory(src)\n\nenable_testing()\nadd_subdirectory(tests)\n```", "```cpp\nset(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)\n\nadd_library(sum_integers sum_integers.cpp)\n\nadd_executable(sum_up main.cpp)\n\ntarget_link_libraries(sum_up sum_integers)\n```", "```cpp\nadd_executable(cpp_test test.cpp)\ntarget_link_libraries(cpp_test sum_integers)\n```", "```cpp\nmacro(add_catch_test _name _cost)\n  math(EXPR num_macro_calls \"${num_macro_calls} + 1\")\n  message(STATUS \"add_catch_test called with ${ARGC} arguments: ${ARGV}\")\n\n  set(_argn \"${ARGN}\")\n  if(_argn)\n    message(STATUS \"oops - macro received argument(s) we did not expect: ${ARGN}\")\n  endif()\n\n  add_test(\n    NAME\n      ${_name}\n    COMMAND\n      $<TARGET_FILE:cpp_test>\n      [${_name}] --success --out\n      ${PROJECT_BINARY_DIR}/tests/${_name}.log --durations yes\n    WORKING_DIRECTORY\n      ${CMAKE_CURRENT_BINARY_DIR}\n    )\n\n  set_tests_properties(\n    ${_name}\n    PROPERTIES\n      COST ${_cost}\n    )\nendmacro()\n```", "```cpp\nset(num_macro_calls 0)\n\nadd_catch_test(short 1.5)\nadd_catch_test(long 2.5 extra_argument)\n\nmessage(STATUS \"in total there were ${num_macro_calls} calls to add_catch_test\")\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n\n-- ...\n-- add_catch_test called with 2 arguments: short;1.5\n-- add_catch_test called with 3 arguments: long;2.5;extra_argument\n-- oops - macro received argument(s) we did not expect: extra_argument\n-- in total there were 2 calls to add_catch_test\n-- ...\n```", "```cpp\n$ cmake --build .\n$ ctest\n```", "```cpp\n    Start 2: long\n1/2 Test #2: long ............................. Passed 0.00 sec\n    Start 1: short\n2/2 Test #1: short ............................ Passed 0.00 sec\n\n100% tests passed, 0 tests failed out of 2\n```", "```cpp\n-- add_catch_test called with 2 arguments: short;1.5\n-- add_catch_test called with 3 arguments: long;2.5;extra_argument\n```", "```cpp\nadd_catch_test(long 2.5 extra_argument)\n```", "```cpp\nset(_argn \"${ARGN}\")\nif(_argn)\n  message(STATUS \"oops - macro received argument(s) we did not expect: ${ARGN}\")\nendif()\n```", "```cpp\nfunction(add_catch_test _name _cost)\n  ...\nendfunction()\n```", "```cpp\nset(variable_visible_outside \"some value\" PARENT_SCOPE)\n```", "```cpp\nset(num_macro_calls 0)\n\nadd_catch_test(short 1.5)\nadd_catch_test(long 2.5 extra_argument)\n\nmessage(STATUS \"in total there were ${num_macro_calls} calls to add_catch_test\")\n```", "```cpp\nmath(EXPR num_macro_calls \"${num_macro_calls} + 1\")\n```", "```cpp\n-- in total there were 2 calls to add_catch_test\n```", "```cpp\nset(CMAKE_INCLUDE_CURRENT_DIR_IN_INTERFACE ON)\n```", "```cpp\n.\n├── cmake\n│   └── colors.cmake\n└── CMakeLists.txt\n```", "```cpp\n# colorize CMake output\n\n# code adapted from stackoverflow: http://stackoverflow.com/a/19578320\n# from post authored by https://stackoverflow.com/users/2556117/fraser\n\nmacro(define_colors)\n  if(WIN32)\n    # has no effect on WIN32\n    set(ColourReset \"\")\n    set(ColourBold \"\")\n    set(Red \"\")\n    set(Green \"\")\n    set(Yellow \"\")\n    set(Blue \"\")\n    set(Magenta \"\")\n    set(Cyan \"\")\n    set(White \"\")\n    set(BoldRed \"\")\n    set(BoldGreen \"\")\n    set(BoldYellow \"\")\n    set(BoldBlue \"\")\n    set(BoldMagenta \"\")\n    set(BoldCyan \"\")\n    set(BoldWhite \"\")\n  else()\n    string(ASCII 27 Esc)\n    set(ColourReset \"${Esc}[m\")\n    set(ColourBold \"${Esc}[1m\")\n```", "```cpp\n    set(Red \"${Esc}[31m\")\n    set(Green \"${Esc}[32m\")\n    set(Yellow \"${Esc}[33m\")\n    set(Blue \"${Esc}[34m\")\n    set(Magenta \"${Esc}[35m\")\n    set(Cyan \"${Esc}[36m\")\n    set(White \"${Esc}[37m\")\n    set(BoldRed \"${Esc}[1;31m\")\n    set(BoldGreen \"${Esc}[1;32m\")\n    set(BoldYellow \"${Esc}[1;33m\")\n    set(BoldBlue \"${Esc}[1;34m\")\n    set(BoldMagenta \"${Esc}[1;35m\")\n    set(BoldCyan \"${Esc}[1;36m\")\n    set(BoldWhite \"${Esc}[1;37m\")\n  endif()\nendmacro()\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-02 LANGUAGES NONE)\n```", "```cpp\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n```", "```cpp\ninclude(colors)\ndefine_colors()\n```", "```cpp\nmessage(STATUS \"This is a normal message\")\nmessage(STATUS \"${Red}This is a red${ColourReset}\")\nmessage(STATUS \"${BoldRed}This is a bold red${ColourReset}\")\nmessage(STATUS \"${Green}This is a green${ColourReset}\")\nmessage(STATUS \"${BoldMagenta}This is bold${ColourReset}\")\n```", "```cpp\nproject(recipe-02 LANGUAGES NONE)\n```", "```cpp\ninclude(colors)\ndefine_colors()\n```", "```cpp\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n```", "```cpp\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n\ninclude(colors)\n```", "```cpp\ninclude(cmake/colors.cmake)\n```", "```cpp\ninclude(CheckCCompilerFlag)\ninclude(CheckCXXCompilerFlag)\ninclude(CheckFortranCompilerFlag)\nfunction(set_compiler_flag _result _lang)\n  # build a list of flags from the arguments\n  set(_list_of_flags)\n```", "```cpp\n  # also figure out whether the function\n  # is required to find a flag\n  set(_flag_is_required FALSE)\n  foreach(_arg IN ITEMS ${ARGN})\n    string(TOUPPER \"${_arg}\" _arg_uppercase)\n    if(_arg_uppercase STREQUAL \"REQUIRED\")\n      set(_flag_is_required TRUE)\n    else()\n      list(APPEND _list_of_flags \"${_arg}\")\n    endif()\n  endforeach()\n\n  set(_flag_found FALSE)\n  # loop over all flags, try to find the first which works\n  foreach(flag IN ITEMS ${_list_of_flags})\n\n    unset(_flag_works CACHE)\n    if(_lang STREQUAL \"C\")\n      check_c_compiler_flag(\"${flag}\" _flag_works)\n    elseif(_lang STREQUAL \"CXX\")\n      check_cxx_compiler_flag(\"${flag}\" _flag_works)\n    elseif(_lang STREQUAL \"Fortran\")\n      check_Fortran_compiler_flag(\"${flag}\" _flag_works)\n    else()\n      message(FATAL_ERROR \"Unknown language in set_compiler_flag: ${_lang}\")\n    endif()\n\n    # if the flag works, use it, and exit\n    # otherwise try next flag\n    if(_flag_works)\n      set(${_result} \"${flag}\" PARENT_SCOPE)\n      set(_flag_found TRUE)\n      break()\n    endif()\n  endforeach()\n\n  # raise an error if no flag was found\n  if(_flag_is_required AND NOT _flag_found)\n    message(FATAL_ERROR \"None of the required flags were supported\")\n  endif()\nendfunction()\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-03 LANGUAGES C CXX)\n```", "```cpp\ninclude(set_compiler_flag.cmake)\n```", "```cpp\nset_compiler_flag(\n  working_compile_flag C REQUIRED\n  \"-foo\"             # this should fail\n  \"-wrong\"           # this should fail\n  \"-wrong\"           # this should fail\n  \"-Wall\"            # this should work with GNU\n  \"-warn all\"        # this should work with Intel\n  \"-Minform=inform\"  # this should work with PGI\n  \"-nope\"            # this should fail\n  )\n\nmessage(STATUS \"working C compile flag: ${working_compile_flag}\")\n```", "```cpp\nset_compiler_flag(\n  working_compile_flag CXX REQUIRED\n  \"-foo\"    # this should fail\n  \"-g\"      # this should work with GNU, Intel, PGI\n  \"/RTCcsu\" # this should work with MSVC\n  )\n\nmessage(STATUS \"working CXX compile flag: ${working_compile_flag}\")\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n```", "```cpp\n-- ...\n-- Performing Test _flag_works\n-- Performing Test _flag_works - Failed\n-- Performing Test _flag_works\n-- Performing Test _flag_works - Failed\n-- Performing Test _flag_works\n-- Performing Test _flag_works - Failed\n-- Performing Test _flag_works\n-- Performing Test _flag_works - Success\n-- working C compile flag: -Wall\n-- Performing Test _flag_works\n-- Performing Test _flag_works - Failed\n-- Performing Test _flag_works\n-- Performing Test _flag_works - Success\n-- working CXX compile flag: -g\n-- ...\n```", "```cpp\ninclude(CheckCCompilerFlag)\ninclude(CheckCXXCompilerFlag)\ninclude(CheckFortranCompilerFlag)\n```", "```cpp\nfunction(set_compiler_flag _result _lang)\n  ...\nendfunction()\n```", "```cpp\nset_compiler_flag(working_compile_flag C REQUIRED \"-Wall\" \"-warn all\")\n```", "```cpp\n# build a list of flags from the arguments\nset(_list_of_flags)\n# also figure out whether the function\n# is required to find a flag\nset(_flag_is_required FALSE)\nforeach(_arg IN ITEMS ${ARGN})\n  string(TOUPPER \"${_arg}\" _arg_uppercase)\n  if(_arg_uppercase STREQUAL \"REQUIRED\")\n    set(_flag_is_required TRUE)\n  else()\n    list(APPEND _list_of_flags \"${_arg}\")\n  endif()\nendforeach()\n```", "```cpp\nset(_flag_found FALSE)\n# loop over all flags, try to find the first which works\nforeach(flag IN ITEMS ${_list_of_flags})\n\n  unset(_flag_works CACHE)\n  if(_lang STREQUAL \"C\")\n    check_c_compiler_flag(\"${flag}\" _flag_works)\n  elseif(_lang STREQUAL \"CXX\")\n    check_cxx_compiler_flag(\"${flag}\" _flag_works)\n  elseif(_lang STREQUAL \"Fortran\")\n    check_Fortran_compiler_flag(\"${flag}\" _flag_works)\n  else()\n    message(FATAL_ERROR \"Unknown language in set_compiler_flag: ${_lang}\")\n  endif()\n  # if the flag works, use it, and exit\n  # otherwise try next flag\n  if(_flag_works)\n    set(${_result} \"${flag}\" PARENT_SCOPE)\n    set(_flag_found TRUE)\n    break()\n  endif()\nendforeach()\n```", "```cpp\nset(${_result} \"${flag}\" PARENT_SCOPE)\n```", "```cpp\n# raise an error if no flag was found\nif(_flag_is_required AND NOT _flag_found)\n  message(FATAL_ERROR \"None of the required flags were supported\")\nendif()\n```", "```cpp\nadd_catch_test(short 1.5)\n```", "```cpp\nadd_catch_test(\n  NAME\n    short\n  LABELS\n    short\n    cpp_test\n  COST\n    1.5\n  )\n```", "```cpp\n.\n├── cmake\n│   └── testing.cmake\n├── CMakeLists.txt\n├── src\n│   ├── CMakeLists.txt\n│   ├── main.cpp\n│   ├── sum_integers.cpp\n│   └── sum_integers.hpp\n```", "```cpp\n└── tests\n    ├── catch.hpp\n    ├── CMakeLists.txt\n    └── test.cpp\n```", "```cpp\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n```", "```cpp\nadd_executable(cpp_test test.cpp)\ntarget_link_libraries(cpp_test sum_integers)\n\ninclude(testing)\n\nadd_catch_test(\n  NAME\n    short\n  LABELS\n    short\n    cpp_test\n  COST\n    1.5\n  )\n\nadd_catch_test(\n  NAME\n    long\n  LABELS\n    long\n    cpp_test\n  COST\n    2.5\n  )\n```", "```cpp\nfunction(add_catch_test)\n  set(options)\n  set(oneValueArgs NAME COST)\n  set(multiValueArgs LABELS DEPENDS REFERENCE_FILES)\n  cmake_parse_arguments(add_catch_test\n    \"${options}\"\n    \"${oneValueArgs}\"\n    \"${multiValueArgs}\"\n    ${ARGN}\n    )\n\n  message(STATUS \"defining a test ...\")\n  message(STATUS \" NAME: ${add_catch_test_NAME}\")\n  message(STATUS \" LABELS: ${add_catch_test_LABELS}\")\n  message(STATUS \" COST: ${add_catch_test_COST}\")\n  message(STATUS \" REFERENCE_FILES: ${add_catch_test_REFERENCE_FILES}\")\n\n  add_test(\n    NAME\n      ${add_catch_test_NAME}\n    COMMAND\n      $<TARGET_FILE:cpp_test>\n      [${add_catch_test_NAME}] --success --out\n      ${PROJECT_BINARY_DIR}/tests/${add_catch_test_NAME}.log --durations yes\n    WORKING_DIRECTORY\n      ${CMAKE_CURRENT_BINARY_DIR}\n    )\n\n  set_tests_properties(${add_catch_test_NAME}\n    PROPERTIES\n      LABELS \"${add_catch_test_LABELS}\"\n    )\n\n  if(add_catch_test_COST)\n    set_tests_properties(${add_catch_test_NAME}\n      PROPERTIES\n        COST ${add_catch_test_COST}\n      )\n  endif()\n\n  if(add_catch_test_DEPENDS)\n    set_tests_properties(${add_catch_test_NAME}\n      PROPERTIES\n        DEPENDS ${add_catch_test_DEPENDS}\n      )\n  endif()\n\n  if(add_catch_test_REFERENCE_FILES)\n    file(\n      COPY\n        ${add_catch_test_REFERENCE_FILES}\n      DESTINATION\n        ${CMAKE_CURRENT_BINARY_DIR}\n      )\n  endif()\nendfunction()\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n\n-- ...\n-- defining a test ...\n--     NAME: short\n--     LABELS: short;cpp_test\n--     COST: 1.5\n--     REFERENCE_FILES: \n-- defining a test ...\n--     NAME: long\n--     LABELS: long;cpp_test\n--     COST: 2.5\n--     REFERENCE_FILES:\n-- ...\n```", "```cpp\n$ cmake --build .\n$ ctest\n```", "```cpp\nfunction(add_catch_test)\n  set(options)\n  set(oneValueArgs NAME COST)\n  set(multiValueArgs LABELS DEPENDS REFERENCE_FILES)\n  cmake_parse_arguments(add_catch_test\n    \"${options}\"\n    \"${oneValueArgs}\"\n    \"${multiValueArgs}\"\n    ${ARGN}\n    )\n  ...\nendfunction()\n```", "```cpp\n.\n├── cmake\n│   ├── custom.cmake\n│   └── include_guard.cmake\n└── CMakeLists.txt\n```", "```cpp\ninclude_guard(GLOBAL)\n\nmessage(STATUS \"custom.cmake is included and processed\")\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-05 LANGUAGES NONE)\n```", "```cpp\n# (re)defines include_guard\ninclude(cmake/include_guard.cmake)\n```", "```cpp\nmacro(include_guard)\n  if (CMAKE_VERSION VERSION_LESS \"3.10\")\n    # for CMake below 3.10 we define our\n    # own include_guard(GLOBAL)\n    message(STATUS \"calling our custom include_guard\")\n\n    # if this macro is called the first time\n    # we start with an empty list\n    if(NOT DEFINED included_modules)\n        set(included_modules)\n    endif()\n\n    if (\"${CMAKE_CURRENT_LIST_FILE}\" IN_LIST included_modules)\n      message(WARNING \"module ${CMAKE_CURRENT_LIST_FILE} processed more than once\")\n    endif()\n\n    list(APPEND included_modules ${CMAKE_CURRENT_LIST_FILE})\n  else()\n    # for CMake 3.10 or higher we augment\n    # the built-in include_guard\n    message(STATUS \"calling the built-in include_guard\")\n\n    _include_guard(${ARGV})\n  endif()\nendmacro()\n```", "```cpp\ninclude(cmake/custom.cmake)\ninclude(cmake/custom.cmake)\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n```", "```cpp\n-- calling the built-in include_guard\n-- custom.cmake is included and processed\n-- calling the built-in include_guard\n```", "```cpp\n-- calling our custom include_guard\n-- custom.cmake is included and processed\n-- calling our custom include_guard\nCMake Warning at cmake/include_guard.cmake:7 (message):\n  module\n  /home/user/example/cmake/custom.cmake\n  processed more than once\nCall Stack (most recent call first):\n  cmake/custom.cmake:1 (include_guard)\n  CMakeLists.txt:12 (include)\n```", "```cpp\nmacro(include_guard)\n  if (CMAKE_VERSION VERSION_LESS \"3.10\")\n    # ...\n  else()\n    # ...\n  endif()\nendmacro()\n```", "```cpp\nmessage(STATUS \"calling our custom include_guard\")\n\n# if this macro is called the first time\n# we start with an empty list\nif(NOT DEFINED included_modules)\n    set(included_modules)\nendif()\n\nif (\"${CMAKE_CURRENT_LIST_FILE}\" IN_LIST included_modules)\n  message(WARNING \"module ${CMAKE_CURRENT_LIST_FILE} processed more than once\")\nendif()\n\nlist(APPEND included_modules ${CMAKE_CURRENT_LIST_FILE})\n```", "```cpp\nmacro(include_guard)\n  if (CMAKE_VERSION VERSION_LESS \"3.10\")\n    # ...\n  else()\n    message(STATUS \"calling the built-in include_guard\")\n\n    _include_guard(${ARGV})\n  endif()\nendmacro()\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-06 LANGUAGES NONE)\n\nmacro(custom_include_guard)\n  if(NOT DEFINED included_modules)\n    set(included_modules)\n  endif()\n\n  if (\"${CMAKE_CURRENT_LIST_FILE}\" IN_LIST included_modules)\n    message(WARNING \"module ${CMAKE_CURRENT_LIST_FILE} processed more than once\")\n  endif()\n\n  list(APPEND included_modules ${CMAKE_CURRENT_LIST_FILE})\nendmacro()\n\ninclude(cmake/custom.cmake)\n\nmessage(STATUS \"list of all included modules: ${included_modules}\")\n```", "```cpp\nfunction(deprecate_variable _variable _access)\n  if(_access STREQUAL \"READ_ACCESS\")\n    message(DEPRECATION \"variable ${_variable} is deprecated\")\n  endif()\nendfunction()\n```", "```cpp\nif (CMAKE_VERSION VERSION_GREATER \"3.9\")\n  # deprecate custom_include_guard\n  macro(custom_include_guard)\n    message(DEPRECATION \"custom_include_guard is deprecated - use built-in include_guard instead\")\n    _custom_include_guard(${ARGV})\n  endmacro()\n\n  # deprecate variable included_modules\n  variable_watch(included_modules deprecate_variable)\nendif()\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n\n-- custom.cmake is included and processed\n-- list of all included modules: /home/user/example/cmake/custom.cmake\n```", "```cpp\nCMake Deprecation Warning at CMakeLists.txt:26 (message):\n  custom_include_guard is deprecated - use built-in include_guard instead\nCall Stack (most recent call first):\n  cmake/custom.cmake:1 (custom_include_guard)\n  CMakeLists.txt:34 (include)\n\n-- custom.cmake is included and processed\nCMake Deprecation Warning at CMakeLists.txt:19 (message):\n  variable included_modules is deprecated\nCall Stack (most recent call first):\n  CMakeLists.txt:9999 (deprecate_variable)\n  CMakeLists.txt:36 (message)\n\n-- list of all included modules: /home/user/example/cmake/custom.cmake\n```", "```cpp\nmacro(somemacro)\n  message(DEPRECATION \"somemacro is deprecated\")\n  _somemacro(${ARGV})\nendmacro()\n```", "```cpp\nfunction(deprecate_variable _variable _access)\n  if(_access STREQUAL \"READ_ACCESS\")\n    message(DEPRECATION \"variable ${_variable} is deprecated\")\n  endif()\nendfunction()\n```", "```cpp\nvariable_watch(somevariable deprecate_variable)\n```", "```cpp\n$ ./bin/automata 40 15 90\n\nlength: 40\nnumber of steps: 15\nrule: 90\n                    *\n                   * *\n                  *   *\n                 * * * *\n                *       *\n               * *     * *\n              *   *   *   *\n             * * * * * * * *\n            *               *\n           * *             * *\n          *   *           *   *\n         * * * *         * * * *\n        *       *       *       *\n       * *     * *     * *     * *\n      *   *   *   *   *   *   *   *\n     * * * * * * * * * * * * * * * *\n```", "```cpp\n.\n├── CMakeLists.txt\n├── external\n│   ├── CMakeLists.txt\n│   ├── conversion.cpp\n│   ├── conversion.hpp\n│   └── README.md\n├── src\n│   ├── CMakeLists.txt\n│   ├── evolution\n│   │   ├── CMakeLists.txt\n│   │   ├── evolution.cpp\n│   │   └── evolution.hpp\n│   ├── initial\n│   │   ├── CMakeLists.txt\n│   │   ├── initial.cpp\n│   │   └── initial.hpp\n│   ├── io\n│   │   ├── CMakeLists.txt\n│   │   ├── io.cpp\n│   │   └── io.hpp\n│   ├── main.cpp\n│   └── parser\n│       ├── CMakeLists.txt\n│       ├── parser.cpp\n│       └── parser.hpp\n└── tests\n    ├── catch.hpp\n    ├── CMakeLists.txt\n    └── test.cpp\n```", "```cpp\n#include \"conversion.hpp\"\n#include \"evolution.hpp\"\n#include \"initial.hpp\"\n#include \"io.hpp\"\n#include \"parser.hpp\"\n\n#include <iostream>\nint main(int argc, char *argv[]) {\n\n  // parse arguments\n  int length, num_steps, rule_decimal;\n  std::tie(length, num_steps, rule_decimal) = parse_arguments(argc, argv);\n\n  // print information about parameters\n  std::cout << \"length: \" << length << std::endl;\n  std::cout << \"number of steps: \" << num_steps << std::endl;\n  std::cout << \"rule: \" << rule_decimal << std::endl;\n\n  // obtain binary representation for the rule\n  std::string rule_binary = binary_representation(rule_decimal);\n\n  // create initial distribution\n  std::vector<int> row = initial_distribution(length);\n\n  // print initial configuration\n  print_row(row);\n\n  // the system evolves, print each step\n  for (int step = 0; step < num_steps; step++) {\n    row = evolve(row, rule_binary);\n    print_row(row);\n  }\n}\n```", "```cpp\n#include \"conversion.hpp\"\n\n#include <bitset>\n#include <string>\n\nstd::string binary_representation(const int decimal) {\n  return std::bitset<8>(decimal).to_string();\n}\n```", "```cpp\n#include \"evolution.hpp\"\n\n#include <string>\n#include <vector>\n\nstd::vector<int> evolve(const std::vector<int> row, const std::string rule_binary) {\n  std::vector<int> result;\n  for (auto i = 0; i < row.size(); ++i) {\n\n    auto left = (i == 0 ? row.size() : i) - 1;\n    auto center = i;\n    auto right = (i + 1) % row.size();\n\n    auto ancestors = 4 * row[left] + 2 * row[center] + 1 * row[right];\n    ancestors = 7 - ancestors;\n\n    auto new_state = std::stoi(rule_binary.substr(ancestors, 1));\n\n    result.push_back(new_state);\n  }\n\n  return result;\n}\n```", "```cpp\n#include \"initial.hpp\"\n\n#include <vector>\n\nstd::vector<int> initial_distribution(const int length) {\n\n  // we start with a vector which is zeroed out\n  std::vector<int> result(length, 0);\n\n  // more or less in the middle we place a living cell\n  result[length / 2] = 1;\n\n  return result;\n}\n```", "```cpp\n#include \"io.hpp\"\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nvoid print_row(const std::vector<int> row) {\n  std::for_each(row.begin(), row.end(), [](int const &value) {\n    std::cout << (value == 1 ? '*' : ' ');\n  });\n  std::cout << std::endl;\n}\n```", "```cpp\n#include \"parser.hpp\"\n\n#include <cassert>\n#include <string>\n#include <tuple>\n\nstd::tuple<int, int, int> parse_arguments(int argc, char *argv[]) {\n  assert(argc == 4 && \"program called with wrong number of arguments\");\n\n  auto length = std::stoi(argv[1]);\n  auto num_steps = std::stoi(argv[2]);\n  auto rule_decimal = std::stoi(argv[3]);\n\n  return std::make_tuple(length, num_steps, rule_decimal);\n}\n```", "```cpp\n#include \"evolution.hpp\"\n\n// this tells catch to provide a main()\n// only do this in one cpp file\n#define CATCH_CONFIG_MAIN\n#include \"catch.hpp\"\n\n#include <string>\n#include <vector>\n\nTEST_CASE(\"Apply rule 90\", \"[rule-90]\") {\n  std::vector<int> row = {0, 1, 0, 1, 0, 1, 0, 1, 0};\n  std::string rule = \"01011010\";\n  std::vector<int> expected_result = {1, 0, 0, 0, 0, 0, 0, 0, 1};\n  REQUIRE(evolve(row, rule) == expected_result);\n}\n\nTEST_CASE(\"Apply rule 222\", \"[rule-222]\") {\n  std::vector<int> row = {0, 0, 0, 0, 1, 0, 0, 0, 0};\n  std::string rule = \"11011110\";\n  std::vector<int> expected_result = {0, 0, 0, 1, 1, 1, 0, 0, 0};\n  REQUIRE(evolve(row, rule) == expected_result);\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-07 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\ninclude(GNUInstallDirs)\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\n\n# defines targets and sources\nadd_subdirectory(src)\n\n# contains an \"external\" library we will link to\nadd_subdirectory(external)\n\n# enable testing and define tests\nenable_testing()\nadd_subdirectory(tests)\n```", "```cpp\nadd_executable(automata main.cpp)\n\nadd_subdirectory(evolution)\nadd_subdirectory(initial)\nadd_subdirectory(io)\nadd_subdirectory(parser)\n\ntarget_link_libraries(automata\n  PRIVATE\n    conversion\n    evolution\n    initial\n    io\n    parser\n  )\n```", "```cpp\nadd_library(conversion \"\")\n\ntarget_sources(conversion\n  PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/conversion.cpp\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/conversion.hpp\n  )\n\ntarget_include_directories(conversion\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}\n  )\n```", "```cpp\nadd_library(evolution \"\")\n\ntarget_sources(evolution\n  PRIVATE\n    evolution.cpp\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/evolution.hpp\n  )\ntarget_include_directories(evolution\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}\n  )\n```", "```cpp\nadd_executable(cpp_test test.cpp)\n\ntarget_link_libraries(cpp_test evolution)\n\nadd_test(\n  NAME\n    test_evolution\n  COMMAND\n    $<TARGET_FILE:cpp_test>\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build .\n\nScanning dependencies of target conversion\n[ 7%] Building CXX object external/CMakeFiles/conversion.dir/conversion.cpp.o\n[ 14%] Linking CXX static library ../lib64/libconversion.a\n[ 14%] Built target conversion\nScanning dependencies of target evolution\n[ 21%] Building CXX object src/evolution/CMakeFiles/evolution.dir/evolution.cpp.o\n[ 28%] Linking CXX static library ../../lib64/libevolution.a\n[ 28%] Built target evolution\nScanning dependencies of target initial\n[ 35%] Building CXX object src/initial/CMakeFiles/initial.dir/initial.cpp.o\n[ 42%] Linking CXX static library ../../lib64/libinitial.a\n[ 42%] Built target initial\nScanning dependencies of target io\n[ 50%] Building CXX object src/io/CMakeFiles/io.dir/io.cpp.o\n[ 57%] Linking CXX static library ../../lib64/libio.a\n[ 57%] Built target io\nScanning dependencies of target parser\n[ 64%] Building CXX object src/parser/CMakeFiles/parser.dir/parser.cpp.o\n[ 71%] Linking CXX static library ../../lib64/libparser.a\n[ 71%] Built target parser\nScanning dependencies of target automata\n[ 78%] Building CXX object src/CMakeFiles/automata.dir/main.cpp.o\n[ 85%] Linking CXX executable ../bin/automata\n[ 85%] Built target automata\nScanning dependencies of target cpp_test\n[ 92%] Building CXX object tests/CMakeFiles/cpp_test.dir/test.cpp.o\n[100%] Linking CXX executable ../bin/cpp_test\n[100%] Built target cpp_test\n```", "```cpp\n$ ctest\n\nRunning tests...\n    Start 1: test_evolution\n```", "```cpp\n1/1 Test #1: test_evolution ................... Passed 0.00 sec\n\n100% tests passed, 0 tests failed out of 1\n```", "```cpp\nadd_library(evolution \"\")\n\ntarget_sources(evolution\n  PRIVATE\n    evolution.cpp\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/evolution.hpp\n  )\n\ntarget_include_directories(evolution\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}\n  )\n```", "```cpp\nadd_executable(automata main.cpp)\n\nadd_subdirectory(evolution)\nadd_subdirectory(initial)\nadd_subdirectory(io)\nadd_subdirectory(parser)\n\ntarget_link_libraries(automata\n  PRIVATE\n    conversion\n    evolution\n    initial\n    io\n    parser\n  )\n```", "```cpp\n$ cd build\n$ cmake --graphviz=example.dot ..\n$ dot -T png example.dot -o example.png\n```", "```cpp\nif(${PROJECT_SOURCE_DIR} STREQUAL ${PROJECT_BINARY_DIR})\n    message(FATAL_ERROR \"In-source builds not allowed. Please make a new directory (called a build directory) and run CMake from there.\")\nendif()\n```", "```cpp\nmessage(\"current binary dir is ${CMAKE_CURRENT_BINARY_DIR}\")\n```", "```cpp\nadd_library(io OBJECT \"\")\n\ntarget_sources(io\n  PRIVATE\n    io.cpp\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/io.hpp\n  )\n\ntarget_include_directories(io\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}\n  )\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-08 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 11)\nset(CMAKE_CXX_EXTENSIONS OFF)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n```", "```cpp\ninclude(GNUInstallDirs)\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\n\n# defines targets and sources\ninclude(src/CMakeLists.txt)\ninclude(external/CMakeLists.txt)\n\nenable_testing()\nadd_subdirectory(tests)\n```", "```cpp\nadd_library(automaton \"\")\nadd_library(evolution \"\")\n\ninclude(${CMAKE_CURRENT_LIST_DIR}/evolution/CMakeLists.txt)\ninclude(${CMAKE_CURRENT_LIST_DIR}/initial/CMakeLists.txt)\ninclude(${CMAKE_CURRENT_LIST_DIR}/io/CMakeLists.txt)\ninclude(${CMAKE_CURRENT_LIST_DIR}/parser/CMakeLists.txt)\n\nadd_executable(automata \"\")\n\ntarget_sources(automata\n  PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/main.cpp\n  )\n\ntarget_link_libraries(automata\n  PRIVATE\n    automaton\n    conversion\n  )\n```", "```cpp\ntarget_sources(automaton\n  PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/evolution.cpp\n```", "```cpp\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/evolution.hpp\n  )\n\ntarget_include_directories(automaton\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}\n  )\n\ntarget_sources(evolution\n  PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/evolution.cpp\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/evolution.hpp\n  )\n\ntarget_include_directories(evolution\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}\n  )\n```", "```cpp\ntarget_sources(automaton\n  PRIVATE\n    ${CMAKE_CURRENT_LIST_DIR}/initial.cpp\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/initial.hpp\n  )\n\ntarget_include_directories(automaton\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build build\n$ ctest\n\n```", "```cpp\nRunning tests...\n Start 1: test_evolution\n1/1 Test #1: test_evolution ................... Passed 0.00 sec\n\n100% tests passed, 0 tests failed out of 1\n```", "```cpp\ninclude(src/CMakeLists.txt)\ninclude(external/CMakeLists.txt)\n```", "```cpp\ninclude(${CMAKE_CURRENT_LIST_DIR}/evolution/CMakeLists.txt)\ninclude(${CMAKE_CURRENT_LIST_DIR}/initial/CMakeLists.txt)\ninclude(${CMAKE_CURRENT_LIST_DIR}/io/CMakeLists.txt)\ninclude(${CMAKE_CURRENT_LIST_DIR}/parser/CMakeLists.txt)\n```", "```cpp\n$ cd build\n$ cmake --graphviz=example.dot ..\n$ dot -T png example.dot -o example.png\n```", "```cpp\n.\n├── CMakeLists.txt\n├── external\n│   ├── CMakeLists.txt\n│   ├── conversion.f90\n│   └── README.md\n├── src\n│   ├── CMakeLists.txt\n│   ├── evolution\n│   │   ├── ancestors.f90\n│   │   ├── CMakeLists.txt\n│   │   ├── empty.f90\n│   │   └── evolution.f90\n│   ├── initial\n│   │   ├── CMakeLists.txt\n│   │   └── initial.f90\n│   ├── io\n│   │   ├── CMakeLists.txt\n│   │   └── io.f90\n│   ├── main.f90\n│   └── parser\n│       ├── CMakeLists.txt\n│       └── parser.f90\n└── tests\n    ├── CMakeLists.txt\n    └── test.f90\n```", "```cpp\nprogram example\n\n  use parser, only: get_arg_as_int\n  use conversion, only: binary_representation\n  use initial, only: initial_distribution\n  use io, only: print_row\n  use evolution, only: evolve\n\n  implicit none\n\n  integer :: num_steps\n  integer :: length\n  integer :: rule_decimal\n  integer :: rule_binary(8)\n  integer, allocatable :: row(:)\n  integer :: step\n\n  ! parse arguments\n  num_steps = get_arg_as_int(1)\n  length = get_arg_as_int(2)\n  rule_decimal = get_arg_as_int(3)\n\n  ! print information about parameters\n  print *, \"number of steps: \", num_steps\n  print *, \"length: \", length\n  print *, \"rule: \", rule_decimal\n\n  ! obtain binary representation for the rule\n  rule_binary = binary_representation(rule_decimal)\n\n  ! create initial distribution\n  allocate(row(length))\n  call initial_distribution(row)\n\n  ! print initial configuration\n  call print_row(row)\n\n  ! the system evolves, print each step\n  do step = 1, num_steps\n    call evolve(row, rule_binary)\n    call print_row(row)\n  end do\n\n  deallocate(row)\n\nend program\n```", "```cpp\nmodule conversion\n\n  implicit none\n  public binary_representation\n  private\n\ncontains\n\n  pure function binary_representation(n_decimal)\n    integer, intent(in) :: n_decimal\n    integer :: binary_representation(8)\n    integer :: pos\n    integer :: n\n\n    binary_representation = 0\n    pos = 8\n    n = n_decimal\n    do while (n > 0)\n      binary_representation(pos) = mod(n, 2)\n      n = (n - binary_representation(pos))/2\n      pos = pos - 1\n    end do\n  end function\n\nend module\n```", "```cpp\nmodule evolution\n\n  implicit none\n  public evolve\n  private\n\ncontains\n\n  subroutine not_visible()\n    ! no-op call to demonstrate private/public visibility\n    call empty_subroutine_no_interface()\n  end subroutine\n\n  pure subroutine evolve(row, rule_binary)\n    use ancestors, only: compute_ancestors\n\n    integer, intent(inout) :: row(:)\n    integer, intent(in) :: rule_binary(8)\n    integer :: i\n    integer :: left, center, right\n    integer :: ancestry\n    integer, allocatable :: new_row(:)\n\n    allocate(new_row(size(row)))\n\n    do i = 1, size(row)\n      left = i - 1\n      center = i\n      right = i + 1\n\n      if (left < 1) left = left + size(row)\n      if (right > size(row)) right = right - size(row)\n\n      ancestry = compute_ancestors(row, left, center, right)\n      new_row(i) = rule_binary(ancestry)\n    end do\n\n    row = new_row\n    deallocate(new_row)\n\n  end subroutine\n\nend module\n```", "```cpp\nmodule ancestors\n\n  implicit none\n  public compute_ancestors\n  private\n\ncontains\n\n  pure integer function compute_ancestors(row, left, center, right) result(i)\n    integer, intent(in) :: row(:)\n    integer, intent(in) :: left, center, right\n\n    i = 4*row(left) + 2*row(center) + 1*row(right)\n    i = 8 - i\n  end function\n\nend module\n```", "```cpp\nmodule empty\n\n  implicit none\n  public empty_subroutine\n  private\n\ncontains\n\n  subroutine empty_subroutine()\n  end subroutine\n\nend module\n\nsubroutine empty_subroutine_no_interface()\n  use empty, only: empty_subroutine\n  call empty_subroutine()\nend subroutine\n```", "```cpp\nmodule initial\n\n  implicit none\n  public initial_distribution\n  private\n\ncontains\n\n  pure subroutine initial_distribution(row)\n    integer, intent(out) :: row(:)\n\n    row = 0\n    row(size(row)/2) = 1\n  end subroutine\n\nend module\n```", "```cpp\nmodule io\n\n  implicit none\n  public print_row\n  private\n\ncontains\n\n  subroutine print_row(row)\n    integer, intent(in) :: row(:)\n    character(size(row)) :: line\n    integer :: i\n\n    do i = 1, size(row)\n      if (row(i) == 1) then\n        line(i:i) = '*'\n      else\n        line(i:i) = ' '\n      end if\n    end do\n\n    print *, line\n  end subroutine\n\nend module\n```", "```cpp\nmodule parser\n\n  implicit none\n  public get_arg_as_int\n  private\n\ncontains\n\n  integer function get_arg_as_int(n) result(i)\n    integer, intent(in) :: n\n    character(len=32) :: arg\n\n    call get_command_argument(n, arg)\n    read(arg , *) i\n  end function\n\nend module\n```", "```cpp\nprogram test\n\n  use evolution, only: evolve\n\n  implicit none\n\n  integer :: row(9)\n  integer :: expected_result(9)\n  integer :: rule_binary(8)\n  integer :: i\n\n  ! test rule 90\n  row = (/0, 1, 0, 1, 0, 1, 0, 1, 0/)\n  rule_binary = (/0, 1, 0, 1, 1, 0, 1, 0/)\n  call evolve(row, rule_binary)\n  expected_result = (/1, 0, 0, 0, 0, 0, 0, 0, 1/)\n  do i = 1, 9\n    if (row(i) /= expected_result(i)) then\n      print *, 'ERROR: test for rule 90 failed'\n      call exit(1)\n    end if\n  end do\n  ! test rule 222\n  row = (/0, 0, 0, 0, 1, 0, 0, 0, 0/)\n  rule_binary = (/1, 1, 0, 1, 1, 1, 1, 0/)\n  call evolve(row, rule_binary)\n  expected_result = (/0, 0, 0, 1, 1, 1, 0, 0, 0/)\n  do i = 1, 9\n    if (row(i) /= expected_result(i)) then\n      print *, 'ERROR: test for rule 222 failed'\n      call exit(1)\n    end if\n  end do\n\nend program\n```", "```cpp\ncmake_minimum_required(VERSION 3.5 FATAL_ERROR)\n\nproject(recipe-09 LANGUAGES Fortran)\n\ninclude(GNUInstallDirs)\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_LIBDIR})\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\n  ${CMAKE_BINARY_DIR}/${CMAKE_INSTALL_BINDIR})\n\n# defines targets and sources\nadd_subdirectory(src)\n\n# contains an \"external\" library we will link to\nadd_subdirectory(external)\n\n# enable testing and define tests\nenable_testing()\nadd_subdirectory(tests)\n```", "```cpp\nadd_executable(automata main.f90)\n\nadd_subdirectory(evolution)\nadd_subdirectory(initial)\nadd_subdirectory(io)\nadd_subdirectory(parser)\n\ntarget_link_libraries(automata\n  PRIVATE\n    conversion\n    evolution\n    initial\n    io\n    parser\n  )\n```", "```cpp\nadd_library(conversion \"\")\n\ntarget_sources(conversion\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/conversion.f90\n  )\n```", "```cpp\nadd_library(initial \"\")\n\ntarget_sources(initial\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/initial.f90\n  )\n```", "```cpp\nadd_library(evolution \"\")\n\ntarget_sources(evolution\n  PRIVATE\n    empty.f90\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/ancestors.f90\n    ${CMAKE_CURRENT_LIST_DIR}/evolution.f90\n  )\n```", "```cpp\nadd_executable(fortran_test test.f90)\n\ntarget_link_libraries(fortran_test evolution)\n\nadd_test(\n  NAME\n    test_evolution\n  COMMAND\n    $<TARGET_FILE:fortran_test>\n  )\n```", "```cpp\n$ mkdir -p build\n$ cd build\n$ cmake ..\n$ cmake --build .\n\nScanning dependencies of target conversion\n[ 4%] Building Fortran object external/CMakeFiles/conversion.dir/conversion.f90.o\n[ 8%] Linking Fortran static library ../lib64/libconversion.a\n[ 8%] Built target conversion\nScanning dependencies of target evolution\n[ 12%] Building Fortran object src/evolution/CMakeFiles/evolution.dir/ancestors.f90.o\n[ 16%] Building Fortran object src/evolution/CMakeFiles/evolution.dir/empty.f90.o\n[ 20%] Building Fortran object src/evolution/CMakeFiles/evolution.dir/evolution.f90.o\n[ 25%] Linking Fortran static library ../../lib64/libevolution.a\n[ 25%] Built target evolution\nScanning dependencies of target initial\n[ 29%] Building Fortran object src/initial/CMakeFiles/initial.dir/initial.f90.o\n[ 33%] Linking Fortran static library ../../lib64/libinitial.a\n[ 33%] Built target initial\nScanning dependencies of target io\n[ 37%] Building Fortran object src/io/CMakeFiles/io.dir/io.f90.o\n[ 41%] Linking Fortran static library ../../lib64/libio.a\n[ 41%] Built target io\nScanning dependencies of target parser\n[ 45%] Building Fortran object src/parser/CMakeFiles/parser.dir/parser.f90.o\n[ 50%] Linking Fortran static library ../../lib64/libparser.a\n[ 50%] Built target parser\nScanning dependencies of target example\n[ 54%] Building Fortran object src/CMakeFiles/example.dir/__/external/conversion.f90.o\n[ 58%] Building Fortran object src/CMakeFiles/example.dir/evolution/ancestors.f90.o\n[ 62%] Building Fortran object src/CMakeFiles/example.dir/evolution/evolution.f90.o\n[ 66%] Building Fortran object src/CMakeFiles/example.dir/initial/initial.f90.o\n[ 70%] Building Fortran object src/CMakeFiles/example.dir/io/io.f90.o\n[ 75%] Building Fortran object src/CMakeFiles/example.dir/parser/parser.f90.o\n[ 79%] Building Fortran object src/CMakeFiles/example.dir/main.f90.o\n[ 83%] Linking Fortran executable ../bin/example\n[ 83%] Built target example\nScanning dependencies of target fortran_test\n[ 87%] Building Fortran object tests/CMakeFiles/fortran_test.dir/__/src/evolution/ancestors.f90.o\n[ 91%] Building Fortran object tests/CMakeFiles/fortran_test.dir/__/src/evolution/evolution.f90.o\n[ 95%] Building Fortran object tests/CMakeFiles/fortran_test.dir/test.f90.o\n[100%] Linking Fortran executable\n```", "```cpp\n$ ctest\n\nRunning tests...\n Start 1: test_evolution\n1/1 Test #1: test_evolution ................... Passed 0.00 sec\n\n100% tests passed, 0 tests failed out of 1\n```", "```cpp\nadd_library(evolution \"\")\n\ntarget_sources(evolution\n  PRIVATE\n```", "```cpp\n    empty.f90\n  PUBLIC\n    ${CMAKE_CURRENT_LIST_DIR}/ancestors.f90\n    ${CMAKE_CURRENT_LIST_DIR}/evolution.f90\n  )\n```", "```cpp\nadd_executable(automata main.f90)\n\nadd_subdirectory(evolution)\nadd_subdirectory(initial)\nadd_subdirectory(io)\nadd_subdirectory(parser)\n\ntarget_link_libraries(automata\n  PRIVATE\n    conversion\n    evolution\n    initial\n    io\n    parser\n  )\n```"]