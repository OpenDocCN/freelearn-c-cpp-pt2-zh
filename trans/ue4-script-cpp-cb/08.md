# 第八章。集成 C ++ 和虚幻编辑器

在本章中，我们将介绍以下食谱:

*   使用类或`struct`作为蓝图变量
*   创建可以在蓝图中子类化的类或结构
*   创建可以在蓝图中调用的函数
*   创建可以在蓝图中实现的事件
*   将多播代表暴露于蓝图
*   创建可在蓝图中使用的 C 枚举
*   在编辑器中不同位置编辑类属性
*   在蓝图编辑器图中使属性可访问
*   响应来自编辑器的属性更改事件
*   实现原生代码构建脚本
*   创建新的编辑器模块
*   创建新工具栏按钮
*   创建新菜单项
*   创建新的编辑器窗口
*   创建新的资产类型
*   为资产创建自定义上下文菜单条目
*   创建新的控制台命令
*   为蓝图创建新的图形引脚可视化器
*   使用自定义**详细信息**面板检查类型

# 简介

虚幻的主要优势之一是它为程序员提供了创建演员和其他对象的能力，这些对象可以由编辑器中的设计师定制或使用。本章展示了如何。之后，我们将尝试通过从头开始创建自定义蓝图和动画节点来自定义编辑器。我们还将实现自定义编辑器窗口和自定义**详细信息**面板，用于检查用户创建的类型。

# 使用类或结构作为蓝图变量

在 C 中声明的类型不会自动合并到蓝图中用作变量。此配方向您展示了如何使它们可访问，以便您可以使用自定义本机代码类型作为蓝图函数参数。

## 怎么做…

1.  Create a new class using the editor. Unlike previous chapters, we are going to create an Object-based class. Object isn't visible in the default list of common classes, so we need to tick the **Show all classes** button in the editor UI, then select **Object**. Call your new **Object** subclass `TileType`.

    ![How to do it…](../images/00136.jpeg)]

2.  将以下属性添加到`TileType`定义中:

    ```
    UPROPERTY()
    int32 MovementCost;
    UPROPERTY()
    bool CanBeBuiltOn;

    UPROPERTY()
    FString TileName;
    ```

3.  编译你的代码。
4.  Inside the editor, create a new Blueprint class based on `Actor`. Call it `Tile`.

    ![How to do it…](../images/00137.jpeg)]

5.  Within the blueprint editor for `Tile`, add a new variable to the Blueprint. Check the list of types that you can create as variables, and verify that `TileType` is not there.

    ![How to do it…](../images/00138.jpeg)]

6.  将`BlueprintType`添加到`UCLASS`宏，如下所示:

    ```
    UCLASS(BlueprintType)
    class UE4COOKBOOK_API UTileType : public UObject
    {
    }
    ```

7.  重新编译项目，然后返回到`Tile`蓝图编辑器。
8.  Now when you add a new variable to your actor, you can select `TileType` as the type for your new variable.

    ![How to do it…](../images/00139.jpeg)]

9.  我们已经现在在`Tile`和`TileType`之间建立了 “有-a” 关系。
10.  Now `TileType` is a Blueprint type that can be used as a function parameter. Create a new function on your `Tile` blueprint called `SetTileType`.

    ![How to do it…](../images/00140.jpeg)]

11.  Add a new input:

    ![How to do it…](../images/00141.jpeg)]

12.  Set the input parameter's type to `TileType`.

    ![How to do it…](../images/00142.jpeg)]

13.  You can drag our `Type` variable into the viewport, and select **Set**.

    ![How to do it…](../images/00143.jpeg)]

14.  Assign the **Exec** pin and input parameter from `SetTileType` to the **Set** node.

    ![How to do it…](../images/00144.jpeg)]

## 它是如何工作的…

1.  出于性能原因，Unreal 假设类不需要使类型可用于蓝图所需的额外反射代码。
2.  我们可以通过在我们的`UCLASS`宏中指定`BlueprintType`来覆盖这个默认值。
3.  在包含说明符的情况下，该类型现在可以作为参数或变量在蓝图中使用。

## 还有更多…

此配方显示，如果其本机代码声明包含`BlueprintType`，则可以在 Blueprint 中使用类型作为函数参数。

但是，目前，我们在 C 中定义的任何属性都无法访问蓝图。

本章中的其他食谱涉及使这些属性可访问，以便我们实际上可以对我们的自定义对象做有意义的事情。

# 创建可以在蓝图中子类化的类或结构

虽然这本书侧重于 C，但在使用 Unreal 进行开发时，更标准的工作流程是在 C 中实现核心游戏功能以及对性能至关重要的代码，并将这些功能公开给蓝图，以允许设计师原型游戏，然后可以由具有其他蓝图功能的程序员重构，或者将其推回到 C 层。

因此，最常见的任务之一是对我们的类和结构进行标记，使它们对蓝图系统可见。

## 怎么做…

1.  使用编辑器向导创建一个新的`Actor`类; 调用它`BaseEnemy`。
2.  将以下`UPROPERTY`添加到类中:

    ```
    UPROPERTY()
    FString WeaponName;
    UPROPERTY()
    int32 MaximumHealth;
    ```

3.  将以下类说明符添加到`UCLASS`宏:

    ```
    UCLASS(Blueprintable)
    class UE4COOKBOOK_API ABaseEnemy : public AActor
    ```

4.  Open the editor and create a new blueprint class. Expand the list to show all classes and select our `BaseEnemyclass` as the parent.

    ![How to do it…](../images/00145.jpeg)]

5.  命名新的蓝图`EnemyGoblin`并在蓝图编辑器中打开它。
6.  注意，我们之前创建的`UPROPERTY`宏仍然不存在，因为我们还没有包含适当的标记，以便它们对蓝图可见。

## 它是如何工作的…

1.  以前的配方演示了将`BlueprintType`用作类说明符。`BlueprintType`允许将类型用作蓝图编辑器内的类型 (即，它可以是变量或函数输入/返回值)。
2.  但是，我们可能希望根据我们的类型 (使用继承) 而不是组合 (例如，将我们的类型的实例放置在`Actor`中) 创建蓝图。
3.  这就是为什么 Epic 提供`Blueprintable`作为类说明符。`Blueprintable`表示开发人员可以将一个类标记为蓝图类可继承的。
4.  我们既有`BlueprintType`又有`Blueprintable`，而不是一个组合的说明符，因为有时，您可能只需要部分功能。例如，某些类应该可以用作变量，但是由于性能原因，禁止在蓝图中创建它们。在这种情况下，您将使用`BlueprintType`而不是两个说明符。
5.  在另一方面，也许我们想使用蓝图编辑器来创建新的子类，但我们不想在`Actor`蓝图中传递对象实例。建议使用`Blueprintable`，但本例省略`BlueprintType`。
6.  与之前的一样，`Blueprintable`或`BlueprintType`都没有指定关于我们类中包含的成员函数或成员变量的任何内容。我们将在以后的食谱中提供这些。

# 创建可以在 Blueprint 中调用的函数

虽然将类标记为`BlueprintType`或`Blueprintable`允许我们在 Blueprint 中传递类的实例，或者使用 Blueprint 类对类型进行子类化，但这些说明符实际上并没有说任何关于成员函数或变量的内容，如果它们应该暴露于 Blueprint。

此配方向您展示了如何标记函数，以便可以在蓝图图中调用它。

## 怎么做…

1.  使用编辑器创建一个新的`Actor`类。打电话给演员`SlidingDoor`。
2.  将以下`UPROPERTY`添加到新类:

    ```
    UFUNCTION(BlueprintCallable, Category = Door)
    void Open();
    UPROPERTY()
    bool IsOpen;

    UPROPERTY()
    FVector TargetLocation;
    ```

3.  通过在`.cpp`文件中添加以下内容来创建类实现:

    ```
    ASlidingDoor::ASlidingDoor()
    :Super()
    {
      auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));
      if (MeshAsset.Object != nullptr)
      {
        GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);
        GetStaticMeshComponent()->bGenerateOverlapEvents = true;
      }
      GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);
      GetStaticMeshComponent()->SetWorldScale3D(FVector(0.3, 2, 3));
      SetActorEnableCollision(true);
      IsOpen = false;
      PrimaryActorTick.bStartWithTickEnabled = true;
      PrimaryActorTick.bCanEverTick = true;
    }
    void ASlidingDoor::Open()
    {
      TargetLocation = ActorToWorld().TransformPositionNoScale(FVector(0, 0, 200));
      IsOpen = true;
    }

    void ASlidingDoor::Tick(float DeltaSeconds)
    {
      if (IsOpen)
      {
        SetActorLocation(FMath::Lerp(GetActorLocation(), TargetLocation, 0.05));
      }
    }
    ```

4.  编译你的代码并启动编辑器。
5.  将门的副本拖到关卡中。
6.  Make sure you have your `SlidingDoor` instance selected, then open the Level blueprint. Right-click on the empty canvas, and expand **Call function on Sliding Door 1**.

    ![How to do it…](../images/00146.jpeg)]

7.  Expand the **Door** section, then select the `Open` function.

    ![How to do it…](../images/00147.jpeg)]

8.  Link the execution pin (white arrow) from `BeginPlay` to the white arrow on the `Open` node, as seen in the following screenshot:

    ![How to do it…](../images/00148.jpeg)]

9.  Play your level, and verify that the door moves up as expected when `Open` is invoked on your door instance.

    ![How to do it…](../images/00149.jpeg)]

## 它是如何工作的…

1.  在门的声明中，我们创建了一个新的打开门的函数，一个布尔值来跟踪门是否被告知打开，以及一个向量，允许我们预先计算门的目标位置。
2.  我们还覆盖了`Tick`actor 函数，这样我们就可以在每一帧上执行一些行为。
3.  在构造函数中，我们加载立方体网格并缩放它以表示我们的门。
4.  我们还将`IsOpen`设置为已知的良好值`false`，并通过使用`bCanEverTick`和`bStartWithTickEnabled`启用 actor ticking。
5.  这两个布尔值分别控制是否可以为此演员启用滴答，以及是否在启用状态下开始滴答。
6.  在`Open`函数内，我们计算相对于门的起始位置的目标位置。
7.  我们还将`IsOpen`布尔值从`false`更改为`true`。
8.  现在，`IsOpen`布尔值为`true`，在`Tick`函数内部，门尝试使用`SetActorLocation`和`Lerp`向目标位置移动，以在当前位置和目的地之间进行插值。

## 另见

*   [第 5 章](05.html#22O7C1-c0ca69a0411046888a488e5085138121 "Chapter 5\. Handling Events and Delegates")，*处理事件和代表*，有许多与演员产卵有关的食谱

# 创建可以在蓝图中实现的事件

C 可以更紧密地与蓝图集成的另一种方法是创建可以在本机代码中具有蓝图实现的函数。这允许程序员指定一个事件，并调用它，而不需要知道任何关于实现。然后，可以在蓝图中对类进行子类化，并且生产团队的另一名成员可以为事件实现处理程序，而不必靠近 C 线。

## 怎么做…

1.  创建一个名为`Spotter`的新的`StaticMeshActor`类。
2.  确保在类头中定义并重写以下函数:

    ```
    virtual void Tick( float DeltaSeconds ) override;
    UFUNCTION(BlueprintImplementableEvent)
    void OnPlayerSpotted(APawn* Player);
    ```

3.  将此代码添加到构造函数中:

    ```
    PrimaryActorTick.bCanEverTick = true;
    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cone.Cone'"));
    if (MeshAsset.Object != nullptr)
    {
      GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);
      GetStaticMeshComponent()->bGenerateOverlapEvents = true;
    }
    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);
    GetStaticMeshComponent()->SetRelativeRotation(FRotator(90, 0, 0));
    ```

4.  将此添加到`Tick`函数:

    ```
    Super::Tick( DeltaTime );

    auto EndLocation = GetActorLocation() + ActorToWorld().TransformVector(FVector(0,0,-200));
    FHitResult HitResult;
    GetWorld()->SweepSingleByChannel(HitResult, GetActorLocation(), EndLocation, FQuat::Identity, ECC_Camera, FCollisionShape::MakeSphere(25), FCollisionQueryParams("Spot", true, this));
    APawn* SpottedPlayer = Cast<APawn>(HitResult.Actor.Get());

    if (SpottedPlayer!= nullptr)
    {
      OnPlayerSpotted(SpottedPlayer);
    }
    DrawDebugLine(GetWorld(), GetActorLocation(), EndLocation, FColor::Red);
    ```

5.  编译并启动编辑器。在**内容浏览器**中找到您的`Spotter`类，然后左键单击并将副本拖入游戏世界。
6.  当你玩关卡时，你会看到红线显示了`Actor`正在执行的轨迹。但是，什么也不会发生，因为我们还没有实现我们的`OnPlayerSpotted`事件。
7.  为了实现此事件，我们需要创建我们的`Spotter`的蓝图子类。
8.  Right-click on `Spotter` in **Content Browser**, and select **Create Blueprint class based on Spotter**. Name the class `BPSpotter`.

    ![How to do it…](../images/00150.jpeg)]

9.  Inside the Blueprint editor, click on the **Override** button in the **Functions** section of the **My Blueprint** panel:

    ![How to do it…](../images/00151.jpeg)]

10.  Select **On Player Spotted**:

    ![How to do it…](../images/00152.jpeg)]

11.  Left-click and drag from the white execution pin on our event. In the context menu that appears, select and add a `Print String` node so that it is linked to the event.

    ![How to do it…](../images/00153.jpeg)]

12.  Play the level again, and verify that walking in front of the trace that the `Spotter` is using now prints a string to the screen.

    ![How to do it…](../images/00154.jpeg)]

## 它是如何工作的…

1.  在我们的`Spotter`对象的构造函数中，我们将基本图元之一 (圆锥体) 加载到静态网格组件中作为视觉表示。
2.  然后，我们旋转圆锥体，使其类似于指向演员的*X*轴的聚光灯。
3.  在`Tick`函数期间，我们得到演员的位置，然后沿着其局部*X*轴找到一个与演员 200 单位的点。我们使用`Super::`调用`Tick`的父类实现，以确保任何其他 tick 功能被保留，尽管我们的覆盖。
4.  我们通过首先获取`Actor`的 Actor-to-world 变换，然后使用该变换来变换指定位置的向量，将局部位置转换为世界空间位置。
5.  变换基于根组件的方向，这是我们在构造函数期间旋转的静态网格组件。
6.  由于存在的旋转，我们需要旋转要转换的向量。鉴于我们希望向量指出圆锥的底部，我们希望沿着负上轴的距离，也就是说，我们希望向量的形式为 (0,0，-d)，其中*d*是实际距离。
7.  计算了跟踪的最终位置后，我们实际上使用`SweepSingleByChannel`函数执行跟踪。
8.  一旦执行扫描，我们尝试将产生的命中`Actor`投射到棋子中。
9.  如果强制转换成功，我们将调用我们的可实现事件`OnPlayerSpotted`，并执行用户定义的蓝图代码。

# 将多播代表暴露于蓝图

多播代表是将事件广播给多个对象的好方法，这些对象**收听**或**订阅**有问题的事件。如果你有一个 C 模块，它会生成潜在任意参与者可能希望得到通知的事件，那么它们是特别无价的。此配方向您展示了如何在 C 中创建一个多播委托，该委托可以在运行时通知一组其他参与者。

## 怎么做…

1.  创建一个名为`King`的新的`StaticMeshActor`类。在类头中添加以下内容:

    ```
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnKingDeathSignature, AKing*, DeadKing);
    ```

2.  向类添加新的`UFUNCTION`:

    ```
    UFUNCTION(BlueprintCallable, Category = King)
    void Die();
    ```

3.  将我们的多播委托的实例添加到类:

    ```
    UPROPERTY(BlueprintAssignable)
    FOnKingDeathSignature OnKingDeath;
    ```

4.  将我们的网格初始化添加到构造函数:

    ```
    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cone.Cone'"));
    if (MeshAsset.Object != nullptr)
    {
      GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);
      GetStaticMeshComponent()->bGenerateOverlapEvents = true;
    }
    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);
    ```

5.  实现`Die`功能:

    ```
    void AKing::Die()
    {
      OnKingDeath.Broadcast(this);
    }
    ```

6.  创建一个名为`Peasant`的新类，也基于`StaticMeshActor`。
7.  在类中声明一个默认构造函数:

    ```
    APeasant();
    ```

8.  声明以下函数:

    ```
    UFUNCTION(BlueprintCallable, category = Peasant)
    void Flee(AKing* DeadKing);
    ```

9.  实现构造函数:

    ```
    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cube.Cube'"));
    if (MeshAsset.Object != nullptr)
    {
      GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);
      GetStaticMeshComponent()->bGenerateOverlapEvents = true;
    }
    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);
    ```

10.  实现`.cpp`文件中的功能:

    ```
    void APeasant::Flee(AKing* DeadKing)
    {
      GEngine->AddOnScreenDebugMessage(-1, 2, FColor::Red, TEXT("Waily Waily!"));
      FVector FleeVector = GetActorLocation() – DeadKing->GetActorLocation();
      FleeVector.Normalize();
      FleeVector *= 500;
      SetActorLocation(GetActorLocation() + FleeVector);
    }
    ```

11.  打开蓝图，根据`APeasant`创建一个名为`BPPeasant`的蓝图类。
12.  Within the blueprint, click and drag away from the white (execution) pin of your `BeginPlay` node. Type `get all`, and you should see **Get All Actors Of Class**. Select the node to place it in your graph.

    ![How to do it…](../images/00155.jpeg)]

13.  Set the value of the purple (class) node to `King`. You can type `king` in the search bar to make locating the class in the list easier.

    ![How to do it…](../images/00156.jpeg)]

14.  Drag from the blue grid (object array) node out into empty space and place a get node.

    ![How to do it…](../images/00157.jpeg)]

15.  Drag away from the blue output pin of the get node, and place a Not Equal (object) node.

    ![How to do it…](../images/00158.jpeg)]

16.  Connect the red (bool) pin of the Not Equal node to a `Branch` node, and wire the execution pin of `Branch` to our `Get All Actors Of Class` node.

    ![How to do it…](../images/00159.jpeg)]

17.  Connect the **True** pin of the branch to the **Bind Event to OnKing Death** node.

    ![How to do it…](../images/00160.jpeg)]

    ### 注意

    请注意，您可能必须在上下文菜单中取消勾选**上下文敏感**，以使**绑定事件**节点可见。

18.  Drag out the red pin on the **Bind Event** node, and select **Add Custom Event…** in the context menu which appears after you release your left mouse button.

    ![How to do it…](../images/00161.jpeg)]

19.  Give your event a name, then connect the white execution pin to a new node named `Flee`.

    ![How to do it…](../images/00162.jpeg)]

20.  Verify that your Blueprint looks like the following figure:

    ![How to do it…](../images/00163.jpeg)]

21.  将您的`King`类的副本拖到级别中，然后在其周围添加一些`BPPeasant`实例。
22.  Open the level Blueprint. Inside it, drag away from `BeginPlay,` and add a `Delay` node. Set the delay to **5** seconds.

    ![How to do it…](../images/00164.jpeg)]

23.  在 “级别” 中选择了您的`King`实例后，在 “级别蓝图” 的 “图形编辑器” 中单击鼠标右键。
24.  Select **Call function on King 1**, and look in the `King` category for a function called `Die`.

    ![How to do it…](../images/00165.jpeg)]

25.  Select `Die`, then connect its execution pin to the output execution pin from the delay.

    ![How to do it…](../images/00166.jpeg)]

26.  When you play your level, you should see that the king dies after 5 seconds, and the peasants all wail and flee directly away from the king.

    ![How to do it…](../images/00167.jpeg)]

    ![How to do it…](../images/00168.jpeg)]

## 它是如何工作的…

1.  我们创建一个新的 actor (为方便起见，基于`StaticMeshActor`，因为它使我们不必为`Actor`视觉表示声明或创建静态网格组件)。
2.  我们使用`DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam`宏声明动态多播委托。动态多播委托允许任意数量的对象订阅 (监听) 和取消订阅 (停止监听)，以便在代理广播时通知它们。
3.  宏包含许多参数-正在创建的新委托签名的类型名称，签名参数的类型，然后是签名参数的名称。
4.  我们还在`King`中添加了一个函数，它将允许我们告诉它死亡。因为我们想将函数暴露给原型设计的蓝图，所以我们将其标记为`BlueprintCallable`。
5.  我们之前使用的`DECLARE_DYNAMIC_MULTICAST_DELEGATE`宏只声明了一个类型; 它没有声明委托的实例，所以我们现在就这样做，引用我们之前在调用宏时提供的类型名称。
6.  动态多播委托可以在其`UPROPERTY`声明中标记`BlueprintAssignable`。这向虚幻表明，当调用委托的`Broadcast`函数时，蓝图系统可以动态地将事件分配给将被调用的委托。
7.  与往常一样，我们为我们的`King`分配一个简单的网格，以便它在游戏场景中具有视觉表示。
8.  Within the `Die` function, we call `Broadcast` on our own delegate. We specified that the delegate would have a parameter that is a pointer to the king which died, so we pass this pointer as a parameter to the broadcast function.

    ### 注意

    如果您希望国王被销毁，而不是在其死亡时播放动画或其他效果，则需要更改代表的声明并以其他类型通过。例如，您可以使用`FVector`，只需直接经过死去的国王的位置，以便农民仍然可以适当地逃离。

    如果没有这个，你可能会出现这样一种情况，即当调用`Broadcast`时，`King`指针是有效的，但是调用`Actor::Destroy()`会在执行绑定的函数之前使它无效。

9.  在我们的下一个`StaticMeshActor`子类中，称为`Peasant`，我们像往常一样使用静态网格组件初始化，与我们用于`King`的形状不同。
10.  在实现农民的`Flee`功能的内部，我们通过在屏幕上打印消息来模拟农民的声音。
11.  然后，我们通过首先找到一个从死去的国王到该农民所在地的向量来计算一个向量，以使农民逃离。
12.  我们对向量进行归一化，以检索指向同一方向的单位向量 (长度为 1)。
13.  缩放归一化向量并将其添加到我们的当前位置计算一个固定距离的位置，在农民直接逃离死去的国王的确切方向上。
14.  `SetActorLocation` is then used to actually teleport the peasants to that location.

    ### 注意

    如果将字符与 AI 控制器一起使用，则可以将`Peasant`路径查找到目标位置，而不是传送。或者，您可以使用在农民的`Tick`中调用的`Lerp`函数来使它们平滑滑动，而不是直接跳到该位置。

## 另见

*   查看[第 4 章](04.html#1KEEU1-c0ca69a0411046888a488e5085138121 "Chapter 4\. Actors and Components")，*演员和组件*，有关演员和组件的更多扩展讨论。[第五章](05.html#22O7C1-c0ca69a0411046888a488e5085138121 "Chapter 5\. Handling Events and Delegates")，*处理事件和委托*，讨论事件如`NotifyActorOverlap`。

# 创建可在蓝图中使用的 C 枚举

枚举是 c 语言中常用的作为 switch 语句的标志或输入。但是，如果要将`enum`值传递给或从蓝图传递给 C，该怎么办？或者，如果您想在蓝图中使用来自 C 的`enum`的`switch`语句，如何让蓝图编辑器知道您的`enum`应该在编辑器中访问？这个食谱告诉你如何让枚举在蓝图中可见。

## 怎么做…

1.  使用编辑器创建一个名为`Tree`的新的`StaticMeshActor`类。
2.  在类声明上方插入以下代码:

    ```
    UENUM(BlueprintType)
    enum TreeType
    {
      Tree_Poplar,
      Tree_Spruce,
      Tree_Eucalyptus,
      Tree_Redwood
    };
    ```

3.  在`Tree`类中添加以下`UPROPERTY`:

    ```
    UPROPERTY(BlueprintReadWrite)
    TEnumAsByte<TreeType> Type;
    ```

4.  将以下内容添加到`Tree`构造函数中:

    ```
    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cylinder.Cylinder'"));
    if (MeshAsset.Object != nullptr)
    {
      GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);
      GetStaticMeshComponent()->bGenerateOverlapEvents = true;
    }
    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);
    ```

5.  基于`Tree`创建一个新的蓝图类，称为`MyTree`。
6.  在`MyTree`的蓝图编辑器中，单击**构建脚本**选项卡。
7.  Right-click in the empty window, and type `treetype`. There is a **Get number of entries in TreeType** node.

    ![How to do it…](../images/00169.jpeg)]

8.  Place it, and then connect its output pin to a **Random Integer** node.

    ![How to do it…](../images/00170.jpeg)]

9.  Connect the output of the random integer to a `ToByte` node.

    ![How to do it…](../images/00171.jpeg)]

10.  In the **Variables** section of the Blueprint panel, expand **Tree** and select **Type**.

    ![How to do it…](../images/00172.jpeg)]

11.  将此拖到图形中，并在出现小上下文菜单时选择**Set**。
12.  Connect the output of the `ToByte` node to the input of the **SET Type** node. You'll see an extra conversion node automatically appear.

    ![How to do it…](../images/00173.jpeg)]

13.  最后，将**构造脚本**的执行引脚连接到**SET Type**节点的执行引脚。
14.  Your Blueprint should look like the following:

    ![How to do it…](../images/00174.jpeg)]

15.  为了验证蓝图是否正常运行，并将一个类型随机分配给我们的树，我们将在事件图中添加一些节点。
16.  Place a `Print String` node after the **Event BeginPlay** event node.

    ![How to do it…](../images/00175.jpeg)]

17.  Place a `Format Text` node, and connect its output to the input of the `Print String` node. A conversion node will be added for you.

    ![How to do it…](../images/00176.jpeg)]

18.  Inside the `Format Text` node, add My Type is {`0`}! to the textbox.

    ![How to do it…](../images/00177.jpeg)]

19.  Drag `Type` from the variables section of the Blueprint into the graph selecting **Get** from the menu.

    ![How to do it…](../images/00178.jpeg)]

20.  Add an **Enum to Name** node to `Type` output pin.

    ![How to do it…](../images/00179.jpeg)]

21.  Connect the Name output to the input pin on `Format Text` labelled `0`.

    ![How to do it…](../images/00180.jpeg)]

22.  Your Event Graph should now look like the following:

    ![How to do it…](../images/00181.jpeg)]

23.  Drag a few copies of your Blueprint into the level and hit **Play**. You should see a number of trees printing information regarding their type, verifying that types are being randomly assigned by the Blueprint code that we created.

    ![How to do it…](../images/00182.jpeg)]

## 它是如何工作的…

1.  像往常一样，我们使用`StaticMeshActor`作为我们的`Actor`的基类，这样我们就可以很容易地在级别中给它一个视觉表示。
2.  枚举类型使用`UENUM`宏向反射系统公开。
3.  我们使用`BlueprintType`说明符将`enum`标记为蓝图可用。
4.  `enum`声明与我们在任何其他上下文中使用的声明相同。
5.  我们的`Tree`需要一个`TreeType`。因为*树有树类型*是我们想要体现的关系，所以我们在`Tree`类中包含一个`TreeType`的实例。
6.  像往常一样，我们需要使用`UPROPERTY()`使反射系统可以访问成员变量。
7.  我们使用`BlueprintReadWrite`说明符将属性标记为在蓝图中同时具有 get 和 set 支持。
8.  枚举类型在`UPROPERTY`中使用时需要包装在`TEnumAsByte`模板中，因此我们将`TEnumAsByte<TreeType>`的实例声明为树的`Type`变量。
9.  `Tree`的构造函数更改只是标准加载和初始化我们在其他配方中使用的静态网格组件前导。
10.  我们创建了一个从我们的`Tree`类继承的蓝图，以便我们可以演示`TreeType enum`的蓝图可访问性。
11.  为了在创建实例时让蓝图随机将类型分配给树，我们需要使用蓝图**构造脚本**。
12.  在**构造脚本**中，我们计算`TreeType enum`中的条目数。
13.  我们生成一个随机数，并将其用作`TreeType enum`类型中的索引来检索要存储为`Type`的值。
14.  但是，随机数节点返回整数。枚举类型在 Blueprint 中被视为字节，因此我们需要使用`ToByte`节点，然后可以通过 Blueprint 隐式转换为`enum`值。
15.  现在我们有了**构造脚本**在创建树实例时将类型分配给它们，我们需要在运行时显示树的类型。
16.  我们使用附加到 “事件图” 选项卡中的`BeginPlay`事件的图形来执行此操作。
17.  为了在屏幕上显示文本，我们使用`Print String`节点。
18.  要执行字符串替换并将我们的类型打印为人类可读的字符串，我们使用`Format Text`节点。
19.  `Format Text`节点采用用大括号括起来的术语，并允许您将其他值替换为返回最终字符串的那些术语。
20.  要将我们的`Type`替换为`Format Text`节点，我们需要将变量存储从`enum`值转换为值的实际名称。
21.  我们可以通过访问我们的`Type`变量，然后使用`Enum to Name`节点来实现。
22.  `Name`，或本机代码中的`FNames`是一种可以通过蓝图转换为字符串的变量，因此我们可以将我们的`Name`连接到`Format Text`节点上的输入。
23.  当我们点击 play 时，图形执行检索放置在关卡中的树实例的类型，并将名称打印到屏幕上。

# 在编辑器中不同地方编辑类属性

使用 Unreal 进行开发时，程序员通常会在 C 中的 actor 或其他对象上实现属性，并使它们对编辑器可见以供设计人员使用。但是，有时查看属性或使其可编辑是有意义的，但仅在对象的默认状态下才有意义。有时，该属性仅应在运行时使用 C 中指定的默认值进行修改。幸运的是，有一些说明符可以帮助我们限制属性何时可用。

## 怎么做…

1.  在名为`PropertySpecifierActor`的编辑器中创建一个新的`Actor`类。
2.  在类中添加以下属性定义:

    ```
    UPROPERTY(EditDefaultsOnly)
    bool EditDefaultsOnly;
    UPROPERTY(EditInstanceOnly)
    bool EditInstanceOnly;
    UPROPERTY(EditAnywhere)
    bool EditAnywhere;
    UPROPERTY(VisibleDefaultsOnly)
    bool VisibleDefaultsOnly;
    UPROPERTY(VisibleInstanceOnly)
    bool VisibleInstanceOnly;
    UPROPERTY(VisibleAnywhere)
    bool VisibleAnywhere;
    ```

3.  编译你的代码并启动编辑器。
4.  根据类创建新的蓝图。
5.  Open the blueprint, and look at the **Class Defaults** section.

    ![How to do it…](../images/00183.jpeg)]

6.  Note which properties are editable and visible.

    ![How to do it…](../images/00184.jpeg)]

7.  Place instances in the level, and view their **Details** panels.

    ![How to do it…](../images/00185.jpeg)]

8.  请注意，一组不同的属性是可编辑的。

## 它是如何工作的…

1.  当指定`UPROPERTY`时，我们可以指出我们希望该值在虚幻编辑器中可用的位置。
2.  `Visible*`前缀表示该值可在所指示对象的**Details**面板中查看。但是，该值将不可编辑。
3.  这并不意味着变量是`const`限定符; 但是，例如，本机代码可以更改该值。
4.  `Edit*`前缀表示可以在编辑器中的**Details**面板中更改属性。
5.  `InstanceOnly`作为后缀表示该属性将仅显示在已放入游戏中的类实例的**Details**面板中。例如，它们在蓝图编辑器的**类默认值**部分中不可见。
6.  `DefaultsOnly`是`InstanceOnly`-`UPROPERTY`的逆，只会显示在**类默认部分**，不能在级别内的单个实例上查看。
7.  后缀`Anywhere`是前面两个后缀的组合-在所有**Details**面板中都可见`UPROPERTY`，这些面板检查对象的默认值或级别中的特定实例。

## 另见

*   这个配方使有问题的属性在检查器中可见，但不允许在实际的蓝图事件图中引用该属性。请参阅下一个食谱，以获取有关如何使其成为可能的说明。

# 在蓝图编辑器图中使属性可访问

前面配方中提到的说明符都很好，但是它们只控制**细节**面板中`UPROPERTY`的可见性。默认情况下，即使使用了适当的说明符，也无法在实际的编辑器图形中查看或访问`UPROPERTY`以在运行时使用。

其他说明符 (可以可选地与先前配方中的说明一起使用) 可用于允许与事件图中的属性进行交互。

## 怎么做…

1.  使用编辑器向导创建一个名为`BlueprintPropertyActor`的新的`Actor`类。
2.  使用 Visual Studio 向演员添加以下`UPROPERTY`:

    ```
    UPROPERTY(BlueprintReadWrite, Category = Cookbook)
    bool ReadWriteProperty;
    UPROPERTY(BlueprintReadOnly, Category = Cookbook)
    bool ReadOnlyProperty;
    ```

3.  编译您的项目，并启动编辑器。
4.  根据您的`BlueprintPropertyActor,`创建一个蓝图类并打开其图形。
5.  Verify that the properties are visible under the category **Cookbook** in the **Variables** sectionof the **My Blueprint** panel.

    ![How to do it…](../images/00186.jpeg)]

6.  Left-click and drag the ReadWrite property into the event graph, and select `Get`.

    ![How to do it…](../images/00187.jpeg)]

7.  重复上一步骤，选择`Set`。
8.  Drag the `ReadOnly` property into the graph, and note that the `Set` node is disabled.

    ![How to do it…](../images/00188.jpeg)]

## 它是如何工作的…

1.  `BlueprintReadWrite`作为`UPROPERTY`说明符向虚幻标题工具指示该属性应同时公开`Get`和`Set`操作以供在蓝图中使用。
2.  顾名思义，`BlueprintReadOnly`是一个说明符，它只允许 Blueprint 检索属性的值; 从不设置它。
3.  当属性由本机代码设置时，`BlueprintReadOnly`可能很有用，但应该在蓝图中可以访问。
4.  应该注意的是，和`BlueprintReadOnly`没有在编辑器的**详细信息**面板或**我的蓝图**部分中指定有关可访问属性的任何内容-这些说明符仅控制 getter/setter 的生成用于蓝图图的节点。

# 从编辑器响应属性更改的事件

当一个设计器更改放置在关卡中的`Actor`的属性时，通常重要的是立即显示该更改的任何视觉结果，而不仅仅是在模拟或播放关卡时。

当使用**Details**面板进行更改时，编辑器会发出一个特殊事件，称为`PostEditChangeProperty`，这使类实例有机会响应正在编辑的属性。

此食谱向您展示了如何处理`PostEditChangeProperty`以获得即时编辑反馈。

## 怎么做…

1.  基于`StaticMeshActor`新建一个名为`APostEditChangePropertyActor`的`Actor`。
2.  将以下`UPROPERTY`添加到类中:

    ```
    UPROPERTY(EditAnywhere)
    bool ShowStaticMesh;
    ```

3.  添加以下函数定义:

    ```
    virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
    ```

4.  将下面的添加到类构造函数中:

    ```
    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cone.Cone'"));
    if (MeshAsset.Object != nullptr)
    {
      GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);
      GetStaticMeshComponent()->bGenerateOverlapEvents = true;
    }
    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);
    ShowStaticMesh = true;
    ```

5.  实施`PostEditChangeProperty`:

    ```
    void APostEditChangePropertyActor::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
    {
      if (PropertyChangedEvent.Property != nullptr)
      {
        const FName PropertyName(PropertyChangedEvent.Property->GetFName());
        if (PropertyName == GET_MEMBER_NAME_CHECKED(APostEditChangePropertyActor, ShowStaticMesh))
        {
          if (GetStaticMeshComponent() != nullptr)
          {
            GetStaticMeshComponent()->SetVisibility(ShowStaticMesh);
          }
        }
      }
      Super::PostEditChangeProperty(PropertyChangedEvent);
    }
    ```

6.  编译你的代码，并启动编辑器。
7.  Drag an instance of your class into the game world, and verify that toggling the boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the editor viewport.

    ![How to do it…](../images/00189.jpeg)]

    ![How to do it…](../images/00190.jpeg)]

## 它是如何工作的…

1.  我们基于`StaticMeshActor`创建一个新的`Actor`，以便通过静态网格轻松访问视觉表示。
2.  添加`UPROPERTY`是为了给我们一个要更改的属性，以导致`PostEditChangeProperty`事件被触发。
3.  `PostEditChangeProperty`是在`Actor`中定义的虚函数。
4.  因此，我们重写了我们类中的函数。
5.  在我们的类构造函数中，我们像往常一样初始化网格，并设置我们的`bool`属性的默认状态以匹配它所控制的组件的可见性。
6.  在`PostEditChangeProperty`内部，我们首先检查该属性是否有效。
7.  假设是，我们使用`GetFName()`检索属性的名称。
8.  `FNames`由引擎内部存储为唯一值表。
9.  接下来我们需要使用`GET_MEMBER_NAME_CHECKED`宏。宏需要许多参数。
10.  第一个是要检查的类的名称。
11.  第二个参数是检查类的属性。
12.  宏将在编译时验证该类是否包含由名称指定的成员。
13.  我们将宏返回的类成员名称与我们的属性包含的名称进行比较。
14.  如果它们相同，则我们验证我们的`StaticMeshComponent`是否已正确初始化。
15.  如果是，我们将其可见性设置为与我们的`ShowStaticMesh`布尔值匹配。

# 实现原生代码构建脚本

在 Blueprint 中，**构造脚本**是一个事件图，无论是在编辑器视口中被拖动还是通过**Details**面板中的直接输入，都可以在附加到的对象上随时更改属性。

例如，构造脚本允许所讨论的对象根据其新位置 “重建” 自身，或者根据用户选择的选项更改其包含的组件。

用虚实引擎在 C 中编码时，等价的概念是`OnConstruction`函数。

## 怎么做…

1.  基于`StaticMeshActor`新建一个名为`AOnConstructionActor`的`Actor`。
2.  将以下`UPROPERTY`添加到类中:

    ```
    UPROPERTY(EditAnywhere)
    bool ShowStaticMesh;
    ```

3.  添加以下函数定义:

    ```
    virtual void OnConstruction(const FTransform& Transform) override;
    ```

4.  将下面的添加到类构造函数中:

    ```
    auto MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT("StaticMesh'/Engine/BasicShapes/Cone.Cone'"));
    if (MeshAsset.Object != nullptr)
    {
      GetStaticMeshComponent()->SetStaticMesh(MeshAsset.Object);
      GetStaticMeshComponent()->bGenerateOverlapEvents = true;
    }
    GetStaticMeshComponent()->SetMobility(EComponentMobility::Movable);
    ShowStaticMesh = true;
    ```

5.  实施`OnConstruction`:

    ```
    void AOnConstructionActor::OnConstruction(const FTransform& Transform)
    {
      GetStaticMeshComponent()->SetVisibility(ShowStaticMesh);
    }
    ```

6.  编译你的代码，并启动编辑器。
7.  将您的类的实例拖到游戏世界中，并验证切换`ShowStaticMesh`的布尔值是否会切换编辑器视口中网格的可见性。
8.  `OnConstruction`当前不会对放置在关卡中的 C 演员运行，如果它们被移动的话。
9.  To test this, place a breakpoint in your `OnConstruction` function, then move your actor around the level.

    ### 提示

    要放置断点，请将光标放在所需的行上，然后在 Visual Studio 中单击*F9*。

10.  You'll notice that the function doesn't get called, but if you toggle the `ShowStaticMesh` Boolean, it does, causing your breakpoint to trigger.

    ### 注意

    为了看看为什么，看看`AActor::PostEditMove`:

    ```
    UBlueprint* Blueprint = Cast<UBlueprint>(GetClass()->ClassGeneratedBy);
    if(Blueprint && (Blueprint->bRunConstructionScriptOnDrag || bFinished) && !FLevelUtils::IsMovingLevel() )
    {
      FNavigationLockContext NavLock(GetWorld(), ENavigationLockReason::AllowUnregister);
      RerunConstructionScripts();
    }
    ```

    此处的顶行将当前对象的`UClass`强制转换为`UBlueprint`，并且仅在类是蓝图的情况下再次运行构造脚本和`OnConstruction`。

## 它是如何工作的…

1.  我们基于`StaticMeshActor`创建了一个新的 Actor，以便通过静态网格轻松访问视觉表示。
2.  添加`UPROPERTY`是为了给我们一个要更改的属性-导致`PostEditChangeProperty`事件被触发。
3.  `OnConstruction`是在 Actor 中定义的虚函数。
4.  因此，我们重写了我们类中的函数。
5.  在我们的类构造函数中，我们像往常一样初始化网格，并设置我们的`bool`属性的默认状态以匹配它所控制的组件的可见性。
6.  在`OnConstruction`内部，演员使用这样做所需的任何属性来重建自己。
7.  对于这个简单的示例，我们设置网格的可见性以匹配我们的`ShowStaticMesh`属性的值。
8.  这也可以扩展到根据`ShowStaticMesh`变量的值更改其他值。
9.  您会注意到，我们不会像以前的食谱那样对正在更改的特定属性进行显式过滤`PostEditChangeProperty`。
10.  对于对象上更改的每个属性，`OnConstruction`脚本都将完整运行。
11.  它没有测试哪个属性刚刚被编辑的方法，所以你需要明智地在其中放置计算密集型代码。

# 新建编辑器模块

以下食谱都与特定于编辑器模式的代码和引擎模块交互。因此，创建一个新模块被认为是一种良好的做法，该模块仅在引擎以编辑器模式运行时才会加载，以便我们可以将所有仅编辑器的代码放入其中。

## 怎么做…

1.  在文本编辑器 (如记事本或记事本) 中打开项目的`.uproject`文件。
2.  将以下内容的粗体部分添加到文件中:

    ```
    {
      "FileVersion": 3,
      "EngineAssociation": "4.11",
      "Category": "",
      "Description": "",
      "Modules": [
        {
          "Name": "UE4Cookbook",
          "Type": "Runtime",
          "LoadingPhase": "Default",
          "AdditionalDependencies": [
            "Engine",
            "CoreUObject"
          ]
        },
     {
     "Name": "UE4CookbookEditor",
     "Type": "Editor",
     "LoadingPhase": "PostEngineInit",
     "AdditionalDependencies": [
     "Engine",
     "CoreUObject"
     ]
     }
      ]
    }
    ```

3.  注意第一个模块后的逗号，第二个大括号前的逗号。
4.  在您的源文件夹中，使用与您在`uproject`文件中指定的相同名称 (在此实例中，`"UE4CookbookEditor"`) 创建一个新文件夹。
5.  在这个新文件夹中，创建一个名为`UE4CookbookEditor.Build.cs`的文件。
6.  在文件中插入以下内容:

    ```
    using UnrealBuildTool;

    public class UE4CookbookEditor : ModuleRules
    {
      public UE4CookbookEditor(TargetInfo Target)
      {
        PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "RHI", "RenderCore", "ShaderCore" });
        PublicDependencyModuleNames.Add("UE4Cookbook");
        PrivateDependencyModuleNames.AddRange(new string[] { "UnrealEd" });
      }
    }
    ```

7.  创建一个名为`UE4CookbookEditor.h`的新文件，并添加以下内容:

    ```
    #pragma once
    #include "Engine.h"
    #include "ModuleManager.h"
    #include "UnrealEd.h"

    class FUE4CookbookEditorModule: public IModuleInterface
    {
    };
    ```

8.  最后，创建一个名为`UE4CookbookEditor.cpp`的新源文件。
9.  添加以下代码:

    ```
    #include "UE4CookbookEditor.h"
    IMPLEMENT_GAME_MODULE(FUE4CookbookEditorModule, UE4CookbookEditor)
    ```

10.  最后，如果打开 Visual Studio，请关闭它，然后右键单击`.uproject`文件，然后选择**生成 Visual Studio 项目文件**。
11.  You should see a small window launch, display a progress bar, and then close.

    ![How to do it…](../images/00191.jpeg)]

12.  您现在可以启动 Visual Studio，验证您的新模块在 IDE 中可见，并成功编译您的项目。
13.  The module is now ready for the next set of recipes.

    ### 注意

    在此编辑器模块中进行的代码更改将不支持与运行时模块中的代码相同的热重新加载。如果遇到编译错误，其中提到对生成的头文件的更改，只需关闭编辑器，然后从 IDE 中重建即可。

## 它是如何工作的…

1.  虚幻项目使用`.uproject`文件格式来指定有关项目的许多不同信息。
2.  此信息用于通知标头和构建工具有关构成此项目的模块，并用于代码生成和`makefile`创建。
3.  该文件使用 JSON 样式的格式。
4.  其中包括以下内容:
    *   项目应在其中打开的引擎版本
    *   项目中使用的模块列表
    *   模块声明列表
5.  这些模块声明中的每一个都包含以下内容:
    *   模块的名称。
    *   模块的类型-是编辑器模块 (仅在编辑器构建中运行，可以访问仅编辑器类) 还是运行时模块 (在编辑器和 Shipping 构建中都运行)。
    *   模块的加载阶段-模块可以在程序启动期间在不同点加载。此值指定应加载模块的点，例如，如果其他模块中存在应首先加载的依赖关系。
    *   模块的依赖项列表。这些是必不可少的模块，其中包含模块所依赖的导出函数或类。
6.  我们在`uproject file`中添加了一个新模块。该模块的名称是`UE4CookbookEditor` (通常，对于编辑器模块，应将`Editor`附加到主游戏模块中)。
7.  此模块被标记为编辑器模块，并设置为在基线引擎之后加载，以便它可以使用引擎代码中声明的类。
8.  我们模块的依赖项暂时保留为默认值。
9.  更改了`uproject`文件以包含我们的新模块，我们需要一个构建脚本。
10.  构建脚本是用 C # 编写的，并取名`<ModuleName>.Build.cs`。
11.  C # 与 C 不同，它不使用单独的头文件和实现-它都在一个`.cs`文件中。
12.  我们想要访问在`UnrealBuildTool`模块中声明的类，所以我们包含一个`using`语句来表示我们想要访问该命名空间。
13.  我们创建一个与我们的模块同名的`public`类，它继承自`ModuleRules`。
14.  在我们的构造函数中，我们将许多模块添加到该模块的依赖项中。
15.  既有私有依赖关系，也有公共依赖关系。根据`ModuleRules`类的代码，公共依赖是模块的公共头文件所依赖的模块。私有依赖是私有代码所依赖的模块。公共标头和私有代码中使用的任何内容都应进入`PublicDependencyModuleNames`数组。
16.  你会注意到我们的`PublicDependencyModuleNames`数组包含我们的主游戏模块。这是因为本章中的一些食谱将扩展编辑器，以更好地支持在我们的主游戏模块中定义的类。
17.  现在我们已经告诉构建系统，我们有一个新的模块要通过项目文件来构建，并且我们已经指定了如何使用构建脚本来构建模块，我们需要创建 C 类，这是我们的实际模块。
18.  我们创建一个头文件，其中包括引擎头、`ModuleManager`头和`UnrealEd`头。
19.  我们包括`ModuleManager`，因为它定义了我们的模块将继承的类`IModuleInterface`。
20.  我们还将包括`UnrealEd`，因为我们正在编写一个编辑器模块，该模块将需要访问编辑器功能。
21.  我们声明的类从`IModuleInterface`继承，并从通常的前缀`F`取其名称，然后是模块名称。
22.  在`.cpp`文件中，我们包含模块的标头，然后使用`IMPLEMENT_GAME_MODULE`宏。
23.  `IMPLEMENT_GAME_MODULE`声明一个导出的 C 函数，`InitializeModule()`，它返回我们新的 module 类的一个实例。
24.  这意味着虚幻可以简单地在任何导出它的库上调用`InitializeModule()`来检索对实际模块实现的引用，而不需要知道它是什么类。
25.  添加了新模块后，我们现在需要重建 Visual Studio 解决方案，因此我们关闭 Visual Studio，然后使用上下文菜单重新生成项目文件。
26.  随着项目的重建，新模块将在 Visual Studio 中可见，我们可以像往常一样向它添加代码。

# 创建新的工具栏按钮

如果您已经创建了一个自定义工具或窗口在编辑器中显示，您可能需要某种方式让用户让它出现。最简单的方法是创建一个工具栏自定义，添加一个新的工具栏按钮，并让它在单击时显示您的窗口。

按照以前的配方创建一个新的引擎模块，因为我们需要它来初始化工具栏自定义。

## 怎么做…

1.  创建一个新的头文件，并插入以下类声明:

    ```
    #pragma once
    #include "Commands.h"
    #include "EditorStyleSet.h"
    /**
     * 
     */
    class FCookbookCommands : public TCommands<FCookbookCommands>
    {
      public:
      FCookbookCommands()
      :TCommands<FCookbookCommands>(FName(TEXT("UE4_Cookbook")), FText::FromString("Cookbook Commands"), NAME_None, FEditorStyle::GetStyleSetName()) 
      {
      };
      virtual void RegisterCommands() override;

      TSharedPtr<FUICommandInfo> MyButton;
    };
    ```

2.  通过在`.cpp`文件中放置以下内容来实现新类:

    ```
    #include "UE4CookbookEditor.h"
    #include "Commands.h"
    #include "CookbookCommands.h"

    void FCookbookCommands::RegisterCommands()
    {
      #define LOCTEXT_NAMESPACE ""
      UI_COMMAND(MyButton, "Cookbook", "Demo Cookbook Toolbar Command", EUserInterfaceActionType::Button, FInputGesture());
      #undef LOCTEXT_NAMESPACE
    }
    ```

3.  在模块类中添加以下内容:

    ```
    virtual void StartupModule() override;
    virtual void ShutdownModule() override;
    TSharedPtr<FExtender> ToolbarExtender;
    TSharedPtr<const FExtensionBase> Extension;
    void MyButton_Clicked()
    {
      TSharedRef<SWindow> CookbookWindow = SNew(SWindow)
      .Title(FText::FromString(TEXT("Cookbook Window")))
      .ClientSize(FVector2D(800, 400))
      .SupportsMaximize(false)
      .SupportsMinimize(false);

      IMainFrameModule& MainFrameModule = FModuleManager::LoadModuleChecked<IMainFrameModule>(TEXT("MainFrame"));

      if (MainFrameModule.GetParentWindow().IsValid())
      {
        FSlateApplication::Get().AddWindowAsNativeChild(CookbookWindow,MainFrameModule.GetParentWindow().ToSharedRef());
      }
      else
      {
        FSlateApplication::Get().AddWindow(CookbookWindow);
      }
    };
    void AddToolbarExtension(FToolBarBuilder &builder)
    {
      FSlateIcon IconBrush = FSlateIcon(FEditorStyle::GetStyleSetName(), "LevelEditor.ViewOptions", "LevelEditor.ViewOptions.Small");

      builder.AddToolBarButton(FCookbookCommands::Get().MyButton, NAME_None, FText::FromString("My Button"), FText::FromString("Click me to display a message"), IconBrush, NAME_None);
    };
    ```

4.  确保到`#include`也为您的命令类的头文件。
5.  我们现在需要实现`StartupModule`和`ShutdownModule`:

    ```
    void FUE4CookbookEditorModule::StartupModule()
    {
      FCookbookCommands::Register();
      TSharedPtr<FUICommandList> CommandList = MakeShareable(new FUICommandList());
      CommandList->MapAction(FCookbookCommands::Get().MyButton, FExecuteAction::CreateRaw(this, &FUE4CookbookEditorModule::MyButton_Clicked), FCanExecuteAction());
      ToolbarExtender = MakeShareable(new FExtender());
      Extension = ToolbarExtender->AddToolBarExtension("Compile", EExtensionHook::Before, CommandList, FToolBarExtensionDelegate::CreateRaw(this, &FUE4CookbookEditorModule::AddToolbarExtension));

      FLevelEditorModule& LevelEditorModule = FModuleManager::LoadModuleChecked<FLevelEditorModule>("LevelEditor");
      LevelEditorModule.GetToolBarExtensibilityManager()->AddExtender(ToolbarExtender);
    }

    void FUE4CookbookEditorModule::ShutdownModule()
    {
      ToolbarExtender->RemoveExtension(Extension.ToSharedRef());
      Extension.Reset();
      ToolbarExtender.Reset();
    }
    ```

6.  添加以下内容包括:

    ```
    #include "LevelEditor.h"
    #include "SlateBasics.h"
    #include "MultiBoxExtender.h"
    #include "Chapter8/CookbookCommands.h"
    ```

7.  编译您的项目，并启动编辑器。
8.  Verify that there's a new button on the toolbar in the main level editor, which can be clicked on to open a new window:

    ![How to do it…](../images/00192.jpeg)]

## 它是如何工作的…

1.  虚幻的编辑器 UI 基于命令的概念。命令是一种设计模式，允许用户界面和它需要执行的操作之间更松散的耦合。
2.  为了创建包含一组命令的类，必须从`TCommands`继承。
3.  `TCommands`是一个模板类，它利用**奇怪的重复出现的模板模式** (**CRTP**)。CRTP 在整个过程中普遍使用**Slate**UI 代码作为创建编译时多态性的一种手段。
4.  在`FCookbookCommands`构造函数的 initializer 列表中，我们调用父类构造函数，传入许多参数。
5.  第一个参数是命令集的名称，是一个简单的`FName`。
6.  第二个参数是工具提示/人类可读字符串，因此使用`FText`，因此它可以在必要时支持本地化。
7.  如果有一个父命令组，则第三个参数包含该组的名称。否则，它包含`NAME_None`。
8.  构造函数的最终参数是 Slate 样式集，其中包含命令集将使用的任何命令图标。
9.  `RegisterCommands()`函数允许`TCommands`派生类创建它们需要的任何命令对象。从该函数返回的结果`FUICommandInfo`实例作为成员存储在`Commands`类中，以便 UI 元素或函数可以绑定到命令。
10.  这就是为什么我们有成员变量`TSharedPtr<FUICommandInfo> MyButton`的原因。
11.  在类的实现中，我们只需要在`RegisterCommands`中创建命令。
12.  用于创建`FUICommandInfo`实例的`UI_COMMAND`宏期望定义本地化命名空间，即使它只是一个空的默认命名空间。
13.  因此，即使我们不打算使用本地化，我们也需要用`#defines`封闭我们的`UI_COMMAND`调用，以便为`LOCTEXT_NAMESPACE`设置有效值。
14.  实际的`UI_COMMAND`宏需要多个参数。
15.  第一个参数是要存储中的`FUICommandInfo`的变量。
16.  第二个参数是命令的人类可读名称。
17.  第三个参数是对命令的描述。
18.  第四个参数是`EUserInterfaceActionType`。此枚举本质上指定正在创建哪种按钮。它支持`Button`、`ToggleButton`、`RadioButton`和`Check`作为有效类型。
19.  按钮是简单的通用按钮。切换按钮存储打开和关闭状态。单选按钮类似于切换，但与其他单选按钮分组，一次只能启用一个。最后，复选框在按钮旁边显示一个只读复选框。
20.  `UI_COMMAND`的最后一个参数是输入和弦，或者激活命令所需的键组合。
21.  此参数主要用于定义链接到相关命令而不是按钮的热键的组合键。因此，我们使用一个空的`InputGesture`。
22.  所以我们现在有了一组命令，但是我们还没有告诉引擎我们想将该组添加到工具栏上显示的命令中。我们还没有设置单击按钮时实际发生的情况。为了做到这一点，我们需要在模块开始时执行一些初始化，因此我们将一些代码放入`StartupModule`/`ShutdownModule`函数中。
23.  在`StartupModule`内部，我们在前面定义的 commands 类上调用静态`Register`函数。
24.  然后，我们使用`MakeShareable`函数创建一个指向命令列表的共享指针。
25.  在命令列表中，我们使用`MapAction`在我们设置为`FCookbookCommands`成员的`UICommandInfo`对象与调用命令时要执行的实际函数之间创建映射或关联。
26.  请注意，我们没有明确设置任何关于这里可以用来调用命令的内容。
27.  为了执行这个映射，我们调用`MapAction`函数。`MapAction`的第一个参数是一个`FUICommandInfo`对象，我们可以通过它的静态`Get()`方法从`FCookbookCommands`中检索实例。
28.  `FCookbookCommands`实现为一个单例-一个存在于整个应用程序中的单个实例的类。你会在大多数地方看到这种模式 -- 引擎中有一种静态的`Get()`方法。
29.  `MapAction`函数的第二个参数是绑定到执行命令时要调用的函数的委托。
30.  因为`UE4CookbookEditorModule`是一个原始 C 类而不是`UObject`，并且我们想调用一个成员函数而不是`static`函数，所以我们使用`CreateRaw`创建一个绑定到原始 C 成员函数的新委托。
31.  `CreateRaw`期望有一个指向对象实例的指针，以及对要在该指针上调用的函数引用。
32.  `MapAction`的第三个参数是一个委托，用于测试操作是否可以执行。因为我们希望命令一直可执行，所以我们可以使用一个简单的预定义委托，该委托始终返回`true`。
33.  通过在我们的命令和它应该调用的操作之间创建关联，我们现在需要告诉扩展系统我们想要向工具栏添加新命令。
34.  我们可以通过`FExtender`类来做到这一点，它可以用来扩展菜单、上下文菜单或工具栏。
35.  我们最初创建一个实例`FExtender`作为共享指针，这样当模块关闭时，我们的扩展就不会被初始化。
36.  然后，我们在新的扩展器上调用`AddToolBarExtension`，将结果存储在共享指针中，以便我们可以在模块取消初始化时将其删除。
37.  `AddToolBarExtension's`第一个参数是我们要添加扩展的扩展点的名称。
38.  要找到要放置扩展的，我们首先需要在编辑器 UI 中打开扩展点的显示。
39.  To do so, open **Editor Preferences** in the **Edit** menu within the editor:

    ![How it works…](../images/00193.jpeg)]

40.  Open **General** | **Miscellaneous**, and select **Display UIExtension Points**:

    ![How it works…](../images/00194.jpeg)]

41.  Restart the editor, and you should see green text overlaid on the editor UI, as in the following screenshot:

    ![How it works…](../images/00195.jpeg)]

42.  绿色的文本表示`UIExtensionPoint`，文本的值是我们应该提供给`AddToolBarExtension`函数的字符串。
43.  我们将在这个食谱中添加我们的扩展到**编译**扩展点，但是当然，你可以使用任何其他你想要的扩展点。
44.  重要的是要注意，将工具栏扩展添加到菜单扩展点将静默失败，反之亦然。
45.  `AddToolBarExtension`的第二个参数是相对于指定的扩展点的位置锚。我们选择了`FExtensionHook::Before`，所以我们的图标将显示在编译点之前。
46.  下一个参数是包含映射动作的命令列表。
47.  最后，最后一个参数是一个委托，负责将 UI 控件实际添加到扩展点的工具栏和我们之前指定的锚。
48.  委托绑定到具有 void (`*func` )( `FToolBarBuilder`和`builder`) 形式的函数。在这个例子中，它是一个在我们的模块类中定义的称为`AddToolbarExtension`的函数。
49.  当调用函数时，在`builder`上调用添加 UI 元素的命令将把这些元素应用到我们指定的 UI 中的位置。
50.  最后，我们需要在此功能中加载级别编辑器模块，以便可以将扩展器添加到级别编辑器中的主工具栏中。
51.  像往常一样，我们可以使用`ModuleManager`加载模块并返回对其的引用。
52.  有了这个参考，我们可以得到该模块的工具栏可扩展性管理器，并告诉它添加我们的扩展器。
53.  虽然这一开始可能看起来很麻烦，但如果您想在不同的编辑器窗口之间创建一致的 UI 布局，目的是允许您将相同的工具栏扩展应用于不同模块中的多个工具栏。
54.  当然，初始化扩展的对应项是在卸载模块时将其删除。为此，我们从扩展器中删除扩展，然后为扩展器和扩展恢复其内存分配的共享指针 null。
55.  编辑器模块中的`AddToolBarExtension`功能是负责将 UI 元素实际添加到可以调用我们的命令的工具栏。
56.  它通过调用作为函数参数传入的`FToolBarBuilder`实例上的函数来做到这一点。
57.  首先，我们使用`FSlateIcon`构造函数为新的工具栏按钮检索适当的图标。
58.  加载图标后，我们在`builder`实例上调用`AddToolBarButton`。
59.  `AddToolbarButton`具有多个参数。
60.  第一个参数是要绑定到的命令-您会注意到它是我们之前在将操作绑定到命令时访问的相同的`MyButton`成员。
61.  第二个参数是我们之前指定的扩展钩子的覆盖，但是我们不想覆盖它，所以我们可以使用`NAME_None`。
62.  第三个参数是我们创建的新按钮的标签覆盖。
63.  参数四是新按钮的工具提示。
64.  倒数第二个参数是按钮的图标，最后一个参数是名称，如果您希望使用编辑器教程框架，则用于引用此按钮元素以突出显示支持。

# 创建新菜单条目

创建新菜单项的工作流程与创建新工具栏按钮的工作流程几乎相同，因此此配方将基于前一个，并向您展示如何将其中创建的命令添加到菜单而不是工具栏中。

## 怎么做…

1.  在你的`module`类中创建一个新函数:

    ```
    void AddMenuExtension(FMenuBuilder &builder)
    {
      FSlateIcon IconBrush = FSlateIcon(FEditorStyle::GetStyleSetName(), "LevelEditor.ViewOptions", "LevelEditor.ViewOptions.Small");

      builder.AddMenuEntry(FCookbookCommands::Get().MyButton);
    };
    ```

2.  在`StartupModule`函数中找到以下代码:

    ```
    Extension = ToolbarExtender->AddToolBarExtension("Compile", EExtensionHook::Before, CommandList, FToolBarExtensionDelegate::CreateRaw(this, &FUE4CookbookEditorModule::AddToolbarExtension));
    LevelEditorModule.GetToolBarExtensibilityManager()->AddExtender(ToolbarExtender);
    ```

3.  将前面的代码替换为:

    ```
    Extension = ToolbarExtender->AddMenuExtension("LevelEditor", EExtensionHook::Before, CommandList, FMenuExtensionDelegate::CreateRaw(this, &FUE4CookbookEditorModule::AddMenuExtension));
    LevelEditorModule.GetMenuExtensibilityManager()->AddExtender(ToolbarExtender);
    ```

4.  编译你的代码，并启动编辑器。
5.  Verify that you now have a menu entry under the **Window** menu that displays the **Cookbook** window when clicked. If you followed the preceding recipe, you'll also see the green text listing the UI extension points, including the one we used in this recipe (**LevelEditor**).

    ![How to do it…](../images/00196.jpeg)]

## 它是如何工作的…

1.  请注意，`ToolbarExtender`类型为`FExtender`，而不是`FToolbarExtender`或`FMenuExtender`。
2.  通过使用通用的`FExtender`类而不是特定的子类，框架允许您创建一系列命令函数映射，这些映射可以在菜单或工具栏上使用。实际添加 UI 控件的委托 (在本例中，`AddMenuExtension`) 可以将这些控件链接到您的`FExtender`中的命令子集。
3.  这样，您不需要为不同类型的扩展具有不同的`TCommands`类，并且您可以将命令放置到单个中央类中，而不管这些命令从 UI 调用的位置如何。
4.  结果，仅需要进行以下更改:
    1.  将呼叫与`AddMenuExtension`交换到`AddToolBarExtension`。
    2.  创建一个可以绑定到`FMenuExtensionDelegate`而不是`FToolbarExtensionDelegate`的函数。
    3.  将扩展器添加到菜单可扩展性管理器，而不是工具栏可扩展性管理器。

# 新建编辑器窗口

当您拥有具有用户可配置设置的新工具，或者想要使用自定义编辑器向人们显示一些信息时，自定义编辑器窗口非常有用。

在开始之前，请务必按照本章前面的食谱进行编辑模块。

通读*创建新菜单项*或*创建新工具栏按钮*食谱，以便您可以在编辑器中创建一个按钮来启动我们的新窗口。

## 怎么做…

1.  在你的命令的绑定函数里面，添加如下代码:

    ```
    TSharedRef<SWindow> CookbookWindow = SNew(SWindow)
    .Title(FText::FromString(TEXT("Cookbook Window")))
    .ClientSize(FVector2D(800, 400))
    .SupportsMaximize(false)
    .SupportsMinimize(false)
    [
      SNew(SVerticalBox)
      +SVerticalBox::Slot()
      .HAlign(HAlign_Center)
      .VAlign(VAlign_Center)
      [
        SNew(STextBlock)
        .Text(FText::FromString(TEXT("Hello from Slate")))
      ]
    ];
    IMainFrameModule& MainFrameModule = FModuleManager::LoadModuleChecked<IMainFrameModule>(TEXT("MainFrame"));

    if (MainFrameModule.GetParentWindow().IsValid())
    {
      FSlateApplication::Get().AddWindowAsNativeChild(CookbookWindow, MainFrameModule.GetParentWindow().ToSharedRef());
    }
    else
    {
      FSlateApplication::Get().AddWindow(CookbookWindow);
    }
    ```

2.  编译你的代码，并启动编辑器。
3.  When you activate the command you created, either by selecting the custom menu option or the toolbar option that you added, you should see that the window has been displayed with some centered text in the middle:

    ![How to do it…](../images/00197.jpeg)]

## 它是如何工作的…

1.  正如应该不言自明的那样，你的新编辑器窗口不会显示自己，所以，在这个食谱的开始，提到你应该已经实现了一个自定义菜单或工具栏按钮或控制台命令，我们可以用它来触发新窗口的显示。
2.  Slate 的所有小部件通常以`TSharedRef< >`或`TSharedPtr< >`的形式进行交互。
3.  `SNew()`函数返回在请求的 widget 类上模板化的`TSharedRef`。
4.  正如本章其他地方提到的那样，Slate 小部件具有它们实现的许多函数，这些函数都返回调用该函数的对象。这允许在创建时使用方法链接来配置对象。
5.  这就是允许`<Widget>.Property(Value).Property(Value)`的 Slate 语法。
6.  在此配方中的小部件上设置的属性是窗口标题，窗口大小以及是否可以最大化和最小化窗口。
7.  设置了小部件上的所有必要属性后，可以使用括号运算符 (`[]`) 指定要放置在小部件内的内容，例如按钮内的图片或标签。
8.  `SWindow`是一个顶级小部件，只有一个用于子小部件的插槽，因此我们不需要自己为它添加插槽。我们通过在一对括号内创建内容来将内容放入该插槽。
9.  我们创建的内容是`SVerticalBox`，这是一个小部件，可以为垂直列表中显示的子小部件具有任意数量的插槽。
10.  对于要放入垂直列表中的每个小部件，我们需要创建一个**插槽**。
11.  最简单的方法是使用重载`+`运算符和`SVerticalBox::Slot()`函数。
12.  `Slot()`返回一个像其他任何一样的小部件，所以我们可以像在我们的`SWindow`上一样在它上设置属性。
13.  此配方使用`HAlign`和`VAlign`将插槽的内容集中在水平轴和垂直轴上。
14.  `Slot`具有一个子小部件，它是在`[]`运算符中创建的，就像`SWindow`一样。
15.  在`Slot`内容中，我们创建了一个包含一些自定义文本的文本块。
16.  我们的新的`SWindow`现在添加了它的子小部件，但是它还没有被显示，因为它没有被添加到窗口层次结构中。
17.  主框架模块用于检查我们是否有顶级编辑器窗口，如果存在，我们的新窗口将作为子窗口添加。
18.  如果没有要添加的顶级窗口作为子窗口，那么我们使用 Slate 应用程序 singleton 添加我们的窗口而没有父窗口。
19.  如果您想查看我们创建的窗口的层次结构，可以使用 Slate Widget Reflector，可以通过**窗口** | **开发人员工具** | **Widget Reflector**访问。
20.  If you select **Pick Live Widget**, and hover your cursor over the text in the center of our custom window, you will be able to see the **SWindow** with our custom widgets added to its hierarchy.

    ![How it works…](../images/00198.jpeg)]

## 另见

*   [第 9 章](09.html#3KB4K1-c0ca69a0411046888a488e5085138121 "Chapter 9\. User Interfaces – UI and UMG")，*用户界面-UI 和 UMG*，都是关于 UI 的，并将向您展示如何添加额外的元素到您的新自定义窗口

# 创建新的资产类型

在项目中的某个点，您可能需要创建一个新的自定义资产类别，例如，用于在 RPG 中存储对话数据的资产。

为了将它们与**内容浏览器**正确集成，您需要创建一个新的资产类型。

## 怎么做…

1.  基于`UObject`创建自定义资产:

    ```
    #pragma once

    #include "Object.h"
    #include "MyCustomAsset.generated.h"

    /**
     * 
     */
    UCLASS()
    class UE4COOKBOOK_API UMyCustomAsset : public UObject
    {
      GENERATED_BODY()
      public:
      UPROPERTY(EditAnywhere, Category = "Custom Asset")
      FString Name;
    };
    ```

2.  基于`UFactory`创建一个名为`UCustomAssetFactory`的类，覆盖`FactoryCreateNew`:

    ```
    #pragma once

    #include "Factories/Factory.h"
    #include "CustomAssetFactory.generated.h"

    /**
     * 
     */
    UCLASS()
    class UE4COOKBOOK_API UCustomAssetFactory : public UFactory
    {
      GENERATED_BODY()

      public:
      UCustomAssetFactory();

      virtual UObject* FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn, FName CallingContext) override;
    };
    ```

3.  实现类:

    ```
    #include "UE4Cookbook.h"
    #include "MyCustomAsset.h"
    #include "CustomAssetFactory.h"

    UCustomAssetFactory::UCustomAssetFactory()
    :Super()
    {
      bCreateNew = true;
      bEditAfterNew = true;
      SupportedClass = UMyCustomAsset::StaticClass();
    }

    UObject* UCustomAssetFactory::FactoryCreateNew(UClass* InClass, UObject* InParent, FName InName, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn, FName CallingContext)
    {
      auto NewObjectAsset = NewObject<UMyCustomAsset>(InParent, InClass, InName, Flags);
      return NewObjectAsset;
    }
    ```

4.  编译你的代码，然后打开编辑器。
5.  Right-click in **Content Browser**, and under the **Miscellaneous** tab of the **Create Advanced Asset** section, you should see your new class, and be able to create instances of your new custom type.

    ![How to do it…](../images/00199.jpeg)]

## 它是如何工作的…

1.  第一个类是游戏运行时可以存在的实际对象。无论您需要什么，它都是您的纹理，数据文件或曲线数据。
2.  出于此配方的目的，最简单的示例是具有要包含名称的`FString`属性的资产。
3.  该属性被标记为`UPROPERTY`，以便它保留在内存中，另外还被标记为`EditAnywhere`，以便它在默认对象和它的实例上都可以编辑。
4.  二等是`Factory`。Unreal 使用`Factory`设计模式创建资产实例。
5.  这意味着有一个通用的基础`Factory`，它使用虚拟方法来声明对象创建的接口，然后`Factory`子类负责创建所讨论的实际对象。
6.  这种方法的优点是，如果需要，用户创建的子类可以潜在地实例化其自己的子类之一; 它隐藏了关于决定远离请求创建的对象创建哪个对象的实现细节。
7.  使用`UFactory`作为我们的基类，我们包含了适当的标头。
8.  构造函数被覆盖，因为在默认构造函数运行后，我们要为新工厂设置许多属性。
9.  `bCreateNew`表示工厂当前能够从头开始创建有问题对象的新实例。
10.  `bEditAfterNew`表示我们希望在创建后立即编辑新创建的对象。
11.  `SupportedClass`变量是`UClass`的实例，其中包含有关工厂将创建的对象类型的反射信息。
12.  我们的`UFactory`子类最重要的功能是实际的工厂方法-`FactoryCreateNew`。
13.  `FactoryCreateNew`负责确定应该创建的对象的类型，并使用`NewObject`构造该类型的实例。它将以下参数传递给`NewObject`调用。
14.  `InClass`是将要构造的对象的类。
15.  `InParent`是应该包含将要创建的新对象的对象。如果未指定，则假定该对象进入瞬态包，这意味着不会自动保存该对象。
16.  `Name`是要创建的对象的名称。
17.  `Flags`是创建标志的位掩码，用于控制诸如使对象在其包含的包外部可见的事物。
18.  在`FactoryCreateNew`内，可以决定应该实例化哪个子类。也可以执行其他初始化; 例如，如果存在需要手动实例化或初始化的子对象，则可以在此处添加它们。
19.  来自此功能的引擎代码的示例如下:

    ```
    UObject* UCameraAnimFactory::FactoryCreateNew(UClass* Class,UObject* InParent,FName Name,EObjectFlags Flags,UObject* Context,FFeedbackContext* Warn)
    {
      UCameraAnim* NewCamAnim = NewObject<UCameraAnim>(InParent, Class, Name, Flags);
      NewCamAnim->CameraInterpGroup = NewObject<UInterpGroupCamera>(NewCamAnim);
      NewCamAnim->CameraInterpGroup->GroupName = Name;
      return NewCamAnim;
    }
    ```

20.  从这里可以看出，有第二个调用`NewObject`来填充`NewCamAnim`实例的`CameraInterpGroup`成员。

## 另见

*   本章前面的编辑器食谱中的*在不同位置编辑类属性为`EditAnywhere`属性说明符提供了更多上下文*

# 为资产创建自定义上下文菜单项

自定义资产类型通常具有您希望能够对其执行的特殊功能。例如，将图像转换为精灵是您不想添加到任何其他资产类型的选项。您可以为特定资产类型创建自定义上下文菜单项，以使用户可以访问这些功能。

## 怎么做…

1.  基于`FAssetTypeActions_Base`创建一个新类。您需要在头文件中包含`AssetTypeActions_Base.h`。
2.  重写类中的以下虚拟函数:

    ```
    virtual bool HasActions(const TArray<UObject*>& InObjects) const override;
    virtual void GetActions(const TArray<UObject*>& InObjects, FMenuBuilder& MenuBuilder) override;
    virtual FText GetName() const override;
    virtual UClass* GetSupportedClass() const override;

    virtual FColor GetTypeColor() const override;
    virtual uint32 GetCategories() override;
    ```

3.  声明以下函数:

    ```
    void MyCustomAssetContext_Clicked();
    ```

4.  在`.cpp`文件中实现声明的函数:

    ```
    bool FMyCustomAssetActions::HasActions(const TArray<UObject*>& InObjects) const
    {
      return true;
    }

    void FMyCustomAssetActions::GetActions(const TArray<UObject*>& InObjects, FMenuBuilder& MenuBuilder)
    {
      MenuBuilder.AddMenuEntry(
      FText::FromString("CustomAssetAction"),
      FText::FromString("Action from Cookbook Recipe"),
      FSlateIcon(FEditorStyle::GetStyleSetName(), "LevelEditor.ViewOptions"),
      FUIAction(
      FExecuteAction::CreateRaw(this, &FMyCustomAssetActions::MyCustomAssetContext_Clicked),
      FCanExecuteAction()));
    }

    uint32 FMyCustomAssetActions::GetCategories()
    {
      return EAssetTypeCategories::Misc;
    }
    FText FMyCustomAssetActions::GetName() const
    {
      return FText::FromString(TEXT("My Custom Asset"));
    }
    UClass* FMyCustomAssetActions::GetSupportedClass() const
    {
      return UMyCustomAsset::StaticClass();
    }

    FColor FMyCustomAssetActions::GetTypeColor() const
    {
      return FColor::Emerald;
    }
    voidFMyCustomAssetActions::MyCustomAssetContext_Clicked()
    {
      TSharedRef<SWindow> CookbookWindow = SNew(SWindow)
      .Title(FText::FromString(TEXT("Cookbook Window")))
      .ClientSize(FVector2D(800, 400))
      .SupportsMaximize(false)
      .SupportsMinimize(false);

      IMainFrameModule& MainFrameModule = FModuleManager::LoadModuleChecked<IMainFrameModule>(TEXT("MainFrame"));

      if (MainFrameModule.GetParentWindow().IsValid())
      {
        FSlateApplication::Get().AddWindowAsNativeChild(CookbookWindow, MainFrameModule.GetParentWindow().ToSharedRef());
      }
      else
      {
        FSlateApplication::Get().AddWindow(CookbookWindow);
      }
    };
    ```

5.  在你的编辑器模块中，在`StartupModule()`函数中添加以下代码:

    ```
    IAssetTools& AssetTools = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools").Get();

    auto Actions =MakeShareable(new FMyCustomAssetActions);
    AssetTools.RegisterAssetTypeActions(Actions);
    CreatedAssetTypeActions.Add(Actions);
    ```

6.  在模块的`ShutdownModule()`函数内部添加以下内容:

    ```
    IAssetTools& AssetTools = FModuleManager::LoadModuleChecked<FAssetToolsModule>("AssetTools").Get();

    for (auto Action : CreatedAssetTypeActions)
    {
      AssetTools.UnregisterAssetTypeActions(Action.ToSharedRef());
    }
    ```

7.  编译您的项目，并启动编辑器。
8.  在**内容浏览器**中创建自定义资产的实例。
9.  Right-click on your new Asset to see our custom command in the context menu.

    ![How to do it…](../images/00200.jpeg)]

10.  选择**CustomAssetAction**命令以显示一个新的空白编辑器窗口。

## 它是如何工作的…

1.  所有特定于资产类型的上下文菜单命令的基类是`FAssetTypeActions_Base`，因此我们需要从该类继承。
2.  `FAssetTypeActions_Base`是一个抽象类，它定义了许多允许扩展上下文菜单的虚拟函数。包含这些虚拟函数的原始信息的接口可以在`IAssetTypeActions.h`中找到。
3.  我们还声明一个函数，我们将其绑定到我们的自定义上下文菜单条目。
4.  `IAssetTypeActions::HasActions ( const TArray<UObject*>& InObjects )`是引擎代码调用的函数，用于查看我们的`AssetTypeActions`类是否包含可以应用于所选对象的任何操作。
5.  如果`HasActions`函数返回`true`，则调用`IAssetTypeActions::GetActions(const TArray<UObject*>& InObjects, class FMenuBuilder& MenuBuilder)`。它在`MenuBuilder`上调用函数来为我们提供的操作创建菜单选项。
6.  `IAssetTypeActions::GetName()`返回该类的名称。
7.  `IAssetTypeActions::GetSupportedClass()`返回我们的操作类支持的`UClass`实例。
8.  `IAssetTypeActions::GetTypeColor()`返回与此类和操作关联的颜色。
9.  `IAssetTypeActions::GetCategories()`返回适合该资产的类别。此用于更改上下文菜单中显示操作的类别。
10.  在所有情况下，依赖于基于`GetSupportedClass`结果的过滤，我们重写的`HasActions`实现简单地返回`true`。
11.  在`GetActions`的实现中，我们可以在`MenuBuilder`对象上调用一些函数，这些函数作为函数参数给出。`MenuBuilder`作为引用传递，所以我们的函数所做的任何更改都将在返回后持续存在。
12.  `AddMenuEntry`具有多个参数。第一个参数是动作本身的名称。这是在上下文菜单中可见的名称。这个名字是一个`FText`，所以如果你愿意，它可以被本地化。为了简单起见，我们从字符串文字中构造`FText`，而不必担心多种语言的支持。
13.  第二个参数也是`FText`，我们通过调用`FText::FromString`来构造。如果用户在我们的命令上徘徊了一小段时间以上，则此参数是显示在工具提示上的文本。
14.  下一个参数是命令的`FSlateIcon`，它是根据编辑器样式集中的`LevelEditor.ViewOptions`图标构造的。
15.  该函数的最后一个参数是`FUIAction`实例。`FUIAction`是围绕委托绑定的包装，因此我们使用`FExecuteAction::CreateRaw`将命令绑定到`FMyCustomAssetActions`这个实例上的`MyCustomAsset_Clicked`函数。
16.  这意味着当菜单项被点击时，我们的`MyCustomAssetContext_Clicked`功能将被运行。
17.  我们的实现的`GetName`返回我们的资产类型的名称。如果我们不自己设置，这个字符串将在我们的资产的缩略图上使用，除了在我们的自定义资产将被放置的菜单部分的标题中使用。
18.  如您所料，`GetSupportedClass`的实现返回`UMyCustomAsset::StaticClass()`，因为这是我们希望我们的行动操作的资产类型。
19.  `GetTypeColor()`返回将在**内容浏览器**中用于颜色编码的颜色-该颜色在资产缩略图底部的栏中使用。我在这里用过祖母绿，但是任何任意颜色都可以。
20.  这个食谱的真正主力是`MyCustomAssetContext_Clicked()`函数。
21.  这个函数做的第一件事是创建一个新的实例`SWindow`。
22.  `SWindow`是 Slate 窗口-来自 Slate UI 框架的类。
23.  Slate 小部件是使用`SNew`函数创建的，该函数返回请求的小部件的实例。
24.  Slate 使用`builder`设计模式，这意味着所有在`SNew`之后被**链接**的函数返回对正在操作的对象的引用。
25.  在此函数中，我们创建新的`SWindow`，然后设置窗口标题，其客户端大小或区域，以及是否可以最大化或最小化。
26.  随着新窗口的准备，我们需要为编辑器获取对根窗口的引用，这样我们就可以将窗口添加到层次结构中并显示出来。
27.  我们使用`IMainFrameModule`类来做到这一点。它是一个模块，所以我们使用**模块管理器**来加载它。
28.  `LoadModuleChecked`如果我们不能加载模块，就会断言，所以我们不需要检查它。
29.  如果模块已加载，我们检查是否有一个有效的父窗口。如果该窗口有效，则我们使用`FSlateApplication::AddWindowAsNativeChild`将我们的窗口添加为顶级父窗口的子窗口。
30.  如果我们没有顶级父级，则该函数将使用`AddWindow`添加新窗口，而无需将其养育到层次结构中的另一个窗口。
31.  所以现在我们有了一个类，它将在我们的自定义资产类型上显示自定义操作，但是我们需要告诉引擎它应该要求我们的类处理该类型的自定义操作。为了做到这一点，我们需要在资产工具模块中注册我们的类。
32.  最好的方法是在我们的编辑器模块加载时注册我们的类，并在它关闭时取消注册。
33.  因此，我们将代码放入`StartupModule`和`ShutdownModule`函数中。
34.  在`StartupModule`内部，我们使用**模块管理器**加载资产工具模块。
35.  加载模块后，我们创建了一个新的共享指针，该指针引用了自定义资产操作类的实例。
36.  然后，我们需要做的就是调用`AssetModule.RegisterAssetTypeActions,`并传递我们的动作类的实例。
37.  然后，我们需要存储对该`Actions`实例的引用，以便以后可以注销它。
38.  如果我们想为其他类添加自定义操作，此配方的示例代码将使用所有创建的资产操作的数组。
39.  在`ShutdownModule`内，我们再次检索资产工具模块的实例。
40.  使用基于范围的 for 循环，我们迭代我们之前填充的`Actions`实例的数组，并调用`UnregisterAssetTypeActions`，传入我们的`Actions`类，以便它可以被取消注册。
41.  在我们的课程注册后，已指示编辑询问我们注册的课程是否可以处理右键单击的资产。
42.  如果资产属于自定义资产类别，则其`StaticClass`将与`GetSupportedClass`返回的资产匹配。然后，编辑器将调用`GetActions`，并显示菜单，其中包含我们对该功能的实现所做的更改。
43.  单击`CustomAssetAction`按钮时，我们的自定义`MyCustomAssetContext_Clicked`函数将通过我们创建的委托调用。

# 创建新的控制台命令

在开发过程中，通过允许开发人员或测试人员轻松绕过内容或禁用与当前正在运行的测试无关的机制，控制台命令可以非常有用。最常见的实现方式是通过控制台命令，它可以在运行时调用函数。可以使用波浪号键 (`~`) 或键盘字母数字区域左上方区域中的等效项访问控制台。

![Creating new console commands](../images/00201.jpeg)]

## 准备就绪

如果你没有按照*创建一个新的编辑器模块*的配方，这样做，因为这个配方将需要一个地方来初始化和注册控制台命令。

## 怎么做...

1.  打开编辑器模块的头文件，并添加以下代码:

    ```
    IConsoleCommand* DisplayTestCommand;
    IConsoleCommand* DisplayUserSpecifiedWindow;
    ```

2.  在`StartupModule`的实现中添加以下内容:

    ```
    DisplayTestCommand = IConsoleManager::Get().RegisterConsoleCommand(TEXT("DisplayTestCommandWindow"), TEXT("test"), FConsoleCommandDelegate::CreateRaw(this, &FUE4CookbookEditorModule::DisplayWindow, FString(TEXT("Test Command Window"))), ECVF_Default);
    DisplayUserSpecifiedWindow= IConsoleManager::Get().RegisterConsoleCommand(TEXT("DisplayWindow"), TEXT("test"), FConsoleCommandWithArgsDelegate::CreateLambda(
      [&](const TArray< FString >& Args)
      {
        FString WindowTitle;
        for (FString Arg : Args)
        {
          WindowTitle +=Arg;
          WindowTitle.AppendChar(' ');
        }
        this->DisplayWindow(WindowTitle);
      }
    ), ECVF_Default);
    ```

3.  在`ShutdownModule`内，添加这个:

    ```
    If (DisplayTestCommand)
    {
      IConsoleManager::Get().UnregisterConsoleObject(DisplayTestCommand);
      DisplayTestCommand = nullptr;
    }
    If (DisplayUserSpecifiedWindow)
    {
      IConsoleManager::Get().UnregisterConsoleObject(DisplayTestCommand);
      DisplayTestCommand = nullptr;
    }
    ```

4.  在编辑器模块中实现以下功能:

    ```
    void DisplayWindow(FString WindowTitle)
    {
      TSharedRef<SWindow> CookbookWindow = SNew(SWindow)
      .Title(FText::FromString(WindowTitle))
      .ClientSize(FVector2D(800, 400))
      .SupportsMaximize(false)
      .SupportsMinimize(false);
      IMainFrameModule& MainFrameModule = FModuleManager::LoadModuleChecked<IMainFrameModule>(TEXT("MainFrame"));
      if (MainFrameModule.GetParentWindow().IsValid())
      {
        FSlateApplication::Get().AddWindowAsNativeChild(CookbookWindow, MainFrameModule.GetParentWindow().ToSharedRef());
      }
      else
      {
        FSlateApplication::Get().AddWindow(CookbookWindow);
      }
    }
    ```

5.  编译你的代码，并启动编辑器。
6.  播放关卡，然后按波浪号键调出控制台。
7.  Type `DisplayTestCommandWindow,` and hit *Enter*.

    ![How to do it...](../images/00202.jpeg)]

8.  You should see our tutorial window open up:

    ![How to do it...](../images/00203.jpeg)]

## 它是如何工作的...

1.  控制台命令通常由一个模块提供。让模块在加载命令时创建命令的最佳方法是将代码放在`StartupModule`方法中。
2.  `IConsoleManager`是包含引擎控制台功能的模块。
3.  由于它是核心模块的子模块，因此我们无需在构建脚本中添加任何其他信息即可链接其他模块。
4.  为了在控制台管理器中调用函数，我们需要获取引擎正在使用的当前实例`IConsoleManager`的引用。为此，我们调用静态`Get`函数，该函数以类似于单例的方式返回对模块的引用。
5.  `RegisterConsoleCommand`是我们可以用来添加新的控制台命令的功能，并使其在控制台中可用:

    ```
    virtual IConsoleCommand* RegisterConsoleCommand(const TCHAR* Name, const TCHAR* Help, const FConsoleCommandDelegate& Command, uint32 Flags);
    ```

6.  函数的参数如下:
    1.  `Name`: 用户将键入的实际控制台命令。它不应该包括空格。
    2.  `Help:`用户在控制台中查看命令时出现的工具提示。如果您的控制台命令接受参数，这是向用户显示使用信息的好地方。
    3.  `Command:`这是用户键入命令时将执行的实际函数委托。
    4.  `Flags:`这些标志控制交付构建中命令的可见性，并且还用于控制台变量。`ECVF_Default`指定命令可见的默认行为，并且对发布版本中的可用性没有限制。
7.  要创建适当委托的实例，我们在`FConsoleCommand`委托类型上使用`CreateRaw`静态函数。这使我们可以将原始 C 函数绑定到委托。在函数引用之后提供的额外参数，即`FString``"Test Command Window"`，是一个编译时定义的参数，它被传递给委托，这样最终用户就不必指定窗口名称。
8.  第二个控制台命令`DisplayUserSpecifiedWindow`是一个演示参数与控制台命令一起使用的命令。
9.  除了用户调用它的不同名称之外，此控制台命令的主要区别是使用`FConsoleCommandWithArgsDelegate`和`CreateLambda`函数。
10.  此函数允许我们将匿名函数绑定到委托。当您要包装或调整函数以使其签名与特定委托的签名匹配时，它特别方便。
11.  在我们的特定用例中，`FConsoleCommandWithArgsDelegate`的类型指定函数应采用`const TArray`的 FStrings。我们的`DisplayWindow`函数需要一个`FString`来指定窗口标题，所以我们需要以某种方式将控制台命令的所有参数连接成一个`FString`来用作我们的窗口标题。
12.  lambda 函数允许我们在将`FString`传递到实际的`DisplayWindow`函数之前执行此操作。
13.  函数的第一行`[&](const TArray<FString>& Args)`指定此 lambda 或匿名函数希望通过引用在捕获选项`[&]`中包含 & 号来捕获声明函数的上下文。
14.  第二个部分与普通函数声明相同，该声明指定我们的 lambda 采用包含 FStrings 的`const Tarray`作为参数 (称为`Args`)。
15.  在 lambda 主体中，我们创建了一个新的`FString,`，并将构成我们参数的字符串连接在一起，在它们之间添加一个空格来分隔它们，这样我们就不会得到没有空格的标题。
16.  为了简洁起见，它使用基于范围的`for`循环来遍历所有循环并执行串联。
17.  一旦它们全部连接起来，我们使用`this`指针 (由前面提到的`&`运算符捕获) 来调用`DisplayWindow`与我们的新标题。
18.  为了使我们的模块在卸载控制台命令时删除它，我们需要维护对控制台命令对象的引用。
19.  为此，我们在类型为`IConsoleCommand*`的模块中创建一个成员变量，称为`DisplayTestCommand`。当我们执行`RegisterConsoleCommand`函数时，它会返回一个指向 console 命令对象的指针，稍后我们可以将其用作句柄。
20.  这使我们能够在运行时根据游戏玩法或其他因素启用或禁用控制台命令。
21.  在`ShutdownModule`内，我们检查`DisplayTestCommand`是否引用了一个有效的控制台命令对象。如果是这样，我们将获得对`IConsoleManager`对象的引用，并调用`UnregisterConsoleCommand`传入我们在对`RegisterConsoleCommand`的调用中存储的指针。
22.  对`UnregisterConsoleCommand`的调用通过传入的指针删除了`IConsoleCommand`实例，所以我们不需要自己把内存`deallocate`，只需将`DisplayTestCommand`重置为`nullptr`，这样我们就可以确定旧指针不会悬挂。
23.  `DisplayWindow`函数将窗口标题作为`FString`参数。这使我们可以使用使用参数来指定标题的控制台命令，或者使用有效负载参数对其他命令的标题进行硬编码的控制台命令。
24.  函数本身使用一个名为`SNew()`的函数来分配和创建一个`SWindow`对象。
25.  `SWindow`是一个 Slate 窗口，使用 Slate UI 框架的顶级窗口。
26.  Slate 使用`Builder`设计模式，以便于配置新窗口。
27.  这里使用的`Title`、`ClientSize`、`SupportsMaximize`和`SupportsMinimize`函数都是`SWindow`的成员函数，它们返回对`SWindow`的引用 (通常是该方法被调用的对象，但有时，使用新配置构造的新对象)。
28.  所有这些成员方法都返回对已配置对象的引用的事实允许我们将这些方法调用链接在一起，以在正确的配置中创建所需的对象。
29.  `DisplayWindow`中使用的函数创建一个新的顶级窗口，该窗口具有基于函数参数的标题。它的宽度为 800x400 像素，并且不能最大化或最小化。
30.  创建新窗口后，我们将检索对主应用程序框架模块的引用。如果编辑器的顶层窗口存在并且有效，我们将新窗口实例添加为该顶层窗口的子级。
31.  为此，我们检索对 Slate 接口的引用，并调用`AddWindowAsNativeChild`在层次结构中插入我们的窗口。
32.  如果没有有效的顶级窗口，我们不需要将新窗口添加为任何内容的子项，因此我们可以简单地调用`AddWindow,`并传入我们的新窗口实例。

## 另见

*   参考[第五章](05.html#22O7C1-c0ca69a0411046888a488e5085138121 "Chapter 5\. Handling Events and Delegates")、*处理事件和委托*，了解更多委托信息。它更详细地解释了有效载荷变量。
*   有关 Slate 的更多信息，请参阅[第 9 章](09.html#3KB4K1-c0ca69a0411046888a488e5085138121 "Chapter 9\. User Interfaces – UI and UMG")，*用户界面*。

# 为蓝图创建一个新的图形引脚可视化器

在蓝图系统中，我们可以使用我们的`MyCustomAsset`类的实例作为变量，只要我们在其`UCLASS`宏中将该类标记为`BlueprintType`。

但是，默认情况下，我们的新资产仅被视为`UObject`，并且我们无法访问其任何成员:

![Creating a new graph pin visualizer for Blueprint](../images/00204.jpeg)]

对于某些类型的资产，我们可能希望以与`FVector`等类支持以下方式相同的方式启用文字值的在线编辑:

![Creating a new graph pin visualizer for Blueprint](../images/00205.jpeg)]

为了启用此功能，我们需要使用**图形引脚**可视化工具。此配方将向您展示如何使用您定义的自定义小部件启用任意类型的在线编辑。

## 怎么做...

1.  创建一个名为`MyCustomAssetPinFactory.h`的新头文件。
2.  在 header 内部，添加以下代码:

    ```
    #pragma once
    #include "EdGraphUtilities.h"
    #include "MyCustomAsset.h"
    #include "SGraphPinCustomAsset.h"

    struct UE4COOKBOOKEDITOR_API FMyCustomAssetPinFactory : public FGraphPanelPinFactory
    {
      public:
      virtual TSharedPtr<class SGraphPin> CreatePin(class UEdGraphPin* Pin) const override 
      {
        if (Pin->PinType.PinSubCategoryObject == UMyCustomAsset::StaticClass())
        {
          return SNew(SGraphPinCustomAsset, Pin);
        }
        else
        {
          return nullptr;
        }
      };
    };
    ```

3.  创建另一个名为`SGraphPinCustomAsset`的头文件:

    ```
    #pragma once
    #include "SGraphPin.h"

    class UE4COOKBOOKEDITOR_API SGraphPinCustomAsset : public SGraphPin
    {
      SLATE_BEGIN_ARGS(SGraphPinCustomAsset) {}
      SLATE_END_ARGS()
      void Construct(const FArguments& InArgs, UEdGraphPin* InPin);
      protected:
      virtual FSlateColor GetPinColor() const override { return FSlateColor(FColor::Black); };
      virtual TSharedRef<SWidget> GetDefaultValueWidget() override;
      void ColorPicked(FLinearColor SelectedColor);
    };
    ```

4.  在`.cpp`文件中实施`SGraphPinCustomAsset`:

    ```
    #include "UE4CookbookEditor.h"
    #include "SColorPicker.h"
    #include "SGraphPinCustomAsset.h"

    void SGraphPinCustomAsset::Construct(const FArguments& InArgs, UEdGraphPin* InPin)
    {
      SGraphPin::Construct(SGraphPin::FArguments(), InPin);
    }
    TSharedRef<SWidget> SGraphPinCustomAsset::GetDefaultValueWidget()
    {
      return SNew(SColorPicker)
      .OnColorCommitted(this, &SGraphPinCustomAsset::ColorPicked);
    }

    void SGraphPinCustomAsset::ColorPicked(FLinearColor SelectedColor)
    {
      UMyCustomAsset* NewValue = NewObject<UMyCustomAsset>();
      NewValue->ColorName = SelectedColor.ToFColor(false).ToHex();
      GraphPinObj->GetSchema()->TrySetDefaultObject(*GraphPinObj, NewValue);
    }
    ```

5.  将`#include "Chapter8/MyCustomAssetDetailsCustomization.h"`添加到`UE4Cookbook`编辑器模块实现文件中。
6.  在编辑器模块类中添加以下成员:

    ```
    TSharedPtr<FMyCustomAssetPinFactory> PinFactory;
    ```

7.  将以下内容添加到`StartupModule()`:

    ```
    PinFactory = MakeShareable(new FMyCustomAssetPinFactory());
    FEdGraphUtilities::RegisterVisualPinFactory(PinFactory);
    ```

8.  同时在`ShutdownModule()`中添加以下代码:

    ```
    FEdGraphUtilities::UnregisterVisualPinFactory(PinFactory);
    PinFactory.Reset();
    ```

9.  编译你的代码，并启动编辑器。
10.  Create a new **Function** inside the Level Blueprint by clicking on the plus symbol beside **Functions** within the **My Blueprint** panel:

    ![How to do it...](../images/00206.jpeg)]

11.  Add an input parameter.

    ![How to do it...](../images/00207.jpeg)]

12.  Set its type to `MyCustomAsset` (**Reference**):

    ![How to do it...](../images/00208.jpeg)]

13.  In the Level Blueprint's Event graph, place an instance of your new function, and verify that the input pin now has a custom visualizer in the form of a color picker:

    ![How to do it...](../images/00209.jpeg)]

## 它是如何工作的...

1.  使用`FGraphPanelPinFactory`类完成自定义对象在蓝图图钉上显示为文字值的方式。
2.  这个类定义了一个单一的虚函数:

    ```
    virtual TSharedPtr<class SGraphPin> CreatePin(class UEdGraphPin* Pin) const
    ```

3.  顾名思义， `CreatePin`的功能是创建图形引脚的新视觉表示。
4.  它接收一个`UEdGraphPin`实例。`UEdGraphPin`包含有关 pin 表示的对象的信息，以便我们的工厂类可以就应该显示的视觉表示做出明智的决定。
5.  在函数的实现中，我们检查 pin 的类型是我们的自定义类。
6.  我们通过查看包含`UClass`的`PinSubCategoryObject`属性，并将其与与我们的自定义资产类别关联的`UClass`进行比较。
7.  如果 pin 的类型满足我们的条件，我们将返回一个新的共享指针到 Slate 小部件，这是我们对象的视觉表示。
8.  如果引脚类型错误，我们返回一个空指针来指示失败状态。
9.  下一个类，`SGraphPinCustomAsset`，是 Slate Widget 类，它是我们的对象作为文字的视觉表示。
10.  它继承了所有图形引脚的基类`SGraphPin`。
11.  `SGraphPinCustomAsset`类有一个`Construct`函数，在创建 widget 时调用该函数。
12.  它还从父类实现了一些功能: `GetPinColor()`和`GetDefaultValueWidget()`。
13.  最后定义的函数是`ColorPicked`，这是一个用于用户在我们的自定义 pin 中选择颜色的处理程序。
14.  在我们的自定义类的实现中，我们通过调用`Construct`的默认实现来初始化我们的自定义 pin。
15.  `GetDefaultValueWidget`的作用是实际创建小部件，它是我们类的自定义表示，并将其返回给引擎代码。
16.  在我们的实现中，它创建了一个新的`SColorPicker`实例-我们希望用户能够选择一种颜色，并将该颜色的基于十六进制的表示形式存储在我们自定义类中的`FString`属性中。
17.  这个`SColorPicker`实例有一个名为`OnColorCommitted`的属性-这是一个 slate 事件，可以分配给对象实例上的函数。
18.  在返回新的`SColorPicker`之前，我们将`OnColorCommitted`链接到此当前对象上的`ColorPicked`函数，因此如果用户选择新颜色，它将被调用。
19.  `ColorPicked`函数接收所选颜色作为输入参数。
20.  因为当没有对象连接到我们关联的引脚时使用此小部件，所以我们不能简单地将关联对象上的属性设置为所需的颜色字符串。
21.  我们需要创建一个自定义资产类别的新实例，并且我们通过使用`NewObject`模板函数来做到这一点。
22.  该函数的行为类似于其他章节中讨论的`SpawnActor`函数，并在返回指向它的指针之前初始化指定类的新实例。
23.  有了一个新实例，我们可以设置它的`ColorName`属性。可以将`FLinearColors`转换为`FColor`对象，该对象定义了一个`ToHex()`函数，该函数返回具有在新小部件上选择的颜色的十六进制表示的`FString`。
24.  最后，我们需要将我们的新对象实例实际放置到图中，以便在执行图时将其引用。
25.  为此，我们需要访问我们表示的 graph pin 对象，并使用`GetSchema`函数。此函数返回拥有包含我们的 pin 的节点的图的架构。
26.  该架构包含与图形引脚相对应的实际值，并且是图形评估过程中的关键元素。
27.  现在我们可以访问架构，我们可以为小部件表示的 pin 设置默认值。如果引脚未连接到另一个引脚，则该值将在图形评估期间使用，并且其作用类似于 C 中函数定义期间提供的默认值。
28.  与我们在本章中所做的所有扩展一样，必须进行某种初始化或注册，以告诉引擎在使用其默认的内置表示形式之前遵循我们的自定义实现。
29.  为此，我们需要向编辑器模块添加一个新成员来存储我们的`PinFactory`类实例。
30.  在`StartupModule`期间，我们创建一个新的共享指针，该指针引用我们的`PinFactory`类的实例。
31.  我们将其存储在编辑器模块的成员中，以便以后可以取消注册。然后我们调用`FEdGraphUtilities::RegisterVisualPinFactory(PinFactory)`来告诉引擎使用我们的`PinFactory`来创建视觉表示。
32.  在`ShutdownModule`期间，我们使用`UnregisterVisualPinFactory`注销 pin 工厂。
33.  最后，我们通过在包含它的共享指针上调用`Reset()`删除旧的`PinFactory`实例。

# 使用自定义详细信息面板检查类型

默认情况下，在通用属性编辑器中打开`UObject-`派生 UAssets。它看起来像下面的截图:

![Inspecting types with custom Details panels](../images/00210.jpeg)]

但是，在时，您可能希望自定义小部件允许编辑类上的属性。为了方便起见，虚幻支持**细节定制**，这是本配方的重点。

## 怎么做...

1.  创建一个名为`MyCustomAssetDetailsCustomization.h`的新头文件。
2.  在标题中添加以下包含:

    ```
    #include "MyCustomAsset.h"
    #include "DetailLayoutBuilder.h"
    #include "IDetailCustomization.h"
    #include "IPropertyTypeCustomization.h"
    ```

3.  定义我们的自定义类如下:

    ```
    class FMyCustomAssetDetailsCustomization : public IDetailCustomization
    {
      public:
      virtual void CustomizeDetails(IDetailLayoutBuilder& DetailBuilder) override;
      void ColorPicked(FLinearColor SelectedColor);
      static TSharedRef<IDetailCustomization> FMyCustomAssetDetailsCustomization::MakeInstance()
      {
        return MakeShareable(new FMyCustomAssetDetailsCustomization);
      }
      TWeakObjectPtr<class UMyCustomAsset> MyAsset;
    };
    ```

4.  在实现文件中，为`CustomizeDetails`:

    ```
    void FMyCustomAssetDetailsCustomization::CustomizeDetails(IDetailLayoutBuilder& DetailBuilder)
    {
      const TArray< TWeakObjectPtr<UObject>>& SelectedObjects = DetailBuilder.GetDetailsView().GetSelectedObjects();
      for (int32 ObjectIndex = 0; !MyAsset.IsValid() && ObjectIndex < SelectedObjects.Num(); ++ObjectIndex)
      {
        const TWeakObjectPtr<UObject>& CurrentObject = SelectedObjects[ObjectIndex];
        if (CurrentObject.IsValid())
        {
          MyAsset = Cast<UMyCustomAsset>(CurrentObject.Get());
        }
      }
      DetailBuilder.EditCategory("CustomCategory", FText::GetEmpty(), ECategoryPriority::Important)
      .AddCustomRow(FText::GetEmpty())
      [
        SNew(SVerticalBox)
        + SVerticalBox::Slot()
        .VAlign(VAlign_Center)
        [
          SNew(SColorPicker)
          .OnColorCommitted(this, &FMyCustomAssetDetailsCustomization::ColorPicked)
        ]
      ];
    }
    ```

    创建一个实现
5.  还要为`ColorPicked`创建定义:

    ```
    void FMyCustomAssetDetailsCustomization::ColorPicked(FLinearColor SelectedColor)
    {
      if (MyAsset.IsValid())
      {
        MyAsset.Get()->ColorName = SelectedColor.ToFColor(false).ToHex();
      }
    }
    ```

6.  最后，在`.cpp`文件中添加以下内容:

    ```
    #include "UE4CookbookEditor.h"
    #include "IDetailsView.h"
    #include "DetailLayoutBuilder.h"
    #include "DetailCategoryBuilder.h"
    #include "SColorPicker.h"
    #include "SBoxPanel.h"
    #include "DetailWidgetRow.h"
    #include "MyCustomAssetDetailsCustomization.h"
    ```

7.  在我们的编辑器模块标头中，在`StartupModule`的实现中添加以下内容:

    ```
    FPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>("PropertyEditor");
    PropertyModule.RegisterCustomClassLayout(UMyCustomAsset::StaticClass()->GetFName(), FOnGetDetailCustomizationInstance::CreateStatic(&FMyCustomAssetDetailsCustomization::MakeInstance));
    ```

8.  将以下内容添加到`ShutdownModule`:

    ```
    FPropertyEditorModule& PropertyModule = FModuleManager::LoadModuleChecked<FPropertyEditorModule>("PropertyEditor");
    PropertyModule.UnregisterCustomClassLayout(UMyCustomAsset::StaticClass()->GetFName());
    ```

9.  编译你的代码，并启动编辑器。通过内容浏览器创建`MyCustomAsset`的新副本。
10.  Double-click on it to verify that the default editor now shows your custom layout:

    ![How to do it...](../images/00211.jpeg)]

## 它是如何工作的...

1.  Details自定义是通过`IDetailCustomization`接口执行的，开发人员可以在定义自定义某个类的资产显示方式的类时继承该接口。
2.  `IDetailCustomization`用于允许此过程发生的主要功能如下:

    ```
    virtual void CustomizeDetails(IDetailLayoutBuilder& DetailBuilder) override;
    ```

3.  在这个函数的实现中，我们使用作为参数传入的`DetailBuilder`上的方法来获取所有选定对象的数组。然后，循环扫描这些对象，以确保至少一个所选对象具有正确的类型。
4.  自定义类的表示是通过调用`DetailBuilder`对象上的方法来完成的。我们使用`EditCategory`函数为我们的详细信息视图创建一个新类别。
5.  `EditCategory`函数的第一个参数是我们要操作的类别的名称。
6.  第二个参数是可选的，并且包含该类别的潜在本地化显示名称。
7.  第三个参数是类别的优先级。更高的优先级意味着它会显示在列表的更多位置。
8.  `EditCategory`返回对类别本身的引用为`CategoryBuilder`，允许我们将其他方法调用链到`EditCategory`的调用中。
9.  作为的结果，我们在`CategoryBuilder`上调用`AddCustomRow()`，它添加了一个新的键值对，以显示在类别中。
10.  然后，使用 Slate 语法，我们指定该行将包含一个具有单个中心对齐插槽的垂直框。
11.  在插槽中，我们创建一个颜色选择器控件，并将其`OnColorCommitted`委托绑定到我们的本地`ColorPicked`事件处理程序。
12.  当然，这需要我们定义和实现`ColourPicked`。它有以下签名:

    ```
    void FMyCustomAssetDetailsCustomization::ColorPicked(FLinearColor SelectedColor)
    ```

13.  在`ColorPicked`的实现中，我们检查选定的资产之一是否具有正确的类型，因为如果至少有一个选定的资产是正确的，那么`MyAsset`将使用有效值填充。
14.  假设我们有一个有效的资产，我们将`ColorName`属性设置为与用户选择的颜色相对应的十六进制字符串值。