# 全面审视内存管理

在本章中，我们将指导读者如何正确和安全地执行 C 风格的内存管理，同时尽可能遵守 C 核心准则，利用 C 11、C 14 和 C 17 中 C 标准模板库的添加来提高安全性、可靠性、和读者系统程序的稳定性。我们将首先介绍`new()`和`delete()`函数，以及它们如何用于分配类型安全内存，包括对齐内存。接下来，本章将讨论直接使用`new()`和`delete()`的安全问题，以及如何使用智能指针处理这些安全问题，包括它们对 C 核心指南合规性的影响。还将讨论如何执行内存映射和权限，本章最后简要讨论了碎片。

# 技术要求

为了编译和执行本章中的示例，读者必须具有以下内容:

*   能够编译和执行 C 17 的基于 Linux 的系统 (例如，Ubuntu 17.10)
*   GCC 7
*   C 让 3.6
*   互联网连接

要下载本章中的所有代码，包括示例和代码片段，请访问: [https://github.com/PacktPublishing/ 动手系统编程与 CPP/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter07)。

# 了解新增和删除功能

在本节中，读者将学习如何使用 C 17 分配和解除分配内存。您将学习如何使用`new()`和`delete()`而不是`malloc()`/`free()`来增加类型-分配和解除分配的安全性。将解释这些功能的各种版本，包括数组，对齐和放置样式分配。

# 编写程序的基础知识

在编写程序 (包括系统编程) 时，作者可以利用几种不同类型的内存:

*   全局内存
*   堆栈内存
*   堆内存

全局内存存在于程序本身中，由 OS 的加载器分配，并且通常存在于两个不同的位置 (假设 ELF 二进制文件):

*   `.bss`: 零初始化 (或未初始化) 内存
*   `.data`: 数值初始化内存

考虑以下示例:

```
#include <iostream>

int bss_mem = 0;
int data_mem = 42;

int main()
{
    std::cout << bss_mem << '\n';
    std::cout << data_mem << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0
// 42
```

尽管在系统编程中使用了很多，但通常不鼓励全局内存使用堆栈内存和动态内存。在使用值初始化的全局内存时要特别小心，因为这种形式的内存使用增加了磁盘上程序的大小，导致更大的存储影响，以及较长的加载时间，而零初始化的内存是由 OS-loader 在链接时提供的。

**堆栈内存**是在堆栈上分配的内存:

```
#include <iostream>

int main()
{
    int stack_mem = 42;
    std::cout << stack_mem << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 42
```

如此示例所示，`stack_mem`是在堆栈上分配的，而不是全局分配的，因为它存在于`main()`函数中。堆栈内存绑定到创建它的作用域-在本例中为`main()`函数。除了作用域之外，堆栈内存的另一个优点是，当内存的作用域完成时，内存将自动为您释放。使用堆栈内存时要小心，因为此内存的大小有限。

It should be noted that the total size of the stack is entirely system-dependent and can vary widely. Unless you know the size of the stack, it should be assumed to be small, and used with caution as there is no simple way to determine when the stack runs out. Unlike dynamic memory allocation, which usually returns an error of some kind when memory is not available, on most systems when the stack runs out, your program will simply crash.

例如，在我们的测试系统上，当尝试在堆栈上分配一个 `268435456` 的整数数组时，如下面的代码所示:

```
#include <iostream>

int main()
{
    int stack_mem[268435456];
    std::cout << stack_mem[0] << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// Segmentation fault (core dumped)
```

这会导致分段错误，因为`stack_mem`变量超过了堆栈的总大小。

第三种形式的内存和本章的主要主题是动态内存 (也叫**堆内存**)。像堆栈一样，每个程序都由 OS 提供一个堆内存池，通常可以根据需求增长。与堆栈甚至全局内存不同，如果物理系统和 OS 可以支持，堆内存分配可能会非常大。此外，与堆栈和全局内存不同，堆内存分配速度较慢，并且用户按需分配的任何内存在完成后也必须由用户释放回堆。在 C 中，分配堆内存的基本方法是通过使用`new()`和`delete()`运算符函数，如下所示:

```
#include <iostream>

int main()
{
    auto ptr = new int;
    std::cout << ptr << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5639c77e4e70
```

在这个简单的示例中，使用 new 运算符在堆上分配一个整数 (其大小与体系结构相关，但此处假定为`4`字节)。将新分配的内存的地址输出到`stdout`，然后使用`delete()`运算符将内存释放回堆。除了单个对象外，还可以使用`new()`/`delete()`运算符分配/释放数组，如下所示:

```
#include <iostream>

int main()
{
    auto ptr = new int[42];
    std::cout << ptr << '\n';
    delete [] ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5594a7d47e70
```

在此示例中，整数数组的大小为`42`。请注意，与标准 C 中的`malloc()`不同，new 运算符会自动计算对象或对象数组所需的字节总数。假设一个整数是`4`字节，在这个例子中，新的运算符分配`42 * sizeof(int) == 42 * 4 == 11088`字节。除了使用`new[]()`分配数组外，还使用`delete []()`运算符代替`delete`运算符。delete 运算符调用单个对象的析构函数，而`delete []()`运算符调用数组中每个对象的析构函数:

```
#include <iostream>

class myclass
{
public:
    ~myclass()
    {
        std::cout << "my delete\n";
    }
};

int main()
{
    auto ptr = new myclass[2];
    std::cout << ptr << '\n';
    delete [] ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x56171064ae78
// my delete
// my delete
```

重要的是要注意，某些系统可能使用不同的池来分配单个对象，对象的数组与对齐对象的数组，以及更多。应注意确保解除分配例程与分配例程匹配。例如，如果使用`new []()`，则应始终使用`delete []()`而不是`delete()`。如果发生不匹配，则共享相同池的系统将正常运行，但不共享这些池的系统可能会发生崩溃，因为您将尝试将内存释放到内存最初不属于的池中。防止这些类型的错误的最简单方法是使用`std::unique_ptr{}`和`std::shared_ptr{}`，这将在*理解智能指针和所有权*部分中进行讨论。

# 对齐内存

在对系统进行编程时，通常需要分配对齐的内存 (即可以被特定对齐整除的内存)。具体地，当分配存储器时，指向所述分配的存储器的结果地址可以是任何值。然而，当对系统进行编程时，这通常是有问题的，因为一些 api 和物理设备需要以一定的最小粒度分配内存。考虑以下示例:

```
0x0ABCDEF123456789 // Unaligned
0x0ABCDEF12345F000 // 4 Kb aligned
```

可以使用所有三种内存类型分配对齐的内存:

*   全球
*   在堆栈上
*   动态

要使用 C 全局分配对齐的内存，请使用`alignas()`说明符:

```
#include <iostream>

alignas(0x1000) int ptr[42];

int main()
{
    std::cout << ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x560809897000
```

在此示例中，全局分配大小为`42`的整数数组，并且`alignas()`说明符用于将数组对齐到 4k 页面边界。然后输出阵列的地址，并且如图所示，该地址可被 4k 页整除 (即，前 12 位为零)。要在堆栈上分配对齐的内存，还可以使用`alignas()`说明符:

```
#include <iostream>

int main()
{
    alignas(0x1000) int ptr[42];
    std::cout << ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x560809897000
```

而不是全局分配数组，而是将数组移动到`main`函数的范围内，因此在执行`main`函数时使用堆栈进行分配，并在`main`函数完成时自动释放。这种类型的分配应该小心使用，因为编译器必须将代码添加到程序的可执行文件中，以移动堆栈指针，以便对齐该内存。结果，堆栈上的对齐分配间接分配额外的不可用内存，以确保指针对齐 (使用 GCC 7.3 在 Intel 的 x86_64 上显示):

```
> objdump -d | grep main
...
00000000000008da <main>:
 8da: 4c 8d 54 24 08 lea 0x8(%rsp),%r10
 8df: 48 81 e4 00 f0 ff ff and $0xfffffffffffff000,%rsp
 8e6: 41 ff 72 f8 pushq -0x8(%r10)
```

可以看出，堆栈指针 (在这种情况下为 RSP 寄存器) 被移动以对齐整数数组。如果这种类型的分配完成了很多，或者对齐度很高 (例如 2 MB 对齐)，则堆栈空间可能会很快用完。分配对齐内存 (不考虑类型) 的另一种方法是手动计算现有字符缓冲区内的对齐位置:

```
#include <iostream>

int main()
{
    char buffer[0x2000];
    auto ptr1 = reinterpret_cast<uintptr_t>(buffer);
    auto ptr2 = ptr1 - (ptr1 % 0x1000) + 0x1000;

    std::cout << std::hex << std::showbase;
    std::cout << ptr1 << '\n';
    std::cout << ptr2 << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x7ffd160dec20
// 0x7ffd160df000
```

在此示例中，在堆栈上分配了足够大小的字符缓冲区。然后将字符缓冲区的地址转换为无符号整数指针类型，应避免 C 核心准则不鼓励的操作为`reinterpret_cast()`，然后对字符缓冲区的指针进行算术运算，以定位缓冲区内的页面对齐地址，还应避免 C 核心准则不鼓励作为指针算术的另一种操作。原始指针和结果指针都输出到`stdout`，如图所示，计算出的指针与字符缓冲区内的 4k 页边界对齐。要了解此算法的工作原理，请参见以下内容:

```
// ptr1 = 0x7ffd160dec20
// ptr1 % 0x1000 = 0xc20
// ptr1 - (ptr1 % 0x1000) = 0x7ffd160de000   
// ptr1 - (ptr1 % 0x1000) + 0x1000 = 0x7ffd160df000 
```

这种类型的过程有效，并且已经使用了多年，但是应该避免使用，因为有更好的方法可以使用`alignas()`来完成相同的任务，而不需要容易出错的类型转换和指针算法 C 核心指南。

最后，分配对齐内存的第三种方法是使用动态分配。在 C 17 之前，这是使用`posix_memalign()`或较新的 C11`aligned_alloc()`完成的，如下所示:

```
#include <iostream>

int main()
{
    int *ptr;

    if (posix_memalign(reinterpret_cast<void **>(&ptr), 0x1000, 42 * sizeof(int))) {
        std::clog << "ERROR: unable to allocate aligned memory\n";
        ::exit(EXIT_FAILURE);
    }

    std::cout << ptr << '\n';
    free(ptr);
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55c5d31d1000
```

`posix_memalign()`API 有点笨重。首先，必须声明一个指针*，*提供对齐方式和大小 (必须手动计算)，成功后函数返回 0。最后，需要`reinterpret_cast()`告诉`posix_memalign()`函数提供的指针是`void **`而不是`int**`。由于`posix_memalign()`函数是 C 风格的函数，所以使用`free()`来释放内存。

分配对齐内存的另一种方法是使用相对较新的`aligned_alloc()`函数，该函数提供了一种不那么笨拙，更可移植的实现:

```
#include <iostream>

int main()
{
    if (auto ptr = aligned_alloc(0x1000, 42 * sizeof(int))) {
        std::cout << ptr << '\n';
        free(ptr);
    }
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55c5d31d1000
```

如图所示，`aligned_alloc()`的功能类似于常规`malloc()`，但具有附加的对齐参数。该 API 仍然存在与`malloc()`和`posix_memalign()`相同的大小问题，其中必须手动计算数组的总大小。

为了解决这些问题，C 17 添加了利用`alignas()`的`new()`和`delete()`运算符的对齐分配版本，如下所示:

```
#include <iostream>

using aligned_int alignas(0x1000) = int;

int main()
{
    auto ptr = new aligned_int;
    std::cout << ptr << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55e32ece1000
```

在这个例子中，我们使用`alignas()`和`new()`和`delete()`运算符分配一个整数。为此，我们创建了一个新类型，称为`aligned_int`，在类型定义中利用`alignas()`。以下也可用于分配对齐数组:

```
#include <iostream>

using aligned_int alignas(0x1000) = int;

int main()
{
    auto ptr = new aligned_int[42];
    std::cout << ptr << '\n';
    delete [] ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5649c0597000
```

使用相同的对齐整数类型，唯一的区别是使用`new []()`和`delete []()`而不是`new()`和`delete()`。与前面代码中显示的 C api 不同，`new()`和`delete()`包括 C 17 中添加的对齐版本，自动计算需要为您分配的字节总数，消除潜在的错误。

# nothrow

允许`new()`和`delete()`运算符抛出异常。实际上，如果分配失败，则默认的 new 运算符会抛出`std::bad_alloc`而不是返回`nullptr`。在某些情况下 (通常在对系统进行编程时会看到)，无效分配上的异常是不需要的，因此，提供了`nothrow`版本:

```
#include <iostream>

int main()
{
    auto ptr = new (std::nothrow) int;
    std::cout << ptr << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55893e230e70
```

具体来说，用`new (std::nothrow)`代替`new()`，它告诉 C 你希望`nullptr`在无效分配时返回，而不是`new()`抛出`std::bad_alloc`。阵列版本也提供如下:

```
#include <iostream>

int main()
{
    auto ptr = new (std::nothrow) int[42];
    std::cout << ptr << '\n';
    delete [] ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5623076e9e70
```

正如人们所期望的那样，还为单对象分配提供了这些函数的对齐分配版本:

```
#include <iostream>

using aligned_int alignas(0x1000) = int;

int main()
{
    auto ptr = new (std::nothrow) aligned_int;
    std::cout << ptr << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55e36201a000
```

还有数组样式的分配:

```
#include <iostream>

using aligned_int alignas(0x1000) = int;

int main()
{
    auto ptr = new (std::nothrow) aligned_int[42];
    std::cout << ptr << '\n';
    delete [] ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x557222103000
```

需要注意的是，仅针对 C 提供的类型返回`nullptr`。对于用户定义的类型，如果在构造过程中引发异常，则`new()`的`nothrow`版本 (标记为`nothrow`) 将调用`std::terminate`并中止:

```
#include <iostream>

class myclass
{
public:
    myclass()
    {
        throw std::runtime_error("the answer was not 42");
    }
};

int main()
{
    auto ptr = new (std::nothrow) myclass;
    std::cout << ptr << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// terminate called after throwing an instance of 'std::runtime_error'
// what(): the answer was not 42
// Aborted (core dumped)
```

为了克服这个问题，可以使用特定于类的`new`和`delete`运算符 (在*重载*部分中要解释的主题)。

# 新的放置

除了对齐的分配和`nothrow`说明符之外，C 还提供了从现有的用户控制的缓冲区分配内存的能力，这种情况在编程系统时经常可以看到。例如，假设您已经从物理设备映射了一个缓冲区。现在，假设您希望从该缓冲区分配一个整数，可以使用`new()`放置运算符来完成此操作:

```
#include <iostream>

char buf[0x1000];

int main()
{
    auto ptr = new (buf) int;
    std::cout << ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5567b8884000
```

在此示例中，我们利用`new()`放置运算符从现有的用户控制缓冲区分配内存。`new()`放置运算符提供要分配的对象与所提供的地址，然后，像往常一样，调用对象的构造函数。需要注意的是，在这种情况下不需要`delete()`运算符，因为被分配对象的内存是用户定义的，在这种情况下，完成后没有堆内存可以返回到堆中。此外，`new()`放置运算符不管理提供给一组对象的内存，该任务必须由用户执行。要证明这一点，请参见以下内容:

```
#include <iostream>

char buf[0x1000];

int main()
{
    auto ptr1 = new (buf) int;
    auto ptr2 = new (buf) int;
    std::cout << ptr1 << '\n';
    std::cout << ptr2 << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x558044c66180
// 0x558044c66180
```

在此示例中，使用了两次`new()`放置。如图所示，提供的地址是相同的，因为我们没有手动推进提供给`new()`放置的地址，这表明当使用`new()`放置时，C 不会自动管理用户定义的内存。通常，这种类型的例子会导致未定义的行为，如果执行 (在这种情况下，它没有，因为我们实际上没有使用新分配的内存)。由于这些原因，应特别小心地使用`new()`放置。除了单个分配之外，还提供了数组分配:

```
#include <iostream>

char buf[0x1000];

int main()
{
    auto ptr = new (buf) int[42];
    std::cout << ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55594aff0000
```

由于 C 不管理`new()`放置分配，因此用户也必须提供对齐的分配。前面代码中提供的对齐算法可以用于从用户定义的缓冲区提供对齐的分配，可以使用已经对齐的内存 (例如，当通过`mmap()`与物理设备接口时)，或者也可以使用`alignas()`，如下所示:

```
#include <iostream>

alignas(0x1000) char buf[0x1000];

int main()
{
    auto ptr = new (buf) int;
    std::cout << ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5567b8884000
```

在本例中，由于缓冲区使用`alignas()`对齐，因此当提供此缓冲区时，所产生的新放置分配也将对齐。这种相同类型的分配也适用于数组分配:

```
#include <iostream>

alignas(0x1000) char buf[0x1000];

int main()
{
    auto ptr = new (buf) int[42];
    std::cout << ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55594aff0000
```

# 过载

通常在对系统进行编程时，C 提供的默认分配方案是不希望的。示例包括 (但不限于):

*   自定义内存布局
*   碎片化
*   性能优化
*   调试和统计

克服这些问题的一种方法是利用 C 分配器，这是一个复杂的主题，将在[第 9 章](09.html)，*一种手动的分配器方法*中讨论。实现这一目标的另一种更繁重的方法是利用`new()`和`delete()`运营商的用户定义重载:

```
#include <iostream>

void *operator new (std::size_t count)
{
    // WARNING: Do not use std::cout here
    return malloc(count);
}

void operator delete (void *ptr)
{
    // WARNING: Do not use std::cout here
    return free(ptr);
}

int main()
{
    auto ptr = new int;
    std::cout << ptr << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55f204617e70
```

在此示例中，提供了自定义的`new()`和`delete()`运算符重载。您的程序将使用用户定义的版本，而不是使用`new()`和`delete()`函数提供的默认分配方案。

These overloads affect all allocations, including those used by the C++ library, so care should be taken when leveraging these overloads as infinite cyclic recursions could occur if an allocation is performed inside these functions. For example, data structures such as `std::vector` and `std::list`, or debugging functions such as `std::cout` and `std::cerr` cannot be used as these facilities use the `new()` and `delete()` operators to allocate memory. 

除了单对象`new()`和`delete()`运算符之外，其他所有运算符也可能会过载，包括数组分配版本:

```
#include <iostream>

void *operator new[](std::size_t count)
{
    // WARNING: Do not use std::cout here
    return malloc(count);
}

void operator delete[](void *ptr)
{
    // WARNING: Do not use std::cout here
    return free(ptr);
}

int main()
{
    auto ptr = new int[42];
    std::cout << ptr << '\n';
    delete [] ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55e5e2c62e70
```

调试和统计是重载`new()`和`delete()`运算符的常见原因，它提供了有关正在发生的分配类型的有用信息。例如，假设您希望记录大于或等于页面的分配总数:

```
#include <iostream>

std::size_t allocations = 0;

void *operator new (std::size_t count)
{
    if (count >= 0x1000) {
        allocations++;
    }

    return malloc(count);
}

void operator delete (void *ptr)
{
    return free(ptr);
}

int main()
{
    auto ptr = new int;
    std::cout << allocations << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0
```

如图所示，我们的程序没有执行大于页面的分配，包括 C 库进行的分配。让我们看看如果我们分配一个页面会发生什么，如下所示:

```
#include <iostream>

std::size_t allocations = 0;

void *operator new (std::size_t count)
{
    if (count >= 0x1000) {
        allocations++;
    }

    return malloc(count);
}

void operator delete (void *ptr)
{
    return free(ptr);
}

struct mystruct
{
    char buf[0x1000];
};

int main()
{
    auto ptr = new mystruct;
    std::cout << allocations << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 1
```

正如预期的那样，我们得到一个大于或等于一页的单一分配。这种类型的使用`new()`和`delete()`重载对于调试内存泄漏、定位分配优化等非常有用。但是，应该注意的是，在编写这些类型的重载时应格外小心。如果您不小心分配了内存 (例如，当使用 C 数据结构如`std::vector{}`时，或者当使用`std::cout`时)，您可能会陷入无限循环，或者添加到您可能试图记录的统计信息中。

除了全局运算符`new`和`delete`运算符重载外，还提供了特定于类的版本:

```
#include <iostream>

class myclass
{
public:
    void *operator new (std::size_t count)
    {
        std::cout << "my new\n";
        return ::operator new (count);
    }

    void operator delete (void *ptr)
    {
        std::cout << "my delete\n";
        return ::operator delete (ptr);
    }
};

int main()
{
    auto ptr = new myclass;
    std::cout << ptr << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// my new
// 0x5561cac52280
// my delete
```

当使用特定于类的运算符时，唯一针对重载的分配是针对您为其提供重载的特定类或多个类的分配。如前面的示例所示，由`std::cout`进行的分配不定向到我们特定于类的重载，从而防止了无限递归。唯一使用重载的分配和释放是针对`myclass`的。

正如预期的那样，对于特定于类的运算符，所有全局运算符也都存在，包括诸如对齐分配之类的版本:

```
#include <iostream>

class myclass
{
public:
    void *operator new[](std::size_t count, std::align_val_t al)
    {
        std::cout << "my new\n";
        return ::operator new (count, al);
    }

    void operator delete[](void *ptr, std::align_val_t al)
    {
        std::cout << "my delete\n";
        return ::operator delete (ptr, al);
    }
};

using aligned_myclass alignas(0x1000) = myclass;

int main()
{
    auto ptr1 = new aligned_myclass;
    auto ptr2 = new aligned_myclass[42];
    std::cout << ptr1 << '\n';
    std::cout << ptr2 << '\n';
    delete ptr1;
    delete [] ptr2;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// my new
// 0x563b49b74000
// 0x563b49b76000
// my delete
```

# 了解智能指针和所有权

在本节中，读者将学习如何使用智能指针来提高其程序的安全性，可靠性和稳定性，同时还遵循 C 核心准则。

# std::unique_ptr{} 指针

现在应该很清楚，C 提供了一组广泛的 api 来分配和释放动态内存。还应该清楚的是，无论您使用的是`malloc()`/`free()`还是`new()`/`delete()`，错误不仅可能发生，而且可能在大型应用程序中。例如，您可能会忘记将内存释放回堆:

```
#include <iostream>

int main()
{
    auto ptr = new int;
    std::cout << ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; valgrind ./a.out
// ==8627== LEAK SUMMARY:
// ==8627== definitely lost: 4 bytes in 1 blocks
// ==8627== indirectly lost: 0 bytes in 0 blocks
// ==8627== possibly lost: 0 bytes in 0 blocks
// ==8627== still reachable: 0 bytes in 0 blocks
// ==8627== suppressed: 0 bytes in 0 blocks
// ==8627== Rerun with --leak-check=full to see details of leaked memory
```

或者您可以在分配数组时使用`delete`而不是`delete []`:

```
#include <iostream>

int main()
{
    auto ptr = new int[42];
    std::cout << ptr << '\n';
    delete ptr;
}

// > g++ -std=c++17 scratchpad.cpp; valgrind ./a.out
// ==8656== Mismatched free() / delete / delete []
// ==8656== at 0x4C2E60B: operator delete(void*) (vg_replace_malloc.c:576)
// ==8656== by 0x108960: main (in /home/user/examples/chapter_7/a.out)
// ==8656== Address 0x5aebc80 is 0 bytes inside a block of size 168 alloc'd
// ==8656== at 0x4C2DC6F: operator new[](unsigned long) (vg_replace_malloc.c:423)
// ==8656== by 0x10892B: main (in /home/user/examples/chapter_7/a.out)
```

为了克服这一点，C ++ 11 引入了具有两个类的指针所有权的概念:

*   `std::unique_ptr{}`: 定义单个实体唯一拥有的指针。复制此指针是不允许的，并且编译器明确阻止了该指针的复制，并且 deallocations 由 C 自动处理。
*   `std::shared_ptr{}`: 定义一个指针，该指针可能由一个或多个实体拥有。允许复制此指针，并且仅在所有所有者都已释放其所有权时才发生释放。

通常，C 核心准则不鼓励这两个类未执行的任何动态分配。对于通常使用`new`和`delete`的大多数情况，应改用`std::unique_ptr{}`。考虑以下示例:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr = std::make_unique<int>(42);
    std::cout << *ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 42
```

要同时创建`std::unique_ptr{}`和`std::shared_ptr`，C 提供以下内容:

*   `std::make_unique()`: 创建`std::unique_ptr{}`
*   `std::make_shared()`: 创建`std::shared_ptr{}`

如果您打算提供 C 核心指南合规性，请习惯这些功能。如图所示，要创建`std::unique_ptr{}`，必须提供您计划分配的对象类型和对象的初始值作为模板参数。另外，如图所示，无需手动调用`delete()`运算符，因为这是为您完成的。要证明这一点，请参见以下内容:

```
#include <memory>
#include <iostream>

class myclass
{
public:
    ~myclass()
    {
        std::cout << "my delete\n";
    }
};

int main()
{
    auto ptr = std::make_unique<myclass>();
    std::cout << ptr.get() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5621eb029e70
// my delete
```

在本示例中，使用`std::unique_ptr{}`可以防止内存泄漏和内存 API 不匹配。此外，这种智能分配和解除分配是有范围的。考虑以下示例:

```
#include <memory>
#include <iostream>

class myclass1
{
public:
    ~myclass1()
    {
        std::cout << "my delete\n";
    }
};

class myclass2
{
    std::unique_ptr<myclass1> m_data;

public:
    myclass2() :
        m_data{std::make_unique<myclass1>()}
    { }
};

int main()
{
    myclass2();
    std::cout << "complete\n";
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// my delete
// complete
```

`myclass1`存储为`myclass2`的成员变量。在`main`函数中，`myclass2`被立即创建并销毁，结果，当`myclass2`被销毁时，`myclass1`也被释放回堆。

`std::unique_ptr{}`接受指向先前分配的内存的指针 (例如，通过`new()`运算符)，然后在销毁时，默认情况下释放通过`delete()`运算符给出的内存。如果提供给`std::unique_ptr{}`的内存是使用`new[]()`而不是`new()`分配的，则应使用`std::unique_ptr{}`的`[]`版本来确保它使用`delete[]()`而不是`delete()`释放分配的内存:

```
#include <memory>
#include <iostream>

class myclass1
{
public:
    ~myclass1()
    {
        std::cout << "my delete\n";
    }
};

int main()
{
    std::unique_ptr<myclass1[]>(new myclass1[2]);
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// my delete
// my delete
```

使用`std::unique_ptr{}`分配和释放数组的更符合 C -Core-Guideline 的方法是使用`std::make_unique()`的数组版本:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr = std::make_unique<int[]>(42);
    std::cout << ptr.get() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55b25f224e70
// my delete
```

`std::make_unique()`不是手动分配数组，而是为您分配数组。单对象分配和数组分配与`std::make_unique()`的区别如下:

*   `std::make_unique<type>(args)`: 要执行单对象分配，类型作为模板参数提供，对象的构造函数参数作为参数提供给`std::make_unique()`
*   `std::make_unique<type[]>(size)`: 要执行数组分配，数组类型作为模板参数提供，数组的大小作为参数提供给`std::make_unique()`

在某些情况下，无法使用`delete()`或`delete[]()`释放提供给`std::unique_ptr{}`的内存 (例如，`mmap()`缓冲区，放置`new()`等)。要支持这些类型的场景，`std::unique_ptr{}`接受自定义删除程序:

```
#include <memory>
#include <iostream>

class int_deleter
{
public:
    void operator()(int *ptr) const
    {
        std::cout << "my delete\n";
        delete ptr;
    };
};

int main()
{
    auto ptr = std::unique_ptr<int, int_deleter>(new int, int_deleter());
    std::cout << ptr.get() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5615be977e70
// my delete
```

在前面的示例中，创建了一个`deleter`类，并提供了一个 functor (即`operator ()`)，该 functor 执行自定义删除。当需要释放分配的内存时，函子由`std::unique_ptr{}`调用。

C 17 中`std::unqiue_ptr{}`的一个缺点是`new`和`delete`运算符的对齐版本没有扩展到`std::unique_ptr{}` (或`std::shared_pointer{}`)。由于没有对齐版本的`std::unique_ptr{}`，如果需要对齐内存，则必须手动分配 (希望在 C 的未来版本中解决此问题，因为 C 核心指南通常不鼓励这种分配方式):

```
#include <memory>
#include <iostream>

using aligned_int alignas(0x1000) = int;

int main()
{
    auto ptr = std::unique_ptr<int>(new aligned_int);
    std::cout << ptr.get() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x560eb6a0a000
```

像普通的 C 样式指针一样，可以使用`*`和`->`在`std::unique_ptr{}`处取消引用:

```
#include <memory>
#include <iostream>

struct mystruct {
    int data{42};
};

int main()
{
    auto ptr1 = std::make_unique<int>(42);
    auto ptr2 = std::make_unique<mystruct>();
    std::cout << *ptr1 << '\n';
    std::cout << ptr2->data << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 42
// 42
```

要让`std::unique_ptr{}`释放它的分配，指针需要失去作用域，导致`std::unique_ptr{}`的析构函数被调用，这又将分配释放回堆。`std::unique_ptr{}`还提供了`reset()`函数，它明确地告诉指针按需释放其内存，而不必失去作用域:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr = std::make_unique<int>();
    std::cout << ptr.get() << '\n';
    ptr.reset();
    std::cout << ptr.get() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55bcfa2b1e70
// 0
```

在这个例子中，`std::unique_ptr{}`被重置，结果，它存储的指针相当于`nullptr`。当使用`->`和`*`等运算符取消引用时，`std::unique_ptr{}`不进行检查以确保指针有效。因此，应谨慎使用`reset()`功能，并且仅在需要时才使用 (例如，当释放分配的顺序很重要时)。

这里有几个方法`std::unique_ptr{}`可能是无效的 (但这不是一个详尽的列表):

*   它最初是使用`nullptr`创建的
*   `reset()`或`release()`被调用

为了检查`std::unique_ptr{}`是否有效，为了确保空取消引用不会意外发生，可以使用布尔运算符:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr = std::make_unique<int>(42);
    if (ptr) {
        std::cout << *ptr << '\n';
    }
    ptr.reset();
    if (ptr) {
        std::cout << *ptr << '\n';
    }
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 42
```

如该示例所示，一旦在`std::unique_ptr{}`上调用`reset()`，它将变为无效 (即等于`nullptr`)，并且布尔运算符返回`false`，从而阻止`nullptr`取消引用。

如果使用数组语法创建`std::unique_ptr{}`，则可以使用下标运算符访问数组中的特定元素，类似于使用标准 C 数组的下标运算符，或`std::array{}`:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr = std::make_unique<int[]>(42);
    std::cout << ptr[0] << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0
```

在前面的示例中，整数数组的大小为`42`，数组中的第一个元素输出到`stdout`，其中包含`0`的值，因为`std::make_unique()`使用值初始化来对所有分配进行零初始化。

It should be noted that even though the C++ Core Guidelines encourage the use of `std::unique_ptr{}` instead of manually allocating and deallocating C-style arrays, the guidelines do not encourage the use of the subscript operator to access the array since doing so performs unsafe pointer arithmetic, and could potentially lead to a `nullptr` dereference. Instead, a newly-allocated array using `std::unique_ptr{}` should be provided to `gsl::span` prior to being accessed.

C 17 关于`std::unique_ptr{}`的一个限制是无法直接将一个添加到 IO 流，例如`std::cout`。使用 C ++ 17，输出`std::unique_ptr{}`地址的最佳方法是使用`get()`函数，该函数返回指针的地址。另一种实现此目的的方法是创建用户定义的重载:

```
#include <memory>
#include <iostream>

template<typename T> std::ostream &
operator<<(std::ostream &os, const std::unique_ptr<T> &ptr)
{
    os << ptr.get();
    return os;
}

int main()
{
    auto ptr = std::make_unique<int>();
    std::cout << ptr << '\n';
    std::cout << ptr.get() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x55ed70997e70
```

# std::shared_ptr 指针

在大多数情况下，应该使用`std::unique_ptr{}`来分配动态内存。但是，在某些用例中，`std::unique_ptr{}`无法正确表示指针所有权。指针所有权是指谁拥有指针，或者换句话说，谁负责分配，更重要的是，释放指针。在大多数情况下，程序中的单个实体负责此任务。但是，在某些用例中，必须有多个实体要求对释放指针负责。

一个以上的实体必须要求对一个变量拥有所有权的最常见情况涉及线程。假设你有两个线程:

*   线程 #1 创建一个指针 (因此拥有它)
*   线程 #2 使用线程 #1 中的指针

在此示例中，第二个线程拥有的指针与创建指针并首先提供指针的第一个线程一样多。下面的示例演示了这种情况:

```
#include <thread>
#include <iostream>

class myclass
{
    int m_data{0};

public:

    ~myclass()
    {
        std::cout << "myclass deleted\n";
    }

    void inc()
    { m_data++; }
};

std::thread t1;
std::thread t2;

void
thread2(myclass *ptr)
{
    for (auto i = 0; i < 100000; i++) {
        ptr->inc();
    }

    std::cout << "thread2: complete\n";
}

void
thread1()
{
    auto ptr = std::make_unique<myclass>();
    t2 = std::thread(thread2, ptr.get());

    for (auto i = 0; i < 10; i++) {
        ptr->inc();
    }

    std::cout << "thread1: complete\n";
}

int main()
{
    t1 = std::thread(thread1);

    t1.join();
    t2.join();
}

// > g++ -std=c++17 -lpthread scratchpad.cpp; ./a.out
// thread1: complete
// myclass deleted
// thread2: complete
```

在本示例中，创建了第一个线程，它创建了一个指向`myclass`的指针。然后，它创建第二个线程，并将新创建的指针传递给第二个线程。两个线程都对指针执行一组操作，然后完成。问题是第一个线程没有第二个线程那么多的工作来执行，所以它很快完成，在第二个线程有机会完成之前释放指针，因为在这种情况下，我们已经明确指出`thread1`是指针的所有者，`thread2`只是指针的用户。

为了克服这个问题，C 提供了第二个智能指针，称为`std::shared_ptr{}`，它能够将所有权分配给多个实体。`std::shared_ptr{}`的语法与`std::unique_ptr{}`几乎相同:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr = std::make_shared<int>();
    std::cout << ptr.get() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x562e6ba9ce80
```

在内部，`std::shared_ptr{}`将托管对象维护在一个单独的对象中，该对象在原始`std::shared_ptr{}`的所有副本之间共享。此托管对象存储的是总数为`std::shared_ptr{}`的副本。每次创建副本时，托管对象内部的计数都会增加。当`std::shared_ptr{}`需要访问指针本身时，它必须使用其指向托管对象的指针来请求指针 (也就是说，`std::shared_ptr{}`不存储指针本身，而是存储指向存储指针的托管对象的指针)。每次销毁`std::shared_ptr{}`时，托管对象的计数都会减少，当计数达到`0`时，指针最终会释放回堆。

使用此模式，`std::shared_ptr{}`能够提供单个指针到多个实体的所有权。下面使用`std::shared_ptr{}`而不是`std::unique_ptr{}`重写前面的示例:

```
#include <thread>
#include <iostream>

class myclass
{
    int m_data{0};

public:

    ~myclass()
    {
        std::cout << "myclass deleted\n";
    }

    void inc()
    { m_data++; }
};

std::thread t1;
std::thread t2;

void
thread2(const std::shared_ptr<myclass> ptr)
{
    for (auto i = 0; i < 100000; i++) {
        ptr->inc();
    }

    std::cout << "thread2: complete\n";
}

void
thread1()
{
    auto ptr = std::make_shared<myclass>();
    t2 = std::thread(thread2, ptr);

    for (auto i = 0; i < 10; i++) {
        ptr->inc();
    }

    std::cout << "thread1: complete\n";
}

int main()
{
    t1 = std::thread(thread1);

    t1.join();
    t2.join();
}

// > g++ -std=c++17 -lpthread scratchpad.cpp; ./a.out
// thread1: complete
// thread2: complete
// myclass deleted
```

如该示例所示，为`thread2`提供了原始`std::shared_ptr{}`的副本，实际上创建了指向单个托管对象的两个副本。当`thread1`完成时，`thread2`仍然保持对被管理对象的引用，结果，指针保持完整。直到第二个线程完成，托管对象的引用计数才达到 0，并且指针才释放回堆。

需要注意的是，`std::shared_ptr{}`有一些缺点:

*   **内存占用**: 由于`std::shared_ptr{}`维护了指向托管对象的指针，因此`std::shared_ptr{}`可能会导致两个 malloc 而不是一个 (某些实现能够分配单个更大的内存块并将其用于指针和托管对象)。无论实现方式如何，`std::shared_ptr{}`所需要的内存量都大于`std::unique_ptr{}`，这往往是一个常规 C 型指针大小相同的 sd。
*   **性能**: 必须首先将对指针的所有访问重定向到托管对象，因为`std::shared_ptr{}`实际上没有指针本身的副本 (只是指向托管对象的指针)。因此，需要额外的函数调用 (即指针取消引用)。
*   **内存泄漏**: 在`std::unique_ptr{}`和`std::shared_ptr{}`之间存在权衡，并且都没有提供完美的解决方案来管理内存，以防止可能的`nullptr`解引用，同时防止内存泄漏。如图所示，在某些情况下使用`std::unique_ptr{}`可能会导致`nullptr`取消引用。另一方面，如果`std::shared_ptr{}`的副本数量从未达到 0，则`std::shared_ptr{}`可能会导致内存泄漏。虽然智能指针存在这些问题，但手动使用`new()`/`delete()`并不能解决这些问题 (几乎肯定会使它们变得更糟)，而且通常，如果在正确的场景中使用正确的智能指针类型，则可以缓解这些类型的问题。
*   **循环引用**: 可以用`std::shared_ptr{}`创建循环引用。

像`std::unique_ptr{}`一样，`std::shared_ptr{}`提供了一个`reset()`函数:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr1 = std::make_shared<int>();
    auto ptr2 = ptr1;
    std::cout << ptr1.get() << '\n';
    std::cout << ptr2.get() << '\n';
    ptr2.reset();
    std::cout << ptr1.get() << '\n';
    std::cout << ptr2.get() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x555b99574e80
// 0x555b99574e80
// 0x555b99574e80
// 0
```

在本示例中，将创建`std::shared_ptr{}`的两个副本。我们首先将这些指针的地址输出到`stdout`，并且正如预期的那样，该地址是有效的，并且它们是相同的 (因为它们都指向相同的托管对象)。接下来，我们使用`reset()`函数释放第二个指针，然后再次输出指针的地址。第二次，第一个`std::shared_ptr{}`仍然指向有效指针，而第二个指向`nullptr`，因为它不再具有对原始托管对象的引用。当`main()`函数完成时，指针最终被释放回堆。

C 17 版本的`std::shared_ptr{}`的一个问题是缺少数组版本，类似于`std::unique_ptr{}`。即没有`std::shared_ptr{}`的`std::shared_ptr<type[]>`版本，类似于`std::unique_ptr<type[]>{}`API。结果，没有办法使用`std::make_shared()`分配数组，并且没有下标运算符来访问数组中的每个元素。相反，您必须执行以下操作:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr = std::shared_ptr<int>(new int[42]());
    std::cout << ptr.get()[0] << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0
```

C 还提供了一种方法，用于确定存在多少个`std::shared_ptr{}`副本 (本质上只是向托管对象询问其引用计数):

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr1 = std::make_shared<int>();
    auto ptr2 = ptr1;
    std::cout << ptr1.get() << '\n';
    std::cout << ptr2.get() << '\n';
    std::cout << ptr1.use_count() << '\n';
    ptr2.reset();
    std::cout << ptr1.get() << '\n';
    std::cout << ptr2.get() << '\n';
    std::cout << ptr1.use_count() << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x5644edde7e80
// 0x5644edde7e80
// 2
// 0x5644edde7e80
// 0
// 1
```

此示例与前面的`reset()`示例类似，但是在`use_count()`函数中添加了一个调用，该函数报告了`std::shared_ptr{}`的总副本数。如图所示，当创建了两个`std::shared_ptr{}`副本时，`use_count()`报告`2`。当运行`reset()`时，`use_count()`减少到`1`，最终当`main()`完成时，这个计数将减少到`0`，指针将被释放到堆中。应该注意的是，在多线程环境中应谨慎使用此功能，因为相对于报告的计数可能会发生竞赛。

与`std::unique_ptr{}`类似，为`std::shared_ptr{}`提供了一个布尔运算符来检查指针是否有效。与`std::unique_ptr{}`不同，布尔运算符不会确定托管对象是否已被释放 (因为在某处可能存在`std::shared_ptr{}`的副本)。相反，布尔运算符报告`std::shared_ptr{}`是否维护对托管对象的引用。如果`std::shared_ptr{}`有效，则它具有对托管对象的引用 (从而访问分配的指针)，并且布尔运算符报告`true`。如果`std::shared_ptr{}`无效，则不再维护对托管对象的引用 (因此不具有对分配的指针的访问权限)，当调用`get()`时返回`nullptr`，布尔运算符报告`false`:

```
#include <memory>
#include <iostream>

int main()
{
    auto ptr = std::make_shared<int>();
    if (ptr) {
        std::cout << "before: " << ptr.get() << '\n';
    }
    ptr.reset();
    if (ptr) {
        std::cout << "after: "<< ptr.get() << '\n';
    }
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// before: 0x55ac226b5e80
```

如前面的示例所示，当调用`reset()`函数时，指针不再有效，因为智能指针的内部管理对象现在指向`nullptr`，因此，布尔运算符返回`false`。由于没有其他的`std::shared_ptr{}`副本 (即托管对象的计数为`0`)，因此分配的指针也会释放回堆。

与`std::unique_pt{}r`一样，都提供了`*`和`->`运算符来取消引用`std::shared_ptr{}` (但没有下标运算符，因为不支持数组):

```

#include <memory>
#include <iostream>

struct mystruct {
    int data;
};

int main()
{
    auto ptr = std::make_shared<mystruct>();
    std::cout << ptr->data << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0
```

最后，`std::shared_ptr{}`的一个问题是循环引用。以下示例可以最好地描述问题:

```
#include <memory>
#include <iostream>

class myclass2;

class myclass1
{
public:

    ~myclass1()
    {
        std::cout << "delete myclass1\n";
    }

    std::shared_ptr<myclass2> m;
};

class myclass2
{
public:

    ~myclass2()
    {
        std::cout << "delete myclass2\n";
    }

    std::shared_ptr<myclass1> m;
};

int main()
{
    auto ptr1 = std::make_shared<myclass1>();
    auto ptr2 = std::make_shared<myclass2>();
    ptr1->m = ptr2;
    ptr2->m = ptr1;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
```

在本示例中，创建了两个类-`myclass1`和`myclass2`。`myclass1`和`myclass2`都保持对彼此的`std::shared_ptr{}`引用 (也就是说，无论出于什么原因，两个类都声称对另一个拥有所有权)。当指针被销毁时，没有内存被释放回堆，因为没有一个析构函数被调用。为了理解原因，我们需要分解制作的副本数量以及它们存在的位置。

`ptr1`和`ptr2`的原始`std::shared_ptr{}`都是在`main()`函数中创建的，这意味着`#1`和`#2`托管对象在创建时都具有`use_count()`的`1`。接下来，将为`ptr2`提供`std::shared_ptr{}`的副本，以及 vice 版本，这意味着`#1`和`#2`托管对象现在都具有`2`的`use_count()`。当`main()`完成时，`main()`函数中`ptr2`的`std::shared_ptr{}` (不是`ptr1`中的`std::shared_ptr{}`) 被销毁，但由于`ptr1`中还有`std::shared_ptr{}`的`ptr2`副本，指针本身不会被释放。接下来，`main()`中的`ptr1`被销毁，但是由于`ptr2`的副本仍然存在于`ptr1`的其中一个副本中，所以`ptr1`本身没有被释放，因此，我们已经创建了一个相互指向的`ptr1`和`ptr2`的副本，但是代码本身中没有留下这些指针的副本来释放这个内存，因此内存被永久删除。

为了解决这个问题，`std::shared_ptr{}`提供了一个名为`std::weak_ptr{}`的版本。它具有与`std::shared_ptr{}`相同的所有属性，但不增加托管对象的引用计数器。尽管可以使用`get()`函数来代替存储原始指针，但`std::weak_ptr{}`仍然保持与托管对象的连接，提供了一种方法来确定托管对象是否已被销毁，这是您无法使用原始指针执行的操作。为了说明这一点，前面的示例已转换为在`myclass1`和`myclass2`中使用`std::weak_ptr{}`而不是`std::shared_ptr{}`:

```
#include <memory>
#include <iostream>

class myclass2;

class myclass1
{
public:

    ~myclass1()
    {
        std::cout << "delete myclass1\n";
    }

    std::weak_ptr<myclass2> m;
};

class myclass2
{
public:

    ~myclass2()
    {
        std::cout << "delete myclass2\n";
    }

    std::weak_ptr<myclass1> m;
};

int main()
{
    auto ptr1 = std::make_shared<myclass1>();
    auto ptr2 = std::make_shared<myclass2>();
    ptr1->m = ptr2;
    ptr2->m = ptr1;
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// delete myclass2
// delete myclass1
```

如图所示，即使循环引用仍然存在，分配的指针在完成`main()`时释放回堆。最后，需要注意的是，可以使用以下语法将`std::unique_ptr`转换为`std::shared_ptr`:

```
auto ptr = std::make_unique<int>();
std::shared_ptr<int> shared = std::move(ptr);
```

由于`std::unique_ptr`被移动，它不再拥有指针，而`std::shared_ptr`现在拥有指针。不允许从`std::shared_ptr`移动到`std::unqiue_ptr`。

# 了解映射和权限

在本节中，读者将学习如何使用 C 模式映射内存。您将学习如何使用 C 模式映射内存 (一种常见的系统编程技术)。

# 基础知识

`malloc()`/`free()`、`new()`/`delete()`和`std::unique_ptr{}`/`std::shared_ptr{}`不是在 POSIX 系统上分配内存的唯一方法。C 型分配器是另一种更复杂的内存分配方法，将在[第 9 章](09.html)，*中详细讨论。用于分配内存的更直接的 POSIX 样式是使用`mmap()`:*

```
#include <iostream>
#include <sys/mman.h>

constexpr auto PROT_RW = PROT_READ | PROT_WRITE;
constexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;

int main()
{
    auto ptr = mmap(0, 0x1000, PROT_RW, MAP_ALLOC, -1, 0);
    std::cout << ptr << '\n';

    munmap(ptr, 0x1000);
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x7feb41ab6000
```

`mmap()`函数可用于将来自不同来源的内存映射到程序中。例如，如果要将设备内存放入应用程序中，则可以使用`mmap()`。如果将`MAP_ANONYMOUS`传递给`mmap()`，则它可以用于分配内存，与使用`malloc()`和`free()`分配内存的方式相同。在前面的示例中，`mmap()`用于分配标记为读/写的 4k 页内存。`MAP_PRIVATE`的使用告诉`mmap()`您不打算与其他应用程序共享此内存 (例如，用于进程间通信)。这种方式映射内存与`malloc()`/`free()`相比有一些优点和缺点。

**优势**:

*   **分片**: 使用`MAP_ANONYMOUS`分配内存通常将内存映射为页面大小的倍数，或者最坏的情况是 2 的幂。这是因为`mmap()`向 OS 内核要块内存，并且该内存必须映射到应用程序中，这只能在不小于页面的块中完成。因此，这种存储器的碎片是不太可能的，多个随机存储器分配通常使用`malloc()`。
*   **权限**: 使用`mmap()`时，您可以声明要应用到新分配的内存的权限。如果您需要具有特殊权限的内存，例如读取/执行内存，这尤其有用。
*   **共享内存**: 使用`mmap()`分配的内存也可以由另一个应用程序共享，而不是像`malloc()`那样为特定应用程序私有分配。

**缺点**:

*   **性能**: `malloc()`/`free()`分配和释放到由应用程序内部的 C 库管理的内存块。如果需要更多内存，C 库将使用`brk()`甚至`mmap()`之类的函数调用 OS，以从 OS 获取更多内存。当 free 被调用时，释放的内存将被提供回由 C 库管理的内存，并且在很多情况下从未实际提供回 OS。因此，`malloc()`/`free()`可以快速为应用程序分配内存，因为没有进行特定于操作系统的调用 (当然，除非 C 库内存不足)。另一方面，每个分配都必须调用 OS。因此，它的性能不如`malloc()`/`free()`，因为操作系统调用可能会很昂贵。
*   **粒度**: 与`mmap()`减少碎片的原因相同，它也减少了粒度。即使请求的内存只有一个字节，`mmap()`进行的每个单个分配至少都是一页大小。

要证明`mmap()`的潜在浪费，请参见以下内容:

```
#include <iostream>
#include <sys/mman.h>

constexpr auto PROT_RW = PROT_READ | PROT_WRITE;
constexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;

int main()
{
    auto ptr1 = mmap(0, 42, PROT_RW, MAP_ALLOC, -1, 0);
    auto ptr2 = mmap(0, 42, PROT_RW, MAP_ALLOC, -1, 0);

    std::cout << ptr1 << '\n';
    std::cout << ptr2 << '\n';

    munmap(ptr1, 42);
    munmap(ptr2, 42);
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x7fc1637ad000
// 0x7fc1637ac000
```

在此示例中，42 个字节被分配两次，但是结果地址相距 4k 页。这是因为通过`mmap()`进行的分配必须至少是一页大小，即使请求的数量只有 42 个字节。`malloc()`/`free()`没有这种浪费的原因是这些函数一次从 OS 请求大块内存，然后在 C 库内部使用各种不同的分配方案来管理这个内存。有关如何完成此操作的更多信息，在`newlib`中有一个关于以下主题的很好的解释: [https://sourceware.org/git/？p= newlib-cygwin.git;a = blob;f = newlib/libc/stdlib/malloc.c。](https://sourceware.org/git/?p=newlib-cygwin.git;a=blob;f=newlib/libc/stdlib/malloc.c;h=f5ac2920888563013663454758cce102e40b69ad;hb=HEAD) 

# 权限

`mmap()`可用于分配具有特殊参数的内存。例如，假设您需要分配具有读取/执行权限的内存，而不是通常与`malloc()`/`free()`关联的读取/写入权限:

```
#include <iostream>
#include <sys/mman.h>

constexpr auto PROT_RE = PROT_READ | PROT_EXEC;
constexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;

int main()
{
    auto ptr = mmap(0, 0x1000, PROT_RE, MAP_ALLOC, -1, 0);
    std::cout << ptr << '\n';

    munmap(ptr, 0x1000);
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x7feb41ab6000
```

如图所示，分配具有读/执行权限的内存与分配具有读/写权限的内存将`PROT_WRITE`替换为`PROT_EXEC`相同。

On systems that support read/write or read/execute (also known as W^E, which states that write is mutually exclusive with execute), write and execute permissions should not be used together at the same time. Specifically, in the event of malicious use of your program, preventing executable memory from also having write permissions can prevent a number of known cyber attacks. 

将内存分配为读取/执行而不是读取/写入/执行的问题是，没有简单的方法将可执行代码放入新分配的缓冲区，因为内存被标记为仅读取/执行。如果您希望分配只读存储器，情况也是如此。再一次，由于从未添加过写权限，因此无法将数据添加到只读存储器中，因为它没有写权限。

更糟糕的是，一些操作系统阻止应用程序在试图强制执行 W ^ E 权限时分配读/写/执行内存。为了克服这个问题，POSIX 仍然提供了一种设置所需权限的方法，它提供了`mprotect()`，它允许您更改已经分配的内存的权限。尽管这可能与由`malloc()`/`free()`管理的内存一起使用，但应与`mmap()`内存权限一起使用，该权限只能在大多数体系结构上的页面级别强制执行。`malloc()`/`free()`从一个大缓冲区分配，该缓冲区在程序的所有分配之间共享，而`mmap()`仅分配具有页粒度的内存，因此不被其他分配共享。

下面展示了如何使用`mprotect`的示例:

```
#include <iostream>
#include <sys/mman.h>

constexpr auto PROT_RW = PROT_READ | PROT_WRITE;
constexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;

int main()
{
    auto ptr = mmap(0, 0x1000, PROT_RW, MAP_ALLOC, -1, 0);
    std::cout << ptr << '\n';

    if (mprotect(ptr, 0x1000, PROT_READ) == -1) {
        std::clog << "ERROR: Failed to change memory permissions\n";
        ::exit(EXIT_FAILURE);
    }

    munmap(ptr, 0x1000);
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 0x7fb05b4b6000
```

在本示例中，`mmap()`用于分配具有读写权限的 4k 页面大小的缓冲区。分配内存后，将使用`mprotect()`将内存的权限更改为只读。最后，使用`munmap()`将内存释放回操作系统。

# 智能指针和 mmap()

关于 C，`mmap()`和`munmap()`最大的问题是它们遭受了很多与`malloc()`/`free()`相同的缺点:

*   **内存泄漏**: 由于`mmap()`和`munmap()`必须手动执行，所以当不再需要内存时，用户可能忘记调用`munmap()`，或者一个复杂的逻辑错误可能导致`munmap()`没有在正确的时间被调用。
*   **内存不匹配**: 有可能是`mmap()`的用户偶然调用`free()`而不是`munmap()`，导致不匹配，几乎肯定会产生不稳定，因为`mmap()`的内存来自 OS 内核，而`free()`是期待来自应用程序堆的内存。

为了克服这个问题，应该用`std::unique_ptr{}`包裹`mmap()`:

```
#include <memory>
#include <iostream>

#include <string.h>
#include <sys/mman.h>

constexpr auto PROT_RW = PROT_READ | PROT_WRITE;
constexpr auto MAP_ALLOC = MAP_PRIVATE | MAP_ANONYMOUS;

class mmap_deleter
{
    std::size_t m_size;

public:
    mmap_deleter(std::size_t size) :
        m_size{size}
    { }

    void operator()(int *ptr) const
    {
        munmap(ptr, m_size);
    }
};

template<typename T, typename... Args>
auto mmap_unique(Args&&... args)
{
    if (auto ptr = mmap(0, sizeof(T), PROT_RW, MAP_ALLOC, -1, 0)) {

        auto obj = new (ptr) T(args...);
        auto del = mmap_deleter(sizeof(T));

        return std::unique_ptr<T, mmap_deleter>(obj, del);
    }

    throw std::bad_alloc();
}

int main()
{
    auto ptr = mmap_unique<int>(42);
    std::cout << *ptr << '\n';
}

// > g++ -std=c++17 scratchpad.cpp; ./a.out
// 42
```

在这个例子中，main 函数调用`mmap_unique()`而不是`std::make_unqiue()`，因为`std::make_unique()`使用`new()`/`delete()`分配内存，我们希望使用`mmap()`/`munmap()`代替。`mmap_unique()`函数的第一部分使用`mmap()`分配内存的方式与我们前面的示例相同。在这种情况下，权限被设置为读/写，但如果需要，也可以使用`mprotect()`来提供只读或读/执行。如果调用`mmap()`失败，则抛出`std::bad_alloc()`，就像 C 库一样。

本示例中的下一行使用`new()`放置运算符，如前面在*放置新*部分中所述。此调用的目标是创建一个对象，该对象的构造函数已被调用以根据需要初始化`T`类型。在这个例子中，这是将一个整数设置为`42`，但是如果使用了一个类而不是一个整数，那么这些类的构造函数将被调用，无论什么参数被传递给`mmap_unique()`。

下一步是为我们的`std::unqiue_ptr{}`创建一个自定义删除器。这样做是因为默认情况下，`std::unqiue_ptr{}`将调用`delete()`运算符，而不是`munmap()`。自定义删除程序采用单个参数，该参数是原始分配的大小。这是需要的，因为`munmap()`需要知道原始分配的大小，不像`delete()`和`free()`，只取一个指针。

最后，使用新创建的对象和自定义删除程序创建`std::unique_ptr{}`。从这一点开始，使用`mmap()`分配的所有内存都可以使用标准`std::unique_ptr{}`接口访问，并将其视为正常分配。当指针不再需要，并且`std::unique_ptr{}`超出范围时，指针将按预期调用`munmap()`释放回 OS 内核。

# 共享内存

除了分配内存之外，`mmap()`还可以用于分配共享内存，通常用于进程间通信。为了演示这一点，我们首先定义一个共享内存名称`"/shm"`，以及我们的读、写和执行权限:

```
#include <memory>
#include <iostream>

#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/mman.h>

constexpr auto PROT_RW = PROT_READ | PROT_WRITE;

auto name = "/shm";
```

接下来，我们必须定义我们的自定义 deleter，它使用`munmap()`而不是`free()`:

```
class mmap_deleter
{
    std::size_t m_size;

public:
    mmap_deleter(std::size_t size) :
        m_size{size}
    { }

    void operator()(int *ptr) const
    {
        munmap(ptr, m_size);
    }
};
```

在这个例子中，我们建立在前面的例子，但我们没有一个单一的`mmap_unique()`函数，我们现在有一个服务器和一个客户端版本。尽管通常将共享内存用于进程间通信，但在本示例中，我们在同一应用程序中共享内存以保持简单。

`main`函数同时创建服务器和客户端共享指针。服务器版本使用以下内容创建共享内存:

```
template<typename T, typename... Args>
auto mmap_unique_server(Args&&... args)
{
  if(int fd = shm_open(name, O_CREAT | O_RDWR, 0644); fd != -1) {
      ftruncate(fd, sizeof(T));

        if (auto ptr = mmap(0, sizeof(T), PROT_RW, MAP_SHARED, fd, 0)) {

            auto obj = new (ptr) T(args...);
            auto del = mmap_deleter(sizeof(T));

            return std::unique_ptr<T, mmap_deleter>(obj, del);
        }
    }

    throw std::bad_alloc();
}
```

该函数与前面示例中的`mmap_unique()`函数类似，但是打开一个共享内存文件的句柄，而不是使用`MAP*_*ANONYMOUS`分配内存。要打开共享内存文件，我们使用`POSIX shm_open()`函数。该函数类似于`open()`函数。第一个参数是共享内存文件的名称。第二个参数定义了文件的打开方式，而第三个参数提供了模式。`shm_open()`用于打开共享内存文件，并检查文件描述符以确保分配成功 (即文件描述符不是`-1`)。

接下来，文件描述符被截断。这样可以确保共享内存文件的大小等于我们希望共享的内存大小。在这种情况下，我们希望共享一个`T`类型，因此我们需要获取`T`的大小。一旦共享内存文件的大小正确，我们需要使用`mmap()`在共享内存中映射。对`mmap()`的调用与我们前面的示例相同，只是使用`MAP_SHARED`。

最后，像前面的示例一样，我们利用`new()`放置运算符在共享内存中创建新分配的类型，我们创建自定义删除器，然后最后，我们为该共享内存返回`std::unique_ptr{}`。

要连接到此共享内存 (可以从另一个应用程序完成)，我们需要使用客户端版本的`mmap_unique()`函数:

```
template<typename T>
auto mmap_unique_client()
{
  if(int fd = shm_open(name, O_RDWR, 0644); fd != -1) {
      ftruncate(fd, sizeof(T));

        if (auto ptr = mmap(0, sizeof(T), PROT_RW, MAP_SHARED, fd, 0)) {

            auto obj = static_cast<T*>(ptr);
            auto del = mmap_deleter(sizeof(T));

            return std::unique_ptr<T, mmap_deleter>(obj, del);
        }
    }

    throw std::bad_alloc();
}
```

这些功能的服务器和客户端版本看起来相似，但有区别。首先，在没有`O_CREAT`的情况下打开共享内存文件。这是因为服务器创建共享内存文件，而客户端连接到共享内存文件，因此不需要在客户端版本中传递`O_CREAT`。最后，此函数的客户端版本的签名不需要像服务器版本那样的任何参数。这是因为服务器版本使用`new()`放置来初始化共享内存，不需要第二次。在将指针传递到新创建的`std::unique_ptr{}`之前，使用`static_cast()`将`void *`转换为正确的类型，而不是使用新的放置位置:

```
int main()
{
    auto ptr1 = mmap_unique_server<int>(42);
    auto ptr2 = mmap_unique_client<int>();
    std::cout << *ptr1 << '\n';
    std::cout << *ptr2 << '\n';
}

// > g++ -std=c++17 scratchpad.cpp -lrt; ./a.out
// 42
// 42
```

此示例的结果是，服务器和客户端之间共享内存，将共享内存包装在`std::unique_ptr{}`中。此外，如示例中所示，内存是正确共享的，从为指针的服务器和客户端版本打印`42`可以看出。尽管我们将其用于整数类型，但这种类型的共享内存可以根据需要与任何复杂类型一起使用 (尽管在尝试共享类时要小心，尤其是那些利用继承并包含`vTable`的类)。

# 学习记忆碎片的重要性

如果不简要讨论碎片，任何关于内存管理的章节都不会完整。内存碎片 (Memory fragmentation) 是指内存被分解成块，经常散开的过程，几乎总是导致分配器无法为应用程序分配内存，最终导致`std::bad_alloc()`在 C 中被抛出。在对系统进行编程时，碎片应该始终是一个问题，因为它会极大地影响程序的稳定性和可靠性，尤其是在资源受限的系统 (例如嵌入式和移动应用程序) 上。在本节中，读者将简要介绍碎片，以及它如何影响他们创建的程序。

碎片化有两种类型 -- 外部碎片化和内部碎片化。

# 外部碎片

外部碎片是指在不同大小的块中分配和释放内存的过程，最终导致大量不可用，不可分配的内存。为了证明这一点，假设我们有五个分配:

![](assets/9fc89297-46e9-493a-994f-e7b8b2386dcf.png)]

所有五个分配都成功，并且所有内存都已分配。现在，让我们假设第二和第四分配被释放回堆:

![](assets/02d7340a-fdc8-4d25-9506-74b811a03676.png)]

通过将内存释放回堆，现在可以再次分配内存。问题在于，由于原始的 1、3 和 5 分配，该内存被分散了。现在，假设我们要进行最终分配:

![](assets/bdfab869-a161-4d4f-ae94-adc506cc324c.png)]

最终分配失败，即使有足够的可用内存用于分配，因为可用内存是分散的-换句话说，可用内存是碎片化的。

在一般情况下，外部碎片是一个极难解决的问题，这个问题已经研究了多年，随着时间的推移，操作系统会实现各种方法。在[第 9 章](09.html)，*分配器的动手方法*中，我们将讨论如何使用 C 分配器使用各种不同的自定义分配器模式来解决程序中的一些外部碎片问题。

# 内部碎片

内部碎片是指在分配过程中浪费了内存。例如，当我们使用`mmap()`分配一个整数时，就像我们在前面的示例中所做的那样，`mmap()`为该整数分配了整个页面，从而在该过程中浪费了将近 4k 的内存。这被称为内部碎片:

![](assets/5e7d70c8-4671-46ec-8946-83c569822fd1.png)]

与外部碎片一样，内部碎片丢失的内存不能用于其他分配。实际上，高层内存的视图看起来就像外部碎片的视图。不同之处在于，外部分片不断地占用大块的免费的，未分配的内存，并将其分解为越来越小的分片内存，在某些时候它变得太小而无法在将来分配。内部碎片看起来是一样的，但在某些情况下，甚至更大的、不可用的内存块也会在整个内存中出现碎片。这个不可用的内存不是不可用的，因为它对于给定的分配来说不够大，而是因为不可用的内存已经被一个较小的、以前的分配所声称，它根本不使用它所给出的所有内存。

应该注意的是，在解决碎片问题时，解决方案通常是针对一种类型的碎片而不是另一种类型的碎片进行优化，每种选择都有其优点和缺点。

# 内部超过外部碎片

`malloc()`和`free()`使用的分配器通常倾向于优化内部碎片而不是外部碎片。目标是为分配器提供尽可能少的浪费，然后利用各种不同的分配模式来尽可能减少外部碎片化的可能性。这些类型的分配器对于应用程序是优选的，因为它们最小化了任何给定操作系统上单个应用程序的内存需求，从而为其他应用程序留下了额外的内存。此外，如果外部碎片阻止了分配的发生，应用程序总是要求操作系统提供更多的内存 (直到操作系统运行干燥)。

# 外部过度内部分裂

操作系统倾向于针对外部碎片而不是内部碎片进行优化。这样做的原因是操作系统通常只能以页面粒度分配内存，这意味着在许多情况下内部碎片是不可避免的。此外，如果允许随着时间的推移发生外部碎片，如果有足够的时间执行，它将导致操作系统最终崩溃。出于这个原因，操作系统使用诸如 buddy allocator 模式之类的分配模式，该模式对外部碎片进行了优化，甚至以牺牲大量内部碎片为代价。

# 摘要

在本章中，我们学习了使用`new()`和`delete()`和`malloc()`和`free()`分配内存的各种方法，包括对齐内存和 C 风格数组。我们研究了全局内存 (全局空间中的内存)，堆栈内存 (或作用域内存) 和动态分配内存 (使用`new()`和`delete()`分配的内存) 之间的差异。还讨论了`new()`和`delete()`的安全问题，我们演示了如何使用 C 智能指针 (包括`std::shared_ptr{}`和`std::unique_ptr{}`) 来防止程序中常见的不稳定问题，以及它们如何提供 C 核心指导支持。我们在本章结束时快速回顾了碎片及其如何影响系统程序。

在下一章中，我们将介绍文件输入和输出，包括对文件的读写，以及 C 17 添加的文件系统 api。

# 问题

1.  `new()`和`new[]()`有什么区别？
2.  可以安全地使用`delete()`将内存释放回使用`new[]()`分配的堆吗？
3.  全局内存和静态内存有什么区别？
4.  如何使用`new()`分配对齐的内存？
5.  `std::make_shared()`可以用来分配数组吗？
6.  什么时候应该用`std::shared_ptr{}`代替`std::unique_ptr{}`？
7.  `mmap()`可以用来分配读/执行内存吗？
8.  内部碎片化和外部碎片化有什么区别？

# 进一步阅读

*   [https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)
*   [https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)