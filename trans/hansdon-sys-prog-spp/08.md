# 学习编程文件输入/输出

文件**输入**/**输出** (**I/O**) 是大多数系统级程序的重要组成部分。它可以用于调试，保存程序状态，处理用户特定的数据，甚至与物理设备 (感谢 POSIX 块和字符设备) 的接口。

在 C 17 之前，使用文件 I/O 很困难，因为必须使用非 C api 来处理文件系统管理，这些 api 通常是不安全的，特定于平台的，甚至是不完整的。

在本章中，我们将对如何打开、读取和写入文件以及如何处理路径、目录和文件系统进行实践回顾。最后，我们将提供三个不同的示例，这些示例演示如何登录到文件，跟踪现有文件以及对 C 文件输入/输出 api 进行基准测试。

本章将涵盖以下主题:

*   打开文件的方法
*   读取和写入文件
*   文件实用程序

# 技术要求

为了编译和执行本章中的示例，读者必须具有以下内容:

*   能够编译和执行 C 17 的基于 Linux 的系统 (例如，Ubuntu 17.10)
*   GCC 7
*   C 让 3.6
*   互联网连接

要下载本章中的所有代码，包括示例和代码片段，请参见以下链接: [https://github.com/PacktPublishing/ 动手系统编程与 CPP/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter08)。

# 打开文件

打开文件有很多方法。我们将在以下章节中讨论其中的一些内容，以及如何使用`std::fstream`C api 来实现这一目标。

# 打开文件的不同方法

在 C 中打开文件就像为`std::fstream`对象提供要打开的对象的文件名和路径一样简单。如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::cout << "success\n";
    }
    else {
        std::cout << "failure\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在此示例中，我们打开一个名为`test.txt`的文件，该文件是我们以前使用 POSIX`touch`命令创建的。此文件以读/写权限打开 (因为这是默认模式)。

该文件存储在名为`file`的变量中，并对其进行检查以确保使用`std::fstream`提供的 bool 运算符重载正确打开了该文件。如果成功打开此文件，我们将输出`success`到`stdout`。

前面的示例利用了这样一个事实，即`std::fstream`对象具有重载`bool`运算符，该运算符在成功打开文件时返回 true。更明确地执行此操作的另一种方法是使用`is_open()`函数，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt"); file.is_open()) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在前面的示例中，我们不用依赖`bool`运算符重载，而是利用 C 17 在`if`语句中使用`is_open()`检查文件是否打开。通过使用构造函数来初始化`std::fstream`，而不是显式调用`open()`，进一步简化了前面的示例，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    auto file = std::fstream();
    if (file.open("test.txt"); file.is_open()) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在此示例中，`std::fstream`对象是使用默认构造函数创建的，这意味着尚未打开任何文件，这使我们可以推迟打开文件，直到准备这样做为止。然后，我们使用`open()`函数打开文件，然后，与前面的示例类似，我们利用 C 17 检查文件是否在将`success`输出到`stdout`之前打开。

在前面的所有示例中，都不需要在文件上调用`close()`。这是因为，像其他 C 类，如利用 RAII 的`std::unique_ptr`一样，`std::fstream`对象会在销毁时自动为您关闭文件。

但是，如果需要，可以显式关闭文件，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    std::cout << std::boolalpha;

    if (auto file = std::fstream("test.txt")) {
        std::cout << file.is_open() << '\n';
        file.close();
        std::cout << file.is_open() << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// true
// false
```

在此示例中，我们打开一个文本文件，并使用`is_open()`检查文件是否打开。第一次使用`is_open()`返回 true，因为文件已成功打开。然后，我们使用`close()`显式关闭文件，然后使用`is_open()`检查文件是否再次打开，现在返回 false。

# 打开文件的模式

到目前为止，我们已经使用默认模式打开了文件。有两种模式可能用于打开文件:

*   `std::ios::in`: 打开文件读取
*   `std::ios::out`: 打开文件进行写入

此外，还有其他几种模式可以与这两种模式结合使用，以修改文件的打开方式:

*   `std::ios::binary`: 打开文件以供二进制使用。默认情况下，`std::fstream`处于文本模式，该模式应用有关如何使用换行符格式化文件以及可以将哪些类型的字符读取/写入文件的特定规则。这些规则通常适用于文本文件，但当您尝试向文件读取/写入二进制数据时会导致问题。在这种情况下，应将`std::ios::binary`添加到您的模式说明符中。
*   `std::ios::app`: 当此模式与`std::ios::out`一起使用时，所有对文件的写入都附加到文件的末尾。
*   `std::ios::ate`: 当此模式与`std::ios::in`或`std::ios::out`一起使用时，一旦成功打开，文件将位于文件的末尾。也就是说，对文件的读写发生在文件的末尾，即使在文件打开之后也是如此。
*   `std::ios::trunc`: 当此模式与`std::ios::in`或`std::ios::out`一起使用时，在打开文件之前会删除文件内容。

为了演示这些模式，第一个示例打开一个文件以二进制模式读取:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    constexpr auto mode = std::ios::in | std::ios::binary;
    if (auto file = std::fstream("test.txt", mode)) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

所有模式都是常量值，因此，在前面的示例中，`constexpr`用于创建一个新的常量，称为`mode`，表示以只读二进制模式打开文件。要以文本模式而不是二进制模式打开只读文件，只需删除`std::ios::binary`模式，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    constexpr auto mode = std::ios::in;
    if (auto file = std::fstream("test.txt", mode)) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在上面的示例中，我们以只读文本模式打开文件。同样的逻辑也可能用于只写，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    constexpr auto mode = std::ios::out | std::ios::binary;
    if (auto file = std::fstream("test.txt", mode)) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在这里，我们以仅写的二进制模式打开文件。要在仅写测试模式下打开文件，请使用以下方法:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    constexpr auto mode = std::ios::out;
    if (auto file = std::fstream("test.txt", mode)) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

再一次，由于`std::ios::binary`已被遗漏，此代码以仅写文本模式打开文件。

要在文件末尾 (而不是文件的开头，这是默认的) 以仅写的二进制模式打开文件，请使用以下内容:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    constexpr auto mode = std::ios::out | std::ios::binary | std::ios::ate;
    if (auto file = std::fstream("test.txt", mode)) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在此示例中，我们通过在模式变量中添加`std::ios::ate`，在文件末尾以仅写二进制模式打开文件。这会将文件中的输出指针移动到文件的末尾，但允许在文件中的任何位置进行写入。

要确保文件始终附加到文件末尾，请使用`std::ios::app`而不是`std::ios::ate`打开文件，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    constexpr auto mode = std::ios::out | std::ios::binary | std::ios::app;
    if (auto file = std::fstream("test.txt", mode)) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在前面的示例中，在使用`std::ios::app`打开文件时，对文件的写入和添加始终会附加到文件中。

需要注意的是，在前面所有使用`std::ios::out`的示例中，文件都是使用`std::ios::trunc`打开的。这是因为使用`std::ios::out`时，截断模式是默认的，除非使用`std::ios::ate`或`std::ios::app`。这样做的问题是，没有办法在不截断文件的情况下只在文件开头打开文件进行写入。

为了克服这个问题，可以使用以下方法:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    constexpr auto mode = std::ios::out | std::ios::binary | std::ios::ate;
    if (auto file = std::fstream("test.txt", mode); file.seekp(0)) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在这个例子中，我们在文件的末尾以只写的二进制模式打开文件，然后我们使用`seekp()` (一个稍后将解释的函数) 将文件中的输出位置移动到文件的开头。

虽然在使用`std::ios::out`时默认为`std::ios::trunc`，但如果也使用`std::ios::in` (即读/写模式)，如果希望在打开文件前清除文件内容，则必须明确添加`std::ios::trunc`，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    constexpr auto mode = std::ios::in | std::ios::out | std::ios::trunc;
    if (auto file = std::fstream("test.txt", mode)) {
        std::cout << "success\n";
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; touch test.txt; ./a.out
// success
```

在这里，以读/写模式打开文件，并且在打开文件之前删除文件的内容。

# 读取和写入文件

以下各节将帮助您了解如何使用`std::fstream`C api 读取和写入文件。

# 从文件中读取

C 提供了几种不同的读取文件的方法，包括按字段，按行和按字节数。

# 按领域阅读

从文件中读取最类型安全的方法是按字段，代码如下:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::string hello, world;
        file >> hello >> world;
        std::cout << hello << " " << world << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// Hello World
```

在这个例子中，我们打开一个文件进行读写 (因为这是默认模式)。如果文件成功打开，我们将两个字符串分别读入两个变量-`hello`和`world`。要读取这两个字符串，我们使用`>> operator()`，它的行为就像`std::cin`在[第 6 章](06.html)，*学习编程控制台输入/输出*中讨论的那样。

对于字符串，流读取字符，直到发现第一个空格或换行符。与`std::cin`一样，数值变量也可以读取，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        int answer;
        file >> answer;
        std::cout << "The answer is: " << answer << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "42" > test.txt; ./a.out
// The answer is: 42
```

在这个例子中，我们用整数而不是字符串读取，就像字符串一样，流以字节读取，直到发现空格或换行符，然后将输入解释为数字。当然，如果读取的字段不是数字，则读取`0`，如下所示:

```cpp
// > g++ -std=c++ 17 scratchpad.cpp; echo "not_a_number" > test.txt; ./a.out
// The answer is: 0
```

应该注意的是，当这种情况发生时会设置一个错误标志，我们将在本章后面讨论这个问题。

与其他 C 流一样，可以重载`std::fstream`以提供对用户定义类型的支持，如下所示:

```cpp
#include <fstream>
#include <iostream>

struct myclass
{
    std::string hello;
    std::string world;
};

std::fstream &operator >>(std::fstream &is, myclass &obj)
{
    is >> obj.hello;
    is >> obj.world;

    return is;
}

std::ostream &operator<<(std::ostream &os, const myclass &obj)
{
    os << obj.hello;
    os << ' ';
    os << obj.world;

    return os;
}

int main()
{
    if (auto file = std::fstream("test.txt")) {
        myclass obj;
        file >> obj;
        std::cout << obj << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// Hello World
```

在此示例中，我们创建了一个名为`myclass`的用户定义类型。在`main()`函数中，我们打开一个文件，如果文件打开成功，我们创建一个`myclass{}`对象，将文件读入`myclass{}`对象，然后将`myclass{}`对象的结果输出到`stdout`。

要将文件读入`myclass{}`对象中，我们对`std::fstream{}`重载`>> operator()`，后者读取两个字符串，并将结果存储在`myclass{}`对象中。要将`myclass{}`对象输出到`stdout`，我们基于在[第 6 章](06.html)，*学习到编程控制台输入/输出*中学习的内容，关于用户定义的`std::ostream`重载，并为我们的`myclass{}`对象提供用户定义的重载。

结果是从文件中读取`Hello World`并输出到`stdout`。

# 读取字节

除了从文件中读取字段外，C 还支持直接从文件中读取字节。要从流中读取单个字节，请使用`get()`函数，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        char c = file.get();
        std::cout << c << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// H
```

在 C 17 中读取多个字节仍然是不安全的操作，因为没有能力将*x*字节数直接读取到`std::string`。这意味着必须使用标准的 C 风格缓冲区，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        char buf[25] = {};
        file.read(buf, 11);
        std::cout << buf << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// Hello World
```

在前面的示例中，我们创建了一个称为`buf`的标准 C 样式字符缓冲区，然后从文件中读取 11 个字节到该字符缓冲区中。最后，我们将结果输出到`stdout`。

我们需要确保被读取的字节总数不超过缓冲区本身的总大小 -- 这种操作经常导致编码错误，产生难以调试的缓冲区溢出。

解决此问题的简单方法是在`read()`函数周围使用一个包装器，该包装器检查以确保请求的字节数不超过缓冲区的总大小，如下所示:

```cpp
#include <fstream>
#include <iostream>

template<typename T, std::size_t N>
void myread(std::fstream &file, T (&str)[N], std::size_t count)
{
    if (count >= N) {
        throw std::out_of_range("file.read out of bounds");
    }

    file.read(static_cast<char *>(str), count);
}

int main()
{
    if (auto file = std::fstream("test.txt")) {
        char buf[25] = {};
        myread(file, buf, 11);
        std::cout << buf << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// Hello World
```

在此示例中，我们创建了一个名为`myread()`的模板函数，该函数在编译期间将缓冲区的总大小编码到函数本身中。在读取发生之前，可以检查缓冲区的大小，以确保不会发生缓冲区溢出。

应该注意的是，这对数组很有效，但对动态分配的数组是有问题的，因为缓冲区的总大小也必须传递给我们的包装函数，可能导致难以调试的逻辑错误 (也就是说，不提供适当大小的缓冲区，用缓冲区大小交换要读取的字节总数，依此类推)。

为了克服这些类型的问题，应该改用`gsl::span`。

当读取字节而不是字段时，了解当前正在读取的文件中的位置可能会有所帮助。从文件流读取时，读取和写入指针都在流内部维护。要获取当前读取位置，请使用`tellg()`函数，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::cout << file.tellg() << '\n';
        char c = file.get();
        std::cout << file.tellg() << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// 0
// 1
```

在这里，我们照常打开一个文件，并输出当前读取指针，按预期为`0`。然后，我们从文件中读取单个字符，并再次输出读取指针。这一次，指针是`1`，表示我们已经成功读取了一个字节。

读取单个字节的另一种方法是使用`peek`函数，该函数的功能类似于`get()`，只是内部读取指针不递增，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::cout << file.tellg() << '\n';
        char c = file.peek();
        std::cout << file.tellg() << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// 0
// 0
```

这个例子和前面的一样，只是用`peek()`代替`get()`。如图所示，在`peek()`之前和之后，读取指针都是`0`用于从缓冲区读取一个字节，这表明`peek()`不会在流中增加读取指针。

反过来也由 C 提供。不需要在不移动读取指针的情况下从文件中读取一个字节，还可以使用`ignore()`函数在不从流中读取字节的情况下移动读取指针，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::cout << file.tellg() << '\n';
        file.ignore(1);
        std::cout << file.tellg() << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// 0
// 1
```

在此示例中，我们将文件流中的读取指针移动一个字节，并使用`tellg()`来验证读取指针是否已被移动。`ignore()`函数相对于当前读取指针递增读取指针。

C++ 还提供了`seekg()`功能，该功能将读取指针设置为绝对位置，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::string hello, world;

        file >> hello >> world;
        std::cout << hello << " " << world << '\n';

        file.seekg(1);

        file >> hello >> world;
        std::cout << hello << " " << world << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// Hello World
// ello World
```

在前面的示例中，`seekg()`函数用于在读取后将读取指针设置为 1 字节到文件中，有效地倒带，使我们可以再次读取文件。

# 按行阅读

最后，文件读取的最后一种类型是按行，这意味着您一次读取文件中的每一行，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        char buf[25] = {};
        file.getline(buf, 25, '\n');
        std::cout << buf << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// Hello World
```

在此示例中，我们创建一个标准的 C 字符缓冲区，从文件中读取一行，然后将该行输出到`stdout`。与`read()`函数不同，`getline()`一直读取直到达到缓冲区的大小 (第二个参数) 或看到分隔符。

由于一行的定义取决于您使用的操作系统 (尽管在这种情况下，我们将坚持使用 Unix)，所以`getline()`函数采用定界符参数，允许您定义一行的结尾。

与`read()`函数一样，此操作是不安全的，因为它要求用户确保给定`getline()`的总缓冲区大小实际上是缓冲区的总大小-提供了一种方便的机制来引入难以调试的缓冲区溢出。

与`read()`函数不同，C 提供了一个非成员版本的`getline()`接受任何流类型 (包括`std::cin`)，而`std::string`则不是标准的 C 风格字符串，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::string str;
        std::getline(file, str);
        std::cout << str << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "Hello World" > test.txt; ./a.out
// Hello World
```

在前面的示例中，我们不是调用`file.getline()`，而是调用`std::getline()`，并为函数提供`std::string`，该函数可以根据需要读取的字节数动态更改其大小-防止可能的缓冲区溢出。

应该注意的是，为了实现这一点，`std::string`将自动为您执行`new()`/`delete()`-这 (尤其是在系统编程方面) 可能会带来不可接受的低效率。在这种情况下，应该使用`file.getline()`版本，并带有一个包装类，类似于我们对`read()`函数所做的。

最后，如果对已经打开的文件进行了更改，则以下内容将与这些更改同步当前流:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        file.sync();
    }
}
```

如前面的代码所示，可以使用`sync()`函数来重新同步已经打开的文件，并对该文件进行更改。

# 写入文件

像`std::cin`和文件读取一样对称，也提供了类似于`std::cout`的文件写入。与读取不同，文件写入只有两种不同的模式-按字段和按字节。

# 按领域写作

要按字段写入文件，请使用`<< operator()`，类似于`std::cout`，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::string hello{"Hello"}, world{"World"};
        file << hello << " " << world << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// Hello World
```

在前面的示例中，我们照常打开一个文件，然后创建两个`std::string`对象，并在字符串中分别添加`hello`和`world`。最后，这些字符串被写入文件。请注意，没有必要关闭或刷新文件，因为这是为我们在销毁文件流对象时完成的。

与`std::cout`一样，C 原生支持标准 C 字符缓冲区和数字类型，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        file << "The answer is: " << 42 << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// The answer is: 42
```

在前面的示例中，我们将一个标准的 C 字符缓冲区和一个整数直接写入文件。在写入方面也支持用户定义类型，如下所示:

```cpp
#include <fstream>
#include <iostream>

struct myclass
{
    std::string hello{"Hello"};
    std::string world{"World"};
};

std::fstream &operator <<(std::fstream &os, const myclass &obj)
{
    os << obj.hello;
    os << ' ';
    os << obj.world;

    return os;
}

int main()
{
    if (auto file = std::fstream("test.txt")) {
        file << myclass{} << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// Hello World
```

在这个例子中，我们打开一个文件，并向该文件写入一个`myclass{}`对象。`myclass{}`对象是一个包含两个用`Hello`和`World`初始化的成员变量的结构。然后提供用户定义的`<< operator()`重载，该重载将`myclass{}`对象的内容写入所提供的文件流，从而导致`Hello World`被写入文件。

# 写入字节

除了按字段写入外，还支持写入字节流。在下面的示例中，我们使用`put()`函数将单个字节写入文件 (除了换行符)，该函数类似于`get()`，但用于写入而不是读取:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        file.put('H');
        file.put('\n');
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// H
```

使用`write()`函数也可以写入多个字节，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        file.write("Hello World\n", 12);
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// Hello World
```

在前面的示例中，我们将`12`字节写入文件 (字符串`Hello World`为 11 个字符，换行符为一个额外的字符串)。

与`read()`函数一样，`write()`函数是不安全的，应进行包装，以确保写入文件的字节总数不超过缓冲区的总大小 (否则会发生缓冲区溢出)。要演示即使是标准的 C-style`const`字符缓冲区也是不安全的，请参见以下内容:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        file.write("Hello World\n", 100);
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// Hello World
// ;�����D���d)��������$=���DR����d���d�����[
```

如图所示，尝试从标准 C`const`字符缓冲区写入 100 个字节，该缓冲区的大小仅为`13`字节 (11 代表`Hello World`，`1`代表新行，`1`代表`\0`空终止)，导致缓冲区溢出。在这种情况下，缓冲区溢出会导致损坏的字节被写入文件，这充其量会泄漏程序的一部分，但也可能产生不稳定，包括难以调试的分段错误。

为了克服这个问题，每当使用这些类型的不安全功能时，都应该使用包装器，如下所示:

```cpp
#include <string.h>

#include <fstream>
#include <iostream>

void
mywrite(std::fstream &file, const char *str, std::size_t count)
{
    if (count > strlen(str)) {
        throw std::out_of_range("file.write out of bounds");
    }

    file.write(str, count);
}

int main()
{
    if (auto file = std::fstream("test.txt")) {
        mywrite(file, "Hello World\n", 100);
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// terminate called after throwing an instance of 'std::out_of_range'
// what(): file.write out of bounds
// Aborted (core dumped)
```

在前面的示例中，我们围绕`write()`函数创建了一个包装器，类似于我们之前创建的`read()`函数包装器。当我们尝试写入比标准 C`const`字符缓冲区的总大小更多的字节时，我们会生成一个异常，该异常可用于将错误跟踪到我们尝试写入 100 字节的错误。

应该注意的是，此包装仅适用于编译器生成的标准 C`const`字符缓冲区。在这种类型的函数将失败的地方，可以手动声明这种类型的缓冲区，如下所示:

```cpp
#include <string.h>

#include <fstream>
#include <iostream>

void
mywrite(std::fstream &file, const char *str, std::size_t count)
{
    if (count > strlen(str)) {
    std::cerr << count << " " << strlen(str) << '\n';
        throw std::out_of_range("file.write out of bounds");
    }

    file.write(str, count);
}

int main()
{
    if (auto file = std::fstream("test.txt")) {
        const char str1[6] = {'H','e','l','l','o','\n'};
        const char str2[6] = {'#','#','#','#','#','\n'};
        mywrite(file, str1, 12);
        mywrite(file, str2, 6);
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// Hello
// World
// World
```

在这个例子中，我们创建了两个标准的 C`const`字符缓冲区。第一个缓冲区由带有换行符的字`Hello`组成，第二个缓冲区由带有换行符的字`World`组成。然后我们在文件中写`Hello`，但我们不是写`6`字符，而是写`12`。最后，我们将`World`写入文件，并提供正确的字节数，即`6`。

结果输出为`Hello World`，其中`World`被写入文件两次。这样做的原因是精心制作的缓冲区溢出。第一次写入文件将`Hello`写入缓冲区，但提供了`write()`函数，其字节为`12`，而不是`6`。在这种情况下，我们的包装器正在寻找一个空终止符，它不存在 (因为我们已经手动定义了我们的标准 C`const`字符缓冲区，删除了空终止符)。

结果，`mywrite()`函数没有检测到溢出，并写入两个缓冲区。

没有安全的方法来克服这种类型的问题 (`read()`函数有类似的问题)，而不使用指南支持库，勤奋，静态分析器能够检测不安全地使用这些类型的缓冲区的使用 (对于静态分析器来说，这不是一件小事)。因此，在一般情况下，应避免使用诸如`read()`和`write()`之类的功能，以支持在可能的情况下使用按字段和按行替代。

与`tellg()`类似，写流也具有使用`tellp()`函数获取当前写指针位置的能力，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::cout << file.tellp() << '\n';
        file << "Hello";
        std::cout << file.tellp() << '\n';
        file << ' ';
        std::cout << file.tellp() << '\n';
        file << "World";
        std::cout << file.tellp() << '\n';
        file << '\n';
        std::cout << file.tellp() << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// 0
// 5
// 6
// 11
// 12
// Hello World
```

在上述示例中，将`Hello World`写入文件，并使用`tellp()`函数输出写入指针位置，结果为`0`、`5`、`6`、`11`、`12`。

也可以使用`seekp()`函数将写指针移动到文件内的绝对位置，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        std::cout << file.tellp() << '\n';
        file << "Hello World\n";
        std::cout << file.tellp() << '\n';
        file.seekp(0);
        std::cout << file.tellp() << '\n';
        file << "The answer is: " << 42 << '\n';
        std::cout << file.tellp() << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// 0
// 12
// 0
// 18
// The answer is: 42
```

在此示例中，我们将`Hello World`写入文件，然后将流中的写入指针移回文件的开头。然后，我们将`The answer is: 42`写入文件。在此过程中，我们使用`tellp()`输出写指针的位置，显示在执行这些操作时写指针如何移动。

结果，该文件由`The answer is: 42`组成，而不是`Hello World`，因为`Hello World`被覆盖。

最后，与`sync()`函数一样，可以在需要时使用以下方法将对文件的写入刷新到文件系统:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    if (auto file = std::fstream("test.txt")) {
        file.flush();
    }
}
```

需要注意的是，尽管您可以手动刷新文件 (例如，如果您知道更改必须击中文件系统)，但当`std::fstream`对象失去作用域并被破坏时，文件将被关闭并自动刷新到文件系统。

读写时，可能会发生不同类型的错误。`std::fstream`提供了四个不同的函数来确定流的状态，如下所示:

*   `good()`: 如果此函数返回`true`，则没有发生错误，并且流尚未到达文件末尾。
*   `eof()`: 如果此函数返回`true`，则文件的末尾已到达。内部错误不会影响此函数的结果。
*   `fail()`: 如果该函数返回`true`，则会出现内部错误，但流仍然起作用，例如，如果发生数值转换错误。
*   `bad()`: 如果返回`true`，则会出现错误，流不再起作用，例如流无法打开文件。

正常文件操作时，`good()`应返回`true`，其他三个状态函数应返回`false`，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    std::cout << std::boolalpha;

    if (auto file = std::fstream("test.txt")) {
        std::string hello{"Hello"}, world{"World"};
        file << hello << " " << world << '\n';
        std::cout << "good: " << file.good() << '\n';
        std::cout << "fail: " << file.fail() << '\n';
        std::cout << "bad: " << file.bad() << '\n';
        std::cout << "eof: " << file.eof() << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// good: true
// fail: false
// bad: false
// eof: false
// Hello World
```

在上面的示例中，`Hello World`被成功写入文件，导致`good()`返回`true`。

除了使用`good()`功能外，`! operator()`还可以用于检测是否发生错误，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    std::cout << std::boolalpha;

    if (auto file = std::fstream("test.txt")) {
        std::string hello{"Hello"}, world{"World"};
        file << hello << " " << world << '\n';
        if (!file) {
            std::cout << "failed\n";
        }
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// Hello World
```

在这里，`Hello World`成功写入文件，结果，`good()`函数返回`true`，这意味着`! operator()`返回`false`，导致`failed`字符串永远不会输出到`stdout`。

同样，可以使用`bool`运算符，它返回与`good()`相同的结果，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    std::cout << std::boolalpha;

    if (auto file = std::fstream("test.txt")) {
        std::string hello{"Hello"}, world{"World"};
        file << hello << " " << world << '\n';
        if (file) {
            std::cout << "success\n";
        }
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "" > test.txt; ./a.out; cat test.txt
// success
// Hello World
```

在上面的代码中，`Hello World`成功写入文件，导致`bool`运算符返回`true`; 这意味着`good()`函数也将返回`true`，因为它们返回相同的结果。

如果发生错误，错误状态将保持触发状态，直到流关闭，或者直到使用`clear()`函数，告诉流您已经处理了错误，如下所示:

```cpp
#include <fstream>
#include <iostream>

int main()
{
    std::cout << std::boolalpha;

    if (auto file = std::fstream("test.txt")) {
        int answer;
        std::cout << file.good() << '\n';
        file >> answer;
        std::cout << file.good() << '\n';
        file.clear();
        std::cout << file.good() << '\n';
    }
}

// > g++ -std=c++ 17 scratchpad.cpp; echo "not_a_number" > test.txt; ./a.out
// true
// false
// true
```

在前面的示例中，字符串被写入文本文件。打开此测试文件进行读取，并读取整数。问题是写入文件的值实际上不是数字，导致文件流报告错误。

然后使用`clear`函数清除错误，之后`good()`函数继续报告`true`。

# 了解文件实用程序

到目前为止，本章中描述的所有 C api 都是在 C 17 之前添加的。尽管 C 提供了读写文件的功能，但它并未提供管理文件系统所需的所有其他文件操作，包括文件路径，目录管理等。

本节将重点介绍 C 17 中的`std::filesystem`添加，这些添加解决了大多数这些缺点。

# 路径

路径只不过是表示文件系统中节点的字符串。在 UNIX 系统上，这通常是由一系列目录名`/`和一个文件名组成的字符串，通常带有扩展名。路径的目的是表示文件的名称和位置，然后可以将其用于对文件执行操作，例如打开文件进行读写，更改文件的权限，甚至从文件中删除文件系统。

应当注意，路径可以表示文件系统中的许多不同类型的节点，包括文件、目录、链接、设备等。更完整的列表将在本章后面介绍。考虑以下示例:

```cpp
/home/user/
```

这是指向一个名为`user`的目录的路径，位于一个名为`home`的根目录中。现在考虑以下几点:

```cpp
/home/user/test.txt
```

这指的是同一目录中名为`test.txt`的文件。文件的词干是`test`，而文件的扩展名是`.txt`。此外，该文件的根目录是`/` (大多数 UNIX 系统都是这种情况)。

在 UNIX 系统上，路径可以采用不同的形式，包括以下几种:

*   **块设备**: 路径是指 POSIX 风格的块设备，如`/dev/sda`
*   **字符设备**: 路径是指 POSIX 风格的字符设备，如`/dev/random`
*   **目录**: 路径引用常规目录
*   **Fifo**: 路径是指管道或其他形式的 IPC
*   **套接字**: 路径是指 POSIX 套接字
*   **符号链接**: 路径引用一个 POSIX 符号链接
*   **文件**: 路径是指普通文件

为了确定 a 路径是什么类型，C 17 提供了以下测试函数:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    using namespace std::filesystem;

    std::cout << std::boolalpha;
    std::cout << is_block_file("/dev/sda1") << '\n';
    std::cout << is_character_file("/dev/random") << '\n';
    std::cout << is_directory("/dev") << '\n';
    std::cout << is_empty("/dev") << '\n';
    std::cout << is_fifo("scratchpad.cpp") << '\n';
    std::cout << is_other("scratchpad.cpp") << '\n';
    std::cout << is_regular_file("scratchpad.cpp") << '\n';
    std::cout << is_socket("scratchpad.cpp") << '\n';
    std::cout << is_symlink("scratchpad.cpp") << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// true
// true
// true
// false
// false
// false
// true
// false
// false
```

如前面示例所示，`/dev/sda`是块设备，`/dev/random`是字符设备，`/dev`是不为空的目录，本章中用于编译所有示例的`scratchpad.cpp`文件是常规文件。

为了确定路径是否存在，C 17 提供了`exists()`函数，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
 std::cout << std::boolalpha;
 std::cout << std::filesystem::exists("/dev") << '\n';
 std::cout << std::filesystem::exists("/dev/random") << '\n';
 std::cout << std::filesystem::exists("scratchpad.cpp") << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// true
// true
// true
```

这里目录`/dev`存在，字符设备`/dev/random`和常规文件`scratchpad.cpp`也是如此。

每个执行的程序都必须从给定的目录执行。为了确定这个目录，C 17 提供了`current_path()`函数，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    std::cout << std::filesystem::current_path() << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08"
```

在此示例中，`current_path()`用于获取`a.out`正在执行的当前目录。由`current_path()`提供的路径是绝对路径。要将绝对路径转换为相对路径，请使用`relative()`函数，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    std::cout << std::filesystem::relative(path) << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "."
```

如图所示，当前路径的相对路径是简单的 (`.`)。

类似地，要将相对路径变成绝对路径，C 17 提供了`canonical()`函数:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    std::cout << std::filesystem::canonical(".") << '\n';
    std::cout << std::filesystem::canonical("../Chapter08") << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08"
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08"
```

在此示例中，我们使用`canonical()`函数将相对路径转换为绝对路径。需要注意的是，获取`.`的绝对路径是返回`current_path()`相同结果的另一种方法。

还要注意，`canonical()`函数返回已解析所有对`../`和`./`的引用的绝对路径，将绝对路径简化为最小形式。如果不需要这种类型的路径，则可以使用`absolute()`函数，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    std::cout << std::filesystem::absolute("../Chapter08") << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/../Chapter08"
```

如本示例所示，`absolute()`函数不会删除`../`。

由于有不同的方式来表示相同的路径 (即相对的、规范的和绝对的)，C 17 提供了`equivalent()`函数，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
 auto path1 = std::filesystem::path{"."};
 auto path2 = std::filesystem::path{"../Chapter08"};
 auto path3 = std::filesystem::path{"../Chapter08/../Chapter08"};
 auto path4 = std::filesystem::current_path();
 auto path5 = std::filesystem::current_path() / "../Chapter08/";

 std::cout << std::boolalpha;
 std::cout << std::filesystem::equivalent(path1, path2) << '\n';
 std::cout << std::filesystem::equivalent(path1, path3) << '\n';
 std::cout << std::filesystem::equivalent(path1, path4) << '\n';
 std::cout << std::filesystem::equivalent(path1, path5) << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// true
// true
// true
// true
```

本示例中引用的所有路径都引用同一目录，无论它们是相对的、规范的还是绝对的。

如果要确定两个路径是否在词法上相等 (包含相同的精确字符)，请使用`== operator()`代替，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path1 = std::filesystem::path{"."};
    auto path2 = std::filesystem::path{"../Chapter08"};
    auto path3 = std::filesystem::path{"../Chapter08/../Chapter08"};
    auto path4 = std::filesystem::current_path();
    auto path5 = std::filesystem::current_path() / "../Chapter08/";

    std::cout << std::boolalpha;
    std::cout << (path1 == path2) << '\n';
    std::cout << (path1 == path3) << '\n';
    std::cout << (path1 == path4) << '\n';
    std::cout << (path1 == path5) << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// false
// false
// false
// false
```

这里的代码与前面的代码相同，除了使用`== operator()`而不是`equivalent()`函数。前面的示例为所有路径返回`true`，因为它们都引用相同的路径，而前面的示例返回`false`，因为相同的路径在词法上不相等，尽管它们在技术上是相同的路径。

请注意在这些示例中使用`/ operator()`。C 17 为路径提供了不同的串联功能，这些功能方便地提供了一种干净，可读的添加到现有路径的方式: `/`，`/=`和`+=`。`/ operator()` (和自修改版本`/= operator()`) 在为您添加`/`的同时连接两条路径，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "scratchpad.cpp";

    std::cout << path << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/scratchpad.cpp"
```

在本示例中，使用`/= operator()`将`scratchpad.cpp`添加到路径中，并为我们添加`/`。如果您希望自己添加`/`，或者根本不希望添加`/`，可以使用`+= operator()`，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path += "/scratchpad.cpp";

    std::cout << path << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/scratchpad.cpp"
```

这里的结果与前面的示例相同，不同的是使用`+= operator()`代替`/= operator()`，因此需要手动添加`/`。

除了串联，C 17 还提供了一些额外的路径修饰符。一个这样的函数是`remove_filename()`，它从路径中删除文件名，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "scratchpad.cpp";

    std::cout << path << '\n';
    path.remove_filename();
    std::cout << path << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/scratchpad.cpp"
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/"
```

如图所示，`remove_filename()`函数从路径中删除文件名。

也可以用其他东西替换文件名，而不是删除它，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "scratchpad.cpp";

    std::cout << path << '\n';
    path.replace_filename("test.cpp");
    std::cout << path << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/scratchpad.cpp"
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/test.cpp"
```

如图所示，文件名`scratchpad.cpp`被替换为`test.cpp`。

除了替换文件名外，还可以替换扩展名，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "scratchpad.cpp";

    std::cout << path << '\n';
    path.replace_extension("txt");
    std::cout << path << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/scratchpad.cpp"
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/scratchpad.txt"
```

如图所示，将`scratchpad.cpp`的扩展名更改为`.txt`。

最后，如果需要，可以使用`clear()`函数清除路径，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "scratchpad.cpp";

    std::cout << path << '\n';
    path.clear();
    std::cout << path << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/scratchpad.cpp"
// ""
```

如前面的代码所示，`clear()`函数删除路径的内容 (就像它是默认构造的一样)。

如上所述，路径由不同部分组成，包括根名称，目录，词干和扩展名。为了将路径分解为这些不同的组件，C 17 提供了一些帮助函数，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "scratchpad.cpp";

    std::cout << std::boolalpha;
    std::cout << path.root_name() << '\n';
    std::cout << path.root_directory() << '\n';
    std::cout << path.root_path() << '\n';
    std::cout << path.relative_path() << '\n';
    std::cout << path.parent_path() << '\n';
    std::cout << path.filename() << '\n';
    std::cout << path.stem() << '\n';
    std::cout << path.extension() << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// ""
// "/"
// "/"
// "home/user/Hands-On-System-Programming-with-CPP/Chapter08/scratchpad.cpp"
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08"
// "scratchpad.cpp"
// "scratchpad"
// ".cpp"
```

在此示例中，我们将`scratchpad.cpp`文件的路径分解为其不同的部分。父路径为`/home/user/Hands-On-System-Programming-with-CPP/Chapter08`，文件名为`scratchpad.cpp`，词干为`scratchpad`，扩展名为`.cpp`。

并非所有路径都包含路径可能包含的所有部分。当路径指向目录或格式不正确时，可能会发生这种情况。

要确定路径包含哪些部分，请使用以下帮助程序:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "scratchpad.cpp";

    std::cout << std::boolalpha;
    std::cout << path.empty() << '\n';
    std::cout << path.has_root_path() << '\n';
    std::cout << path.has_root_name() << '\n';
    std::cout << path.has_root_directory() << '\n';
    std::cout << path.has_relative_path() << '\n';
    std::cout << path.has_parent_path() << '\n';
    std::cout << path.has_filename() << '\n';
    std::cout << path.has_stem() << '\n';
    std::cout << path.has_extension() << '\n';
    std::cout << path.is_absolute() << '\n';
    std::cout << path.is_relative() << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// false
// true
// false
// true
// true
// true
// true
// true
// true
// true
// false
```

如图所示，您可以确定路径是否具有根路径，根名称，根目录，相对路径，父路径，文件名，词干和扩展名。还可以确定路径是绝对路径还是相对路径。

最后，C 17 提供了不同的机制来管理文件系统上的路径，具体取决于您使用的路径类型。例如，如果您希望创建目录或删除路径 (无论其类型如何)，请分别使用`create_directory()`和`remove()`函数，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "test";

    std::cout << std::boolalpha;
    std::cout << std::filesystem::create_directory(path) << '\n';
    std::cout << std::filesystem::remove(path) << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// true
// true
```

在上面的示例中，我们使用`create_directory()`函数创建目录，然后使用`remove()`函数将其删除。

我们也可以使用`rename()`函数重命名路径，如下所示:

```cpp
#include <iostream>
#include <filesystem>

int main()
{
    auto path1 = std::filesystem::current_path();
    auto path2 = std::filesystem::current_path();
    path1 /= "test1";
    path2 /= "test2";

    std::cout << std::boolalpha;
    std::cout << std::filesystem::create_directory(path1) << '\n';
    std::filesystem::rename(path1, path2);
    std::cout << std::filesystem::remove(path1) << '\n';
    std::cout << std::filesystem::remove(path2) << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// true
// false
// true
```

在这个例子中，我们使用`create_directory()`函数创建一个目录。我们使用`rename()`函数重命名目录，然后删除旧目录路径和新目录路径。如图所示，删除已重命名的目录的尝试失败，因为该路径不再存在，而删除新目录的尝试成功，因为该路径确实存在。

`remove()`函数将删除任何路径 (假设程序具有适当的权限)，除非路径指向不为空的目录，在这种情况下它将失败。要删除不为空的目录，请使用`remove_all()`函数，如下所示:

```cpp
#include <fstream>
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "test";

    std::cout << std::boolalpha;
    std::cout << std::filesystem::create_directory(path) << '\n';

    std::fstream(path / "test1.txt", std::ios::app);
    std::fstream(path / "test2.txt", std::ios::app);
    std::fstream(path / "test3.txt", std::ios::app);

    std::cout << std::filesystem::remove_all(path) << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// true
// 4
```

如图所示，我们创建一个目录，并使用`std::fstream`将一些文件添加到目录中。然后，我们使用`remove_all()`而不是`remove()`删除新创建的目录。如果我们使用`remove()`函数，程序将抛出异常，如下所示:

```cpp
terminate called after throwing an instance of 'std::filesystem::__cxx11::filesystem_error'
 what(): filesystem error: cannot remove: Directory not empty [/home/user/Hands-On-System-Programming-with-CPP/Chapter08/test]
Aborted (core dumped)
```

在文件系统上执行的另一个常见操作是迭代目录中的所有文件。为此，C++ 17 提供了一个目录迭代器，如下所示:

```cpp
#include <fstream>
#include <iostream>
#include <filesystem>

int main()
{
    auto path = std::filesystem::current_path();
    path /= "test";

    std::cout << std::boolalpha;
    std::cout << std::filesystem::create_directory(path) << '\n';

    std::fstream(path / "test1.txt", std::ios::app);
    std::fstream(path / "test2.txt", std::ios::app);
    std::fstream(path / "test3.txt", std::ios::app);

    for(const auto &p: std::filesystem::directory_iterator(path)) {
        std::cout << p << '\n';
    }

    std::cout << std::filesystem::remove_all(path) << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// true
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/test/test1.txt"
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/test/test3.txt"
// "/home/user/Hands-On-System-Programming-with-CPP/Chapter08/test/test2.txt"
// 4
```

在前面的示例中，我们使用`create_directory()`函数创建一个目录，将一些文件添加到该目录中，然后使用目录迭代器对所有文件进行迭代。

目录迭代器的功能与 C 中的任何其他迭代器一样，这意味着，如前面的示例所示，我们可以利用 ranged for 语法。

最后，C 17 提供了一个方便的功能，用于确定临时目录的路径，该功能可用于根据您的程序需要创建临时目录，如下所示:

```cpp
#include <fstream>
#include <iostream>
#include <filesystem>

int main()
{
    std::cout << std::filesystem::temp_directory_path() << '\n';
}

// > g++ -std=c++ 17 scratchpad.cpp -lstdc++ fs; ./a.out
// "/tmp"

#endif
```

需要注意的是，在 POSIX 系统上，临时目录通常是`/tmp`，如下所示。然而，使用`temp_directory_path()`而不是硬编码这条路径仍然是谨慎的。

# 了解记录器示例

在本节中，我们将扩展[第 6 章](06.html)，*学习到编程控制台输入/输出*中的调试示例，以包括一个基本的记录器。此记录器的目标是将对`std::clog`流的添加重定向到除控制台之外的日志文件。

就像[第 6 章](https://cdp.packtpub.com/hands_on_system_programming_with_c___/wp-admin/post.php?post=31&action=edit#post_29)，*学习编程控制台输入/输出*中的调试功能一样，如果调试级别不够，或者调试已经被禁用，我们希望日志功能被编译出来。

为此，请参见以下代码: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter08/example1.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/example1.cpp)进行动手系统编程。

首先，我们需要创建两个常量表达式-一个用于调试级别，一个用于直接启用或禁用调试，如下所示:

```cpp
#ifdef DEBUG_LEVEL
constexpr auto g_debug_level = DEBUG_LEVEL;
#else
constexpr auto g_debug_level = 0;
#endif

#ifdef NDEBUG
constexpr auto g_ndebug = true;
#else
constexpr auto g_ndebug = false;
#endif
```

接下来，我们将需要创建一个全局变量，如下所示:

```cpp
std::fstream g_log{"log.txt", std::ios::out | std::ios::app};
```

全局变量是日志文件流。这将用于将对`std::clog`流的添加写入日志文件。由于这是一个日志文件，我们将其打开为仅写，追加，这意味着我们只能写入日志，并且所有写入都必须追加到文件末尾。

接下来，我们将需要定义`log`函数本身。此函数需要能够输出到`std::clog`和我们的日志文件流，而无需多次执行调试逻辑 (因为这可能导致意外行为)。

以下实现了这个目标的`log`函数:

```cpp
template <std::size_t LEVEL>
constexpr void log(void(*func)()) {
    if constexpr (!g_ndebug && (LEVEL <= g_debug_level)) {
        std::stringstream buf;

        auto g_buf = std::clog.rdbuf();
        std::clog.rdbuf(buf.rdbuf());

        func();

        std::clog.rdbuf(g_buf);

        std::clog << "\033[1;32mDEBUG\033[0m: ";
        std::clog << buf.str();

        g_log << "\033[1;32mDEBUG\033[0m: ";
        g_log << buf.str();
    };
}
```

像[第 6 章](06.html)中的调试函数，*学习编程控制台输入/输出*一样，此`log`函数首先将函数的业务逻辑包装在`constexpr``if`语句中 (C 17 的新功能)，如果禁用调试，或者提供的调试级别大于当前调试级别，则为编译器提供编译代码的方法。

如果应该进行调试，第一步是创建一个字符串流，它的行为就像`std::clog`和日志文件流一样，但是将任何添加到流中的结果保存到`std::string`中。

然后保存`std::clog`的读缓冲区，并将字符串流的读缓冲区提供给`std::clog`。对`std::clog`流的任何添加都将重定向到我们的字符串流，而不是`stderr`。

接下来，我们执行用户提供的`debug`函数，收集调试字符串并将其存储在字符串流中。最后，将`std::clog`的`read()`缓冲区恢复到`stderr`，我们将字符串流同时输出到`std::clog`和日志文件流。

最后一步是创建我们的`protected_main ()`函数，该函数记录`Hello World`。请注意，为了演示，我们还手动将`Hello World`添加到`std::clog`中，不使用`log`功能，以演示`std::clog`功能正常，并且仅在使用`log`功能时才记录到我们的日志文件中。这通过以下代码显示:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    log<0>([]{
        std::clog << "Hello World\n";
    });

    std::clog << "Hello World\n";

    return EXIT_SUCCESS;
}
```

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt)。

有了这些代码，我们可以使用以下内容编译和执行这些代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter08/
> mkdir build
> cd build

> cmake ..
> make
> ./example1
DEBUG: Hello World
Hello World

> cat log.txt
DEBUG: Hello World
```

请注意两个`debug`语句是如何输出到`stderr`的 (两个是`log`函数中的语句，以及没有`log`函数手动执行的语句)。然而，日志文件中只有一个语句，演示了`log`函数负责将添加到`std::clog`的内容重定向到日志文件和`stderr`，同时将`std::clog`保持完整，以备将来使用。

# 了解尾部文件示例

在这个例子中，我们将创建一个简单的程序来拖尾文件。此示例的目标是模仿`tail -f -n0`的行为，该行为将新添加的内容输出到文件中。`-f`参数告诉 tail 跟随文件，`-n0`告诉 tail 只输出到`stdout`新添加。

第一步是定义我们计划在打开我们要拖尾的文件时使用的模式，如下所示:

```cpp
constexpr auto mode = std::ios::in | std::ios::ate;
```

在这种情况下，我们将以只读方式打开文件，并在打开时将读取指针移动到文件的末尾。

下一步是创建一个`tail`函数，该函数监视文件的更改，并将更改输出到`stdout`，如下所示:

```cpp
[[noreturn]] void
tail(std::fstream &file)
{
    while (true) {
        file.peek();
        while(!file.eof()) {
            auto pos = file.tellg();

            std::string buf;
            std::getline(file, buf, '\n');

            if (file.eof() && !file.good()) {
                file.seekg(pos);
                break;
            }

            std::cout << buf << '\n';
        }

        sleep(1);

        file.clear();
        file.sync();
    }
}
```

这个`tail`函数首先告诉编译器这个函数不返回，因为这个函数被包装在一个永远不会结束的`while(true)`循环中。

接下来，函数通过首先窥视文件，然后使用`eof()`检查文件结束位来检查文件结束是否已到达。如果有，则程序会休眠一秒钟，清除所有状态位，与文件系统重新同步以查看是否进行了任何新更改，然后再次循环。

如果读取指针不在文件的末尾，则读取其当前位置，以防需要恢复其在文件中的位置。文件中的下一行被读取并存储在缓冲区中。

尝试使用`getline`读取下一行可能会失败 (例如，当文件中的最后一个字符不是换行符时)。如果发生这种情况，则应忽略缓冲区的内容 (因为它不是完整的行)，并且需要将读取指针恢复到其原始位置。

如果下一行读取成功，则输出到`stdout`，我们再次循环查看是否需要读取更多行。

本示例中的最后一个函数必须解析提供给我们程序的参数，以获取文件名到 tail，打开文件，然后用新打开的文件调用`tail`函数，如下所示:

```cpp
int
protected_main(int argc, char **argv)
{
    std::string filename;
    auto args = make_span(argv, argc);

    if (args.size() < 2) {
        std::cin >> filename;
    }
    else {
        filename = ensure_z(args[1]).data();
    }

    if (auto file = std::fstream(filename, mode)) {
        tail(file);
    }

    throw std::runtime_error("failed to open file");
}
```

与前面的示例一样，我们使用`gsl::span`解析参数以确保安全性并保持符合 C 核心准则。如果未向程序提供任何参数，我们将等待用户向程序提供文件名到 tail。

如果提供了文件名，我们打开文件并调用`tail()`。如果无法打开文件，我们将抛出异常。

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt)。

有了这些代码，我们可以使用以下内容编译和执行这些代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter08/
> mkdir build
> cd build

> cmake ..
> make
> touch test.txt
> ./example2 test.txt
```

从另一个终端，我们可以对文件进行如下更改:

```cpp
> cd Hands-On-System-Programming-with-CPP/Chapter08/build
> echo "Hello World" > test.txt
```

这将导致示例程序将以下内容输出到`stdout`:

```cpp
Hello World
```

为了确保程序忽略不完整的行，我们可以在文件中添加不完整的行，如下所示:

```cpp
> echo -n "Hello World" > test.txt
```

这导致示例程序没有输出。

# 比较 C 与 mmap 基准

在此示例中，我们将使用`std::fstream`读取文件内容与使用`mmap()`读取文件内容之间的差异进行基准测试。

需要注意的是，`mmap()`函数利用系统调用将文件直接映射到程序中，我们期望`mmap()`比本章强调的 C api 更快。这是因为 C api 必须执行额外的内存复制，这显然要慢一些。

我们将通过定义我们计划读取的文件的大小来开始这个示例，如下所示:

```cpp
constexpr auto size = 0x1000;
```

接下来，我们必须定义一个`benchmark`函数来记录执行一个动作需要多长时间:

```cpp
template<typename FUNC>
auto benchmark(FUNC func) {
    auto stime = std::chrono::high_resolution_clock::now();
    func();
    auto etime = std::chrono::high_resolution_clock::now();

    return etime - stime;
}
```

在上面的功能中，我们利用高分辨率计时器来记录执行用户提供的功能所需的时间。应该注意的是，此基准测试程序是相对通用的，并且可以用于许多非平凡的功能 (因为即使使用高分辨率计时器，平凡的功能通常也很难进行基准测试)。

最后，我们需要创建一个文件读取，然后我们需要使用`std::fstream`和`mmap()`读取文件，如下所示:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    using namespace std::chrono;

    {
        char buf[size] = {};
        if (auto file = std::fstream("test.txt", std::ios::out)) {
            file.write(buf, size);
        }
    }

    {
        char buf[size];
        if (auto file = std::fstream("test.txt", std::ios::in)) {
            auto time = benchmark([&file, &buf]{
                file.read(buf, size);
            });

            std::cout << "c++ time: "
                      << duration_cast<microseconds>(time).count()
                      << '\n';
        }
    }

    {
        void *buf;
        if (int fd = open("test.txt", O_RDONLY); fd != 0) {
            auto time = benchmark([&fd, &buf]{
                buf = mmap(NULL, size, PROT_READ, 0, fd, 0);
            });

            munmap(buf, size);

            std::cout << "mmap time: "
                      << duration_cast<microseconds>(time).count()
                      << '\n';
        }
    }

    return EXIT_SUCCESS;
}
```

`protected_main()`函数的第一步是创建我们计划读取的文件，如下所示:

```cpp
char buf[size] = {};
if (auto file = std::fstream("test.txt", std::ios::out)) {
    file.write(buf, size);
}
```

为此，我们使用只写打开我们计划读取的文件，默认情况下，它也使用`std::ios::trunc`打开文件，为我们擦除文件的内容，以防万一。最后，我们在文件中写`size`0 的数量。

下一步是使用`std::fstream`读取文件，如下所示:

```cpp
char buf[size];
if (auto file = std::fstream("test.txt", std::ios::in)) {
    auto time = benchmark([&file, &buf]{
        file.read(buf, size);
    });

    std::cout << "c++ time: "
                << duration_cast<microseconds>(time).count()
                << '\n';
}
```

在我们使用`std::fstream`读取文件之前，我们使用只读打开文件，它在文件的开头打开文件。然后我们的文件读取被封装在我们的基准函数中。基准的结果输出到`stdout`。

最后，最后一步是对`mmap()`执行相同的操作，如下所示:

```cpp
void *buf;
if (int fd = open("test.txt", O_RDONLY); fd != 0) {
    auto time = benchmark([&fd, &buf]{
        buf = mmap(NULL, size, PROT_READ, 0, fd, 0);
    });

    munmap(buf, size);

    std::cout << "mmap time: "
                << duration_cast<microseconds>(time).count()
                << '\n';
}
```

与`std::fstream`一样，首先打开文件，然后将`mmap()`的使用封装在我们的基准测试函数中。

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt)。

有了这些代码，我们可以使用以下内容编译和执行这些代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter08/
> mkdir build
> cd build

> cmake ..
> make
> ./example3
c++ time: 16
mmap time: 3
```

如图所示，`mmap()`的执行速度快于`std::fstream`。

# 摘要

在本章中，我们学习了如何以不同的方式打开文件，这取决于我们计划如何使用文件本身。打开后，我们学习了如何使用`std::fstream`C api 读写文件。

我们了解了字段和字节之间的区别，以及读写方法的优缺点，以及常见的不安全做法。此外，我们还了解了支持功能，这些功能可以在`std::fstream`api 中移动指针，以操纵文件的读写方式。

此外，在本章中，我们对 C 17 中添加的新文件系统 api 进行了广泛的概述，包括用于操作文件和目录的路径及其支持功能。

我们用三个例子来总结本章。首先，我们编写了一个记录器，将`std::clog`的输出重定向到日志文件和`stdout`。第二个示例演示了如何使用 C 重写 tail POSIX 命令。

最后，在第三个示例中，我们编写了一些基准代码来比较 POSIX，C 和 C 的性能差异。在下一章中，我们将介绍 C 分配器，包括如何创建有状态的分配器，例如可以在系统编程时使用的内存池，以在适用时提高内存性能和效率。

# 问题

1.  用于查看文件是否成功打开的函数的名称是什么？
2.  打开文件的默认模式是什么？
3.  如果您尝试从文件中将非数字值读取到数字变量中，会发生什么？
4.  如果您不安全地使用`read()`或`write()`函数，会发生哪些类型的错误？
5.  `/= operator()`是否自动为您的路径添加`/`？
6.  下面的路径-`/home/user/test.txt`的词干是什么？
7.  下面的路径-`/home/user/test.txt`的父目录是什么？

# 进一步阅读

*   [https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)
*   [https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)