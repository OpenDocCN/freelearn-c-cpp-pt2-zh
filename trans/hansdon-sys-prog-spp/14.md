# 评估

# 第一章

1.  进行系统调用以完成操作系统提供的任务的行为称为**系统编程**。
2.  通过调用操作系统的中断处理程序。
3.  在 CPU 中添加了特殊指令以支持系统调用，而无需调用中断处理程序，这可以在执行之前节省更多的 CPU 状态。
4.  没有。`malloc()`/`free()`的大多数实现都要求从操作系统中获取大量内存，然后在程序执行过程中分割该内存。仅当此内存用完并且`malloc()`/`free()`必须要求更多时才需要系统调用。
5.  投机执行。
6.  类型安全是编程语言在多大程度上有助于防止由于类型之间的差异而导致的错误。强类型语言比弱类型语言更能防止这些类型的错误。
7.  C 模板为用户提供了定义代码的能力，而无需提前定义类型信息。

# 第二章

1.  是的。大多数 C 标准也是 POSIX 标准的一部分。POSIX 通常会超越并提供特定于 POSIX 操作系统的其他功能。C 和 POSIX 函数的示例包括`read()`和`write()`。
2.  `_start()`是应用的入口点，通常由 C 运行时设施提供。`main()`是用户提供的函数，通常是用户代码中第一个执行的函数，一旦应用完全初始化，最终由 C 运行时设施调用。
3.  执行全局构造函数和析构函数，并初始化 C++ 异常。
4.  前。

5.  C name mangling 将函数的整个签名嵌入函数的符号中。这不仅需要为 C++ 中的函数重载提供支持，还可以确保链接器不会意外地动态链接两个具有不同签名的同名函数 (这可能发生在 C++ 中)。
6.  C 符号没有被破坏。C 是。
7.  指针可以指向任何内存，包括`nullptr`。引用不能。

# 第三章

1.  这取决于 CPU 架构。在某些 cpu 上，短的`int`为 16 位宽，而`int`为 32 位宽。并非所有 cpu 都如此。
2.  这取决于 CPU 架构。在大多数 cpu 上，`int`的宽度为 32 位，但并非总是如此。
3.  没有。
4.  `int32_t`将始终为 32 位宽。在某些 cpu 上，`int`可以是 16、32 或 64 位宽。
5.  是的。这些称为**精确宽度**类型，并且始终是所需宽度。
6.  确保编译器不会自动填充结构以进行优化。
7.  没有。

# 第四章

1.  结构化绑定提供了通过手动提供单个变量来检索结构结果的能力，例如，`auto [first, second] = std::pair{1, 2}`
2.  您现在可以在同一行列出嵌套的命名空间
3.  您不再需要提供错误消息
4.  为您提供在`if`语句中定义变量的能力
5.  资源获取是初始化
6.  在建设时获取和初始化资源，并在销毁时释放资源
7.  拥有指针的州 (即负责删除指针的实体)
8.  `Expects()`定义函数输入期望，`Ensures()`定义函数的输出

# 第五章

1.  `rax`].
2.  `rdi`].
3.  减法。
4.  段是一组段。
5.  处理异常所需的信息。
6.  `Fork()`创建新进程，而`exec()`用新程序覆盖现有进程。启动新程序都需要两者。
7.  二。
8.  完成的进程 ID。

# 第六章

1.  `std::cin`是类型感知。
2.  能够处理用户定义的类型，提供更清洁、类型安全的 IO。
3.  格式说明符通常比`#include <iomanip>`更灵活。
4.  如果必须发生冲洗，请使用`std::endl`。
5.  每次写入后，`std::cerr`将刷新，而`std::clog`不会。在处理错误时使用`std::cerr`，以确保在发生灾难性问题之前成功刷新所有调试信息。
6.  `std::internal`].
7.  通过同时使用`std::oct`和`std::uppercase`。
8.  通过利用`gsl::span`。
9.  通过利用`rdbuf()`成员函数。

# 第 7 章

1.  `new()`分配单个对象，而`new()`分配对象数组。
2.  没有。
3.  全局内存对整个程序可见，而静态内存 (全局定义) 仅对其中定义的源文件可见。
4.  通过使用具有`alignas()`函数的别名，例如`using aligned_int alignas(0x1000) = int;`。

5.  不在 C 17 及以下
6.  只有当一个以上的对象必须拥有内存时，才应该使用 (也就是说，内存需要能够由多个对象以任何顺序和任何时间释放)。
7.  是 (取决于操作系统和权限)。
8.  如果分配 4 个字节并使用 3 个字节，则创建了内部碎片 (浪费的内存)。如果您以这样的方式分配内存，则分配器不再具有要发出的连续内存块 (即使它有很多可用内存)，您也创建了外部碎片。

# 第八章

1.  `is_open()`]
2.  `std::ios_base::in` | `std::ios_base::out`]
3.  `0`读取并设置标志
4.  缓冲区溢出错误
5.  是的
6.  测试
7.  `/home/user`]

# 第九章

1.  这意味着同一分配器的两个实例始终相等，这又意味着两个分配器可以分配和释放彼此的内存。
2.  如果同一分配器的两个实例可以分配和释放彼此的内存。
3.  是的。
4.  是的。
5.  复制容器时，其分配器也会被复制。
6.  它为容器提供了创建为其他类型提供的分配器副本的能力。
7.  对于`std::list`，`n ==1`; 对于`std::vector`，`n`可以是任意数字。

# 第十章

1.  UDP 是无连接的。
2.  `SOCK_DGRAM`]
3.  `SOCK_STREAM`]
4.  Ipv4。
5.  `Bind()`分配一个端口，而`connect()`连接到之前分配的端口。
6.  `sendto()`以地址为参数，通常由 UDP 使用，`send()`通常由 TCP 使用。
7.  没有。
8.  类型安全。

# 第 11 章

1.  星期四，1970 年 1 月 1 日
2.  UNIX 时代开始以来的秒数。
3.  `clock()`是相对于程序的执行。
4.  非 POSIX 操作系统可能支持部分时间。
5.  围绕`difftime()`的包装。
6.  稳定的时钟提供实际时间，而高分辨率计时器提供的数字仅在与`duration{}`一起使用时提供一个值。

# 第十二章

1.  `pthread_self()`]
2.  它们不安全。
3.  当两个线程竞相读取/写入相同的资源时。
4.  当线程等待永远不会释放的同步原语 (例如，互斥锁) 时。
5.  C 未来提供了一种类型安全的机制来返回线程的结果。
6.  以确保一个函数只执行一次，而不考虑调用它的线程数。

7.  `std::shared_mutex`提供支持多个阅读器的能力。
8.  允许单个线程多次锁定相同的互斥锁，而不会进入死锁。

# 第 13 章

1.  C 异常不需要检查每个函数调用的返回结果。
2.  POSIX 风格的函数必须保留函数输出的一部分来传达错误。例如，如果函数必须返回文件句柄，则在发生错误时返回`0`，这意味着文件句柄不能具有值`0`。
3.  Set jump 不会取消堆栈，这意味着析构函数被跳过。
4.  `catch(...)`]
5.  必须为每个功能存储有关如何展开堆栈的说明。这是提高性能的权衡。
6.  他们很慢。