# 分配者的动手方法

在[第 7 章](07.html)、*全面了解内存管理*中，我们学习了如何使用 C ++ 特定的技术分配和释放内存，包括使用`std::unique_ptr`和`std::shared_ptr`。此外，我们了解了碎片以及它如何能够浪费大量内存，具体取决于如何分配内存，然后再释放内存。系统程序员经常不得不从不同的池中分配内存 (有时来自不同的来源)，并处理碎片，以防止系统在运行过程中耗尽内存。对于嵌入式程序员来说尤其如此。放置`new()`可以用来解决这些类型的问题，但是基于新放置的实现通常很难创建，甚至更难维护。Placement`new()`也只能从用户定义的代码中访问，不提供对源自 C 标准库 api (如`std:: list`和`std:: map`) 的分配的控制。

为了解决这些类型的问题，C 提供了一个概念，称为**分配器**。C 分配器定义了应如何分配和释放特定类型 T 的内存。在本章中，您将学习如何创建自己的分配器，同时涵盖 C 分配器概念的复杂细节。本章将以两个不同的示例结束; 第一个示例将演示如何创建一个简单的、缓存对齐的无状态分配器，而第二个示例将提供一个有状态对象分配器的功能示例，该分配器维护一个免费池以进行快速分配。

本章的目标如下:

*   介绍 C 分配器
*   研究无状态，缓存对齐的分配器的示例
*   研究有状态内存池分配器的示例

# 技术要求

为了编译和执行本章中的示例，读者必须具有以下内容:

*   能够编译和执行 C 17 的基于 Linux 的系统 (例如，Ubuntu 17.10)
*   GCC 7
*   C 让 3.6
*   互联网连接

要下载本章中的所有代码，包括示例和代码片段，请参见以下链接: [https://github.com/PacktPublishing/ 动手系统编程与 CPP/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter09)。

# 介绍 C 分配器

C 分配器定义一个模板类，该类为特定类型 T 分配内存，并由分配器概念定义。有两种不同类型的分配器:

*   相等的分配器
*   不平等的分配器

相等的分配器是可以从一个分配器分配内存并从另一个分配器解除分配内存的分配器，例如:

```cpp
myallocator<myclass> myalloc1;
myallocator<myclass> myalloc2;

auto ptr = myalloc1.allocate(1);
myalloc2.deallocate(ptr, 1);
```

如前面的示例所示，我们创建了两个实例`myallocator{}`。我们从其中一个分配器分配内存，然后从另一个分配器释放内存。要使其有效，分配器必须相等:

```cpp
myalloc1 == myalloc2; // true
```

如果不成立，则分配器被认为是不相等的，这使分配器的使用方式变得非常复杂。不相等的分配器通常是有状态的分配器，这意味着它在自身内部存储一个状态，该状态可防止分配器从同一分配器的另一个实例中释放内存 (因为状态不同)。

# 了解基本分配器

在我们深入研究有状态的，不平等的分配器的细节之前，让我们回顾一下最基本的分配器，它是无状态的，相等的分配器。这个最基本的分配器采用以下形式:

```cpp
template<typename T>
class myallocator
{
public:

 using value_type = T;
 using pointer = T *;
 using size_type = std::size_t;

public:

 myallocator() = default;

 template <typename U>
 myallocator(const myallocator<U> &other) noexcept
 { (void) other; }

 pointer allocate(size_type n)
 {
 if (auto ptr = static_cast<pointer>(malloc(sizeof(T) * n))) {
 return ptr;
 }

 throw std::bad_alloc();
 }

 void deallocate(pointer p, size_type n)
 { (void) n; return free(p); }
};

template <typename T1, typename T2>
bool operator==(const myallocator<T1> &, const myallocator<T2> &)
{ return true; }

template <typename T1, typename T2>
bool operator!=(const myallocator<T1> &, const myallocator<T2> &)
{ return false; }
```

首先，所有分配器都是模板类，如下所示:

```cpp
template<typename T>
class myallocator
```

应该注意的是，分配器可以具有任意数量的模板参数，但是至少需要一个来定义分配器将分配和解除分配的类型。在我们的示例中，我们使用以下别名:

```cpp
using value_type = T;
using pointer = T *;
using size_type = std::size_t;
```

从技术上讲，唯一需要的别名如下:

```cpp
using value_type = T;
```

但是，由于创建最小分配器需要`T*`和`std::size_t`，因此不妨添加这些别名以提供更完整的实现。可选别名包括以下内容:

```cpp
using value_type = T;
using pointer = T *;
using const_pointer = const T *;
using void_pointer = void *;
using const_void_pointer = const void *;
using size_type = std::size_t;
using difference_type = std::ptrdiff_t;
```

如果自定义分配器不提供这些，则将为您提供前面的默认值。

如图所示，所有分配器都必须提供一个默认的构造函数。这是由于 C 容器将自己创建分配器，在某些情况下会多次创建分配器，并且它们将使用默认构造函数来执行此操作，这意味着分配器的构造必须是可能的，而不需要额外的参数。

我们示例中的`allocate()`函数如下:

```cpp
pointer allocate(size_type n)
{
    if (auto ptr = static_cast<pointer>(malloc(sizeof(T) * n))) {
        return ptr;
    }

    throw std::bad_alloc();
}
```

与本例中所解释的所有函数一样，`allocate()`函数的函数签名是由分配器概念定义的，这意味着分配器中的每个函数都必须具有特定的签名; 否则，当被现有容器使用时，分配器将无法正确编译。

在前面的示例中，`malloc()`用于分配一些内存，如果`malloc`不返回`nullptr`，则返回结果指针。由于分配器分配的是`T*`类型的指针，而不是`void *`，所以在返回指针之前，我们必须静态地强制转换`malloc()`的结果。提供给`malloc()`的字节数等于`sizeof(T) * n`。这是因为`n`参数定义了分配器必须分配的对象总数-因为某些容器会一次分配多个对象，并且期望所分配的对象在内存中是连续的。这方面的例子包括`std::deque`和`std::vector`，这取决于分配器来确保这些规则在内存中保持真实。最后，如果`malloc()`返回`nullptr`，表示请求的内存无法分配，则抛出`std::bad_alloc()`。

应该注意的是，在我们的示例中，我们使用`malloc()`而不是`new()`。在这里，应该使用`malloc()`而不是`new()`，因为容器将构造为您分配的对象。因此，我们不想使用`new()`，因为它也会构造对象，这意味着对象将被构造两次，这将导致损坏和未定义的行为。因此，不应在分配器中使用`new()`和`delete()`。

`deallocate`函数执行与`allocate`相反的功能，释放内存并将其释放回操作系统:

```cpp
void deallocate(pointer p, size_type n)
{ (void) n; free(p); }
```

在前面的示例中，要释放内存，我们只需要调用`free()`。请注意，我们正在创建一个*等于*分配器，这意味着`ptr`不需要源自执行解除分配的同一分配器。但是，分配的数量`n`必须与原始分配相匹配，在我们的情况下，可以安全地忽略它，因为我们使用的是`malloc()`和`free()`，它们会自动为我们跟踪原始分配的大小。并非所有分配器都具有此属性。

在我们的简单示例中，有两个附加要求符合 C 分配器，就其确切目的而言，这两个要求远没有那么明显。首先是使用模板类型为`U`的复制构造函数，如下所示:

```cpp
template <typename U>
myallocator(const myallocator<U> &other) noexcept
{ (void) other; }
```

这是因为当您将分配器与容器一起使用时，您可以在容器的定义中指定类型，例如:

```cpp
std::list<myclass, myallocator<myclass>> mylist;
```

在前面的示例中，我们创建了一个`myclass{}`类型的`std::list`，并带有一个分配和释放`myclass{}`对象的分配器。问题是，`std::list`有自己的内部数据结构，也必须进行分配。具体来说，`std::list`实现了链表，因此，`std::list`必须能够分配和释放链表节点。在上面的定义中，我们定义了一个分配和解除分配`myclass{}`对象的分配器，但是`std::list`实际上会分配和解除分配节点，这两种类型并不相同。为了解决这个问题，`std::list`将使用复制构造函数的模板版本创建`myclass{}`分配器的副本，从而使`std::list`能够使用最初提供的分配器创建自己的节点分配器。因此，对于功能齐全的分配器，需要复制构造函数的模板版本。

前面示例的第二个奇数是使用相等运算符，如下所示:

```cpp
template <typename T1, typename T2>
bool operator==(const myallocator<T1> &, const myallocator<T2> &)
{ return true; }

template <typename T1, typename T2>
bool operator!=(const myallocator<T1> &, const myallocator<T2> &)
{ return false; }
```

等式运算符定义分配器是*等于*还是*不等于*。在前面的示例中，我们创建了一个无状态分配器，这意味着以下内容是有效的:

```cpp
myallocator<int> myalloc1;
myallocator<int> myalloc2;

auto ptr = myalloc1.allocate(1);
myalloc2.deallocate(ptr, 1);
```

如果前面的属性成立，则分配符相等。因为，在我们的示例中，`myalloc1{}`在分配时调用`malloc()`，而`myalloc2{}`在解除分配时调用`free()`，我们知道它们是可互换的，这意味着前面的内容成立，并且我们的示例实现了*等于*分配器。前面的相等运算符只是正式声明这个相等性，提供 api (如 C 容器)，并根据需要创建新的分配器。

# 了解分配器的属性和选项

我们刚刚讨论的基本分配器仅提供了创建和使用具有现有 C 数据结构 (以及利用对象分配的其他用户定义类型) 的分配器所需的功能。除了我们讨论的可选别名之外，还有其他几个组成 C 分配器的选项和属性。

# 学习属性

C 分配器必须遵守一定的属性集，其中大多数属性是显而易见的或易于遵守的。

# 值指针类型

第一组属性确保分配器返回的指针类型实际上是一个指针:

```cpp
myallocator<myclass> myalloc;

myclass *ptr = myalloc.allocate(1);
const myclass *cptr = myalloc.allocate(1);

std::cout << (*ptr).data1 << '\n';
std::cout << (*cptr).data2 << '\n';

std::cout << ptr->data1 << '\n';
std::cout << cptr->data2 << '\n';

// 0
// 32644
// 0
// 32644
```

如果分配器返回的指针确实是一个指针，则可以取消引用该指针以访问其指向的内存，如前面示例所示。还应该注意的是，在这个例子中，当我们试图将结果分配的内存输出到`stdout`时，我们得到了相对随机的值。这是因为不需要从分配器中归零内存，因为此操作是由使用此内存的容器为我们完成的，性能更高。

# 平等

如前所述，如果分配器在比较时相等，则它们返回`true`，如下所示:

```cpp
myallocator<myclass> myalloc1;
myallocator<myclass> myalloc2;

std::cout << std::boolalpha;
std::cout << (myalloc1 == myalloc2) << '\n';
std::cout << (myalloc1 != myalloc2) << '\n';

// true
// false
```

如果两个相同类型的分配器返回`true`，则意味着使用此分配器的容器可以自由分配和释放相同分配器的不同实例的内存，这最终可以使用某些优化。例如，容器可能从不实际存储对分配器的内部引用，而是仅在需要分配内存时创建分配器。从那时起，容器在内部管理内存，并且仅在销毁时释放内存，此时容器将创建另一个分配器来执行释放，再次假设分配器是相等的。

正如我们所介绍的，分配器平等通常与状态相关。通常，有状态分配器不相等，而无状态分配器则相等; 但是此规则并不总是成立，尤其是当副本由有状态分配器组成时，规范要求提供相等性 (或者至少能够解除分配以前分配的从副本分配的内存)。当我们涵盖有状态分配器时，我们将提供有关此特定问题的更多详细信息。

C 17 之前的分配器的一个问题是，容器没有简单的方法来识别分配器是否相等，而无需首先在初始化时创建相同分配器的两个实例，比较它们，然后根据结果设置内部状态。由于 C 分配器概念的这种限制，容器要么假定无状态分配器 (旧版本的 C 库就是这种情况)，要么假定所有分配器都是有状态的，从而消除了优化的可能性。

为了克服这一点，C 17 引入了以下内容:

```cpp
using is_always_equal = std::true_type;
```

如果您的分配器没有提供这一点 (如前面的示例)，则默认值为`std::empty`，告诉容器需要旧样式的比较来确定相等性。如果提供了此别名，则容器将知道如何优化自身。

# 不同的分配类型

容器如何分配内存完全取决于容器的类型，因此，分配器必须能够支持不同的分配类型，例如:

*   分配器的所有分配必须在内存中连续。不要求一个分配与另一个分配在内存中是连续的，但是每个单独的分配必须是连续的。
*   分配器必须能够在一次分配中分配多个元素。根据分配器的不同，这有时会出现问题。

要探索这些属性，让我们使用以下示例:

```cpp
template<typename T>
class myallocator
{
public:

    using value_type = T;
    using pointer = T *;
    using size_type = std::size_t;
    using is_always_equal = std::true_type;

public:

    myallocator()
    {
        std::cout << this << " constructor, sizeof(T): "
                  << sizeof(T) << '\n';
    }

    template <typename U>
    myallocator(const myallocator<U> &other) noexcept
    { (void) other; }

    pointer allocate(size_type n)
    {
        if (auto ptr = static_cast<pointer>(malloc(sizeof(T) * n))) {
            std::cout << this << " A [" << n << "]: " << ptr << '\n';
            return ptr;
        }

        throw std::bad_alloc();
    }

    void deallocate(pointer p, size_type n)
    {
        (void) n;

        std::cout << this << " D [" << n << "]: " << p << '\n';
        free(p);
    }
};

template <typename T1, typename T2>
bool operator==(const myallocator<T1> &, const myallocator<T2> &)
{ return true; }

template <typename T1, typename T2>
bool operator!=(const myallocator<T1> &, const myallocator<T2> &)
{ return false; }
```

前面的分配器与第一个分配器相同，只是在构造函数以及分配和释放函数中添加了调试语句，使我们可以看到容器如何分配内存。

让我们来考察一个简单的例子`std::list`:

```cpp
std::list<int, myallocator<int>> mylist;
mylist.emplace_back(42);

// 0x7ffe97b0e8e0 constructor, sizeof(T): 24
// 0x7ffe97b0e8e0 A [1]: 0x55c0793e8580
// 0x7ffe97b0e8e0 D [1]: 0x55c0793e8580
```

正如我们所看到的，我们有一个来自分配器的单一分配和解除分配。分配器正在分配 24 字节的内存，即使提供的类型是一个 int，它的大小是 4 字节。这是因为`std::list`分配链表节点，在本例中为 24 字节。分配器位于`0x7ffe97b0e8e0`，分配位于`0x55c0793e8580`。而且，如图所示，每次调用分配函数时分配的元素数量为 1。这是因为`std::list`实现了链表，它对添加到列表中的每个元素进行动态分配。虽然这在使用自定义分配器时似乎非常浪费，但在执行系统编程时，这可能非常有用，因为当一次只分配一个元素 (而不是多个) 时，有时使用内存更容易。

现在来看`std::vector`，如下:

```cpp
std::vector<int, myallocator<int>> myvector;
myvector.emplace_back(42);
myvector.emplace_back(42);
myvector.emplace_back(42);

// 0x7ffe1db8e2d0 constructor, sizeof(T): 4
// 0x7ffe1db8e2d0 A [1]: 0x55bf9dbdd550
// 0x7ffe1db8e2d0 A [2]: 0x55bf9dbebe90
// 0x7ffe1db8e2d0 D [1]: 0x55bf9dbdd550
// 0x7ffe1db8e2d0 A [4]: 0x55bf9dbdd550
// 0x7ffe1db8e2d0 D [2]: 0x55bf9dbebe90
// 0x7ffe1db8e2d0 D [4]: 0x55bf9dbdd550
```

在前面的示例中，我们使用客户分配器创建`std::vector`，然后与前面的示例不同，我们将三个整数添加到向量中，而不是一个。这是因为`std::vector`必须保持连续的内存，而不管向量中的元素数量 (这是`std::vector`的主要属性之一)。结果，如果`std::vector`填满 (即内存耗尽)，`std::vector`必须为`std::vector`中的所有元素分配一个全新的连续内存块，将`std::vector`从旧内存复制到新内存，然后释放先前的内存块，因为它不再足够大。

为了演示这是如何工作的，我们在`std::vector`中添加了三个元素:

*   第一个元素分配一个大小为四个字节的内存块 (`n == 1`和`sizeof(T) == 4`)。
*   我们第二次将数据添加到`std::vector`时，当前内存块已满 (因为第一次只分配了四个字节)，因此`std::vector`必须释放先前分配的内存，分配新的内存块，然后复制`std::vector`的旧内容。但是，这次分配设置了`n == 2`，因此分配了八个字节。
*   第三次我们添加一个元素，`std::vector`再次内存不足，重复这个过程，但是用`n == 4`，这意味着分配了 16 个字节。

顺便说一句，第一次分配从`0x55bf9dbdd550`开始，这也恰好是第三次分配的位置。这是因为`malloc()`分配的是对齐到 16 个字节的内存，这意味着第一次分配虽然只有 4 个字节大小，但实际上分配了 16 个字节，这对于`n == 4`一开始就足够了 (也就是说，GCC 提供的`std::vector`的实现可以使用优化)。由于第一分配被解除分配，第二次存储器被添加到`std::vector`，该存储器在第三次使用元素时是自由使用的，因为原始分配对于所请求的量来说仍然足够大。

从分配器的使用方式来看，很明显，除非您实际上需要连续的内存，否则`std::vector`不是存储列表的好选择，因为它很慢。但是，由于每个元素为 24 字节，而不是 4 字节，因此占用了大量额外的内存。下一个也是最后一个要观察的容器是`std::deque`，它在`std::vector`和`std::list`之间找到一个快乐的介质:

```cpp
std::deque<int, myallocator<int>> mydeque;
mydeque.emplace_back(42);
mydeque.emplace_back(42);
mydeque.emplace_back(42);

// constructor, sizeof(T): 4
// 0x7ffdea986e67 A [8]: 0x55d6822b0da0
// 0x7ffdea986f30 A [128]: 0x55d6822afaf0
// 0x7ffdea986f30 D [128]: 0x55d6822afaf0
// 0x7ffdea986e67 D [8]: 0x55d6822b0da0
```

`std::deque`创建可用于存储多个元素的内存块的链接列表。换句话说，`std::deque`是`std::vectors`的`std::list`。与`std::list`一样，内存不是连续的，但与`std::vector`一样，每个元素只消耗四个字节，添加的每个元素都不需要动态内存分配。如图所示，`sizeof(T) == 4`字节，并且在`std::deque`创建期间，分配了一个大的内存缓冲区来存储几个元素 (`128`元素，具体来说)。第二，较小的分配用于内部簿记。

为了进一步探索`std::deque`，让我们在`std::deque`中添加很多元素:

```cpp
std::deque<int, myallocator<int>> mydeque;

for (auto i = 0; i < 127; i++)
    mydeque.emplace_back(42);

for (auto i = 0; i < 127; i++)
    mydeque.emplace_back(42);

for (auto i = 0; i < 127; i++)
    mydeque.emplace_back(42);

// constructor, sizeof(T): 4
// 0x7ffc5926b1b7 A [8]: 0x560285cc0da0
// 0x7ffc5926b280 A [128]: 0x560285cbfaf0
// 0x7ffc5926b280 A [128]: 0x560285cc1660
// 0x7ffc5926b280 A [128]: 0x560285cc1bc0
// 0x7ffc5926b280 D [128]: 0x560285cbfaf0
// 0x7ffc5926b280 D [128]: 0x560285cc1660
// 0x7ffc5926b280 D [128]: 0x560285cc1bc0
// 0x7ffc5926b1b7 D [8]: 0x560285cc0da0
```

在前面的示例中，我们将`127`元素添加了三次。这是因为每个分配都足够分配`128`元素，其中一个元素用于记账。如图所示，`std::deque`分配三个内存块。

# 复制相等的分配器

使用相同的分配器复制容器是直接的-这是因为分配器是可互换的。为了探索这一点，让我们将以下重载添加到先前的分配器中，以便我们可以观察到发生的其他操作:

```cpp
myallocator(myallocator &&other) noexcept
{
    (void) other;
    std::cout << this << " move constructor, sizeof(T): "
                << sizeof(T) << '\n';
}

myallocator &operator=(myallocator &&other) noexcept
{
    (void) other;
    std::cout << this << " move assignment, sizeof(T): "
                << sizeof(T) << '\n';
    return *this;
}

myallocator(const myallocator &other) noexcept
{
    (void) other;
    std::cout << this << " copy constructor, sizeof(T): "
                << sizeof(T) << '\n';
}

myallocator &operator=(const myallocator &other) noexcept
{
    (void) other;
    std::cout << this << " copy assignment, sizeof(T): "
                << sizeof(T) << '\n';
    return *this;
}
```

前面的代码添加了一个复制构造函数、`copy assignment`运算符、move 构造函数和`move assignment`运算符，所有这些都有 debug 语句，这样我们就可以看到容器在做什么。通过前面的添加，我们将能够看到何时执行分配器的副本。现在让我们在复制的容器中使用这个分配器:

```cpp
std::list<int, myallocator<int>> mylist1;
std::list<int, myallocator<int>> mylist2;

mylist1.emplace_back(42);
mylist1.emplace_back(42);

std::cout << "----------------------------------------\n";
mylist2 = mylist1;
std::cout << "----------------------------------------\n";

mylist2.emplace_back(42);
mylist2.emplace_back(42);
```

在前面的示例中，我们创建了两个列表。在第一个`std::list`中，我们将两个元素添加到列表中，然后将列表复制到第二个`std::list`中。最后，我们在第二个`std::list`中再添加两个元素。输出如下:

```cpp
0x7fff866d1e50 constructor, sizeof(T): 24
0x7fff866d1e70 constructor, sizeof(T): 24
0x7fff866d1e50 A [1]: 0x557c430ec550
0x7fff866d1e50 A [1]: 0x557c430fae90
----------------------------------------
0x7fff866d1d40 copy constructor, sizeof(T): 24
0x7fff866d1d40 A [1]: 0x557c430e39a0
0x7fff866d1d40 A [1]: 0x557c430f14a0
----------------------------------------
0x7fff866d1e70 A [1]: 0x557c430f3b30
0x7fff866d1e70 A [1]: 0x557c430ec4d0
0x7fff866d1e70 D [1]: 0x557c430e39a0
0x7fff866d1e70 D [1]: 0x557c430f14a0
0x7fff866d1e70 D [1]: 0x557c430f3b30
0x7fff866d1e70 D [1]: 0x557c430ec4d0
0x7fff866d1e50 D [1]: 0x557c430ec550
0x7fff866d1e50 D [1]: 0x557c430fae90
```

正如预期的那样，每个列表都会创建它计划使用的分配器，并且分配器会创建 24 字节的`std::list`节点。然后，我们看到第一个分配器为添加到第一个列表中的两个元素分配内存。在复制第一个列表之前，第二个列表仍然为空，因此，第二个容器创建了第三个临时分配器，它可以仅用于复制列表。完成此操作后，我们将最后两个元素添加到第二个列表中，我们可以看到第二个列表使用其原始分配器来执行分配。

`std::list`可以自由地从一个分配器分配内存，而从另一个分配器分配内存，这在 deallocations 中可以看到，这就是为什么`std::list`在复制过程中创建一个临时分配器的原因，因为它可以自由地这样做。容器是否应该创建临时分配器不是重点 (尽管它可能是一个有争议的优化)。

# 移动相等的分配器

如果分配器相等，则移动容器类似于复制容器。同样，这是因为没有关于容器必须做什么的规则，因为容器可以使用其原始分配器来处理任何内存，如果需要，它可以创建一个新的分配器，如下所示:

```cpp
std::list<int, myallocator<int>> mylist1;
std::list<int, myallocator<int>> mylist2;

mylist1.emplace_back(42);
mylist1.emplace_back(42);

std::cout << "----------------------------------------\n";
mylist2 = std::move(mylist1);
std::cout << "----------------------------------------\n";

mylist2.emplace_back(42);
mylist2.emplace_back(42);
```

在前面的示例中，我们不是复制第一个容器，而是移动它。结果，移动后的第一个容器不再有效，第二个容器现在拥有来自第一个容器的内存。

这个例子的输出如下:

```cpp
0x7ffe582e2850 constructor, sizeof(T): 24
0x7ffe582e2870 constructor, sizeof(T): 24
0x7ffe582e2850 A [1]: 0x56229562d550
0x7ffe582e2850 A [1]: 0x56229563be90
----------------------------------------
----------------------------------------
0x7ffe582e2870 A [1]: 0x5622956249a0
0x7ffe582e2870 A [1]: 0x5622956324a0
0x7ffe582e2870 D [1]: 0x56229562d550
0x7ffe582e2870 D [1]: 0x56229563be90
0x7ffe582e2870 D [1]: 0x5622956249a0
0x7ffe582e2870 D [1]: 0x5622956324a0
```

与复制示例类似，创建两个列表，每个`std::list`创建一个分配器，该分配器管理 24 字节的`std::list`节点。将两个元素添加到第一个列表中，然后将第一个列表移动到第二个列表中。结果，属于第一列表的存储器现在由第二容器拥有，并且不执行任何副本。对第二列表的第二分配由其自己的分配器执行，所有的解除分配也是如此，因为来自第一分配器的分配可以使用第二分配器解除分配。

# 探索一些可选属性

C 分配器提供了一些超出`is_always_equal`的附加属性。具体来说，C 分配器的作者可以可选地定义以下内容:

可选属性告诉容器在特定操作 (即复制、移动和交换) 期间应如何处理分配器。具体来说，当容器被复制、移动或交换时，分配器不会被触摸，正如我们将展示的那样，这可能会导致效率低下。传播属性告诉容器将操作传播到分配器。例如，如果将`propagate_on_container_copy_assignment`设置为`std::true_type`并且正在复制容器，则分配器也必须在正常情况下复制。

为了更好地探索这些属性，让我们创建我们的第一个不相等分配器 (也就是说，同一分配器的两个不同实例可能不相等)。如上所述，大多数不平等的分配者都是有状态的。在这个例子中，我们将创建一个无状态的、不相等的分配器来保持简单。我们在本章的最后一个例子将创建一个不相等的、有状态的分配器。

要开始我们的示例，我们首先需要为我们的分配器类创建一个托管对象，如下所示:

```cpp
class myallocator_object
{
public:

    using size_type = std::size_t;

public:

    void *allocate(size_type size)
    {
        if (auto ptr = malloc(size)) {
            std::cout << this << " A " << ptr << '\n';
            return ptr;
        }

        throw std::bad_alloc();
    }

    void deallocate(void *ptr)
    {
        std::cout << this << " D " << ptr << '\n';
        free(ptr);
    }
};
```

不相等的分配器必须遵守以下属性:

*   分配器的所有副本必须相等。这意味着，即使我们创建了一个不相等的分配器，一个分配器的副本也必须仍然相等。当使用 rebind 复制构造函数时，这将成为问题，因为此属性仍然为 true (也就是说，即使两个分配器可能没有相同的类型，如果一个是另一个的副本，它们可能仍然必须相等)。
*   所有相等的分配器必须能够释放彼此的内存。再次，当使用 rebind 复制构造函数时，这将成为问题。具体来说，这意味着管理`int`对象的分配器可能必须从管理`std::list`节点的分配器释放内存。

为了支持这两个规则，大多数不相等的分配器最终成为托管对象的包装器。也就是说，创建了一个对象，该对象可以分配和释放内存，并且每个分配器都存储一个指向该对象的指针。在前面的示例中，`myallocator_object{}`是能够分配和释放内存的托管对象。为了创建这个对象，我们所做的只是将`malloc()`和`free()`从分配器本身移动到这个`myallocator_object{}`; 代码是相同的。添加到`myallocator_object{}`的唯一附加逻辑如下:

*   构造函数的大小。这是因为我们无法将托管对象创建为模板类。具体来说，托管对象需要能够更改其管理的内存类型 (因为概述的规则)。对此的具体需求将很快得到解决。
*   添加了一个`rebind()`函数，该函数专门更改了受管理对象管理的内存大小。再次，这允许我们更改 `myallocator_object{}` 正在执行的分配的大小。

接下来，我们需要定义分配器本身，如下所示:

```cpp
template<typename T>
class myallocator
{
```

分配器的第一部分与其他分配器相同，要求使用模板类，该模板类的分配器内存为某些`T`类型:

```cpp
public:

    using value_type = T;
    using pointer = T *;
    using size_type = std::size_t;
    using is_always_equal = std::false_type;
```

分配器的下一部分定义了我们的类型别名和可选属性。如图所示，所有三个 propagate 函数都是未定义的，这告诉使用此分配器的任何容器，当发生容器的复制、移动或交换时，分配器也不会被复制、移动或交换 (容器应继续使用构造时给出的相同分配器)。

下一组函数定义了我们的构造函数和运算符。让我们从默认构造函数开始:

```cpp
myallocator() :
    m_object{std::make_shared<myallocator_object>()}
{
    std::cout << this << " constructor, sizeof(T): "
                << sizeof(T) << '\n';
}
```

与所有构造函数和运算符一样，我们将一些调试信息输出到`stdout`，以便我们可以观察容器对分配器的作用。如图所示，默认构造函数分配`myallocator_object{}`并将其存储为`std::shared_ptr`。我们利用`std::shared_ptr`，因为分配器的每个副本必须相等，因此，每个副本必须共享相同的托管对象 (以便从一个分配器分配的内存可以从副本中释放)。由于任何一种分配器都可以在任何类型上销毁，因此*都拥有*托管对象，因此`std::shared_ptr`是更合适的智能指针。

接下来的两个函数是移动构造函数和赋值运算符:

```cpp
myallocator(myallocator &&other) noexcept :
    m_object{std::move(other.m_object)}
{
    std::cout << this << " move constructor, sizeof(T): "
                << sizeof(T) << '\n';
}

myallocator &operator=(myallocator &&other) noexcept
{
    std::cout << this << " move assignment, sizeof(T): "
                << sizeof(T) << '\n';

    m_object = std::move(other.m_object);
    return *this;
}
```

在这两种情况下，作为移动操作的结果，我们需要`std::move()`我们的托管对象。同样的事情也适用于复制:

```cpp
myallocator(const myallocator &other) noexcept :
    m_object{other.m_object}
{
    std::cout << this << " copy constructor, sizeof(T): "
                << sizeof(T) << '\n';
}

myallocator &operator=(const myallocator &other) noexcept
{
    std::cout << this << " copy assignment, sizeof(T): "
                << sizeof(T) << '\n';

    m_object = other.m_object;
    return *this;
}
```

如图所示，如果由分配器构成副本，则我们还必须复制托管对象。结果，分配器的副本利用了相同的托管对象，这意味着该副本可以从原始副本中释放内存。

下一个函数是使不平等分配器如此困难的原因:

```cpp
template <typename U>
myallocator(const myallocator<U> &other) noexcept :
    m_object{other.m_object}
{
    std::cout << this << " copy constructor (U), sizeof(T): "
                << sizeof(T) << '\n';
}
```

前面的函数是 rebind 复制构造函数。这个构造函数的重点是创建另一个不同类型的分配器的副本。例如，`std::list`从`myallocator<int>{}`开始，但它确实需要`myallocator<std::list::node>{}`类型的分配器，而不是`myallocator<int>{}`。为了克服这个问题，前面的函数允许容器执行如下操作:

```cpp
myallocator<int> alloc1;
myallocator<std::list::node> alloc2(alloc1);
```

在前面的示例中，`alloc2`是`alloc1`的副本，即使`alloc1`和`alloc2`不共享相同的`T`类型。问题是，一个`int`是四个字节，而在我们的例子中，`std::list::node`已经是 24 字节，这意味着不仅前面的函数必须能够创建一个不同类型的分配器的副本，即*等于*，它还必须能够创建能够释放不同类型内存的副本 (具体地说，在这种情况下，`alloc2`必须能够释放 ints，即使它管理`std::list::node`元素)。在我们的示例中，这不是问题，因为我们正在使用`malloc()`和`free()`，但是正如我们将在上一个示例中显示的那样，一些有状态的分配器 (例如内存池) 不符合此要求。

`allocate`和`deallocate`函数定义如下:

```cpp
pointer allocate(size_type n)
{
    auto ptr = m_object->allocate(sizeof(T) * n);
    return static_cast<pointer>(ptr);
}

void deallocate(pointer p, size_type n)
{
    (void) n;
    return m_object->deallocate(p);
}
```

由于我们的托管对象只是调用`malloc()`和`free()`，因此我们可以将对象的`allocate()`和`deallocate()`函数也视为`malloc()`和`free()`，因此，实现很简单。

我们在`allocator`类中的私有逻辑如下:

```cpp
std::shared_ptr<myallocator_object> m_object;

template <typename T1, typename T2>
friend bool operator==(const myallocator<T1> &lhs, const myallocator<T2> &rhs);

template <typename T1, typename T2>
friend bool operator!=(const myallocator<T1> &lhs, const myallocator<T2> &rhs);
```

如前所述，我们存储一个指向托管对象的智能指针，这使我们能够创建分配器的副本。我们还声明我们的平等函数是朋友，尽管我们将这些朋友函数放在类的私有部分，但我们可以将它们放在任何地方，因为朋友声明不受公共/保护/私有声明的影响。

最后，等式函数如下:

```cpp
template <typename T1, typename T2>
bool operator==(const myallocator<T1> &lhs, const myallocator<T2> &rhs)
{ return lhs.m_object.get() == rhs.m_object.get(); }

template <typename T1, typename T2>
bool operator!=(const myallocator<T1> &lhs, const myallocator<T2> &rhs)
{ return lhs.m_object.get() != rhs.m_object.get(); }
```

我们的*等于*分配器示例仅对`operator==`返回 true，对`operator!=`返回 false，这说明分配器是相等的 (除了使用`is_always_equal`)。在这个例子中，`is_always_equal`设置为`false`，在我们的相等运算符中，我们比较托管对象。每次创建新的分配器时，都会创建一个新的托管对象，结果，分配器不相等 (也就是说，它们是不相等的分配器)。问题是，我们不能简单地总是为`operator==`返回`false`，因为分配器的副本必须始终等于规范中的原始副本，这就是我们使用`std::shared_ptr`的原因。分配器的每个副本都会创建一个`std::shared_ptr`的副本，并且由于如果创建了分配器的副本，我们会比较托管对象的地址，因此该副本和原始副本具有相同的托管对象，因此返回`true` (即它们相等)。尽管可能不使用`std::shared_ptr`，但大多数不相等分配器都是这样实现的，因为它提供了一种简单的方法来根据分配器是否已被复制来处理相等和不相等分配器之间的差异。

现在我们有了一个分配器，让我们测试一下:

```cpp
std::list<int, myallocator<int>> mylist;
mylist.emplace_back(42);

// 0x7ffce60fbd10 constructor, sizeof(T): 24
// 0x561feb431590 A [1]: 0x561feb43fec0
// 0x561feb431590 D [1]: 0x561feb43fec0
```

如您所见，我们的分配器能够分配和释放内存。上述示例中的分配器位于`0x561feb431590`，而由`std::list`容器分配的元素位于`0x561feb43fec0`。

复制一个不相等的容器，将 propagate 属性设置为`false`很简单，如下所示:

```cpp
std::list<int, myallocator<int>> mylist1;
std::list<int, myallocator<int>> mylist2;

mylist1.emplace_back(42);
mylist1.emplace_back(42);

mylist2.emplace_back(42);
mylist2.emplace_back(42);

std::cout << "----------------------------------------\n";
mylist2 = mylist1;
std::cout << "----------------------------------------\n";

mylist2.emplace_back(42);
mylist2.emplace_back(42);
```

如前面的示例所示，我们创建两个列表，并分别用两个元素填充两个列表。填充列表后，我们将第一个容器复制到第二个容器中，然后输出到`stdout`，以便我们可以看到容器如何处理此副本。最后，我们在刚刚复制的容器中添加了两个元素。

这个例子的输出如下:

```cpp
// 0x7ffd65a15cb0 constructor, sizeof(T): 24
// 0x7ffd65a15ce0 constructor, sizeof(T): 24
// 0x55c4867c3a80 A [1]: 0x55c4867b9210  <--- add to list #1
// 0x55c4867c3a80 A [1]: 0x55c4867baec0  <--- add to list #1
// 0x55c4867d23c0 A [1]: 0x55c4867c89c0  <--- add to list #2
// 0x55c4867d23c0 A [1]: 0x55c4867cb050  <--- add to list #2
// ----------------------------------------
// ----------------------------------------
// 0x55c4867d23c0 A [1]: 0x55c4867c39f0  <--- add to list #2 after copy
// 0x55c4867d23c0 A [1]: 0x55c4867c3a10  <--- add to list #2 after copy
// 0x55c4867d23c0 D [1]: 0x55c4867c89c0  <--- deallocate list #2
// 0x55c4867d23c0 D [1]: 0x55c4867cb050  <--- deallocate list #2
// 0x55c4867d23c0 D [1]: 0x55c4867c39f0  <--- deallocate list #2
// 0x55c4867d23c0 D [1]: 0x55c4867c3a10  <--- deallocate list #2
// 0x55c4867c3a80 D [1]: 0x55c4867b9210  <--- deallocate list #1
// 0x55c4867c3a80 D [1]: 0x55c4867baec0  <--- deallocate list #1
```

如图所示，复制容器不涉及分配器。当复制发生时，列表二保留它已经拥有的两个分配，覆盖前两个元素的值。由于 propagate 属性是`false`，因此第二个容器保留了最初给出的分配器，并使用分配器分配复制后的第二个元素，但是当列表失去作用域时，也释放了所有先前分配的元素。

这种方法的问题是需要容器循环遍历每个元素并执行手动复制。对于整数，这种类型的复制很好，但是我们可以在列表中存储大型结构，因此，复制容器会导致复制容器中的每个元素，这是浪费且昂贵的。由于 propagate 属性是`false`，因此容器没有选择，因为它不能使用第一个列表中的分配器，也不能使用自己的分配器来复制第一个列表中分配的元素 (因为分配器不相等)。尽管这是浪费的，但正如将显示的那样，这种方法可能仍然是最快的方法。

移动列表也有类似的问题:

```cpp
std::list<int, myallocator<int>> mylist1;
std::list<int, myallocator<int>> mylist2;

mylist1.emplace_back(42);
mylist1.emplace_back(42);

mylist2.emplace_back(42);
mylist2.emplace_back(42);

std::cout << "----------------------------------------\n";
mylist2 = std::move(mylist1);
std::cout << "----------------------------------------\n";

mylist2.emplace_back(42);
mylist2.emplace_back(42);
```

在前面的示例中，我们做的事情与在前面的示例中相同。我们创建两个列表，并在将一个列表移动到另一个列表之前向每个列表添加两个元素。

这个例子的结果如下:

```cpp
// 0x7ffd65a15cb0 constructor, sizeof(T): 24
// 0x7ffd65a15ce0 constructor, sizeof(T): 24
// 0x55c4867c3a80 A [1]: 0x55c4867c3a10  <--- add to list #1
// 0x55c4867c3a80 A [1]: 0x55c4867c39f0  <--- add to list #1
// 0x55c4867d23c0 A [1]: 0x55c4867c0170  <--- add to list #2
// 0x55c4867d23c0 A [1]: 0x55c4867c0190  <--- add to list #2
// ----------------------------------------
// ----------------------------------------
// 0x55c4867d23c0 A [1]: 0x55c4867b9c90  <--- add to list #2 after move
// 0x55c4867d23c0 A [1]: 0x55c4867b9cb0  <--- add to list #2 after move
// 0x55c4867d23c0 D [1]: 0x55c4867c0170  <--- deallocate list #2
// 0x55c4867d23c0 D [1]: 0x55c4867c0190  <--- deallocate list #2
// 0x55c4867d23c0 D [1]: 0x55c4867b9c90  <--- deallocate list #2
// 0x55c4867d23c0 D [1]: 0x55c4867b9cb0  <--- deallocate list #2
// 0x55c4867c3a80 D [1]: 0x55c4867c3a10  <--- deallocate list #1
// 0x55c4867c3a80 D [1]: 0x55c4867c39f0  <--- deallocate list #1
```

在前面的例子中，我们可以看到同样的低效率存在。由于 propagate 属性为`false`，因此容器不能使用第一个列表中的分配器，而是必须继续使用它已经拥有的分配器。因此，移动操作不能简单地将内部容器从一个列表移动到另一个列表，而是必须循环遍历整个容器，对每个单独的元素执行`std::move()`，这样与列表中的每个节点相关联的内存仍然由第二个列表的原始分配器管理。

为了克服这些问题，我们将在分配器中添加以下内容:

```cpp
using propagate_on_container_copy_assignment = std::true_type;
using propagate_on_container_move_assignment = std::true_type;
using propagate_on_container_swap = std::true_type;
```

这些属性告诉使用此分配器的任何容器，如果发生容器的复制，移动或交换，则分配器应执行相同的操作。例如，如果我们复制`std::list`，容器不仅必须复制*元素，而且还应该复制分配器。*

让我们看下面的副本示例:

```cpp
std::list<int, myallocator<int>> mylist1;
std::list<int, myallocator<int>> mylist2;

mylist1.emplace_back(42);
mylist1.emplace_back(42);

mylist2.emplace_back(42);
mylist2.emplace_back(42);

std::cout << "----------------------------------------\n";
mylist2 = mylist1;
std::cout << "----------------------------------------\n";

mylist2.emplace_back(42);
mylist2.emplace_back(42);
```

这个复制示例与我们之前的复制示例相同。我们创建两个列表，并在每个列表中添加两个元素。然后，我们将第一个列表复制到第二个列表中，然后在完成之前将两个额外的元素添加到第二个列表中 (这最终将释放列表)。

这个例子的结果如下。应该注意的是，这个输出有点复杂，所以我们将一步一步来:

```cpp
// 0x7ffc766ec580 constructor, sizeof(T): 24
// 0x7ffc766ec5b0 constructor, sizeof(T): 24
// 0x5638419d9720 A [1]: 0x5638419d0b60  <--- add to list #1
// 0x5638419d9720 A [1]: 0x5638419de660  <--- add to list #1
// 0x5638419e8060 A [1]: 0x5638419e0cf0  <--- add to list #2
// 0x5638419e8060 A [1]: 0x5638419d9690  <--- add to list #2
```

在上面的输出中，将创建两个列表，并将两个元素添加到每个容器中。接下来，输出将显示当我们将第二个容器复制到第一个容器时会发生什么:

```cpp
// 0x5638419e8060 D [1]: 0x5638419e0cf0
// 0x5638419e8060 D [1]: 0x5638419d9690
// 0x7ffc766ec5b0 copy assignment, sizeof(T): 24
// 0x7ffc766ec450 copy constructor (U), sizeof(T): 4
// 0x7ffc766ec3f0 copy constructor (U), sizeof(T): 24
// 0x7ffc766ec460 copy constructor, sizeof(T): 24
// 0x5638419d9720 A [1]: 0x5638419e8050
// 0x5638419d9720 A [1]: 0x5638419d9690
```

由于我们将 propagate 属性设置为`false`，因此容器现在可以选择保留第一个容器使用的内存 (例如，实现写时复制实现)。这是因为容器应该创建分配器的副本，并且分配器的任何两个副本都是相等的 (也就是说，它们可以释放彼此的内存)。glibc 的这个实现没有这样做。相反，它试图创建内存的干净视图。这两个列表，分配器是不相等的，这意味着，一旦复制已经发生，容器将不再能够释放它自己的，以前分配的内存 (因为它可能不再有访问其原始分配器)。结果，容器删除了之前作为第一步分配的所有内存。然后，它使用第一个列表的分配器的 rebind 副本 (奇怪的是，它似乎是未使用的) 创建一个临时分配器，就在创建第一个列表的分配器的直接副本之前，并使用它来分配将被复制的元素的新内存。

最后，现在副本已经完成，可以将最后两个元素添加到第二个列表中，并且每个列表一旦失去范围就可以销毁:

```cpp
// 0x5638419d9720 A [1]: 0x5638419d96b0  <--- add to list #2 after copy
// 0x5638419d9720 A [1]: 0x5638419d5e10  <--- add to list #2 after copy
// 0x5638419d9720 D [1]: 0x5638419e8050  <--- deallocate list #2
// 0x5638419d9720 D [1]: 0x5638419d9690  <--- deallocate list #2
// 0x5638419d9720 D [1]: 0x5638419d96b0  <--- deallocate list #2
// 0x5638419d9720 D [1]: 0x5638419d5e10  <--- deallocate list #2
// 0x5638419d9720 D [1]: 0x5638419d0b60  <--- deallocate list #1
// 0x5638419d9720 D [1]: 0x5638419de660  <--- deallocate list #1
```

如图所示，由于分配器是传播的，因此使用相同的分配器来释放两个列表中的元素。这是因为一旦复制完成，两个列表现在都使用相同的分配器 (因为任何两个分配器的副本必须相等，我们选择实现这一点的方式是在复制发生时创建相同的基本分配器对象的副本)。还应该注意的是，glibc 实现没有选择实现写时复制方案，这意味着不仅实现未能利用 propagate 属性提供的可能的优化，而且实现一个副本实际上是较慢的，由于副本不仅必须一次复制每个元素，而且还必须为副本分配新的内存。

现在我们来看一个移动的例子:

```cpp
std::list<int, myallocator<int>> mylist1;
std::list<int, myallocator<int>> mylist2;

mylist1.emplace_back(42);
mylist1.emplace_back(42);

mylist2.emplace_back(42);
mylist2.emplace_back(42);

std::cout << "----------------------------------------\n";
mylist2 = std::move(mylist1);
std::cout << "----------------------------------------\n";

mylist2.emplace_back(42);
mylist2.emplace_back(42);
```

像我们之前的移动示例一样，这将创建两个列表，并在将第一个列表移动到第二个列表之前将两个元素添加到每个列表中。最后，我们的示例将两个元素添加到第二个列表 (现在是第一个列表) 中，然后在两个列表失去范围时完成并释放它们。

此示例的结果输出如下:

```cpp
// 0x7ffc766ec580 constructor, sizeof(T): 24
// 0x7ffc766ec5b0 constructor, sizeof(T): 24
// 0x5638419d9720 A [1]: 0x5638419d96b0  <--- add to list #1
// 0x5638419d9720 A [1]: 0x5638419d9690  <--- add to list #1
// 0x5638419d5e20 A [1]: 0x5638419e8050  <--- add to list #2
// 0x5638419d5e20 A [1]: 0x5638419d5e30  <--- add to list #2
// ----------------------------------------
// 0x5638419d5e20 D [1]: 0x5638419e8050  <--- deallocate list #2
// 0x5638419d5e20 D [1]: 0x5638419d5e30  <--- deallocate list #2
// 0x7ffc766ec5b0 move assignment, sizeof(T): 24
// ----------------------------------------
// 0x5638419d9720 A [1]: 0x5638419d5e10
// 0x5638419d9720 A [1]: 0x5638419e8050
// 0x5638419d9720 D [1]: 0x5638419d96b0  <--- deallocate list #1
// 0x5638419d9720 D [1]: 0x5638419d9690  <--- deallocate list #1
// 0x5638419d9720 D [1]: 0x5638419d5e10  <--- deallocate list #2
// 0x5638419d9720 D [1]: 0x5638419e8050  <--- deallocate list #2
```

与前面的示例一样，您可以看到正在创建的列表以及将第一个元素添加到每个列表中。一旦移动发生，第二个列表将删除与其先前添加的元素相关联的内存。这是因为一旦移动发生，就不再需要与第二个列表相关联的存储器 (因为它即将被替换为由第一个列表分配的存储器)。这是可能的，因为第一个列表的分配器将被移动到第二个列表 (因为 propagate 属性被设置为`true`)，因此，第二个列表现在将拥有第一个列表的所有内存。

最后，将最后两个元素添加到列表中，并且列表将失去作用域并释放其所有内存。如图所示，这是最优的实现方式。不分配额外的内存不需要逐个元素移动。移动操作只是将内存和分配器从一个容器移动到另一个容器。另外，由于不复制分配器，因此对于任何分配器来说，这是一个简单的操作，因此，此属性应始终设置为 true。

# 可选功能

除了属性之外，还有几个可选功能为容器提供有关它们所提供的分配器类型的附加信息。一个可选功能如下:

```cpp
size_type myallocator::max_size();
```

`max_size()`函数告诉容器分配器可以分配的最大大小 “n”。在 C ++ 17 中，这个函数已被弃用。`max_size()`函数返回分配器可以执行的最大可能分配。奇怪的是，在 C 17 中，这默认为`std::numeric_limits<size_type>::max() / sizeof(value_type)`，这在大多数情况下可能不是一个有效的答案，因为大多数系统根本没有这么多可用的 RAM，这表明该功能在实践中几乎没有价值。相反，与 C 中的其他分配方案一样，当分配失败时，将抛出`std::bad_alloc`，向容器指示它试图执行的分配是不可能的。

C ++ 中的另一组可选函数如下:

```cpp
template<typename T, typename... Args>
static void myallocator::construct(T* ptr, Args&&... args);

template<typename T>
static void myallocator::destroy(T* ptr);
```

就像`max_size()`函数一样，在 C 17 中不推荐使用 construct 和 destruct 函数。在 C 17 之前，这些函数可用于构造和破坏与 `ptr` 提供的对象相关联的对象。应该注意的是，这就是为什么我们在构造函数中分配内存时不使用 new 和 delete，而是使用`malloc()`和`free()`。如果我们使用`new()`和`delete()`，我们会不小心调用对象的构造函数和/或析构函数两次，这将导致未定义的行为。

# 研究无状态，缓存对齐分配器的示例

在此示例中，我们将创建一个无状态，相等的分配器，该分配器旨在分配缓存对齐的内存。这个分配器的目标是展示一个 C 17 分配器，它可以被利用来提高容器存储的对象 (例如，链表) 的效率，因为高速缓存的发生可能性较小。

首先，我们将如下定义分配器:

```cpp
template<typename T, std::size_t Alignment = 0x40>
class myallocator
{
public:

    using value_type = T;
    using pointer = T *;
    using size_type = std::size_t;
    using is_always_equal = std::true_type;

    template<typename U> struct rebind {
        using other = myallocator<U, Alignment>;
    };

public:

    myallocator()
    { }

    template <typename U>
    myallocator(const myallocator<U, Alignment> &other) noexcept
    { (void) other; }

    pointer allocate(size_type n)
    {
        if (auto ptr = aligned_alloc(Alignment, sizeof(T) * n)) {
            return static_cast<pointer>(ptr);
        }

        throw std::bad_alloc();
    }

    void deallocate(pointer p, size_type n)
    {
        (void) n;
        free(p);
    }
};
```

前面的分配器类似于我们在本章创建的其他相等的分配器。有几个显着的区别:

*   分配器的模板签名不同。我们不仅定义了分配器类型`T`，还添加了一个`Alignment`参数，并将默认值设置为`0x40` (即分配将为 64 字节对齐，这是 Intel cpu 上高速缓存行的典型大小)。
*   我们还提供我们自己的 rebind 结构。通常，此结构是为我们提供的，但是由于我们的分配器具有多个模板参数，因此我们必须提供自己的 rebind 结构版本。此结构由容器 (例如`std::list`) 来创建容器所需的任何分配器，而无需创建副本 (相反，它可以在初始化期间直接创建分配器)。在这个 rebind 结构的版本中，我们传递原始分配器提供的`Alignment`参数。
*   rebind 复制构造函数还必须定义`Alignment`变量。在这种情况下，如果要发生重新绑定，我们将强制`Alignment`相同，因为重新绑定结构提供了`Alignment` (也是相同的)。

为了测试我们的示例，让我们创建分配器并输出分配的地址，以确保内存对齐:

```cpp
myallocator<int> myalloc;

auto ptr = myalloc.allocate(1);
std::cout << ptr << '\n';
myalloc.deallocate(ptr, 1);

// 0x561d512b6500
```

如图所示，所分配的存储器至少是 64 字节对齐的。对于多个分配也是如此，如下所示:

```cpp
myallocator<int> myalloc;

auto ptr = myalloc.allocate(42);
std::cout << ptr << '\n';
myalloc.deallocate(ptr, 42);

// 0x55dcdcb41500
```

如图所示，分配的存储器也至少是 64 字节对齐的。我们也可以将这个分配器与一个容器一起使用:

```cpp
std::vector<int, myallocator<int>> myvector;
myvector.emplace_back(42);

std::cout << myvector.data() << '\n';

// 0x55f875a0f500
```

再一次，内存仍然正确对齐。

# 编译和测试

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter09/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt)。

有了这段代码，我们可以使用以下内容编译这段代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter09/
> mkdir build
> cd build

> cmake ..
> make
```

要执行该示例，请运行以下命令:

```cpp
> ./example6
```

输出应类似于以下内容:

```cpp
0x55aec04dbd00
0x55aec04e8f40
0x55aec04d5d00
===============================================================================
test cases: 3 | 3 passed
assertions: - none -
```

如前面的代码片段所示，我们能够分配不同类型的内存，以及释放该内存，并且所有地址都是 64 字节对齐的。

# 研究有状态的内存池分配器的示例

在这个例子中，我们将创建一个复杂得多的分配器，称为**池分配器**。池分配器的目标是为固定大小的类型快速分配内存，同时 (更重要的是) 减少内存的内部碎片 (即每次分配浪费的内存量)，即使分配大小不是 2 的倍数或其他一些优化的分配大小)。

内存池分配器非常有用，以至于 C 的某些实现已经包含池分配器。此外，从技术上讲，C 17 在称为**多态分配器**的东西中支持池分配器 (本书没有涉及，因为在撰写本文时，C 17 的主要实现都没有支持多态分配器)，而且大多数操作系统都利用内核中的池分配器来减少内部碎片。

池分配器的主要优点如下:

*   `malloc()`的使用较慢。有时`free()`也很慢，但对于某些实现，`free()`就像翻转一点一样简单，在这种情况下，它可以实现得非常快。
*   大多数池分配器都使用 deque 结构，这意味着池分配器分配一个大的内存*块*，然后将该内存分开以进行分配。内存的每个*块*使用链表链接，以便可以根据需要将更多内存添加到池中。

池分配器还具有一个有趣的属性，其中块大小越大，内部碎片的减少就越大。这种优化的惩罚是，如果没有完全利用池，则浪费的内存量会随着块大小的增加而增加，因此应量身定制池分配器以满足应用程序的需求。

为了开始我们的示例，我们将首先创建一个`pool`类，该类管理*块*的列表，并从块中给出内存。块列表将存储在一个永远增长的堆栈中 (也就是说，在这个例子中，我们将尝试对块中的内存进行碎片整理，或者如果块中的所有内存都已被释放，则从堆栈中删除一个块)。每次将内存块添加到池中时，我们都会将块分成大小为`sizeof(T)`的块，并将每个块的地址添加到称为地址堆栈的第二个堆栈中。当分配内存时，我们会从地址堆栈中弹出一个地址，当内存被释放时，我们会将地址推回到堆栈中。

我们池的开始如下:

```cpp
class pool
{
public:

    using size_type = std::size_t;

public:

    explicit pool(size_type size) :
        m_size{size}
    { }
```

池将作为我们的不平等分配器的托管对象，就像我们之前的不平等分配器示例一样。因此，池不是模板类，因为如果使用了 rebind 复制构造函数，我们将需要更改池的大小 (有关该特定主题的更多信息)。如图所示，在我们的构造函数中，我们存储池的大小，但是我们不尝试预加载池。

为了分配，我们从地址堆栈中弹出一个地址并返回它。如果地址栈为空，我们通过分配另一个内存块，将其添加到地址栈中，将其添加到块堆栈中，将内存分成块，并将划分的块添加到地址栈中，如下所示:

```cpp
    void *allocate()
    {
        if (m_addrs.empty()) 
        {
            this->add_addrs();
        }

        auto ptr = m_addrs.top();
        m_addrs.pop();

        return ptr;
    }
```

要释放内存，我们将提供的地址推送到地址堆栈，以便以后可以再次分配。使用这种方法，为容器分配和释放内存就像弹出并将地址推送到单个堆栈一样简单:

```cpp
    void deallocate(void *ptr)
    { 
        m_addrs.push(ptr); 
    }
```

如果使用了 rebind 复制构造函数，我们将需要更改池的大小。只有在尝试将`int`类型的分配器创建为`std::list::node`类型的分配器时才会发生这种类型的复制，这意味着正在复制的分配器尚未被使用，这意味着可以调整大小。如果已使用分配器，则意味着分配器已经分配了不同大小的内存，因此，此实现将无法进行重新绑定。考虑以下代码:

```cpp
    void rebind(size_type size)
    {
        if (!m_addrs.empty() || !m_blocks.empty()) 
        {
            std::cerr << "rebind after alloc unsupported\n";
            abort();
        }

        m_size = size;
    }
```

应当指出，还有其他方法可以处理这一具体问题。例如，可以创建一个不尝试使用 rebind 复制构造函数的`std::list`。还可以创建能够管理多个内存池的分配器，每个池能够分配和释放特定类型的内存 (当然，这将导致性能下降)。

在我们的私有部分中，我们有在`allocate`函数中看到的`add_addrs()`函数。`this`函数的目标是重新填充地址堆栈。为此，`this`函数分配另一个内存块，将内存分开，并将其添加到地址堆栈中:

```cpp
    void add_addrs()
    {
        constexpr const auto block_size = 0x1000;
        auto block = std::make_unique<uint8_t[]>(block_size);

        auto v = gsl::span<uint8_t>(
            block.get(), block_size
        );

        auto total_size =
            v.size() % m_size == 0 ? v.size() : v.size() - m_size;

        for (auto i = 0; i < total_size; i += m_size) 
        {
            m_addrs.push(&v.at(i));
        }

        m_blocks.push(std::move(block));
    }
```

最后，我们有私有成员变量，其中包括池的大小，地址堆栈和块堆栈。请注意，我们为此使用`std::stack`。`std::stack`使用`std::deque`来实现堆栈，虽然可以编写一个不利用迭代器的更高效的堆栈，但在测试中，`std::stack`几乎是性能:

```cpp
    size_type m_size;

    std::stack<void *> m_addrs{};
    std::stack<std::unique_ptr<uint8_t[]>> m_blocks{};
```

分配器本身与我们已经定义的先前的不相等分配器几乎相同:

```cpp
template<typename T>
class myallocator
{
public:

    using value_type = T;
    using pointer = T *;
    using size_type = std::size_t;
    using is_always_equal = std::false_type;
    using propagate_on_container_copy_assignment = std::false_type;
    using propagate_on_container_move_assignment = std::true_type;
    using propagate_on_container_swap = std::true_type;
```

一个区别是，我们将`propagate_on_container_copy_assignment`定义为`false`，具体是为了尽可能地防止分配器被复制。这一选择也得到了这样一个事实的支持，即我们已经确定，当利用不平等的分配器时，glibc 不会提供巨大的好处。

构造函数与先前定义的相同:

```cpp
    myallocator() :
        m_pool{std::make_shared<pool>(sizeof(T))}
    {
        std::cout << this << " constructor, sizeof(T): "
                  << sizeof(T) << '\n';
    }

    template <typename U>
    myallocator(const myallocator<U> &other) noexcept :
        m_pool{other.m_pool}
    {
        std::cout << this << " copy constructor (U), sizeof(T): "
                  << sizeof(T) << '\n';

        m_pool->rebind(sizeof(T));
    }

    myallocator(myallocator &&other) noexcept :
        m_pool{std::move(other.m_pool)}
    {
        std::cout << this << " move constructor, sizeof(T): "
                  << sizeof(T) << '\n';
    }

    myallocator &operator=(myallocator &&other) noexcept
    {
        std::cout << this << " move assignment, sizeof(T): "
                  << sizeof(T) << '\n';

        m_pool = std::move(other.m_pool);
        return *this;
    }

    myallocator(const myallocator &other) noexcept :
        m_pool{other.m_pool}
    {
        std::cout << this << " copy constructor, sizeof(T): "
                  << sizeof(T) << '\n';
    }

    myallocator &operator=(const myallocator &other) noexcept
    {
        std::cout << this << " copy assignment, sizeof(T): "
                  << sizeof(T) << '\n';

        m_pool = other.m_pool;
        return *this;
    }
```

`allocate`和`deallocate`函数与之前定义的相同，调用池的分配函数。一个区别是，我们的池只能在单个块中分配内存 (也就是说，池分配器不能分配多个地址，同时还保持连续性)。因此，如果`n`不是`1` (也就是说，容器不是`std::list`或`std::map`)，我们将回退到`malloc()`/`free()`实现，这通常是默认实现:

```cpp
    pointer allocate(size_type n)
    {
        if (n != 1) {
            return static_cast<pointer>(malloc(sizeof(T) * n));
        }

        return static_cast<pointer>(m_pool->allocate());
    }

    void deallocate(pointer ptr, size_type n)
    {
        if (n != 1) {
            free(ptr);
        }

        m_pool->deallocate(ptr);
    }
```

其余的分配器是相同的:

```cpp
private:

    std::shared_ptr<pool> m_pool;

    template <typename T1, typename T2>
    friend bool operator==(const myallocator<T1> &lhs, const myallocator<T2> &rhs);

    template <typename T1, typename T2>
    friend bool operator!=(const myallocator<T1> &lhs, const myallocator<T2> &rhs);

    template <typename U>
    friend class myallocator;
};

template <typename T1, typename T2>
bool operator==(const myallocator<T1> &lhs, const myallocator<T2> &rhs)
{ return lhs.m_pool.get() == rhs.m_pool.get(); }

template <typename T1, typename T2>
bool operator!=(const myallocator<T1> &lhs, const myallocator<T2> &rhs)
{ return lhs.m_pool.get() != rhs.m_pool.get(); }
```

最后，在测试分配器之前，我们需要定义一个基准测试功能，该功能能够指示特定操作需要多长时间。该函数将在 Unix 中的[第 11 章](11.html)，*时间接口中进行更详细的定义。目前，要理解的最重要的是，该函数将回调函数作为输入 (在我们的例子中是 Lambda)，并返回一个数字。返回的数字越高，回调函数执行的时间越长:*

```cpp
template<typename FUNC>
auto benchmark(FUNC func) {
    auto stime = std::chrono::high_resolution_clock::now();
    func();
    auto etime = std::chrono::high_resolution_clock::now();

    return (etime - stime).count();
}
```

我们将执行的第一个测试是创建两个列表并将元素添加到每个列表中，同时计时将所有元素添加到列表中需要多长时间。由于对列表的每次添加都需要分配，因此执行此测试将使我们大致比较一下与 glibc 提供的默认分配器相比，分配器在分配内存方面有多好。

```cpp
constexpr const auto num = 100000;

std::list<int> mylist1;
std::list<int, myallocator<int>> mylist2;

auto time1 = benchmark([&]{
    for (auto i = 0; i < num; i++) {
        mylist1.emplace_back(42);
    }
});

auto time2 = benchmark([&]{
    for (auto i = 0; i < num; i++) {
        mylist2.emplace_back(42);
    }
});

std::cout << "[TEST] add many:\n";
std::cout << " - time1: " << time1 << '\n';
std::cout << " - time2: " << time2 << '\n';
```

如上所述，对于每个列表，我们将`100000`整数添加到列表中，并花费多长时间，从而使我们能够比较分配器。结果如下:

```cpp
0x7ffca71d7a00 constructor, sizeof(T): 24
[TEST] add many:
  - time1: 3921793
  - time2: 1787499
```

如图所示，我们的分配器在分配内存时比默认分配器快 219%。

在我们的下一个测试中，我们将比较我们的分配器与默认分配器在释放内存方面。要执行此测试，我们将执行与以前相同的操作，但是我们将计时从每个列表中删除元素所需的时间，而不是计时分配:

```cpp
constexpr const auto num = 100000;

std::list<int> mylist1;
std::list<int, myallocator<int>> mylist2;

for (auto i = 0; i < num; i++) {
    mylist1.emplace_back(42);
    mylist2.emplace_back(42);
}

auto time1 = benchmark([&]{
    for (auto i = 0; i < num; i++) {
        mylist1.pop_front();
    }
});

auto time2 = benchmark([&]{
    for (auto i = 0; i < num; i++) {
        mylist2.pop_front();
    }
});

std::cout << "[TEST] remove many:\n";
std::cout << " - time1: " << time1 << '\n';
std::cout << " - time2: " << time2 << '\n';
```

`this`函数的结果如下:

```cpp
0x7fff14709720 constructor, sizeof(T): 24
[TEST] remove many:
  - time1: 1046463
  - time2: 1285248
```

如图所示，我们的分配器仅 81% 默认分配器的速度。这可能是因为`free()`函数更有效，这并不令人惊讶，因为从理论上讲，推送到堆栈可能比`free()`的某些实现更慢。尽管我们的`free()`功能较慢，但与分配和分片方面的改进相比，差异可以忽略不计。同样重要的是要注意，此实现的分配和释放速度几乎相同，这是我们所期望的。

为了确保我们正确编写了分配器，下面将再次运行我们的测试，但是我们将添加列表中的每个值，而不是计时将元素添加到列表中需要多长时间。如果我们的总数符合我们的预期，我们将知道分配和解除分配是正确执行的:

```cpp
constexpr const auto num = 100000;

std::list<int, myallocator<int>> mylist;

for (auto i = 0; i < num; i++) {
    mylist.emplace_back(i);
}

uint64_t total1{};
uint64_t total2{};

for (auto i = 0; i < num; i++) {
    total1 += i;
    total2 += mylist.back();
    mylist.pop_back();
}

std::cout << "[TEST] verify: ";
if (total1 == total2) {
    std::cout << "success\n";
}
else {
    std::cout << "failure\n";
    std::cout << " - total1: " << total1 << '\n';
    std::cout << " - total2: " << total2 << '\n';
}
```

不出所料，我们测试的输出为`success`。

# 编译和测试

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter09/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter09/CMakeLists.txt)。

有了这段代码，我们可以使用以下内容编译这段代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter09/
> mkdir build
> cd build

> cmake -DCMAKE_BUILD_TYPE=Release ..
> make
```

要执行该示例，请运行以下命令:

```cpp
> ./example7
```

输出应类似于以下内容:

```cpp
0x7ffca71d7a00 constructor, sizeof(T): 24
[TEST] add many:
  - time1: 3921793
  - time2: 1787499
0x7fff14709720 constructor, sizeof(T): 24
[TEST] remove many:
  - time1: 1046463
  - time2: 1285248
0x7fff5d8ad040 constructor, sizeof(T): 24
[TEST] verify: success
===============================================================================
test cases: 5 | 5 passed
assertions: - none -
```

如您所见，我们示例的输出与我们之前提供的输出匹配。应该注意的是，您的结果可能非常基于诸如硬件或包装盒上已经运行的内容之类的因素。

# 摘要

在本章中，我们研究了如何创建自己的分配器，并涵盖了 C 分配器概念的复杂细节。主题包括相等分配器和不相等分配器之间的差异，如何处理容器传播，重新绑定以及有状态分配器的潜在问题。最后，我们用两个不同的例子来总结。第一个示例演示了如何创建一个简单的、缓存对齐的无状态分配器，而第二个示例提供了一个有状态对象分配器的功能示例，该分配器维护一个免费池以进行快速分配。

在下一章中，我们将使用几个示例来演示如何使用 C ++ 对 POSIX 套接字进行编程 (即网络编程)。

# 问题

1.  `is_always_equal`是什么意思？
2.  是什么决定了分配器是相等还是不相等？
3.  有状态的分配器可以相等吗？
4.  无国籍分配器可以相等吗？
5.  `propagate_on_container_copy_assignment`是做什么的？
6.  rebind 复制构造函数对容器做什么？
7.  关于传递给分配函数的`n`变量，`std::list`和`std::vector`有什么区别？

# 进一步阅读

*   [https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)
*   [https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)