# 系统编程入门

在本章中，我们将讨论什么是系统编程 (即对操作系统进行系统调用以代表您执行操作的行为)，并讨论系统编程和使用 C++ 进行系统编程的利弊。

在本章中，我们将回顾以下内容:

*   系统调用，包括它们是什么、如何执行它们以及与它们相关的潜在安全风险
*   系统编程时使用 C 的好处

# 技术要求

为了遵循本章中的示例，读者必须具有:

*   能够编译和执行 C 17 的基于 Linux 的系统 (例如，Ubuntu 17.10)
*   GCC 7
*   C 让 3.6
*   互联网连接

# 理解系统调用

操作系统是一种软件，旨在同时执行一个或多个应用，同时还提供这些应用执行所需的资源。为此，操作系统必须能够在系统上同时执行的所有应用之间划分硬件资源。

例如，大多数**个人计算机** (**PCs**) 都有一个硬盘，用于存储 PC 所有者正在使用的所有文件。在现代 pc 上，用户可能希望一次执行多个应用-例如，web 浏览器和 office 套件。

这两个应用在执行时将需要在不同时间对硬盘进行独占访问。对于 web 浏览器，这可能是将网站缓存到磁盘，而对于 office 套件，这可能是存储文档。

操作系统有责任管理应用及其对硬盘的访问，以确保 web 浏览器和 office 套件都能够正确执行。

为此，操作系统提供了一个应用编程接口 (**API**)，应用可以利用该接口来完成其任务。访问硬盘是这些任务之一的示例。`read()`和`write()`函数是兼容 POSIX 的操作系统提供的用于从文件描述符读取和写入数据的 api 的示例。

在后台，这些 api 使用一个叫做**系统调用**的应用二进制接口 (**ABI**) 对操作系统进行调用。为完成操作系统提供的任务而进行系统调用的行为称为**系统编程**，这是本书的主要内容。

# 系统调用的解剖

为了本节的目的，我们将把我们的示例集中在 Intel x86 架构上，尽管这些示例适用于大多数其他 CPU 架构。

最初的 x86 架构利用中断来提供系统调用 ABIs。操作系统提供的 api 将对 CPU 上的特定寄存器进行编程，并使用中断对操作系统进行调用。

例如，使用 BIOS，应用可以使用以下寄存器布局使用`int 0x13`从硬盘读取数据:

*   `AH = 2`]
*   `AL`: 要读取的扇区
*   �� T0 】 : Cylinder
*   `CL`: 扇区
*   `DH`: 头
*   `DL`: 驱动器
*   `ES:BX`: 缓冲区地址

应用作者将使用`read()`API 命令读取此数据，而在引擎盖下，`read()`将使用前面的 ABI 执行系统调用。当执行`int 0x13`时，应用将被硬件暂停，操作系统 (在本例中为 BIOS) 将代表应用执行以从磁盘读取数据并在应用提供的缓冲区中返回结果。

完成后，BIOS 将执行`iret` (中断返回) 以返回到应用，然后将从磁盘读取的数据等待其缓冲区使用。

通过这种方法，应用不需要知道如何与特定计算机上的硬盘物理接口来读取数据; 这是一个由操作系统及其设备驱动程序处理的任务。

应用不必担心可能正在执行的其他应用。它可以简单地利用提供的 API (或 ABI，取决于操作系统)，其余的血淋淋的细节由操作系统处理。

换句话说，系统调用提供了应用之间的清晰划分，以帮助用户完成特定任务，并帮助其工作是管理这些应用和它们所需的硬件资源的操作系统。

但是，中断很慢。硬件对操作系统是如何编写的，或者操作系统正在执行的应用是如何编写或组织的，不做任何假设。因此，interrupts 必须在执行中断处理程序之前保存 CPU 状态，并在执行`iret`命令时恢复此状态，导致性能不佳。

如将显示的那样，应用在尝试执行其工作时会进行大量的系统调用，而这种糟糕的性能成为 x86 体系结构 (以及其他 CPU 体系结构) 的瓶颈。

为了解决这个问题，现代版本的英特尔 x86 CPU 提供了*快速系统调用*指令。这些指令是专门为解决中断驱动的系统调用的性能瓶颈而设计的。但是，它们需要在 CPU，操作系统和在该操作系统上执行的应用之间进行协调，以减少开销。

具体来说，操作系统必须以特定的方式 (由 CPU 决定) 构建自身的内存布局以及运行的应用。通过预先定义操作系统及其相关应用的内存布局，CPU 在执行系统调用时不再需要保存和恢复那么多的 CPU 状态，从而减少了开销。完成此操作的方式取决于您是在 Intel 还是 AMD x86 CPU 上执行。

关于如何执行系统调用，最重要的一点是系统调用并不便宜。即使有快速的系统调用支持，系统调用也必须执行大量工作。在通过`read()`API 从硬盘读取数据的情况下，必须设置 CPU 寄存器状态并执行系统调用指令。CPU 控制被移交给操作系统，以从磁盘读取数据。

由于可能有多个应用正在执行，并且试图同时从磁盘读取数据，因此操作系统可能不得不暂停该应用，以便它可以为另一个应用提供服务。

一旦操作系统准备好为应用提供服务，它必须首先弄清楚应用正在尝试读取哪些数据，这最终决定了它需要使用哪个物理设备。在我们的示例中，这是一个硬盘，但是在符合 POSIX 的系统上，它可以是任何类型的块设备。

接下来，操作系统必须利用其设备驱动程序之一从该磁盘读取数据。这需要时间，因为操作系统必须通过硬件总线对硬盘进行物理编程，以从特定位置请求数据，而几乎可以肯定，硬件总线的执行速度与 CPU 本身的速度不同。

一旦硬盘最终向操作系统提供了请求的数据，操作系统就可以将这些信息提供回应用并返回控制，将 CPU 状态恢复到应用。所有这些精神错乱都被一次调用`read()`所掩盖。

因此，系统调用应谨慎执行，并且仅在绝对需要时执行，以防止生成的应用性能不佳。

应该注意的是，这种类型的优化需要对应用利用的 API 有深刻的了解，因为更高级别的 API 代表 API 进行自己的系统调用。例如，分配内存 (将在后面讨论) 是另一种类型的系统调用。

例如，查看使用`std::array{}`或`std::vector{}`命令的区别。`std::vector{}`支持在引擎盖下管理的阵列的大小调整，需要分配内存。这不仅会导致内存碎片 (这一主题将在本书后面讨论)，还会导致性能不佳，因为内存分配可能不得不要求操作系统提供更多的系统 RAM。

# 了解不同类型的系统调用

在符合 POSIX 的操作系统上执行的几乎每个应用都必须进行几个系统调用。在这里，我们概述了本书将探讨的一些系统调用类型。

# 控制台输入/输出

如果您曾经执行过命令行应用，那么您将熟悉基于控制台的输入/输出的概念。对于符合 POSIX 的操作系统尤其如此。输出到控制台时，可以输出到`stdout` (通常用于正常输出) 或`stderr` (通常用于输出错误消息)。

输出到`stdout`和`stderr`是通过执行系统的应用来完成的，该系统要求操作系统将字符缓冲区传递到这些输出设备。(需要注意的是，在本书中，我们通常声明我们是*输出到*`stdout`，而不是*打印到控制台*。)

这样做的原因是，在 POSIX 兼容的系统上，您的应用实际上并不知道将文本发送到哪里。应用利用 API 输出到`stdout`。这可以通过以下方式实现:

*   写入专用文件句柄 (即`stdout`)
*   使用 C api，如`printf`
*   使用 C api，如`std::cout`
*   为您分叉输出到`stdout`的应用 (例如，通过使用`echo`)

这些示例中的大多数，当所有内容都说完了之后，请对操作系统进行系统调用，以将字符缓冲区传输到管理`stdout`或`stderr`的设备。在某些情况下，这会导致操作系统将生成的字符缓冲区中继到父进程 (可能是您的 shell)，这最终会进行另一个系统调用以在屏幕上显示字符缓冲区。

但是，您的操作系统决定处理此问题，操作系统中存在一个设备驱动程序，该驱动程序管理用于显示文本的物理监视器，并且应用调用输出文本的简单 api (例如，`printf`和`std::cout`) 最终为该设备驱动程序提供了请求的字符缓冲区。

尽管在大多数系统上，通常将输出到`stdout`的文本提供给您的 shell 并最终显示在屏幕上，但事实并非如此。由于应用正在进行系统调用以输出字符缓冲区，因此操作系统可以自由地将此数据转发到串行设备，日志文件，作为输入到另一个应用，等等。

这种灵活性是兼容 POSIX 的操作系统如此强大的原因之一，也是学习如何正确进行系统调用如此重要的原因之一。

# 内存分配

内存是应用必须使用系统调用请求的另一个资源。大多数应用在首次执行应用时会被赋予全局和堆栈内存资源，同时还会在调用`malloc()`和`free()`等函数时应用可以使用的一小堆内存。

如果应用仅使用最初在此堆中给出的内存，则应用无需请求额外的内存。但是，如果堆内存用完，则应用的`malloc()`或`free()`引擎将不得不要求操作系统 (通过系统调用) 获取更多内存。

为此，操作系统将通过向应用添加更多物理内存来扩展应用的末尾。然后，`malloc()`或`free()`引擎能够利用这个额外的内存，直到需要更多。

在 RAM 有限的系统上，当请求附加内存时，操作系统必须从当前未执行的其他应用中获取内存。它通过将这些应用交换到磁盘来做到这一点，这是执行成本很高的操作。

因此，在资源受限的系统上，对`malloc()`或`free()`的调用不应在时间紧迫的代码中进行，因为执行这些函数所花费的时间可能会有很大差异。

我们将在[第 7 章](07.html)，*中进一步详细介绍内存管理*。

# 文件输入/输出

读取和写入文件是大多数需要进行系统调用的应用的另一个常见用例。

应该注意的是，在符合 POSIX 的系统上，对文件描述符的读写并不总是意味着对存储设备上的文件的读写。相反，系统调用您对*字符*或*块*设备进行写入。这可以是存储设备，但也可以是控制台设备，甚至是虚拟设备，如`/dev/random`，它在读取时提供随机数据。

在[第 8 章](08.html)，*学习编程文件输入/输出*中，我们将提供有关文件输入/输出系统编程的更多信息。

# 网络

网络是另一个需要进行系统调用的常见用例。在符合 POSIX 的系统上，我们通过使用 POSIX 套接字来执行基于网络的系统编程。套接字提供用于编程**网络接口控制器** (**NIC**) 的 API，并支持操作系统内的逻辑 (例如 TCP/IP 堆栈)。

网络本身是一个极其复杂的话题，值得拥有自己的书，但值得庆幸的是，执行这种类型的编程所需的系统调用很简单，大部分血腥细节都由操作系统处理。

在[第 10 章](10.html)，*使用 C*编程 POSIX 套接字，我们将进一步详细介绍如何使用 socket API 进行这些类型的系统调用。

# 时间

有些读者可能会惊讶地发现，即使执行诸如获取当前日期和时间之类的简单任务，也需要系统调用来询问操作系统以获取此信息。即使到今天，系统上仍提供专用芯片 (带有电池，以防断电)，以保持当前日期和时间。

如果需要此信息，则必须进行系统调用以请求它。当这种情况发生时，操作系统会询问负责管理芯片的设备驱动程序，它当前存储的日期和时间是什么，然后这些信息将返回给应用。

需要注意的是，并不是所有的时间接口都需要系统调用。例如，大多数高分辨率计时器 (旨在比较操作之前和之后的高分辨率数字) 不需要操作系统来执行此操作。这是因为这些高分辨率计时器通常直接存在于 CPU 中，并且可以使用简单的指令提取它们的值。

这些类型的计时器的缺点是它们本身的值通常是没有意义的 (也就是说，返回的值之间的差异是什么提供了意义，而不是值本身)。从本质上讲，这些计时器通常只不过是一个计数器，每次 CPU 滴答 (即执行一条指令) 时都会递增。

由于现代 CPU 可以动态更改其频率，因此这些计数器存储的值取决于自上一个电源周期以来 CPU 执行了多长时间，以及 CPU 在执行时设置的频率。

甚至不能保证一个计数器中的值与另一个物理核上另一个计数器中读取的值相同，因为每个物理核都能够独立于多核 cpu 上的其他核改变自己的频率。

高分辨率计时器的好处是它们可以非常快地执行 (因为您只是在执行读取 CPU 中的计数器的指令)。两个测量值之间的差异可用于执行任务，例如测量执行小功能所需的时间-该任务通常不适用于标准计时器，因为它们没有足够的粒度。

在 Unix 中的[第 11 章](11.html)，*时间接口中，我们将详细介绍这些细节，甚至提供一个如何自己执行此操作的示例。*

# 线程和流程创建

同时执行多个任务可以通过要求操作系统创建额外的线程 (甚至是新进程) 来完成。这是系统编程中的常见任务，并且有许多系统调用来完成工作。

进程是一个执行单元，其具有分配给它的一组资源 (例如，内存，文件描述符等)。每个应用至少由一个进程组成，但它们可以包含多个进程 (例如，shell 是专门设计用于运行多个子进程的应用)。

每个进程都由操作系统调度，以便在下一个进程访问 CPU 之前执行有限的时间，并且此循环根据需要继续。

线程就像进程，但它们与同一进程的其他线程共享相同的资源。线程为应用提供了创建能够并行执行的任务的机会，而不需要进程间通信方法。在[第 12 章](12.html)，*学习编程 POSIX 和 C 线程*中，我们将学习如何同时使用 POSIX 和 C api 编程线程。

# 系统调用安全风险

系统调用并非没有安全隐患。即使在现代硬件上，并且使用英特尔以外的 CPU 体系结构，在操作系统中执行多个进程且进程之间完全隔离几乎是不可能的。

尽管现代硬件和现代操作系统努力提供最佳的隔离和安全性，但应该始终假设与您一起执行的其他恶意进程可能能够监视您正在做的事情，包括敏感任务，例如解密用户数据。

这是另一个值得自己读书的话题，但是在这里，我们将简要讨论影响系统编程的两个不同的，最近的安全漏洞。

# SYSRET

英特尔和 AMD 提供的*快速系统调用*接口并非没有问题。如前所述，要使快速的系统调用正常工作，必须协调硬件，操作系统和应用。这是为了确保 ABI 信息得到正确处理，以允许操作系统执行系统调用，而不需要硬件在执行开始之前保存整个 CPU 状态。

当系统调用完成时，同样适用，并且必须将控制权交还给应用。为此，操作系统必须加载应用的堆栈，然后执行`SYSRET`指令，该指令将控制权返回给应用。

这种方法的问题是，一个**非屏蔽中断** (**NMI**) 可能在加载应用堆栈的操作系统和`SYSRET`的执行之间触发。这种竞争条件的结果是，NMI (以根权限执行的代码) 将使用应用的堆栈而不是内核的堆栈执行，从而导致可能的安全漏洞或损坏。

值得庆幸的是，现代操作系统有多种方法可以防止这种类型的攻击，大多数操作系统 (例如 Linux) 可以并且确实可以利用这种攻击。

# 崩溃和幽灵

Meltdown 和 Spectre 攻击是实现系统调用多么复杂的现代示例。为了支持系统调用的快速执行，使用称为 3:1 拆分的内存布局技术将内核的内存映射到每个应用中，该技术是指应用内存与内核内存的三比一。

为了防止应用读取/写入可能包含或可能不包含高度敏感信息 (例如加密密钥和密码) 的内核内存，现代 CPU 体系结构提供了一种机制来锁定该内存的内核部分，从而只有内核能够看到所有内容。该应用只能看到该内存的特权部分。

为了提高这些现代 cpu 的性能，包括英特尔、AMD 和 ARM 在内的大多数架构都采用了一种称为**推测性执行**的技术。例如，看看下面的代码:

```cpp
if (x) {
    do_y();
}

do_z();
```

CPU 在执行此指令之前，不知道`x`是真还是假。如果 CPU 假设`x`为真，它可以通过节省一些 CPU 周期来增强性能。实际上，如果`x`确实为 true，则 CPU 可以节省周期，而如果`x`实际上为 false，则通常值得冒险，特别是如果 CPU 可以对`x`为 true 而不是 false 的可能性做出有根据的猜测 (例如，如果 CPU 过去执行此语句并且`x`为真)。

这种类型的优化称为*推测性执行*。CPU 正在执行代码，即使可能以后代码可能无效并且需要撤消。

诸如 Meltdown 和 Spectre 之类的推测性执行攻击利用此过程来绕过保护应用及其内核之间的系统调用接口的内存保护。这是通过说服 CPU 推测地执行通常会导致安全违规的指令 (例如，尝试从内核内存读取密码) 来完成的。

如果 CPU 推测性地执行此类指令，则 CPU 将密码加载到 CPU 的缓存中与 CPU 确定发生了安全违规之间将存在间隙。如果 CPU 在此间隙期间中断 (使用所谓的瞬态指令)，则密码将留在 CPU 的缓存中，即使该指令从未实际完成其执行。

为了从缓存中恢复密码，攻击者会利用对 CPU 的其他攻击，称为**侧通道攻击**，这些攻击专门用于读取 CPU 缓存中的内容，而无需执行直接内存操作。

最终结果是，攻击者能够设置一组复杂的条件，最终允许他们恢复存储在内核中的敏感信息，只使用一个非特权应用 (这可能是您在寻找猫视频时碰巧点击的网站)。

如果这看起来很复杂，那是因为它是。这些类型的攻击极其复杂。这些示例的目的是简要概述为什么系统调用并非没有其问题。根据您要执行的 CPU 和操作系统，在系统编程时处理敏感信息时，可能需要特别小心。

# 系统编程时使用 C 的好处

尽管本书的重点是系统编程而不是 C，并且我们确实在 C 中提供了很多示例，但是与标准 C 相比，C 中的系统编程有几个好处。

请注意，本节假设了 C 的一些一般知识。关于 C 标准的更完整的解释将在[第 2 章](02.html)，*学习 C，C 17 和 POSIX 标准*中提供。

# C 型安全

标准 C 不是一种类型安全的语言。类型安全是指为防止一种类型与另一种类型混淆而设置的保护措施。某些语言 (例如 ADA) 非常安全，提供了许多保护，有时使用该语言可能会令人沮丧。

相反，诸如 C 之类的语言是如此的类型不安全，以至于难以找到的类型错误经常发生，并且经常导致不稳定。

C 提供了两种方法之间的折衷，默认情况下鼓励合理的类型安全性，同时提供了在需要时规避这种情况的机制。

例如，考虑以下代码:

```cpp
/* Example: C */
int *p = malloc(sizeof(int));

// Example: C++
auto p = new int;
```

在 C 中的堆上分配一个整数需要使用`malloc()`，它返回`void *`。这段代码有几个问题在 C 中解决:

*   C 自动将`void *`类型转换为`int *`，这意味着即使用户声明的类型与返回的类型之间没有连接，也发生了隐式类型转换。用户可以轻松地分配`short` (这与`int`不是一回事，我们将在[第 3 章](03.html)，*C 和 C*系统类型中讨论这个主题)。类型转换仍将被应用，这意味着编译器将没有适当的上下文来检测分配对于用户试图分配的类型来说不够大。
*   分配的大小必须由程序员说明。与 C 不同，C 对正在分配的类型没有理解。因此，它不知道类型的大小，因此程序员必须明确声明这一点。这种方法的问题在于，可以引入难以找到的分配错误。通常，提供给`sizeof()`的类型是不正确的 (例如，程序员可能会提供指针而不是类型本身，或者程序员可能会在以后更改代码，但忘记更改提供给`sizeof()`的值)。如前所述，`malloc()`分配和返回的内容与用户尝试分配的类型之间没有联系，从而提供了引入难以发现的逻辑错误的机会。
*   类型必须明确说明两次。`malloc()`返回`void *`，但 C 隐式转换为用户状态的任何指针类型-这意味着一个类型已被声明两次 (在本例中为`void *`和`int *`)。在 C 中，使用`auto`意味着只声明一次类型 (在这种情况下，`int`表示该类型是`int *`)，而`auto`将承担返回的任何类型。`auto`的使用和隐式类型转换的删除意味着在分配中声明的任何类型都是`p`变量将承担的。如果此分配后的代码期望与 `p` 不同的类型，则编译器将在 C 中编译时了解它，而像这样的错误可能直到运行时才会在 C 中捕获，当程序崩溃时 (我们希望这段代码不能控制飞机!)。

除了前面关于隐式类型铸造的危险的示例外，C 还提供了**运行时类型信息** (**RTTI**)。这些信息有很多用途，但最重要的用例涉及`dynamic_cast<>`运算符，它执行运行时类型检查。

具体来说，可以在运行时检查从一种类型转换为另一种类型，以确保不会发生类型错误。在执行以下操作时经常会看到这一点:

*   **多态类型转换**: 在 C 中，多态是可能的，但必须手动完成，这种模式在内核编程中经常看到。但是，C 无法确定是否为基本类型分配了指针，从而可能导致类型错误。相反，C 能够在运行时确定所提供的指针是否被强制转换为正确的类型，包括在使用多态时。
*   **异常支持**: 在捕获异常时，C 使用 RTTI (本质上是`dynamic_cast<>`)，以确保抛出的异常被正确的处理程序捕获。

# C 的对象

尽管 C 支持具有内置构造的面向对象编程，但面向对象编程是一种设计模式，在 C 中以及通常在 POSIX 中都经常使用。以以下示例为例:

```cpp
/* Example: C */

struct point 
{
    int x;
    int y;
};

void translate(point *p; int val)
{
    if (p == NULL) {
        return;
    }

    p->x += val;
    p->y += val;
}
```

在前面的示例中，我们有一个存储`point{}`的结构，其中包含`x`和`y`位置。然后，我们提供了一个函数，该函数能够使用给定值 (即对角线翻译) 在`x`和`y`位置上翻译这个`point{}`。

关于这个例子有几个注释:

*   通常，人们会声称不喜欢面向对象的编程，但是你会在他们的代码中看到这种东西，事实上，这是一种面向对象的设计。使用类并不是创建面向对象设计的唯一方法。与 C 的区别在于，该语言为干净安全地处理对象提供了额外的构造，而与 C 相同的功能必须手动完成-这是一个容易出错的过程。
*   `translate()`函数仅与`point{}`对象相关，因为它将`point{}`作为参数。结果，编译器没有上下文信息来理解如何操作`point{}`结构，而没有给`translate()`作为参数的指针。这意味着，每个希望操作`point{}`结构的面向公众的函数都必须将指向它的指针作为其第一个参数，并验证该指针是否有效。这不仅是一个笨重的界面，而且速度很慢。

在 C 中，前面的例子可以写成如下:

```cpp
// Example: C++

struct point 
{
    int x;
    int y;

    void translate(int val)
    {
        p->x += val;
        p->y += val;
    }
};
```

在这个例子中，仍然使用一个结构。类和 C 中的 struct 之间的唯一区别是，所有变量和函数默认情况下都是公共的，带有 struct，而默认情况下它们是私有的。

不同之处在于`translate()`函数是`point{}`的成员，这意味着它可以访问其结构的内容，因此不需要指针来执行翻译。结果，此代码更安全，更具确定性，并且更易于推理，因为永远不会担心 null 取消引用。

最后，C 中的对象提供了构造和销毁例程，这些例程有助于防止对象无法正确初始化或正确解构。以以下示例为例:

```cpp
// Example: C++

struct myfile 
{
    int fd{0};

    ~myfile() {
        close(fd);
    }
};
```

在前面的示例中，我们创建了一个自定义文件对象，该对象包含文件描述符，在使用 POSIX api 进行系统编程时经常看到并使用该文件描述符。

在 C 中，程序员必须记住在初始化时手动将文件描述符设置为`0`，并在文件描述符不再在作用域中时关闭它。在 C 中，使用前面的示例，当您使用`myfile`时，这两个操作都将为您完成。

这是一个使用**资源获取是初始化** (**RAII**) 的示例，这个主题将在[第 4 章](04.html)，*C，RAII，和 GSL 刷新*，因为这个模式被 C 大量使用。在系统编程时，我们将利用此技术来避免许多常见的 POSIX 风格的陷阱。

# C 中使用的模板

模板编程通常是对 C 的低估，被误解的补充，没有得到足够的重视。大多数程序员只需要尝试创建一个通用链表来了解原因就可以了。

C 模板为您提供了定义代码的能力，而不必提前定义类型信息。

在 C 中创建链表的一种方法是使用指针和动态内存分配，如这个简单的示例所示:

```cpp
struct node 
{
    void *data;
    node next;
};

void add_data(node *n, void *val);
```

在前面的示例中，我们使用`void *`将数据存储在链表中。如何使用的示例如下:

```cpp
node head;
add_data(&head, malloc(sizeof(int)));
*(int*)head.data = 42;
```

这种方法有几个问题:

*   这种类型的链表显然不是类型安全的。数据的使用和数据的分配是完全不相关的，要求程序员使用这个链表来管理所有这些都没有错误。
*   节点和数据都需要动态内存分配。如前所述，内存分配速度很慢，因为它们需要系统调用。
*   通常，此代码很难阅读且笨拙。

创建通用链表的另一种方法是使用宏。存在在因特网上浮动的这些类型的链表 (和其他数据结构) 的几种实现，它们提供链表的通用实现，而不需要动态分配数据。这些宏为用户提供了一种定义链表在编译时将管理的数据类型的方法。

除了可靠性之外，这些方法的问题在于，这些实现使用宏以一种远不那么优雅的方式来实现模板编程。换句话说，向 C 添加通用数据结构的解决方案是使用 C 的宏语言手动实现模板编程。程序员最好只使用 C 模板。

在 C 中，可以创建像链表这样的数据结构，而不必声明链表正在管理的类型，直到声明为止，如下所示:

```cpp
template<typename T>
class mylinked_list
{
    struct node 
    {
        T data;
        node *next;
    };

public:

    ...

private:

    node m_head;
};
```

在前面的示例中，我们不仅能够创建一个没有宏或动态分配的链接列表 (以及使用`void *`指针带来的所有问题)，而且我们还能够封装功能，提供更简洁的实现和用户 API。

关于模板编程的一个抱怨是它生成的代码数量。大多数来自模板的代码膨胀通常源于编程错误。例如，程序员可能没有意识到整数和无符号整数不是相同的类型，导致使用模板时代码膨胀 (因为创建了每种类型的定义)。

即使除了这个问题，使用宏也会产生相同的代码膨胀。没有免费的午餐。如果要避免使用动态分配和类型转换，同时仍提供通用算法，则必须为计划使用的每种类型创建算法实例。如果可靠性是您的目标，那么允许编译器生成确保程序正确执行所需的代码就超过了缺点。

# 与 C 相关的函数式编程

函数式编程是对 C 的另一种补充，它以 lambda 函数的形式为用户提供编译器帮助。目前，这必须在 C 中手工进行。

在 C 中，可以使用回调来实现函数式编程构造。例如，考虑以下代码:

```cpp
void
guard(void (*ptr)(int *val), int *val)
{
    lock();
    ptr(val);
    unlock();
}

void 
inc(int *val)
{
    *val++ ;
}

void 
dec(int *val)
{
    *val--;
}

void
foo() 
{
    int count = 0;
    guard(inc, &count);
    guard(dec, &count);
}
```

在前面的代码示例中，我们创建了一个`guard`函数，该函数锁定互斥锁，调用对值进行操作的函数，然后在退出时解锁互斥锁。然后，我们创建两个函数，一个递增给它的值，另一个递减给它的值。最后，我们创建一个实例化计数的函数，然后使用 guard 函数递增计数和递减计数。

这段代码有几个问题:

*   第一个问题是需要指针逻辑来确保我们可以操纵我们想要操作的变量。我们还需要手动传递此指针以跟踪它。这使得 api 变得笨拙，因为我们有很多额外的代码，我们必须为这样一个简单的示例手动编写。
*   辅助函数的函数签名是静态的。保护功能是一个简单的功能。它锁定一个互斥锁，调用一个函数，然后解锁它。问题在于，由于在编写代码时而不是在编译时必须知道函数的参数，因此我们无法将此函数用于其他任务。我们将需要为我们计划支持的每个函数签名类型手工编写相同的函数。

同样的例子可以用 C 写成如下:

```cpp
template<typename FUNC>
guard(FUNC f)
{
    lock();
    f();
    unlock();
}

void
foo() 
{
    int count = 0;
    guard(inc, [&]{ count++ });
    guard(inc, [&]{ count-- });
}
```

在前面的示例中，提供了相同的功能，但不需要指针。此外，保护功能是通用的，可以用于多种情况。这是通过利用模板编程和函数编程来实现的。

lambda 提供了回调，但是回调的参数被编码到 lambda 的函数签名中，通过使用模板函数来吸收。编译器能够生成用于使用的保护函数的版本，该版本采用参数 (在本例中，引用`count`变量) 并将其存储在代码中，从而消除了用户手动执行此操作的需要。

在本书中，前面的示例将被大量使用，尤其是在创建基准测试示例时，因为此模式使您能够将功能包装在旨在为回调执行计时的代码中。

# C++ 中的错误处理机制

错误处理是 C++ 的另一个问题。至少在添加 set 跳转异常之前，问题是从函数中获取错误代码的唯一方法如下:

*   约束函数的输出，因此可以将函数的某些输出值视为错误
*   获取函数以返回一个结构，然后手动解析该结构

例如，考虑以下代码:

```cpp
struct myoutput 
{
    int val;
    int error_code;
}

struct myoutput myfunc(int val)
{
    struct myoutput = {0};

    if (val == 42) {
        myoutput.error_code = -1;
    }

    myoutput.val = val;
    return myoutput;
}

void 
foo(void)
{
    struct myoutput = myfunc(42);

    if (myoutput.error_code == -1) {
        printf("yikes\n");
        return;
    }
}
```

前面的示例提供了一种简单的机制，用于从函数输出错误，而不必约束函数的输出 (例如，通过假设`-1`始终是错误)。

在 C++ 中，这可以使用以下 C++ 17 逻辑来实现:

```cpp
std::pair<int, int>
myfunc(int val)
{
    if (val == 42) {
        return {0, -1};
    }

    return {val, 0};
}

void 
foo(void)
{
    if (auto [val, error_code] = myfunc(42); error_code == -1) {
        printf("yikes\n");
        return;
    }
}
```

在前面的示例中，我们能够通过利用`std::pair{}`来消除对专用结构的需求，并且我们能够通过利用`initializer_list{}`和 C 17 结构的绑定来消除使用`std::pair{}`的需求。

但是，有一种更简单的方法来处理错误，而无需检查您执行的每个函数的输出，那就是使用异常。C 通过 set jump API 提供异常，而 C 提供 C 异常支持。这两者将在[第 13 章](13.html)，*错误处理与异常*中详细讨论。

# C 中的 api 和 C 容器

除了 C 提供的语言原语外，它还带有一个**标准模板库** (**STL**) 和相关的 api，这些 api 极大地帮助了系统编程。本书的很大一部分将重点介绍这些 api，以及它们如何支持系统编程。

需要注意的是，本书的重点是系统编程而不是 C，为此，我们不详细介绍 C 容器，而是假设读者对它们是什么以及它们是如何工作的一些一般知识。话虽如此，C 容器通过防止用户不得不手动重写它们来支持系统编程。

我们教学生如何编写自己的数据结构，不是这样，当他们需要一个数据结构时，他们知道如何编写一个数据结构，而是这样，当他们需要一个数据结构时，他们知道使用哪个数据结构以及为什么使用。C 已经提供了系统编程时可能需要的大部分 (如果不是全部) 数据结构。

# 摘要

在本章中，我们学习了什么是系统编程。我们介绍了系统调用的一般解剖，不同类型的系统调用，以及最近系统调用的一些安全问题。

此外，我们涵盖了使用 C 进行系统编程而不是严格使用标准 C 的优点。在下一章中，我们将详细介绍 C、C 和 POSIX 标准，以及它们与系统编程的关系。

# 问题

1.  什么是系统编程？
2.  在*快速系统调用*之前，系统调用是如何执行的？
3.  为了支持*快速系统调用*做了什么关键更改？
4.  分配内存是否总是导致系统调用？
5.  崩溃和幽灵攻击利用哪种类型的执行？
6.  什么是类型安全？
7.  为 C++ 中的模板编程提供至少一个好处？

# 进一步阅读

*   [https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)
*   [https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)