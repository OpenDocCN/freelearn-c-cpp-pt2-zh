# 使用 C 编程 POSIX 套接字

在本章中，您将学习如何使用 C 17 编程 POSIX 套接字，包括更常见的 C 范例，例如**资源获取是初始化** (**RAII**)。首先，本章将讨论什么是套接字，以及 UDP 和 TCP 之间的区别。在引导您通过五个不同的示例之前，将详细解释 POSIX api。第一个示例将通过创建 UDP echo server 示例来逐步使用 POSIX 套接字进行编程。第二个示例将使用 TCP 而不是 UDP 创建相同的示例，并解释差异。第三个示例将扩展我们在前面的章节中创建的现有调试记录器，而第四和第五个示例将解释如何安全地处理数据包。

在本章中，我们将介绍以下主题:

*   POSIX 插座
*   利用 C 和 RAII 与套接字
*   TCP vs UDP

# 技术要求

为了编译和执行本章中的示例，读者必须具有以下内容:

*   能够编译和执行 C 17 的基于 Linux 的系统 (例如，Ubuntu 17.10)
*   GCC 7
*   C 让 3.6
*   互联网连接

要下载本章中的所有代码，包括示例和代码片段，请参见以下链接: [https://github.com/PacktPublishing/ 动手系统编程与 CPP/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter10)。

# 从 POSIX 套接字开始

不幸的是，C 不包含本机网络库 (希望可以用 C 20 解决)。因此，需要 POSIX 套接字来执行与 C 的联网。POSIX sockets API 定义了一个 API，用于使用标准的 Unix 文件描述符范例发送和接收网络数据包。使用套接字编程时，必须同时创建服务器和客户端。服务器负责将特定端口绑定到套接字库的用户正在开发的套接字协议。客户端是连接到先前绑定的端口的任何其他应用程序。服务器和客户端都有自己的 ip 地址。

在对套接字进行编程时，除了选择地址类型 (例如 IPv4 与 IPv6) 之外，程序员通常还必须在 UDP 与 TCP 之间进行选择。UDP 是一种无连接协议，它不能保证可靠地发送数据包，其优点是速度和简单性。UDP 通常用于不必 100% 接收的数据，例如您在视频游戏中的位置。另一方面，TCP 是一种基于连接的协议，可确保按发送顺序接收所有数据包，并且是用于其可靠性的典型协议。

# 从 api 开始

以下各节将详细解释不同的 socket api。

# 套接字 () API

所有 POSIX 套接字编程都从使用`socket()`API 创建套接字文件描述符开始，该文件描述符采用以下形式:

```cpp
int socket(int domain, int type, int protocol);
```

域定义创建套接字时使用的地址类型。在大多数情况下，对于 IPv4，这将是`AF_INET`，对于 ipv6，这将是`AF_INET6`。在本章的示例中，我们将使用`AF_INET.`类型字段通常在 TCP 连接中采用`SOCK_STREAM`，在 UDP 连接中采用`SOCK_DGRAM`，这两个字段将在本章中进行演示。最后，在我们的所有示例中，此 API 中的协议字段将设置为`0`，告诉 API 对于指定的套接字类型使用默认协议。

完成此 API 后，将返回一个套接字文件描述符，其余 POSIX API 将需要该描述符。如果该 API 失败，则返回`-1`，并将`errno`设置为相应的错误码。需要注意的是，`errno`不是线程安全的，使用时应小心处理。处理这些类型的错误的一种好方法是立即将`errno`转换为 C 异常，可以使用以下方法来完成:

```cpp
if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {
    throw std::runtime_error(strerror(errno));
}
```

在前面的示例中，创建了一个 IPv4 TCP 套接字。生成的文件描述符保存到内存变量`m_fd`中。使用 C++ 17 语法，检查文件描述符的有效性，如果报错 (即`-1`)，则引发异常。为了提供错误的人类可读版本，使用`strerror()`将`errno`转换为字符串。这不仅提供了`errno`的字符串版本，还确保了记录错误的过程不会在过程中改变`errno`，如果使用更复杂的方法，可能会发生这种情况。

最后，当不再需要套接字时，应该像使用 POSIX`close()`函数的任何其他文件描述符一样将其关闭。应该注意的是，大多数 POSIX 操作系统会自动关闭应用程序关闭时仍处于打开状态的套接字。

为了防止可能的描述符泄漏，套接字文件描述符可以封装在一个类中，如下所示:

```cpp
class mytcpsocket
{
public:
    explicit mytcpsocket(uint16_t port)
    {
        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {
            throw std::runtime_error(strerror(errno));
        }
    }

    ~mytcpsocket()
    {
        close(m_fd);
    }

    auto descriptor() const
    { return m_fd; }

private:

    int m_fd{};
};
```

在前面的示例中，我们使用先前示例中的逻辑打开 IPv4 TCP 套接字，以确保检测到任何错误并正确报告。不同之处在于，我们将文件描述符存储为成员变量，并且当`mytcpsocket{}`失去作用域时，我们会自动确保文件描述符已正确释放回操作系统。任何时候需要文件描述符，都可以使用`descriptor()`访问器。

# bind() 和 connect() api

创建套接字文件描述符后，必须绑定或连接套接字，具体取决于套接字是在创建连接 (服务器) 还是在连接到现有的绑定套接字 (客户端)。通过 TCP 或 UDP 进行通信时，绑定套接字会为套接字指定一个端口。端口`0`-`1024`是为特定服务保留的，通常由操作系统管理 (需要特殊权限才能绑定)。其余端口是用户定义的，通常可以在没有特权的情况下绑定。确定使用哪个端口取决于实现。某些端口是针对特定应用程序预先确定的，或者该应用程序可以要求操作系统使用开放端口，这增加了将此新分配的端口传达给潜在客户端应用程序的复杂性。

`bind()`API 采用以下形式:

```cpp
int bind(int socket, const struct sockaddr *address, socklen_t address_len);
```

`socket`integer 参数是之前由`socket()`API 提供的 socket 文件描述符。`address`参数告诉操作系统绑定到哪个端口，以及接受来自哪个 IP 的传入连接，通常`INADDR_ANY`告诉操作系统可以从任何 IP 地址接受传入连接。最后，`address_len`参数告诉 API 地址结构的总大小是多少。

地址结构需要总大小 (以字节为单位)，因为根据您使用的套接字类型，支持不同的结构。例如，与 IPv4 套接字相比，IPv6 套接字具有更大的 ip 地址。在本章中，我们将讨论使用`sockaddr_in{}`结构的 IPv4，它定义了以下字段:

*   `sin_family`: 这与套接字域相同，在 IPv4 的情况下，套接字域为`AF_INET`。
*   `sin_port`: 这定义了要绑定到的端口，必须使用`htons()`将其转换为网络字节顺序。
*   `sin_address`: 这定义了要接受来自的传入连接的 ip 地址，也必须使用`htonl()`将其转换为网络字节顺序。通常，这被设置为`htonl(INADDR_ANY)`，表示从任何 ip 地址接受连接。

由于地址结构在长度上是可变的，所以`bind()`API 使用指向不透明结构类型的指针，并使用 length 字段来确保提供了正确的信息。应该注意的是，C 核心指南不鼓励这种类型的 API，因为没有类型安全的方法来实现此 API。实际上，为了使用此 API，需要`reinterpret_cast()`将`sockaddr_in{}`转换为不透明的`sockaddr{}`结构。尽管 C 核心指南不支持`reinterpret_cast()`的使用，但没有其他选择，因此，如果需要套接字，则必须打破此规则。

当服务器使用`bind()`为套接字专用端口时，客户端使用`connect()`连接到已绑定的端口。`connect()`API 的形式如下:

```cpp
int connect(int socket, const struct sockaddr *address, socklen_t address_len);
```

需要注意的是，`connect()`的参数与`bind()`相同。像`bind()`一样，您必须提供调用`socket()`返回的文件描述符，像`bind()`一样，在 IPv4 的情况下，您必须提供指向`sockaddr_in{}`结构的指针以及`sockaddr_in{}`结构的大小。填写`sockaddr_in{}`结构时，您将使用以下内容:

*   `sin_family`: 这与套接字域相同，在 IPv4 的情况下，套接字域为`AF_INET`。
*   `sin_port`: 这定义了要连接的端口，必须使用`htons()`将其转换为网络字节顺序。
*   `sin_address`: 这定义了要连接到的 ip 地址，也必须使用`htonl()`转换为网络字节顺序。对于环回连接，这将被设置为`htonl(INADDR_LOOPBACK)`。

最后，`bind()`和`connect()`都在成功时返回`0`，或者在失败时返回`-1`，在出现错误时设置`errno`。

# listen() 和 accept() api

对于 TCP 服务器，存在两个额外的 api，它们为服务器提供了一种侦听和接受传入 TCP 连接的方法-`listen()`和`accept()`。

`listen()`API 具有以下形式:

```cpp
int listen(int socket, int backlog); 
```

socket 参数是由`socket()`API 返回的文件描述符，而 backlog 参数限制了可能建立的未完成连接的总数。在本章的示例中，我们将使用`0`的 backlog，它告诉 API 对 backlog 使用特定于实现的值。

如果`listen()`成功，则返回`0`，否则返回`-1`，并将`errno`设置为相应的错误码。

一旦您的应用程序被设置为侦听传入的连接，一旦连接准备就绪，就可以使用`accept()`API 接受连接。`accept()`API 的形式如下:

```cpp
int accept(int socket, struct sockaddr *address, socklen_t *address_len);
```

与其他 API 一样，`socket`参数是`socket()`API 返回的文件描述符和地址，`address_len`参数返回连接信息。如果不需要连接信息，也可以为地址和 `address_len` 提供`nullptr`。成功完成`accept()`API 后，将返回客户端连接的套接字文件描述符，该文件描述符可用于向客户端发送和从客户端接收数据。

如果 accept 执行失败，则返回`-1`，而不是返回有效的套接字文件描述符，并适当设置`errno`。

需要注意的是，只有 TCP 连接才需要`listen()`和`accept()`。通过 TCP 连接，服务器创建两个或多个套接字描述符; 第一个用于绑定到端口并监听连接，而第二个是客户端的套接字文件描述符，用于发送和接收数据。另一方面，UDP 是无连接协议，因此用于绑定到端口的同一套接字也用于与客户端发送和接收数据。

# send() 、recv() 、sendto() 和 recv() api

为了在打开 socket 后将信息发送到服务器或客户端，POSIX 提供了`send()`和`sendto()`api。`send()`API 的形式如下:

```cpp
ssize_t send(int socket, const void *buffer, size_t length, int flags);
```

第一个参数是您希望向其发送数据的服务器或客户端的套接字文件描述符。应该注意的是，套接字必须连接到特定的客户端或服务器才能工作 (例如与服务器通信，或与使用 TCP 打开的客户端通信)。`buffer`参数指向您希望发送的缓冲区，`length`定义了您希望发送的缓冲区的长度，`flags`为您希望发送缓冲区的方式提供了各种不同的设置，大多数情况下只是设置为`0`。还需要注意的是，当`flags`设置为`0`时，`write()`函数和`send()`函数通常没有区别，两者都可以使用。

如果服务器试图使用 UDP 与客户端通信，服务器将不知道谁或如何向客户端发送信息，因为服务器绑定到特定端口，而不是特定客户端。同样，如果使用 UDP 的客户端没有连接到特定的服务器，它将不知道谁或如何向服务器发送信息。因此，POSIX 提供了`sendto()`，它添加了`sockaddr{}`结构来定义您希望发送缓冲区的人以及如何发送缓冲区。`sendto()`具有以下形式:

```cpp
ssize_t sendto(int socket, const void *buffer, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);
```

`send()`和`sendto()`之间的唯一区别是`sendto()`还提供了目标`address`和`len`参数，这些参数为用户提供了一种定义缓冲区发送到谁的方法。

为了从客户端或服务器接收数据，POSIX 提供了`recv()`API，其形式如下:

```cpp
ssize_t recv(int socket, void *buffer, size_t length, int flags);
```

`recv()`API 采用与`send()`API 相同的参数，不同之处在于当接收到数据时，缓冲区将被写入 (这就是为什么它没有被标记为`const`)，长度字段描述缓冲区的总大小，而不是接收到的字节总数。

同样，POSIX 提供了一个`recvfrom()`API，它类似于`sendto()`API，具有以下形式:

```cpp
ssize_t recvfrom(int socket, void *restrict buffer, size_t length, int flags, struct sockaddr *restrict address, socklen_t *restrict address_len);
```

`send()`和`sendto()`函数都返回发送的字节总数，`recv()`和`recvfrom()`函数返回接收的字节总数。所有这些函数都返回`-1`，并在出现错误时将`errno`设置为适当的值。

# 在 UDP echo 服务器上的示例研究

在此示例中，我们将引导您使用 UDP 进行简单的 echo server 示例。回声服务器 (与我们之前的章节相同) 将任何输入回声到其输出。在此 UDP 示例的情况下，服务器将从客户端发送给它的数据回回到客户端。为了使示例简单，将回显字符缓冲区。如何正确处理结构化数据包将在以下示例中介绍。

# 服务器

首先，我们必须定义我们计划从客户端发送到服务器并返回的最大缓冲区大小，我们还必须定义我们希望使用的端口:

```cpp
#define PORT 22000
#define MAX_SIZE 0x10
```

应该注意的是，只要端口号高于`1024`，任何端口号都会这样做，以防止需要特权。在此示例中，服务器需要以下内容:

```cpp
#include <array>
#include <iostream>
#include <stdexcept>

#include <unistd.h>
#include <string.h>

#include <sys/socket.h>
#include <netinet/in.h>
```

将使用类来定义服务器，以利用 RAII，提供一种干净的方法，用于在不再需要服务器时关闭服务器打开的套接字。我们还定义了三个私有成员变量。第一个变量将存储服务器将在整个示例中使用的套接字文件描述符。第二个变量存储服务器的地址信息，该地址信息将提供给`bind()`函数，而第三个参数则存储客户端的地址信息，该地址信息将由`recvfrom()`和`sendto()`函数使用:

```cpp
class myserver
{
    int m_fd{};
    struct sockaddr_in m_addr{};
    struct sockaddr_in m_client{};

public:
```

服务器的构造函数将打开套接字，并将提供的端口绑定到套接字，如下所示:

```cpp
    explicit myserver(uint16_t port)
    {
        if (m_fd = ::socket(AF_INET, SOCK_DGRAM, 0); m_fd == -1) {
            throw std::runtime_error(strerror(errno));
        }

        m_addr.sin_family = AF_INET;
        m_addr.sin_port = htons(port);
        m_addr.sin_addr.s_addr = htonl(INADDR_ANY);

        if (this->bind() == -1) {
            throw std::runtime_error(strerror(errno));
        }
    }
```

使用`AF_INET`打开 socket，它告诉 socket API 需要 IPv4。另外，提供了`SOCK_DGRAM`，它告诉 socket API 需要 UDP 而不是 TCP。调用`::socket()`的结果保存到`m_fd`变量中，该变量存储服务器套接字文件描述符。利用 C 17，如果结果文件描述符为`-1`，则发生错误，我们抛出错误，该错误将在以后恢复。

接下来，我们填写一个`sockaddr_in{}`结构:

*   `sin_family`设置为`AF_INET`以匹配套接字，告诉我们希望使用 ipv4 的套接字 API。
*   `sin_port`设置为端口号，`htons`用于将主机字节顺序短转换为网络字节顺序。
*   `sin_addr`设置为`INADDR_ANY`，它告诉 socket API 服务器将接受来自任何客户端的数据。由于 UDP 是无连接协议，这意味着如果需要，我们可以从任何客户端接收数据。

最后，调用一个成员函数，称为`bind()`，并检查结果是否有错误。如果发生错误，则会引发异常。

bind 函数只不过是围绕`::bind()`套接字 API 的包装，如下所示:

```cpp
    int bind()
    {
        return ::bind(
            m_fd,
            reinterpret_cast<struct sockaddr *>(&m_addr),
            sizeof(m_addr)
        );
    }
```

在前面的代码片段中，我们用在我们的服务器类的构造函数中打开的套接字文件描述符调用`bind`，并且我们为`bind`API 提供了在调用该函数之前也在构造函数中初始化的端口和地址，它告诉套接字绑定到端口`22000`和任何 ip 地址。

一旦套接字被绑定，服务器就可以从客户端接收数据了。由于我们将套接字绑定到任何 ip 地址，因此任何客户端都可以向我们发送信息。我们可以使用`recv()`POSIX API，但是这种方法的问题是，一旦我们收到数据，我们将不知道是谁向我们发送了信息。如果我们不需要向该客户端发送任何信息作为回报，或者我们在接收到的数据中嵌入客户端信息，但是在简单的 echo 服务器的情况下，我们需要知道向谁回显数据。为了解决这个问题，我们用`recvfrom()`代替`recv()`，如下所示:

```cpp
   ssize_t recv(std::array<char, MAX_SIZE> &buf)
   {
        socklen_t client_len = sizeof(m_client);

        return ::recvfrom(
            m_fd,
            buf.data(),
            buf.size(),
            0,
            (struct sockaddr *) &m_client,
            &client_len
        );
    }
```

第一个参数是在构造过程中创建的套接字文件描述符，而第二个和第三个参数是缓冲区及其最大大小。请注意，我们的`recv()`成员函数采用`std::array`而不是指针和大小，因为指针和大小参数将不符合 C -Core，因为这样做提供了在报告数组的实际大小时出错的机会。最后两个参数是指向`sockaddr_in{}`结构及其大小的指针。

应该注意的是，在我们的示例中，我们提供了具有`sockaddr_in{}`结构的`recvfrom()`，因为我们知道将要连接的客户端将使用 IPv4 地址。如果不是这种情况，`recvfrom()`函数将失败，因为我们将为它提供一个太小的结构，如果使用它，不能提供 IPv6 地址。为了克服这个问题，您可以使用`sockaddr_storage{}`而不是`sockaddr_in{}`。`sockaddr_storage{}`结构足够大，可以存储传入地址类型。要确定您收到的地址类型，可以使用`sin_family`字段，这是所有结构中必需的。

最后，我们将调用的结果返回到`recvfrom()`，它可以是接收到的字节数，或者在出现错误时返回`-1`。

要向连接到 UDP 服务器的客户端发送缓冲区，我们使用`sendto()`API，如下所示:

```cpp
    ssize_t send(std::array<char, MAX_SIZE> &buf, ssize_t len)
    {
        if (len >= buf.size()) {
            throw std::out_of_range("len >= buf.size()");
        }

        return ::sendto(
            m_fd,
            buf.data(),
            buf.size(),
            0,
            (struct sockaddr *) &m_client,
            sizeof(m_client)
        );
    }
```

与其他 api 一样，第一个参数是在构造函数中打开的套接字文件描述符。然后提供缓冲区。在这种情况下，`recvrom()`和`sendto()`之间的区别在于提供了要发送的字节数，而不是缓冲区的总大小。这不会破坏 C 核心指导，因为缓冲区的总大小仍然附加到缓冲区本身，而是要发送的字节数是第二个值，用于确定我们计划解决的数组的距离。但是，我们确实需要确保长度字段不超出范围。这可以通过调用`Expects()`来完成，如下所示:

```cpp
Expects(len < buf.size())
```

在本例的情况下，我们显式检查是否存在超出范围的错误，如果发生这种情况，则抛出更详细的错误。两种方法都有效。

与`recvfrom()`调用一样，我们为`sendto()`API 提供了指向`sockaddr_in{}`结构的指针，该结构告诉套接字向哪个客户端发送数据。在这种情况下，由于 API 不修改地址结构 (因此结构不能改变大小)，因此不需要指向 length 字段的指针。

下一步是将所有这些放在一起以创建 echo server 本身，如下所示:

```cpp
    void echo()
    {
        while(true)
        {
            std::array<char, MAX_SIZE> buf{};

            if (auto len = recv(buf); len != 0) {
                send(buf, len);
            }
            else {
                break;
            }
        }
    }
```

echo 服务器旨在从客户端接收数据缓冲区，将其发送回同一客户端，然后重复。首先，我们创建了一个无限循环，能够从任何客户端回响数据，直到我们被告知客户端已断开连接。下一步是定义一个缓冲区，该缓冲区将用于向客户端发送和接收数据。然后，我们调用`recv()`成员函数，并为其提供缓冲区，我们希望接收函数用来自客户端的数据填充，并检查从客户端返回的字节数是否大于`0`。如果从客户端返回的字节数大于`0`，我们使用`send`成员函数将缓冲区发送 (或回显) 回客户端。如果字节数是`0`，我们假设客户端因此断开连接，我们停止无限循环，这反过来又完成了回声过程。

客户端信息结构 (即`m_client`) 提供给`recvfrom()`和`sendto()`POSIX api。这是故意的。我们唯一的假设是所有连接的客户端都将使用 ipv4。当从客户接收到数据时，`recvfrom()`函数将为我们填写`m_client`结构，告诉我们向我们发送信息的客户是谁。然后，我们将相同的结构提供给`sendto()`函数，以告诉 API 将数据回显给谁。

如前所述，当服务器类被销毁时，我们关闭套接字，如下所示:

```cpp
    ~myserver()
    {
        close(m_fd);
    }
```

最后，我们通过在`protected_main()`函数中实例化服务器来完成服务器，然后开始回显:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myserver server{PORT};
    server.echo();

    return EXIT_SUCCESS;
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

如图所示，`main`函数被保护免受可能的异常，在`protected_main()`函数中，我们实例化服务器并调用其`echo()`成员函数，该函数启动用于回显客户端数据的无限循环。

# 客户端逻辑

在此示例中，客户端需要以下包含:

```cpp
#include <array>
#include <string>
#include <iostream>
#include <stdexcept>

#include <unistd.h>
#include <string.h>

#include <sys/socket.h>
#include <netinet/in.h>
```

像服务器一样，使用类创建客户端以利用 RAII:

```cpp
class myclient
{
    int m_fd{};
    struct sockaddr_in m_addr{};

public:
```

除了类定义之外，还定义了两个私有成员变量。第一个，像服务器一样，是将由客户端使用的套接字文件描述符。第二个定义了客户端希望与之通信的服务器的地址信息。

客户端的构造函数与服务器的相似，有一些细微的差别:

```cpp
    explicit myclient(uint16_t port)
    {
        if (m_fd = ::socket(AF_INET, SOCK_DGRAM, 0); m_fd == -1) {
            throw std::runtime_error(strerror(errno));
        }

        m_addr.sin_family = AF_INET;
        m_addr.sin_port = htons(port);
        m_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

        if (connect() == -1) {
            throw std::runtime_error(strerror(errno));
        }
    }
```

像服务器一样，客户端通过`AF_INET`为 IPv4 创建一个套接字文件描述符，协议类型通过`SOCK_DGRAM`设置为 UDP。如果 API 返回错误，则会引发异常。设置的`sockaddr_in{}`结构与服务器不同。服务器的`sockaddr_in{}`结构定义了服务器将如何绑定套接字，而客户端`sockaddr_in{}`结构定义了客户端将连接到什么服务器。在本例中，我们将地址设置为`INADDR_LOOPBACK`，因为服务器将在同一台计算机上运行。最后，调用`connect()`成员函数，该函数连接到服务器，如果发生错误，则引发异常。

要连接到服务器，请使用以下`connect()`成员函数:

```cpp
    int connect()
    {
        return ::connect(
            m_fd,
            reinterpret_cast<struct sockaddr *>(&m_addr),
            sizeof(m_addr)
        );
    }
```

应该注意的是，使用 UDP 连接到服务器是可选的，因为 UDP 是无连接协议。在这种情况下，`connect`函数告诉操作系统您计划与哪个服务器通信，以便可以使用`send()`和`recv()`，而不是客户端上的`sendto()`和`recvfrom()`。与服务器的`bind()`成员函数一样，`connect()`函数利用构造函数填充的`sockaddr_in{}`结构。

要将数据发送到要回显的服务器，请使用以下`send()`成员变量:

```cpp
    ssize_t send(const std::string &buf)
    {
        return ::send(
            m_fd,
            buf.data(),
            buf.size(),
            0
        );
    }
```

由于我们计划向服务器发送一个字符串，因此我们将`send()`成员函数传递一个字符串引用。然后，`send()` POSIX API 被赋予在构造函数中创建的套接字文件描述符、要发送到要回显的服务器的缓冲区以及要发送的缓冲区的总长度。由于我们不使用`flags`字段，所以也可以使用`write()`函数编写`send()`成员函数，如下所示:

```cpp
    ssize_t send(const std::string &buf)
    {
        return ::write(
            m_fd,
            buf.data(),
            buf.size()
        );
    }
```

要在响应后从服务器接收数据，我们使用以下`recv()`成员函数:

```cpp
    ssize_t recv(std::array<char, MAX_SIZE> &buf)
    {
        return ::recv(
            m_fd,
            buf.data(),
            buf.size() - 1,
            0
        );
    }
```

实现`recv()`成员函数的方法有很多。因为我们知道发送到服务器的字符串的总大小，并且我们知道服务器将回显相同大小的字符串给我们，所以我们总是可以创建与第一个相同大小的第二个字符串 (或者简单地重用原始字符串，如果您信任 echo 实际上正在发生)。在本例的情况下，我们创建一个具有特定最大大小的接收缓冲区，以演示更可能的情况。因此，在这个例子中，我们可以发送我们想要的任何大小的字符串，但是服务器有它自己的内部最大缓冲区大小，它可以接受。然后，服务器将把数据回显给客户端。客户端本身具有其自己的最大大小的接收缓冲区，这最终限制了可能被回显的字节总数。由于客户端正在回显字符串，因此我们必须为尾随`'\0'`保留一个字节，以 null 终止客户端接收到的填充整个接收缓冲区的任何字符串。

为了向服务器发送和从服务器接收数据，我们创建了一个`echo`函数，如下所示:

```cpp
    void echo()
    {
        while(true) {
            std::string sendbuf{};
            std::array<char, MAX_SIZE> recvbuf{};

            std::cin >> sendbuf;
            if (sendbuf == "exit") {
                send({});
                break;
            }

            send(sendbuf);
            recv(recvbuf);

            std::cout << recvbuf.data() << '\n';
        }
    }
```

`echo`函数与服务器一样，首先创建一个无限循环，以便它可以向服务器发送多个字符串以进行回显。在无限循环内部，创建了两个缓冲区。第一个是将接受用户输入的字符串。第二个定义了要使用的接收缓冲区。定义缓冲区后，我们使用`std::cin`从用户那里获取要发送到服务器的字符串 (最终将被回显)。

如果字符串是单词`exit`，我们将 0 个字节发送到服务器并退出无限循环。由于 UDP 是无连接协议，因此服务器无法知道客户端是否已断开连接，因为不存在此类构造。因此，如果不发送信号到服务器停止 (在这种情况下，我们发送 0 字节)，服务器将停留在无限循环，因为它没有办法知道何时停止。在这个例子中，这带来了一个有趣的问题，因为如果客户端崩溃或被杀死 (例如，使用*Ctrl**C*)，服务器将永远不会得到 0 字节的信号，从而保持无限循环。有很多方法可以解决这个问题 (也就是说，通过发送一个保持活动信号)，但是一旦你走上了试图解决这个问题的道路，你很快就会得到一个与 TCP 如此相似的协议，你不妨使用 TCP。

最后，使用`send()`成员函数将用户输入的缓冲区发送到服务器，服务器对字符串进行回声，然后客户端使用`recv()`成员函数接收字符串。收到字符串后，使用`std::cout`将数据输出到`stdout`。

像服务器一样，当客户端类被销毁时，套接字文件描述符被关闭，关闭套接字:

```cpp
    ~myclient()
    {
        close(m_fd);
    }
};
```

最后，使用与服务器和我们前面的示例相同的`protected_main()`函数创建客户端:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myclient client{PORT};
    client.echo();

    return EXIT_SUCCESS;
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

在上面的代码中，客户端在`protected_main()`函数中被实例化，并调用`echo`函数，该函数接受用户输入，将输入发送到服务器，并将任何回声数据输出到`stdout`。

# 编译和测试

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。

有了这段代码，我们可以使用以下内容编译这段代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter10/
> mkdir build
> cd build

> cmake ..
> make
```

要执行服务器，请运行以下命令:

```cpp
> ./example1_server
```

要执行客户端，请打开一个新的终端并运行以下内容:

```cpp
> cd Hands-On-System-Programming-with-CPP/Chapter10/build
> ./example1_client
Hello ↵
Hello
World
World ↵
exit ↵
```

如前面的代码片段所示，当执行客户端并输入输入时，输入将回显到终端。完成并输入单词`exit`后，客户端退出。客户端完成后，服务器也将退出。要演示与 UDP 的连接问题，请在客户端上单击*Ctrl**C*，而不是输入`exit`-客户端将退出，但服务器将继续执行，等待来自客户端的更多输入，因为它不会知道客户端已经完成。为了解决这个问题，下一个示例将创建相同的 echo 服务器，但使用 TCP 代替。

# 在 TCP echo 服务器上进行示例研究

在这个例子中，我们将引导读者创建一个 echo 服务器，但是使用 TCP 而不是 UDP。就像前面的示例一样，echo 服务器将任何输入回声到其输出。与 UDP 示例不同，TCP 是基于连接的协议，因此在本示例中，如何建立连接和发送/接收数据的某些细节有所不同。

# 服务器

首先，我们必须定义我们计划从客户端发送到服务器并返回的最大缓冲区大小，我们还必须定义我们希望使用的端口:

```cpp
#define PORT 22000
#define MAX_SIZE 0x10
```

对于服务器，我们将需要以下内容:

```cpp
#include <array>
#include <iostream>

#include <unistd.h>
#include <string.h>

#include <sys/socket.h>
#include <netinet/in.h>
```

与前面的示例一样，我们将使用一个类来利用 RAII 创建服务器:

```cpp
class myserver
{
    int m_fd{};
    int m_client{};
    struct sockaddr_in m_addr{};

public:
```

与 UDP 一样，将使用三个成员变量。第一个成员变量`m_fd`存储与服务器关联的套接字文件描述符。与 UDP 不同，此描述符将不用于与客户端一起发送/接收数据。相反，`m_client`表示将用于与客户端发送/接收数据的第二个套接字文件描述符。与 UDP 一样，`sockaddr_in{}`结构`m_addr`将用服务器地址类型填充，该类型将被绑定。

服务器的构造函数类似于 UDP 示例:

```cpp
    explicit myserver(uint16_t port)
    {
        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {
            throw std::runtime_error(strerror(errno));
        }

        m_addr.sin_family = AF_INET;
        m_addr.sin_port = htons(port);
        m_addr.sin_addr.s_addr = htonl(INADDR_ANY);

        if (this->bind() == -1) {
            throw std::runtime_error(strerror(errno));
        }
    }
```

与 UDP 示例一样，创建了服务器的套接字文件描述符，但使用的不是`SOCK_DGRAM`，而是`SOCK_STREAM`。`sockaddr_in{}`结构与 UDP 示例相同，其中使用了 IPv4 (即`AF_INET`)，端口以及用于表示将接受来自任何 ip 地址的连接的任何 ip 地址。

像 UDP 示例一样，然后使用以下成员函数绑定`sockaddr_in{}`结构:

```cpp
    int bind()
    {
        return ::bind(
            m_fd,
            reinterpret_cast<struct sockaddr *>(&m_addr),
            sizeof(m_addr)
        );
    }
```

上面的`bind()`函数与 UDP 示例中使用的`bind()`函数相同。

与 UDP 不同，会创建第二个特定于客户端的套接字描述符，并且 ip 地址，端口和地址类型都已为该套接字类型设置，与客户端通信的含义不需要`sendto()`或`recvfrom()`，因为我们有一个特定的套接字文件描述符已经绑定了此附加信息。因此，可以使用`send()`和`recv()`代替`sendto()`和`recvfrom()`。

要从客户端接收数据，将使用以下成员函数:

```cpp
    ssize_t recv(std::array<char, MAX_SIZE> &buf)
    {
        return ::recv(
            m_client,
            buf.data(),
            buf.size(),
            0
        );
    }
```

UDP 示例与此示例之间的唯一区别是使用`recv()`而不是`recvfrom()`，这省略了额外的`sockaddr_in{}`结构。如果您回想起以前的 UDP 示例，则将`m_fd`与`recvfrom()`一起使用，而不是`m_client`与`recv()`一起使用。不同之处在于，UDP 示例中的`m_client`是一个定义从谁接收数据的`sockaddr_in{}`结构。对于 TCP，`m_client`改为套接字描述符，从谁接收数据绑定到描述符，这就是为什么不需要额外的`sockaddr_in{}`结构的原因。

对于`send()`成员函数也是如此:

```cpp
    ssize_t send(std::array<char, MAX_SIZE> &buf, ssize_t len)
    {
        if (len >= buf.size()) {
            throw std::out_of_range("len >= buf.size()");
        }

        return ::send(
            m_client,
            buf.data(),
            len,
            0
        );
    }
```

与 UDP 示例不同，前面的`send()`函数可以使用`send()`POSIX API 而不是`sendto()`，因为关于谁和如何向客户端发送数据的地址信息被绑定到描述符，因此，可以省略附加的`sockaddr_in{}`信息。`send()`函数的其余部分与 UDP 示例相同。

`echo`函数与 UDP 对应函数有很大不同:

```cpp
    void echo()
    {
        if (::listen(m_fd, 0) == -1) {
            throw std::runtime_error(strerror(errno));
        }

        if (m_client = ::accept(m_fd, nullptr, nullptr); m_client == -1) {
            throw std::runtime_error(strerror(errno));
        }

        while(true)
        {
            std::array<char, MAX_SIZE> buf{};

            if (auto len = recv(buf); len != 0) {
                send(buf, len);
            }
            else {
                break;
            }
        }

        close(m_client);
    }
```

由于 TCP 需要连接，因此服务器的`echo`函数的第一步是告诉 POSIX API 您希望开始侦听传入的连接。在我们的示例中，我们告诉 API 使用默认的连接积压，这是特定于实现的，通过将积压设置为`0`。下一步是使用`accept()`POSIX API 等待来自客户端的传入连接。默认情况下，此函数是一个阻塞函数。`accept()`函数返回具有绑定到描述符的地址信息的套接字文件描述符，因此，我们将`nullptr`传递给`accept()`POSIX API 中的地址字段，因为在我们的示例中不需要此信息 (但是如果您，例如，需要过滤某些传入的客户端)。

下一步是等待客户端接收数据，然后使用`send()`成员函数将该数据回显到客户端。此逻辑与 UDP 示例相同。应该注意的是，如果我们从客户端接收到`0`字节，我们将停止处理来自客户端的数据，这与 UDP 所做的类似。不同之处在于，正如将显示的那样，在客户端，我们不需要显式地向服务器发送 0 个字节来发生这种情况。

`echo`函数的最后一步是在客户端完成后关闭客户端套接字文件描述符:

```cpp
    ~myserver()
    {
        close(m_fd);
    }
};
```

与其他示例一样，当服务器类被销毁时，我们关闭服务器的套接字文件描述符。最后，在`protected_main()`函数中实例化服务器，如下所示:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myserver server{PORT};
    server.echo();
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

与 UDP 示例一样，对服务器进行实例化，并执行`echo()`函数。

# 客户端逻辑

客户端逻辑类似于 UDP 客户端逻辑，但有一些小的例外。需要以下内容:

```cpp
#include <array>
#include <string>
#include <iostream>

#include <unistd.h>
#include <string.h>

#include <sys/socket.h>
#include <netinet/in.h>
```

就像 UDP 示例一样，创建了一个客户端类来利用 RAII，并定义了`m_fd`和`m_addr`私有成员变量来存储客户端的套接字文件描述符，以及客户端希望连接到的服务器的地址信息:

```cpp
class myclient
{
    int m_fd{};
    struct sockaddr_in m_addr{};

public:
```

与 UDP 示例不同，但与 TCP 服务器逻辑一样，构造函数使用`AF_INET`和`SOCK_STREAM`为 IPv4 和 TCP 创建一个套接字，如下所示:

```cpp
    explicit myclient(uint16_t port)
    {
        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {
            throw std::runtime_error(strerror(errno));
        }

        m_addr.sin_family = AF_INET;
        m_addr.sin_port = htons(port);
        m_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

        if (connect() == -1) {
            throw std::runtime_error(strerror(errno));
        }
    }
```

构造函数的其余部分与 UDP 示例相同，例如`connect()`，`send()`和`recv()`函数:

```cpp
     int connect()
    {
        return ::connect(
            m_fd,
            reinterpret_cast<struct sockaddr *>(&m_addr),
            sizeof(m_addr)
        );
    }

    ssize_t send(const std::string &buf)
    {
        return ::send(
            m_fd,
            buf.data(),
            buf.size(),
            0
        );
    }

    ssize_t recv(std::array<char, MAX_SIZE> &buf)
    {
        return ::recv(
            m_fd,
            buf.data(),
            buf.size() - 1,
            0
        );
    }
```

如上面的代码片段所示，客户端的功能几乎与 UDP 客户端完全相同。除了使用`SOCK_STREAM`之外，UDP 客户端和 TCP 客户端的区别在于`echo`功能的实现:

```cpp
    void echo()
    {
        while(true) {
            std::string sendbuf{};
            std::array<char, MAX_SIZE> recvbuf{};

            std::cin >> sendbuf;

            send(sendbuf);
            recv(recvbuf);

            std::cout << recvbuf.data() << '\n';
        }
    }
```

与 UDP 示例不同，TCP 客户端不需要检查`exit`字符串。这是因为如果客户端断开连接 (例如，*Ctrl**C*用于杀死客户端)，服务器端会收到`0`字节，告诉服务器逻辑客户端已断开连接。这是可能的，因为 TCP 是一个基于连接的协议，因此，操作系统正在维护一个开放的连接，包括服务器和客户端之间的保持活动信号，以便 API 的用户不必明确地这样做。由于这个原因，在大多数情况下，这是所需的套接字类型，因为它可以防止许多连接状态的常见问题:

```cpp
    ~myclient()
    {
        close(m_fd);
    }
};
```

如前面的代码所示，与所有其他示例一样，当客户端被销毁时，套接字文件描述符将关闭，如下所示:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myclient client{PORT};
    client.echo();
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

最后，在`protected_main()`函数中实例化客户端，并调用`echo`函数。

# 编译和测试

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。

有了这段代码，我们可以使用以下内容编译这段代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter10/
> mkdir build
> cd build

> cmake ..
> make
```

要执行服务器，请运行以下命令:

```cpp
> ./example2_server
```

要执行客户端，请打开一个新的终端并运行以下内容:

```cpp
> cd Hands-On-System-Programming-with-CPP/Chapter10/build
> ./example2_client
Hello ↵
Hello
World
World ↵
<ctrl+c>
```

如前面的代码片段所示，当执行客户端并输入输入时，输入将回显到终端。完成后，输入*Ctrl**C*，客户端退出。如您所见，服务器将在客户端完成后退出。以上示例演示了 TCP 的易用性，以及它相对于 UDP 的优势。下一个示例将演示如何使用 TCP 来获得更有用的东西。

# 探索 TCP 记录器的一个例子

为了演示更有用的东西，下面的示例实现了我们在本书中一直在开发的相同的记录器，但是作为远程日志记录工具。

# 服务器

本示例需要与本章前面的示例相同的宏和包含。要启动服务器，我们必须定义日志文件:

```cpp
std::fstream g_log{"server_log.txt", std::ios::out | std::ios::app};
```

由于记录器将在同一台计算机上执行以保持示例简单，因此我们将服务器记录到的文件命名为`server_log.txt`。

服务器与前面示例中的 TCP 服务器相同，只是需要一个`recv()`成员函数 (即，不需要`send()`函数，因为服务器只会接收日志数据):

```cpp
class myserver
{
    int m_fd{};
    int m_client{};
    struct sockaddr_in m_addr{};

public:
    explicit myserver(uint16_t port)
    {
        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {
            throw std::runtime_error(strerror(errno));
        }

        m_addr.sin_family = AF_INET;
        m_addr.sin_port = htons(port);
        m_addr.sin_addr.s_addr = htonl(INADDR_ANY);

        if (this->bind() == -1) {
            throw std::runtime_error(strerror(errno));
        }
    }

    int bind()
    {
        return ::bind(
            m_fd,
            reinterpret_cast<struct sockaddr *>(&m_addr),
            sizeof(m_addr)
        );
    }

    ssize_t recv(std::array<char, MAX_SIZE> &buf)
    {
        return ::recv(
            m_client, buf.data(), buf.size(), 0
        );
    }
```

前面的 TCP 示例与本示例的区别在于使用`log()`函数而不是`echo`函数。这两个功能的相似之处在于，它们侦听传入的连接，然后无限循环，直到服务器接收到数据:

```cpp
    void log()
    {
        if (::listen(m_fd, 0) == -1) {
            throw std::runtime_error(strerror(errno));
        }

        if (m_client = ::accept(m_fd, nullptr, nullptr); m_client == -1) {
            throw std::runtime_error(strerror(errno));
        }

        while(true)
        {
            std::array<char, MAX_SIZE> buf{};

            if (auto len = recv(buf); len != 0) {
                g_log.write(buf.data(), len);
                std::clog.write(buf.data(), len);
            }
            else {
                break;
            }
        }

        close(m_client);
    }
```

与`log`功能的不同之处在于，当客户端接收到数据时，不是将数据回显到服务器，而是将数据输出到`stdout`并写入`server_log.txt`日志文件。

如图所示，服务器逻辑的其余部分与前面的示例相同:

```cpp
    ~myserver()
    {
        close(m_fd);
    }
};

int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myserver server{PORT};
    server.log();

    return EXIT_SUCCESS;
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

当服务器对象被销毁时，socket 文件描述符被关闭，服务器在`protected_main()`函数中被实例化，然后执行`log()`函数。

# 客户端逻辑

此示例的客户端逻辑是前几章 (我们一直在构建) 中的调试示例和之前的 TCP 示例的组合。

我们首先定义调试级别并启用宏，就像前面的示例一样:

```cpp
#ifdef DEBUG_LEVEL
constexpr auto g_debug_level = DEBUG_LEVEL;
#else
constexpr auto g_debug_level = 0;
#endif

#ifdef NDEBUG
constexpr auto g_ndebug = true;
#else
constexpr auto g_ndebug = false;
#endif
```

客户端类与前面 TCP 示例中的客户端类相同:

```cpp
class myclient
{
    int m_fd{};
    struct sockaddr_in m_addr{};

public:
    explicit myclient(uint16_t port)
    {
        if (m_fd = ::socket(AF_INET, SOCK_STREAM, 0); m_fd == -1) {
            throw std::runtime_error(strerror(errno));
        }

        m_addr.sin_family = AF_INET;
        m_addr.sin_port = htons(port);
        m_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

        if (connect() == -1) {
            throw std::runtime_error(strerror(errno));
        }
    }

    int connect()
    {
        return ::connect(
            m_fd,
            reinterpret_cast<struct sockaddr *>(&m_addr),
            sizeof(m_addr)
        );
    }

    ssize_t send(const std::string &buf)
    {
        return ::send(
            m_fd,
            buf.data(),
            buf.size(),
            0
        );
    }

    ~myclient()
    {
        close(m_fd);
    }
};
```

本示例中的客户端与上一示例中的客户端之间的唯一区别是，在本示例中，不需要`recv()`函数 (因为没有从服务器接收数据)，并且不需要`echo()`功能 (或类似的功能)，因为客户端将直接用于根据需要将数据发送到服务器。

与前面的调试示例一样，需要客户端的日志文件，在本示例中，我们还将全局实例化客户端，如下所示:

```cpp
myclient g_client{PORT};
std::fstream g_log{"client_log.txt", std::ios::out | std::ios::app};
```

如图所示，客户端日志文件将被命名为`client_log.txt`，以防止与服务器日志文件发生冲突，因为两者都将在同一台计算机上运行以简化示例。

`log`函数与[第 8 章](08.html)，*学习编程文件输入/输出，*中定义的`log`函数相同，除了登录`stderr`和客户端日志文件外，调试字符串也将记录到服务器:

```cpp
template <std::size_t LEVEL>
constexpr void log(void(*func)()) {
    if constexpr (!g_ndebug && (LEVEL <= g_debug_level)) {
        std::stringstream buf;

        auto g_buf = std::clog.rdbuf();
        std::clog.rdbuf(buf.rdbuf());

        func();

        std::clog.rdbuf(g_buf);

        std::clog << "\033[1;32mDEBUG\033[0m: ";
        std::clog << buf.str();

        g_log << "\033[1;32mDEBUG\033[0m: ";
        g_log << buf.str();

        g_client.send("\033[1;32mDEBUG\033[0m: ");
        g_client.send(buf.str());
    };
}
```

如前面的代码所示，`log`函数将任何输出封装到`std::clog`，并将生成的字符串重定向到日志文件`stderr`，并且在本示例中，将该字符串发送到要在服务器端记录的服务器的客户端对象。

该示例的其余部分与前面的示例相同:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    log<0>([]{
        std::clog << "Hello World\n";
    });

    std::clog << "Hello World\n";

    return EXIT_SUCCESS;
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

`protected_main()`函数将`Hello World\n`输出到`stderr`，重定向到包含日志文件`stderr`，最后发送到服务器。对`std::clog`的另一个调用是为了表明只有对封装在`log()`函数中的`std:clog`的调用才被重定向。

# 编译和测试

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。

有了这段代码，我们可以使用以下内容编译这段代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter10/
> mkdir build
> cd build

> cmake ..
> make
```

要执行服务器，请运行以下命令:

```cpp
> ./example3_server
```

要执行客户端，请打开一个新的终端并运行以下内容:

```cpp
> cd Hands-On-System-Programming-with-CPP/Chapter10/build
> ./example3_client
Debug: Hello World
Hello World

> cat client_log.txt
Debug: Hello World

> cat server_log.txt
Debug: Hello World

```

如前面的代码片段所示，当客户端被执行时，客户端和服务器端都输出`DEBUG: Hello World`到`stderr.`。此外，客户端输出`Hello World`到`stderr`，因为对`std::clog`的第二次调用不会被重定向。最后，两个日志文件都包含重定向的`DEBUG: Hello World`。

到目前为止，在所有示例中，被忽略的一件事是，如果多个客户端尝试连接到服务器，会发生什么。在本章的示例中，只支持一个客户端。为了支持其他客户端，需要执行线程，这将在[第 12 章](12.html)，*学习编程 POSIC 和 C 线程*中介绍，我们将在此示例中进行扩展，以创建能够记录多个应用程序的调试输出的日志记录服务器。本章最后两个示例将演示如何使用 TCP 处理非字符串数据包。

# 尝试处理数据包的示例

在此示例中，我们将讨论如何处理从客户端到服务器的以下数据包:

```cpp
struct packet
{
    uint64_t len;
    char buf[MAX_SIZE];

    uint64_t data1;
    uint64_t data2;
};
```

数据包由一些固定宽度的整数数据和字符串组成 (网络中的字段必须始终为固定宽度，因为您可能无法控制应用程序正在运行的计算机类型和非固定宽度类型，例如`int`和`long`，可能会根据计算机而变化)。

这种类型的数据包在许多程序中很常见，但是正如将要证明的那样，这种类型的数据包在安全解析方面存在挑战。

服务器与之前的 TCP 示例相同，减去`recv_packet()`函数 (并且`recv()`函数处理数据包而不是`std::arrays` ):

```cpp
class myserver
{
...

    void recv_packet()
    {
        if (::listen(m_fd, 0) == -1) {
            throw std::runtime_error(strerror(errno));
        }

        if (m_client = ::accept(m_fd, nullptr, nullptr); m_client == -1) {
            throw std::runtime_error(strerror(errno));
        }

        packet p{};

        if (auto len = recv(p); len != 0) {
            auto msg = std::string(p.buf, p.len);

            std::cout << "data1: " << p.data1 << '\n';
            std::cout << "data2: " << p.data2 << '\n';
            std::cout << "msg: \"" << msg << "\"\n";
            std::cout << "len: " << len << '\n';
        }

        close(m_client);
    }

...
};
```

在`recv_packet()`函数中，我们等待从客户端接收数据。一旦从客户端接收到数据包，我们就解析收到的数据包。与数据包关联的整数数据被读取并输出到`stdout`，没有问题。然而，字符串数据更有问题。由于我们不知道正在接收的字符串数据的总大小，因此我们必须考虑整个缓冲区以安全地处理字符串，并且在某种意义上保持类型安全。当然，在我们的示例中，为了减小数据包的总大小，我们可以先将整数数据放在数据包中，然后创建一个可变长度的数据包，但这既不安全，又难以控制或在更复杂的情况下完成。解决此问题的大多数尝试 (必须发送和接收比实际需要的数据更多的数据) 都会导致长度可变的操作，因此不安全。

服务器的其余部分与前面的示例相同:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myserver server{PORT};
    server.recv_packet();
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

如前面的代码所示，服务器在`protected_main()`函数中实例化，并调用`recv_packet()`函数。

# 客户端逻辑

客户端的大部分也与前面的示例相同:

```cpp
class myclient
{
...

    void send_packet()
    {
        auto msg = std::string("Hello World");

        packet p = {
            42,
            43,
            msg.size(),
            {}
        };

        memcpy(p.buf, msg.data(), msg.size());

        send(p);
    }

...
};
```

`send_packet()`函数是与前面示例不同的唯一部分 (减去`send()`函数发送数据包而不是`std::array()`的事实)。在`send_packet()`函数中，我们创建一个不包含`"Hello World"`字符串的数据包。应该注意的是，要创建此数据包，我们仍然需要一些处理，包括内存副本。创建数据包后，我们将其发送到服务器进行处理。

客户端的其余部分与前面的示例相同:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myclient client{PORT};
    client.send_packet();
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

客户端在`proceted_main()`函数中实例化，并执行`send_packet()`函数。

# 编译和测试

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。

有了这段代码，我们可以使用以下内容编译这段代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter10/
> mkdir build
> cd build

> cmake ..
> make
```

要执行服务器，请运行以下命令:

```cpp
> ./example4_server
```

要执行客户端，请打开一个新的终端并运行以下内容:

```cpp
> cd Hands-On-System-Programming-with-CPP/Chapter10/build
> ./example4_client
```

在服务器端，以下内容输出到`stdout`:

```cpp
data1: 42
data2: 43
msg: "Hello World"
len: 280
```

如前面的代码片段所示，数据包数据由客户端发送并由服务器接收。服务器接收的数据包的总大小为 280 字节，即使字符串的总大小要小得多。在下一个示例中，我们将演示如何通过一些额外的处理来安全地减少数据包的总大小 (尽管根据您的用例可能可以忽略不计)。

# 处理处理 JSON 的示例

在最后一个示例中，我们将演示如何使用 JSON 对数据包进行封送，以安全地减小网络数据包的大小，同时牺牲一些额外的处理。为了支持此示例，将使用以下 C JSON 库: [https://github.com/nlohmann/json](https://github.com/nlohmann/json)。

要将此 JSON 库合并到我们的示例中，必须将以下内容添加到我们的`CMakeLists.txt`中，该文档下载此仅标头库并将其安装到我们的构建文件夹中才能使用:

```cpp
list(APPEND JSON_CMAKE_ARGS
    -DBUILD_TESTING=OFF
    -DCMAKE_INSTALL_PREFIX=${CMAKE_BINARY_DIR}
)

ExternalProject_Add(
    json
    GIT_REPOSITORY https://github.com/nlohmann/json.git
    GIT_SHALLOW 1
    CMAKE_ARGS ${JSON_CMAKE_ARGS}
    PREFIX ${CMAKE_BINARY_DIR}/external/json/prefix
    TMP_DIR ${CMAKE_BINARY_DIR}/external/json/tmp
    STAMP_DIR ${CMAKE_BINARY_DIR}/external/json/stamp
    DOWNLOAD_DIR ${CMAKE_BINARY_DIR}/external/json/download
    SOURCE_DIR ${CMAKE_BINARY_DIR}/external/json/src
    BINARY_DIR ${CMAKE_BINARY_DIR}/external/json/build
    UPDATE_DISCONNECTED 1
)
```

# 服务器

服务器包含和宏相同，除了必须添加 JSON 外，如下所示:

```cpp
#include <nlohmann/json.hpp>
using json = nlohmann::json;
```

本示例中的服务器与前面的示例相同，除了`recv_packet()`函数:

```cpp
class myserver
{
...

    void recv_packet()
    {
        std::array<char, MAX_SIZE> buf{};

        if (::listen(m_fd, 0) == -1) {
            throw std::runtime_error(strerror(errno));
        }

        if (m_client = ::accept(m_fd, nullptr, nullptr); m_client == -1) {
            throw std::runtime_error(strerror(errno));
        }

        if (auto len = recv(buf); len != 0) {
            auto j = json::parse(buf.data(), buf.data() + len);

            std::cout << "data1: " << j["data1"] << '\n';
            std::cout << "data2: " << j["data2"] << '\n';
            std::cout << "msg: " << j["msg"] << '\n';
            std::cout << "len: " << len << '\n';
        }

        close(m_client);
    }

...
};
```

在`recv_packet()`函数中，我们需要分配一个最大大小的缓冲区; 这个缓冲区不需要完全接收，而是我们的 JSON 缓冲区的占位符，它可以是最大的任何大小。解析 JSON 数据很简单。将整数数据和字符串数据分别安全地解析为 integer 和`std::string`类型，所有这些都遵循 C 核心准则。该代码易于阅读和遵循，并且将来可以更改数据包，而无需更改任何其他逻辑。

服务器的其余部分是相同的:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myserver server{PORT};
    server.recv_packet();
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

服务器在`protected_main()`函数中实例化，并调用`recv_packet()`函数。

# 客户端逻辑

像服务器一样，客户端还必须包含 JSON 标头:

```cpp
#include <nlohmann/json.hpp>
using json = nlohmann::json;
```

与服务器一样，客户端与前面的示例相同，减去`send_packet()`函数:

```cpp
class myclient
{
...

    void send_packet()
    {
        json j;

        j["data1"] = 42;
        j["data2"] = 43;
        j["msg"] = "Hello World";

        send(j.dump());
    }

...
};
```

`send_packet()`函数同样简单。一个 JSON 数据包被构造并发送到服务器。不同之处在于，数据包在发送之前会先封送为 JSON 字符串 (使用`dump()`函数)。这会将所有数据转换为具有特殊语法的单个字符串，以良好的，经过良好测试的方式定义每个字段的开始和结束，以防止不安全的解析。此外，如将很快显示的那样，正在发送的字节总数大大减少。

客户端的其余部分是相同的:

```cpp
int
protected_main(int argc, char** argv)
{
    (void) argc;
    (void) argv;

    myclient client{PORT};
    client.send_packet();
}

int
main(int argc, char** argv)
{
    try {
        return protected_main(argc, argv);
    }
    catch (const std::exception &e) {
        std::cerr << "Caught unhandled exception:\n";
        std::cerr << " - what(): " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Caught unknown exception\n";
    }

    return EXIT_FAILURE;
}
```

客户端在`protected_main()`函数中实例化，并调用`send_packet()`函数。

# 编译和测试

为了编译此代码，我们利用了我们一直在其他示例中使用的相同的`CMakeLists.txt`文件: [https://github.com/PacktPublishing/ 使用 CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt)。

有了这段代码，我们可以使用以下内容编译这段代码:

```cpp
> git clone https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP.git
> cd Hands-On-System-Programming-with-CPP/Chapter10/
> mkdir build
> cd build

> cmake ..
> make
```

要执行服务器，请运行以下命令:

```cpp
> ./example5_server
```

要执行客户端，请打开一个新的终端并运行以下内容:

```cpp
> cd Hands-On-System-Programming-with-CPP/Chapter10/build
> ./example5_client
```

在服务器端，以下内容输出到`stdout`:

```cpp
data1: 42
data2: 43
msg: "Hello World"
len: 43
```

如前面的代码片段所示，数据包数据由客户端发送并由服务器接收。服务器接收到的数据包的总大小为 43 字节，与前面的示例相比，效率提高了 6.5 倍。除了提供较小的数据包外，用于创建和解析数据包的逻辑相似，并且将来更易于阅读和修改。此外，对于诸如 JSON 模式之类的东西，甚至可以在处理之前对数据包进行验证，这超出了本书的范围。

# 摘要

在本章中，我们学习了如何使用 C 17 对 POSIX 套接字进行编程。具体来说，我们学习了与 POSIX 套接字相关的通用 api，以及如何使用它们。我们用五个不同的例子来结束本章。第一个示例创建了 UDP echo 服务器，而第二个示例使用 TCP 而不是 UDP 创建了类似的 echo 服务器，概述了不同方法之间的差异。第三个示例通过将服务器组件添加到调试器中，扩展了我们的调试示例。第四和第五个示例演示了如何处理简单的网络数据包，以及使用封送处理来简化流程的好处。

在下一章中，我们将讨论 C 和 C 时间接口，这些接口可用于获取挂钟，测量经过时间并执行基准测试。

# 问题

1.  UDP 和 TCP 的主要区别是什么？
2.  UDP 使用什么协议类型？
3.  TCP 使用什么协议类型？
4.  `AF_INET`代表什么地址类型？
5.  `bind()`和`connect()`有什么区别？
6.  `sendto()`和`send()`有什么区别？
7.  UDP 服务器如何检测 UDP 客户端何时被丢弃或崩溃？
8.  使用数据包封送有什么好处？

# 进一步阅读

*   [https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)
*   [https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)