# 七、高级 IR 生成

使用前面章节中介绍的**中间表示**(**IR**)生成，您已经可以实现编译器中所需的大部分功能。 在本章中，我们将介绍一些在实际编译器方面经常出现的高级主题。 例如，许多现代语言使用异常处理，我们来看看如何将其转换为**低级虚拟机**(**LLVM**)IR。

为了支持 LLVM 优化器在某些情况下生成更好的代码，我们向 IR 代码添加了额外的类型元数据，附加的调试元数据使编译器的用户能够利用源代码级别的调试工具。

在本章中，您将了解以下主题：

*   在*抛出和捕获异常*中，您将学习如何在编译器中实现异常处理。
*   在*生成用于基于类型的别名分析的元数据*时，您将附加元数据附加到 LLVM IR，这有助于 LLVM 更好地优化代码。
*   在*添加调试元数据*中，实现将调试信息添加到生成的 IR 代码所需的支持类。

在本章结束时，您将了解有关异常处理的知识，以及有关用于基于类型的别名分析和调试信息的元数据的知识。

# 技术要求

本章的代码文件位于[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter07)

您可以在[https://bit.ly/3nllhED](https://bit.ly/3nllhED)上找到动作视频中的代码。

# 抛出和捕获异常

LLVM IR 中的异常处理与平台的支持紧密相关。 这里，我们将使用`libunwind`查看最常见的异常处理类型。 C++ 充分利用了它的全部潜力，因此我们将首先查看 C++ 中的一个示例，其中`bar()`函数可以抛出`int`或`double`值，如下所示：

```cpp
int bar(int x) {
  if (x == 1) throw 1;
  if (x == 2) throw 42.0;
  return x;
}
```

`foo()`函数调用`bar()`，但只处理抛出的`int`值。 它还声明它只抛出个个值，如下所示：

```cpp
int foo(int x) throw(int) {
  int y = 0;
  try {
    y = bar(x);
  }
  catch (int e) {
    y = e;
  }
  return y;
}
```

抛出异常需要对运行时库进行两次调用。 首先，通过调用`__cxa_allocate_exception()`来分配异常的内存。 此函数将要分配的字节数作为参数。 异常有效负载(示例中的`int`或`double`值)被复制到分配的内存。 然后通过调用`__cxa_throw()`引发异常。 此函数有三个参数：指向分配的异常的指针；有关有效负载的类型信息；以及指向析构函数的指针(如果异常有效负载有析构函数的话)。 函数`__cxa_throw()`启动堆栈展开过程，并且永远不会返回。 在 LLVM IR 中，这是针对`int`值执行的，如下所示：

```cpp
%eh = tail call i8* @__cxa_allocate_exception(i64 4)
%payload = bitcast i8* %eh to i32*
store i32 1, i32* %payload
tail call void @__cxa_throw(i8* %eh,
                   i8* bitcast (i8** @_ZTIi to i8*), i8* 
                   null)
unreachable
```

`_ZTIi`是描述`int`类型的类型信息。 对于 DOUBLE 类型，它将是`_ZTId`。 对`__cxa_throw()`的调用被标记为尾部调用，因为它是此函数中的最后一个调用，可能会启用当前堆栈帧的重用。

到目前为止，还没有执行任何特定于LLVM 的操作。 这在`foo()`函数中会发生变化，因为对`bar()`的调用可能会引发异常。 如果是`int`类型的异常，则必须将控制流传输到`catch`子句的 IR 代码。 要实现这一点，必须使用`invoke`指令而不是`call`指令，如以下代码片段所示：

```cpp
%y = invoke i32 @_Z3bari(i32 %x) to label %next
                                 unwind label %lpad
```

这两条指令的不同之处在于`invoke`有两个关联的标签。 第一个标签是在被调用函数正常结束时继续执行的位置，通常使用`ret`指令。 在前面的代码示例中，此标签称为`%next`。 如果发生异常，则在带有`%lpad`标签的所谓*着陆台*继续执行。

起落架是一个基本模块，必须以`landingpad`指令开始。 `landingpad`指令提供有关已处理异常类型的 LLVM 信息。 对于`foo()`函数，它提供以下信息：

```cpp
lpad:
%exc = landingpad { i8*, i32 }
          cleanup
          catch i8* bitcast (i8** @_ZTIi to i8*)
          filter [1 x i8*] [i8* bitcast (i8** @_ZTIi to 
              i8*)]
```

这里有三种可能的操作类型，概述如下：

*   `cleanup`：这表示存在清理当前状态的代码。 通常，这用于调用本地对象的析构函数。 如果存在此标记，则在展开堆叠期间始终调用着陆垫。
*   `catch`：这是类型-值对的列表，表示可以处理的异常类型。 如果在此列表中找到抛出的异常类型，则调用着陆台。 在`foo()`函数的情况下，该值是指向`int`类型的 C++ 运行时类型信息的指针，类似于`__cxa_throw()`函数的参数。
*   `filter`：这指定异常类型的数组。 如果在数组中找不到当前异常的异常类型，则调用着陆台。 这用于实现`throw()`规范。 对于`foo()`函数，数组只有一个成员-`int`类型的类型信息。

`landingpad`指令的结果类型是`{ i8*, i32 }`结构。 第一个元素是指向引发的异常的指针，而第二个元素是类型选择器。 让我们从结构中提取这两个元素，如下所示：

```cpp
%exc.ptr = extractvalue { i8*, i32 } %exc, 0
%exc.sel = extractvalue { i8*, i32 } %exc, 1
```

*类型选择器*是一个数字，它帮助我们确定起落架被称为的原因*。 如果当前异常类型与`landingpad`指令的`catch`部分中给出的异常类型之一匹配，则该值为正值。 如果当前异常类型与`filter`部分中给出的任何值都不匹配，则该值为负值，如果应该调用清理代码，则该值为`0`。*

基本上，类型选择器被偏置到类型信息表中，该表由`landingpad`指令的`catch`和`filter`部分中给出的值构成。 在优化过程中，可以将多个着陆台合并为一个，这意味着该表的结构在 IR 级别是未知的。 要检索给定类型的类型选择器，我们需要调用`@llvm.eh.typeid.for`内部函数。 我们需要检查类型选择器值是否对应于`int`的类型信息，以便能够执行`catch (int e) {}`块中的代码，如下所示：

```cpp
%tid.int = tail call i32 @llvm.eh.typeid.for(
                             i8* bitcast (i8** @_ZTIi to 
                             i8*))
%tst.int = icmp eq i32 %exc.sel, %tid.int
br i1 % tst.int, label %catchint, label %filterorcleanup
```

异常的处理由对`__cxa_begin_catch()`和`__cxa_end_catch()`的调用构成。 `__cxa_begin_catch()`函数需要一个参数：当前异常。 这是`landingpad`指令返回的值之一。 它返回一个指向异常有效负载的指针-在我们的例子中是一个`int`值。 函数`__cxa_end_catch()`标志着异常处理的结束，并释放使用`__cxa_allocate_exception()`分配的内存。 请注意，如果在`catch`块中抛出另一个异常，则运行时行为会复杂得多。 异常的处理方式如下所示：

```cpp
catchint:
%payload = tail call i8* @__cxa_begin_catch(i8* %exc.ptr)
%payload.int = bitcast i8* %payload to i32*
%retval = load i32, i32* %payload.int
tail call void @__cxa_end_catch()
br label %return
```

如果当前异常的类型与`throws()`声明中的列表不匹配，则调用意外异常处理程序。 首先，我们需要再次检查类型选择器，如下所示：

```cpp
filterorcleanup:
%tst.blzero = icmp slt i32 %exc.sel, 0
br i1 %tst.blzero, label %filter, label %cleanup
```

如果类型选择器的值小于`0`，则调用处理程序，如下所示：

```cpp
filter:
tail call void @__cxa_call_unexpected(i8* %exc.ptr) #4
unreachable
```

再说一次，操控者预计不会回来。

在这种情况下不需要清理工作，因此清理代码所做的全部工作就是恢复堆栈展开程序的执行，如下所示：

```cpp
cleanup:
resume { i8*, i32 } %exc
```

仍然缺少一段：`libunwind`驱动堆栈展开，但它没有绑定到任何一种语言。 语言相关的处理在`personality`函数中完成。 对于 Linux 上的 C++，`personality`函数称为`__gxx_personality_v0()`。 根据平台或编译器的不同，此名称可能会有所不同。 每个需要参与堆栈展开的函数都附加了一个`personality`函数。 函数的作用是：分析函数是否捕捉到异常、是否具有不匹配的筛选器列表或是否需要进行清理调用。 它将此信息返回给展开程序，后者相应地执行操作。 在 LLVM IR 中，指向`personality`函数的指针是函数定义的一部分，如以下代码片段所示：

```cpp
define i32 @_Z3fooi(i32) personality i8* bitcast
                     (i32 (...)* @__gxx_personality_v0 to 
                      i8*)
```

这样，异常处理工具就完成了。

要在编程语言的编译器中使用异常处理，最简单的策略是利用现有的 C++ 运行时函数。 这还有一个好处，即您的异常可以与 C++ 互操作。 一个缺点是您将一些 C++ 运行时绑定到您的语言的运行时中--最明显的是内存管理。 如果您希望避免这种情况，则需要创建您自己的`_cxa_`函数等效项。 不过，您仍需要使用`libunwind`，它提供了堆栈展开机制。

1.  让我们看看如何创建此 IR。 我们在[*第 3 章*](03.html#_idTextAnchor048)，*《编译器的结构》*中创建了`calc`表达式编译器。 现在，我们将扩展表达式编译器的代码生成器，以便在执行除以`0`时引发并处理异常。 生成的 IR 将检查除法的除数是否为`0`。 如果为`true`，则将引发异常。 我们还将向该函数添加一个着陆板，该函数捕捉异常，将`Divide by zero!`打印到控制台，并结束计算。 在这个简单的案例中，使用异常处理并不是真正必要的，但它允许我们专注于代码生成。 我们将所有代码添加到`CodeGenerator.cpp`文件中。 我们首先添加必需的新字段和一些帮助器方法。 我们需要存储`__cxa_allocate_exception()`和`__cxa_throw()`函数的 LLVM 声明，由函数类型和函数本身组成。 需要一个`GlobalVariable`实例来保存类型信息。 我们还需要引用存放着陆垫的基本块和只包含`unreachable`指令的基本块，如以下代码片段所示：

    ```cpp
      GlobalVariable *TypeInfo = nullptr;
      FunctionType *AllocEHFty = nullptr;
      Function *AllocEHFn = nullptr;
      FunctionType *ThrowEHFty = nullptr;
      Function *ThrowEHFn = nullptr;
      BasicBlock *LPadBB = nullptr;
      BasicBlock *UnreachableBB = nullptr;
    ```

2.  我们还添加了一个新的助手函数来创建 IR，用于比较两个值。 `createICmpEq()`函数将`Left`和`Right`值作为参数进行比较。 对于相等和不相等的情况，它创建一条`compare`指令来测试值的相等性，并为两个基本块创建一条分支指令。 这两个基本块通过`TrueDest`和`FalseDest`参数中的引用返回。 可以在`TrueLabel`和`FalseLabel`参数中给出新基本块的标签。 代码显示在以下代码片段中：

    ```cpp
      void createICmpEq(Value *Left, Value *Right,
                        BasicBlock *&TrueDest,
                        BasicBlock *&FalseDest,
                        const Twine &TrueLabel = "",
                        const Twine &FalseLabel = "") {
        Function *Fn =        Builder.GetInsertBlock()->getParent();
        TrueDest = BasicBlock::Create(M->getContext(),                                  TrueLabel, Fn);
        FalseDest = BasicBlock::Create(M->getContext(),                                   FalseLabel, Fn);
        Value *Cmp = Builder.CreateCmp(CmpInst::ICMP_EQ,                                   Left, Right);
        Builder.CreateCondBr(Cmp, TrueDest, FalseDest);
      }
    ```

3.  要使用运行时中的函数，我们需要创建几个函数声明。 在 LLVM 中，必须构造一个提供签名的函数类型，以及函数本身。 我们使用`createFunc()`方法创建这两个对象。 函数需要引用`FunctionType`和`Function`指针、新声明的函数名和结果类型。 参数类型列表是可选的，并且指示可变参数列表的标志被设置为`false`，指示在参数列表中没有可变部分。 代码可以在以下代码片段中看到：

    ```cpp
      void createFunc(FunctionType *&Fty, Function *&Fn,
                      const Twine &N, Type *Result,
                      ArrayRef<Type *> Params = None,
                      bool IsVarArgs = false) {
        Fty = FunctionType::get(Result, Params, IsVarArgs);
        Fn = Function::Create(
            Fty, GlobalValue::ExternalLinkage, N, M);
      }
    ```

完成这些准备后，我们继续生成 IR 以引发异常。

## 引发异常

为了生成引发异常的 IR代码，我们添加了一个`addThrow()`方法。 这个新方法需要初始化新字段，然后生成 IR 以通过`__cxa_throw`函数引发异常。 引发的异常的有效负载是`int`类型，可以设置为任意值。 下面是我们需要编写的代码：

1.  新的`addThrow()`方法首先检查`TypeInfo`字段是否已初始化。 如果不是，则创建`i8*`类型和`_ZTIi`名称的全局外部常量。 这表示描述 C++ `int`类型的 C++ 元数据。 代码如以下代码片段所示：

    ```cpp
      void addThrow(int PayloadVal) {
        if (!TypeInfo) {
          TypeInfo = new GlobalVariable(
              *M, Int8PtrTy,
              /*isConstant=*/true,
              GlobalValue::ExternalLinkage,
              /*Initializer=*/nullptr, "_ZTIi");
    ```

2.  初始化继续，使用我们的`createFunc()`帮助器方法为`__cxa_allocate_exception()`和`__cxa_throw functions()`创建 IR 声明，如下所示：

    ```cpp
          createFunc(AllocEHFty, AllocEHFn,
                     "__cxa_allocate_exception", 
                     Int8PtrTy,
                     {Int64Ty});
          createFunc(ThrowEHFty, ThrowEHFn, "__cxa_throw",
                     VoidTy,
                     {Int8PtrTy, Int8PtrTy, Int8PtrTy});
    ```

3.  使用异常处理的函数需要`personality`函数，该函数有助于堆栈展开。 我们添加 IR 代码以声明 C++ 库中的`__gxx_personality_v0()``personality`函数，并将其设置为当前函数的`personality`例程。 当前函数没有存储为字段，但我们可以使用`Builder`实例来查询当前基本块，该基本块将函数存储为`parent`字段，如以下代码片段所示：

    ```cpp
          FunctionType *PersFty;
          Function *PersFn;
          createFunc(PersFty, PersFn,                 "__gxx_personality_v0", Int32Ty, None,                 true);
          Function *Fn =          Builder.GetInsertBlock()->getParent();
          Fn->setPersonalityFn(PersFn);
    ```

4.  接下来，我们将创建并填充着陆台的基本块。 首先，我们需要保存指向当前基本块的指针。 然后，我们创建一个新的基本块，将其设置在构建器中以用作插入指令的基本块，并调用`addLandingPad()`方法。 此方法生成用于处理异常的 IR 代码，将在下一节*捕获异常*中介绍。 下面的代码填充着陆台的基本块：

    ```cpp
          BasicBlock *SaveBB = Builder.GetInsertBlock();
          LPadBB = BasicBlock::Create(M->getContext(),                                  "lpad", Fn);
          Builder.SetInsertPoint(LPadBB);
          addLandingPad();
    ```

5.  初始化部分已完成创建包含`unreachable`指令的基本块。 同样，我们创建了一个基本块，并将其设置为生成器处的插入点。 然后，我们向其添加一条`unreachable`指令。 最后，我们将构建器的插入点设置回保存的`SaveBB`实例，以便将以下 IR 添加到右侧基本块。 代码如以下代码片段所示：

    ```cpp
          UnreachableBB = BasicBlock::Create(
              M->getContext(), "unreachable", Fn);
          Builder.SetInsertPoint(UnreachableBB);
          Builder.CreateUnreachable();
          Builder.SetInsertPoint(SaveBB);
        }
    ```

6.  要引发异常，我们需要通过调用`__cxa_allocate_exception()`函数为异常和有效负载分配内存。 我们的有效负载是 C++ `int`类型，通常有 4 个字节的大小。 我们为大小创建一个常量无符号值，并使用它作为参数调用函数。 函数类型和函数声明已经初始化，所以我们只需要创建一条`call`指令，如下所示：

    ```cpp
        Constant *PayloadSz =       ConstantInt::get(Int64Ty, 4, false);
        CallInst *EH = Builder.CreateCall(        AllocEHFty, AllocEHFn, {PayloadSz});
    ```

7.  接下来，我们将值存储到分配的内存中。 为此，我们需要通过调用`ConstantInt::get()`函数创建一个 LLVM IR 常量。 指向已分配内存的指针是`i8*`类型，但要存储`i32`类型的值，我们需要创建一个`bitcast`指令来强制转换该类型，如下所示：

    ```cpp
        Value *PayloadPtr =        Builder.CreateBitCast(EH, Int32PtrTy);
        Builder.CreateStore(        ConstantInt::get(Int32Ty, PayloadVal, true),
            PayloadPtr);
    ```

8.  最后，我们通过调用 `__cxa_throw`函数引发异常。 由于此函数实际上引发了一个异常，该异常也在同一函数中得到处理，因此我们需要使用`invoke`指令而不是`call`指令。 与`call`指令不同，`invoke`指令结束一个基本块，因为它有两个后续的基本块。 这里，这些是`UnreachableBB`和`LPadBB`基本块。 如果该函数没有引发异常，则控制流被转移到`UnreachableBB`基本块。 由于`__cxa_throw()`函数的设计，这种情况永远不会发生。 控制流被转移到`LPadBB`基本块来处理异常。 这就完成了`addThrow()`方法的实现，如下面的代码片段所示：

    ```cpp
        Builder.CreateInvoke(
            ThrowEHFty, ThrowEHFn, UnreachableBB, LPadBB,
            {EH, ConstantExpr::getBitCast(TypeInfo, 
             Int8PtrTy),
             ConstantPointerNull::get(Int8PtrTy)});
      }
    ```

接下来，我们添加代码以生成处理异常的 IR。

## 捕获异常

为了生成捕获异常的IR 代码，我们添加了一个`addLandingPad()`方法。 生成的 IR 从异常中提取类型信息。 如果它与 C++ `int`类型匹配，则通过将`Divide by zero!`输出到控制台并从函数返回来处理异常。 如果类型不匹配，我们只需执行一条`resume`指令，该指令将控制权传回运行时。 因为调用层次结构中没有其他函数来处理此异常，所以运行库将终止应用。 以下是生成 IR 以捕获异常所需的步骤：

1.  在生成的 IR 中，我们需要从 C++ 运行时库中调用`__cxa_begin_catch()`和`_cxa_end_catch()`函数。 要打印错误消息，我们将从 C 运行时库生成对`puts()`函数的调用，要从异常获取类型信息，我们必须生成对`llvm.eh.typeid.for`本征函数的调用。 我们需要所有它们的`FunctionType`和`Function`实例，并利用我们的`createFunc()`方法创建它们，如下所示：

    ```cpp
      void addLandingPad() {
        FunctionType *TypeIdFty; Function *TypeIdFn;
        createFunc(TypeIdFty, TypeIdFn,
                   "llvm.eh.typeid.for", Int32Ty,
                   {Int8PtrTy});
        FunctionType *BeginCatchFty; Function 
            *BeginCatchFn;
        createFunc(BeginCatchFty, BeginCatchFn,
                   "__cxa_begin_catch", Int8PtrTy,
                   {Int8PtrTy});
        FunctionType *EndCatchFty; Function *EndCatchFn;
        createFunc(EndCatchFty, EndCatchFn,
                   "__cxa_end_catch", VoidTy);
        FunctionType *PutsFty; Function *PutsFn;
        createFunc(PutsFty, PutsFn, "puts", Int32Ty,
                   {Int8PtrTy});
    ```

2.  `landingpad`指令是我们生成的第一条指令。 结果类型是包含`i8*`和`i32`类型的字段的结构。 此结构是通过调用`StructType::get()`函数生成的。 我们处理 C++ `int`类型的异常，必须将其作为子句添加到`landingpad`指令中。 子句必须是`i8*`类型的常量，因此我们需要生成一条`bitcast`指令来将`TypeInfo`值转换为该类型。 我们将指令返回的值存储在`Exc`变量中以供以后使用，如下所示：

    ```cpp
        LandingPadInst *Exc = Builder.CreateLandingPad(
            StructType::get(Int8PtrTy, Int32Ty), 1, "exc");
        Exc->addClause(ConstantExpr::getBitCast(TypeInfo, 
                       Int8PtrTy));
    ```

3.  接下来，我们从返回值中提取类型选择器。 通过调用`llvm.eh.typeid.for`内部函数，我们检索`TypeInfo`字段的类型 ID，表示 C++ `int`类型。 有了这个 IR，我们现在已经生成了需要比较的两个值，以确定是否可以处理异常，如下面的代码片段所示：

    ```cpp
        Value *Sel = Builder.CreateExtractValue(Exc, {1},                  "exc.sel");
        CallInst *Id =
            Builder.CreateCall(TypeIdFty, TypeIdFn,
                               {ConstantExpr::getBitCast(
                                   TypeInfo, Int8PtrTy)});
    ```

4.  要生成比较的 IR，我们调用`createICmpEq()`函数。 此函数还生成两个基本块，我们将它们存储在`TrueDest`和`FalseDest`变量中，如以下代码片段所示：

    ```cpp
        BasicBlock *TrueDest, *FalseDest;
        createICmpEq(Sel, Id, TrueDest, FalseDest, 
                     "match",
                     "resume");
    ```

5.  如果两个值不匹配，则控制流从`FalseDest`基本块继续。 这个基本块只包含一条`resume`指令，将控制权交还给 C++ 运行时。 下面的代码片段说明了这一点：

    ```cpp
        Builder.SetInsertPoint(FalseDest);
        Builder.CreateResume(Exc);
    ```

6.  如果这两个值相等，则控制流从`TrueDest`基本块继续。 我们首先生成 IR 代码，以便从存储在`Exc`变量中的`landingpad`指令的返回值中提取指向异常的指针。 然后，我们生成对`__cxa_begin_catch ()`函数的调用，将指向异常的指针作为参数传递。 这表示异常开始被处理到运行库，如以下代码片段所示：

    ```cpp
        Builder.SetInsertPoint(TrueDest);
        Value *Ptr =
            Builder.CreateExtractValue(Exc, {0}, 
                "exc.ptr");
        Builder.CreateCall(BeginCatchFty, BeginCatchFn,
                           {Ptr});
    ```

7.  我们通过调用`puts()`函数来处理异常，以便将消息打印到控制台。 为此，我们首先通过调用`CreateGlobalStringPtr()`函数生成一个指向字符串的指针，然后在生成的调用中将该指针作为参数传递给`puts()`函数，如下所示：

    ```cpp
        Value *MsgPtr = Builder.CreateGlobalStringPtr(
            "Divide by zero!", "msg", 0, M);
        Builder.CreateCall(PutsFty, PutsFn, {MsgPtr});
    ```

8.  这样就完成了对异常的处理，并且我们生成了对`__cxa_end_catch()`函数的调用，以通知运行时有关该异常的信息。 最后，我们从函数返回一条`ret`指令，如下所示：

    ```cpp
        Builder.CreateCall(EndCatchFty, EndCatchFn);
        Builder.CreateRet(Int32Zero);
      }
    ```

使用`addThrow()`和`addLandingPad()`函数，我们可以生成 IR 以引发异常并处理异常。 我们仍然需要添加 IR 来检查除数是否为`0`，这是下一节的主题。

## 将异常处理代码集成到应用中

在`visit(BinaryOp&)`方法内生成除法的 IR。 我们不是只生成`sdiv`指令，而是首先生成 IR 以将除数与`0`进行比较。 如果除数是`0`，则控制流在引发异常的基本块中继续。 否则，控制流在带有`sdiv`指令的基本块中继续。 在`createICmpEq()`和`addThrow()`函数的帮助下，我们可以非常容易地对此进行编码，如下所示：

```cpp
    case BinaryOp::Div:
      BasicBlock *TrueDest, *FalseDest;
      createICmpEq(Right, Int32Zero, TrueDest,
                   FalseDest, "divbyzero", "notzero");
      Builder.SetInsertPoint(TrueDest);
      addThrow(42); // Arbitrary payload value.
      Builder.SetInsertPoint(FalseDest);
      V = Builder.CreateSDiv(Left, Right);
      break;
```

代码生成部分现在已经完成。 要构建应用，请切换到`build`目录并运行`ninja`工具，如下所示：

```cpp
$ ninja
```

构建完成后，您可以检查生成的 IR-例如，使用`with a: 3/a`表达式，如下所示：

```cpp
$ src/calc "with a: 3/a"
```

您将看到引发和捕获异常所需的额外 IR。

生成的 IR 现在取决于 C++ 运行时。 链接到所需库的最简单方法是使用 clang++ 编译器。 使用表达式计算器的运行时函数将`rtcalc.c`文件重命名为`rtcalc.cpp`，并在文件内的每个函数前面添加`extern "C"`。 然后，我们可以使用`llc`工具将生成的 IR 转换为目标文件，并使用 clang++ 编译器创建可执行文件，如下所示：

```cpp
$ src/calc "with a: 3/a" | llc -filetype obj -o exp.o
$ clang++ -o exp exp.o ../rtcalc.cpp
```

然后，我们可以使用不同的值运行生成的应用，如下所示：

```cpp
$ ./exp
Enter a value for a: 1
The result is: 3
$ ./exp
Enter a value for a: 0
Divide by zero!
```

在第二次运行中，输入是`0`，这会引发异常。 它就像预期的那样工作！

我们已经学会了如何引发和捕获异常。 生成 IR 的代码可以作为其他编译器的蓝图。 当然，使用的类型信息和`catch`子句的数量取决于编译器的输入，但我们需要生成的 IR 仍然遵循本节中给出的模式。

添加元数据是向 LLVM 提供更多信息的一种方式。 在下一节中，我们将添加类型元数据，以在某些情况下支持 LLVM 优化器。

# 为基于类型的别名分析生成元数据

两个指针可能指向相同的内存单元，然后它们会彼此别名。 LLVM 模型中没有内存类型，这使得优化器很难确定两个指针是否相互别名。 如果编译器能够证明两个指针不会彼此别名，那么就有可能进行更多的优化。 在下一节中，在实现此方法之前，我们将更仔细地研究问题，并调查添加其他元数据会有什么帮助。

## 了解对附加元数据的需求

为了演示问题，让我们看一下下面的函数：

```cpp
void doSomething(int *p, float *q) {
  *p = 42;
  *q = 3.1425;
} 
```

优化器无法确定`p`和`q`指针是否指向同一存储单元。 在优化期间，这是一个重要的分析，称为**别名分析**。 如果`p`和`q`指向相同的存储单元，则它们是别名。 如果优化器能够证明这两个指针永远不会彼此混淆，这将带来更多的优化机会。 例如，在`soSomething()`函数中，在这种情况下，可以在不改变结果的情况下对商店进行重新排序。

一种类型的变量是否可以是另一种类型的变量的别名取决于源语言的定义。 请注意，语言还可能包含违反基于类型的别名假设的表达式-例如，不相关类型之间的类型转换。

LLVM 开发人员选择的解决方案是向`load`和`store` 指令添加元数据。 元数据有两个目的，概述如下：

*   首先，它基于哪个类型可以作为另一个类型的别名来定义类型层次结构
*   其次，描述了`load`或`store`指令中的存储器访问

让我们看一下C 中的类型层次结构。每种层次结构类型都以根节点(名为的**或**匿名的**)开始。 LLVM 假设具有相同名称的根节点描述相同类型的层次结构。 您可以在相同的 LLVM 模块中使用不同的类型层次结构，并且 LLVM 假定这些类型可能有别名。 在根节点下面，有标量类型的节点。 聚合类型的节点不附加到根节点，但它们引用标量类型和其他聚合类型。 Clang 定义了 C 的层次结构，如下所示：**

*   根节点称为`Simple C/C++ TBAA`。
*   根节点下面是`char`类型的节点。 这是 C 中的一种特殊类型，因为所有指针都可以转换为指向`char`的指针。
*   在`char`节点下面是用于其他标量类型的节点和用于所有指针的类型，称为`any pointer`。

聚合类型定义为成员类型和偏移量的序列。

这些元数据定义用于附加到`load`和`store`指令的访问标记中。 访问标记由三部分组成：基本类型、访问类型和偏移量。 根据基类型的不同，访问标记有两种可能的方式描述内存访问，如下所示：

1.  如果基类型是聚合类型，则访问标签描述具有访问类型并且位于给定偏移量的`struct`成员的存储器访问。
2.  如果基类型是标量类型，则访问类型必须与基类型相同，偏移量必须为`0`。

有了这些定义，我们现在可以在访问标记上定义一个关系，该关系用于评估两个指针是否可以彼此别名。 元组的直接父级(基类型、偏移量)由基类型和偏移量确定，如下所示：

*   如果基类型为标量类型，且偏移量为 0，则直接父类型为(父类型，0)，其中父类型为类型层次中定义的父节点的类型。 如果偏移量不是 0，则未定义直接父级。
*   如果基类型是聚合类型，则元组(基类型，偏移量)的直接父级是元组(新类型，新偏移量)，新类型是偏移量上的成员的类型。 新偏移是新类型的偏移，调整为新起点。

此关系的传递闭包是父关系。 两个存储器访问类型(例如，(基类型 1，访问类型 1，偏移量 1)和(基类型 2，访问类型 2，偏移量 2))可以别名 IF(基类型 1，偏移量 1)和(基类型 2，偏移量 2)，反之亦然。

让我们用一个例子来说明这一点，如下所示：

```cpp
struct Point { float x, y; }
void func(struct Point *p, float *x, int *i, char *c) {
  p->x = 0; p->y = 0; *x = 0.0; *i = 0; *c = 0; 
}
```

使用前面标量类型的存储器访问标记定义，参数`i`的访问标记为(`int`，`int`，`0`)，参数`c`的访问标记为(`char`，`char`，`0`)。 在类型层次结构中，`int`类型的节点的父节点是`char`节点，因此(`int`，`0`)的直接父节点是(`char`，`0`)，并且两个指针都可以是别名。 参数`x`和参数`c`也是如此。 但是参数`x`和`i`不相关，因此它们不会彼此混淆。 `struct Point`的`y`成员的访问权限为(`Point`，`float`，`4`)，其中 4 是结构中`y`成员的偏移量。 (`Point`，`4`)的直系父是(`float`，`0`)，因此对`p->y`和`x`的访问可以是别名，并且-以相同的推理-也可以使用参数`c`。

为了创建元数据，我们使用在`llvm/IR/MDBuilder.h`头文件中声明的`llvm::MDBuilder`类。 数据本身存储在`llvm::MDNode`和`llvm::MDString`类的实例中。 使用构建器类可以保护我们不受构造内部细节的影响。

通过调用`createTBAARoot()`方法创建根节点，该方法期望类型层次结构的名称作为参数并返回根节点。 可以使用`createAnonymousTBAARoot()`方法创建匿名唯一根节点。

使用`createTBAAScalarTypeNode()`方法将标量类型添加到层次结构中，该方法将类型名称和父节点作为参数。 为聚合类型添加类型节点稍微复杂一些。 `createTBAAStructTypeNode()`方法将类型名称和字段列表作为参数。 这些字段以`std::pair<llvm::MDNode*, uint64_t>`实例的形式给出。 第一个元素指示成员的类型，第二个元素指示`struct`类型中的偏移量。

使用`createTBAAStructTagNode()`方法创建访问标记，该方法将基类型、访问类型和偏移量作为参数。

最后，元数据必须附加到`load`或`store`指令。 `llvm::Instruction`类有一个`setMetadata()`方法，用于添加各种元数据。 第一个参数必须是`llvm::LLVMContext::MD_tbaa`，第二个参数必须是访问标记。

有了这个知识，我们将在下一节中向`tinylang`添加用于**基于类型的别名分析**(**TBAA**)的元数据。

## 将 TBAA 元数据添加到 tinylang

为了支持TBAA，我们添加了一个新的`CGTBAA`类。 该类负责生成元数据节点。 我们使其成为`CGModule`类的成员，称之为`TBAA`。 每条`load`和`store`指令都可能被注释，我们还在`CGModule`类中为此目的放置了一个新函数。 该函数尝试创建标签访问信息。 如果成功，则将元数据附加到指令。 此设计还允许我们在不需要元数据生成时关闭元数据生成-例如，在关闭优化的构建中。 代码如以下代码片断所示：

```cpp
void CGModule::decorateInst(llvm::Instruction *Inst,
                            TypeDenoter *TyDe) {
  if (auto *N = TBAA.getAccessTagInfo(TyDe))
    Inst->setMetadata(llvm::LLVMContext::MD_tbaa, N);
}
```

我们将新`CGTBAA`类的声明放入`include/tinylang/CodeGen/CGTBAA.h`头文件，并将定义放入`lib/CodeGen/CGTBAA.cpp`文件。 除了抽象语法树(**AST**)定义之外，头文件还需要包括定义元数据节点和构建器的文件，如以下代码片段所示：

```cpp
#include "tinylang/AST/AST.h"
#include "llvm/IR/MDBuilder.h"
#include "llvm/IR/Metadata.h"
```

`CGTBAA`类需要存储一些数据成员。 那么，让我们一步一步来看看如何做到这一点，如下所示：

1.  首先，我们需要缓存类型层次结构的根，如下所示：

    ```cpp
     class CGTBAA {
      llvm::MDNode *Root;
    ```

2.  要构造元数据节点，我们需要`MDBuilder`类的一个实例，如下所示：

    ```cpp
      llvm::MDBuilder MDHelper;
    ```

3.  最后，我们存储为类型生成的元数据以供重用，如下所示：

    ```cpp
      llvm::DenseMap<TypeDenoter *, llvm::MDNode *> 
        MetadataCache;
    // …
    };
    ```

在定义了构造所需的变量之后，我们现在添加创建元数据所需的方法，如下所示：

1.  构造函数初始化数据成员，如下所示：

    ```cpp
    CGTBAA::CGTBAA(llvm::LLVMContext &Ctx)
          : MDHelper(llvm::MDBuilder(Ctx)), Root(nullptr) {}
    ```

2.  我们懒惰地实例化类型层次结构的根，我们将其命名为`Simple tinylang TBAA`，如以下代码片段所示：

    ```cpp
    llvm::MDNode *CGTBAA::getRoot() {
      if (!Root)
        Root = MDHelper.createTBAARoot("Simple tinylang                                    TBAA");
      return Root;
    }
    ```

3.  对于标量类型，我们在基于类型名称的`MDBuilder`类的帮助下，创建了一个元数据节点。 新的元数据节点存储在缓存中，如以下代码片段所示：

    ```cpp
    llvm::MDNode *
    CGTBAA::createScalarTypeNode(TypeDeclaration *Ty,
                                 StringRef Name,
                                 llvm::MDNode *Parent) {
      llvm::MDNode *N =
          MDHelper.createTBAAScalarTypeNode(Name, Parent);
      return MetadataCache[Ty] = N;
    }
    ```

4.  为记录创建元数据的方法更为复杂，因为我们必须枚举记录的所有字段。 代码如以下代码片段所示：

    ```cpp
    llvm::MDNode *CGTBAA::createStructTypeNode(
        TypeDeclaration *Ty, StringRef Name,
        llvm::ArrayRef<std::pair<llvm::MDNode *, 
            uint64_t>>
            Fields) {
      llvm::MDNode *N =
          MDHelper.createTBAAStructTypeNode(Name, Fields);
      return MetadataCache[Ty] = N;
    }
    ```

5.  要返回`tinylang`类型的元数据，我们需要创建类型层次结构。 因为`tinylang`的类型系统非常有限，所以我们可以使用一种简单的方法。 每个标量类型都映射到一个附加到根节点的唯一类型，我们将所有指针映射到一个类型。 然后，结构化类型引用这些节点。 如果无法映射类型，则返回`nullptr`，如下所示：

    ```cpp
    llvm::MDNode *CGTBAA::getTypeInfo(TypeDeclaration *Ty) {
      if (llvm::MDNode *N = MetadataCache[Ty])
        return N;
      if (auto *Pervasive =
              llvm::dyn_cast<PervasiveTypeDeclaration>(Ty)) {
        StringRef Name = Pervasive->getName();
        return createScalarTypeNode(Pervasive, Name, 
            getRoot());
      }
      if (auto *Pointer =
              llvm::dyn_cast<PointerTypeDeclaration>(Ty)) {
        StringRef Name = "any pointer";
        return createScalarTypeNode(Pointer, Name, 
            getRoot());
      }
      if (auto *Record =
              llvm::dyn_cast<RecordTypeDeclaration>(Ty)) {
        llvm::SmallVector<std::pair<llvm::MDNode *, 
            uint64_t>,
                          4>
            Fields;
        auto *Rec =
            llvm::cast<llvm::StructType>(              CGM.convertType(Record));
        const llvm::StructLayout *Layout =
            CGM.getModule()->getDataLayout()
                .getStructLayout(Rec);
        unsigned Idx = 0;
        for (const auto &F : Record->getFields()) {
          uint64_t Offset = Layout->getElementOffset(Idx);
          Fields.emplace_back(getTypeInfo(F.getType()), 
              Offset);
          ++ Idx;
        }
        StringRef Name = CGM.mangleName(Record);
        return createStructTypeNode(Record, Name, Fields);
      }
      return nullptr;
    }
    ```

6.  获取元数据的一般方法是`getAccessTagInfo()`。 因为我们只需要在中查找来查找指针类型，所以我们会检查它。 否则，我们返回`nullptr`，如以下代码片段所示：

    ```cpp
    llvm::MDNode *CGTBAA::getAccessTagInfo(TypeDenoter *TyDe) 
    {
      if (auto *Pointer = llvm::dyn_cast<PointerType>(TyDe)) 
      {
        return getTypeInfo(Pointer->getTyDen());
      }
      return nullptr;
    }
    ```

要启用 TBAA 元数据的生成，我们现在只需将元数据附加到我们生成的`load`和`store`指令。 例如，在存储到全局变量的`CGProcedure::writeVariable()`中，使用`store` 指令，如下所示：

```cpp
      Builder.CreateStore(Val, CGM.getGlobal(D));
```

要修饰该指令，我们需要将前面的行替换为以下行：

```cpp
      auto *Inst = Builder.CreateStore(Val,
                                       CGM.getGlobal(Decl));
      CGM.decorateInst(Inst, V->getTypeDenoter());
```

有了这些更改，我们就完成了 TBAA 元数据的生成。

在下一节中，我们将讨论一个非常相似的主题：调试元数据的生成。

# 添加调试元数据

要允许源代码级别的调试，我们必须添加调试信息。 LLVM 中对调试信息的支持使用调试元数据来描述源语言的类型和其他静态信息，并使用内在变量来跟踪变量值。 LLVM 核心库在 Unix 系统上以 DWARF 格式生成调试信息，在 Windows 上以**蛋白质数据库**(**PDB**)格式生成调试信息。 我们将在下一节中查看总体结构。

## 了解调试元数据的一般结构

为了描述静态结构，LLVM 使用元数据的方式与用于基于类型的分析的元数据类似。 静态结构描述文件、编译单元、函数、词块和使用的数据类型。

我们使用的主类是`llvm::DIBuilder`，我们需要使用`llvm/IR/DIBuilder`Include 文件来获取类声明。 这个构建器类提供了一个易于使用的接口来创建调试元数据。 元数据稍后会添加到 LLVM 对象(如全局变量)中，或者用于调用调试内部函数。 下面列出了生成器类可以创建的重要元数据：

*   `lvm::DIFile`：这使用包含文件的目录的文件名和绝对路径来描述文件。 您可以使用`createFile()`方法创建它。 文件可以包含主编译单元，也可以包含导入的声明。
*   `llvm::DICompileUnit`：用于描述当前编译单位。 在其他方面，您可以指定源语言、特定于编译器的生成器字符串、是否启用优化，当然还有编译单元所在的`DIFile`。 您可以通过调用`createCompileUnit()`来创建它。
*   `llvm::DISubprogram`：这描述了一个函数。 重要信息包括作用域(对于嵌套函数，通常为`DICompileUnit`或`DISubprogram`)、函数名称、损坏的函数名称和函数类型。 它是通过调用`createFunction()`创建的。
*   `llvm::DILexicalBlock`：这描述了一个对许多高级语言中的块作用域进行建模的词块。 您可以通过调用`createLexicalBlock()`来创建它。

LLVM 对您的编译器翻译的语言没有任何假设。 因此，它没有关于该语言的数据类型的信息。 若要支持源代码级别的调试，特别是在调试器中显示变量值，还必须添加类型信息。 下面列出了重要的构件：

*   `createBasicType()`函数返回指向`llvm::DIBasicType`类的指针，创建描述基本类型(如`tinylang`中的`INTEGER`或 C++ 中的`int`)的元数据。 除了类型的名称，需要的参数是位大小和编码-例如，它是有符号类型还是无符号类型。
*   有几种方法可以构造复合数据类型的元数据，由`llvm::DIComposite`类表示。 您可以使用`createArrayType()`、`createStructType()`、`createUnionType()`和`createVectorType()`函数来实例化`array`、`struct`、`union`和`vector`数据类型的元数据。 这些函数需要您期望的参数-例如，数组类型的基本类型和订阅数量，或者`struct`类型的字段成员列表。
*   还有一些方法可以支持枚举、模板、类等。

函数列表显示您必须将源语言的每一个细节添加到调试信息中。 让我们假设您的`llvm::DIBuilder`类的实例名为`DBuilder`。 进一步假设您在`/home/llvmuser`文件夹中名为`File.mod`的文件中有一些`tinylang`源文件。 文件内部的*行 5*处有一个`Func():INTEGER`函数，该函数在*行 7*处包含一个`VAR i:INTEGER`局部声明。 让我们为此创建元数据，从文件的信息开始。 您需要指定文件所在文件夹的文件名和绝对路径，如以下代码片段所示：

```cpp
llvm::DIFile *DbgFile = DBuilder.createFile("File.mod",
                                            "/home/llvmuser"); 
```

该文件是`tinylang`中的一个模块，因此是 LLVM 的编译单元。 它携带大量的信息，如下面的代码片段所示：

```cpp
bool IsOptimized = false;
llvm::StringRef CUFlags;
unsigned ObjCRunTimeVersion = 0;
llvm::StringRef SplitName;
llvm::DICompileUnit::DebugEmissionKind EmissionKind =
      llvm::DICompileUnit::DebugEmissionKind::FullDebug;
llvm::DICompileUnit *DbgCU = DBuilder.createCompileUnit(
      llvm::dwarf::DW_LANG_Modula2, DbgFile, „tinylang",
      IsOptimized, CUFlags, ObjCRunTimeVersion, SplitName,
      EmissionKind);
```

调试器需要知道源语言。 DWARF 标准定义了具有所有公共值的枚举。 缺点是您不能简单地添加一种新的源语言。 要做到这一点，你必须通过矮人委员会创建一个请求。 请注意，调试器和其他调试工具也需要支持新语言-仅向枚举中添加新成员是不够的。

在许多情况下，选择一种接近源语言的语言就足够了。 在`tinylang`的情况下，这是模-2，我们使用`DW_LANG_Modula2`来识别语言。 编译单元驻留在一个文件中，该文件由我们之前创建的`DbgFile`变量标识。 调试信息可以携带关于生产者的信息。 这可以是编译器的名称和版本信息。 在这里，我们只传递一个`tinylang`字符串。 如果您不想添加此信息，则只需使用空字符串作为参数即可。

下一组信息包括一个`IsOptimized`标志，它应该指示编译器是否打开了优化。 通常，此标志派生自`–O`命令行开关。 可以使用`CUFlags`参数将其他参数设置传递给调试器。 这里没有使用它，我们传递一个空字符串。 我们不使用 Objective-C，所以我们传递`0`作为 Objective-C 运行时版本。 通常，调试信息嵌入到我们正在创建的目标文件中。 如果我们想要将调试信息写入一个单独的文件，那么`SplitName`参数必须包含该文件的名称；否则，只传递一个空字符串。 最后，您可以定义应该发出的调试信息的级别。 默认设置是完整调试信息，由使用`FullDebug`枚举值指示。 如果只想发出行号，也可以选择`LineTablesOnly`值，如果根本不想发出调试信息，则可以选择`NoDebug`值。 对于后者，最好一开始就不要创建调试信息。

我们的极简主义源代码只使用`INTEGER`数据类型，这是一个有符号的 32 位值。 创建此类型的元数据非常简单，如以下代码片段所示：

```cpp
llvm::DIBasicType *DbgIntTy =
                       DBuilder.createBasicType("INTEGER", 32,
                                  llvm::dwarf::DW_ATE_signed);
```

要创建函数的调试元数据，我们必须首先创建签名的类型，然后创建函数本身的元数据。 这类似于为函数创建 IR。 函数的签名是一个数组，其中所有类型的参数按源代码顺序排列，函数的返回类型作为索引`0`处的第一个元素。 通常，此数组是动态构造的。 在我们的例子中，我们还可以静态构造元数据。 这对于内部函数非常有用-例如，用于模块初始化。 通常，这些函数的参数总是已知的，编译器编写者可以对它们进行硬编码。 代码如以下代码片断所示：

```cpp
llvm::Metadata *DbgSigTy = {DbgIntTy};
llvm::DITypeRefArray DbgParamsTy =
                      DBuilder.getOrCreateTypeArray(DbgSigTy);
llvm::DISubroutineType *DbgFuncTy =
                   DBuilder.createSubroutineType(DbgParamsTy);
```

我们的函数有一个`INTEGER`返回类型，没有其他参数，因此`DbgSigTy`数组只包含指向该类型的元数据的指针。 该静态数组被转换为类型数组，然后使用该类型数组创建函数的类型。

函数本身需要更多数据，如下所示：

```cpp
unsigned LineNo = 5;
unsigned ScopeLine = 5;
llvm::DISubprogram *DbgFunc = DBuilder.createFunction(
      DbgCU, "Func", "_t4File4Func", DbgFile, LineNo,
      DbgFuncTy, ScopeLine, 
      llvm::DISubprogram::FlagPrivate,
      llvm::DISubprogram::SPFlagLocalToUnit);
```

函数属于编译单元，在我们的例子中存储在`DbgCU`变量中。 我们需要在源文件中指定函数的名称，即`Func`，损坏的名称存储在目标文件中。 此信息有助于调试器稍后定位函数的机器码。 根据`tinylang`的规则，损坏的名称是`_t4File4Func`。 我们还必须指定包含该函数的文件。

乍一看，这听起来可能令人惊讶，但想想 C 和 C++ 中的包含机制：函数可以存储在不同的文件中，然后将该文件包含在主编译单元中的`#include`中。 在这里，情况并非如此，我们使用的文件与编译单元使用的文件相同。 接下来，传递函数的行号和函数类型。 函数的行号不能是函数词法范围开始的行号。 在这种情况下，您可以指定不同的`ScopeLine`。 函数也有保护，我们在这里使用`FlagPrivate`值指定保护，以指示私有函数。 对于公共和受保护功能，其他可能的值是`FlagPublic`和`FlagProtected`。

除了保护级别，这里还可以指定其他标志。 例如，`FlagVirtual`表示虚拟函数，`FlagNoReturn`表示函数不返回给调用方。 您可以在`llvm/include/llvm/IR/DebugInfoFlags.def`LLVM 包含文件中找到可能值的完整列表。 最后，可以指定特定于函数的标志。 最常用的是`SPFlagLocalToUnit`值，它表示该函数是该编译单元的本地函数。 经常使用的还有`MainSubprogram`值，表示该函数是应用的主要函数。 您还可以在前面提到的 LLVMinclude 文件中找到所有可能的值。

到目前为止，我们只创建了引用静态数据的元数据。 变量本质上是动态的，在下一节中，我们将探索如何将静态元数据附加到 IR 代码以访问变量。

## 跟踪变量及其值

为了有用，上一节中描述的类型元数据需要与源程序的变量相关联。 对于全局变量来说，这相当容易。 `llvm::DIBuilder`类的`createGlobalVariableExpression()`函数创建描述全局变量的元数据。 这包括源文件中变量的名称、损坏的名称、源文件等。 LLVM IR 中的全局变量由`GlobalVariable`类的实例表示。 该类有一个`addDebugInfo()`方法，该方法将从`createGlobalVariableExpression()`返回的元数据节点与全局变量关联起来。

对于局部变量，我们需要采取另一种方法。 LLVM IR 不知道表示局部变量的类；它只知道值。 LLVM 社区开发的解决方案是将对内部函数的调用插入到函数的 IR 代码中。 内在函数是 LLVM 知道的函数，因此可以对其进行一些魔术处理。 在大多数情况下，内部函数不会在计算机级别产生子例程调用。 在这里，函数调用是将元数据与值相关联的便捷工具。

调试元数据最重要的内部函数是`llvm.dbg.declare`和`llvm.dbg.value`。 前者被调用一次以声明局部变量的地址，而后者在局部变量被设置为新值时被调用。

未来的 LLVM 版本将用 llvm.dbg.addr 内在函数替换 llvm.dbg.ECLARE

`llvm.dbg.declare`内部函数做了一个非常强的假设：内部函数调用中描述的变量地址在函数的整个生存期内都是有效的。 这一假设使得在优化期间很难保留调试元数据，因为实际存储地址可能会改变。 为了解决这个问题，设计了一个新的内蕴函数`llvm.dbg.addr`。 此内在变量采用与`llvm.dbg.declare`相同的参数，但其语义不那么严格。 它仍然描述局部变量的地址，并且前端应该恰好生成对它的一次调用。

在优化过程中，传递可以用对`llvm.dbg.value`和/或`llvm.dbg.addr`的(可能是多个)调用替换此内在特性，以保留调试信息。

`llvm.dbg.declare`内部函数将被弃用，稍后在`llvm.dbg.addr`上的工作完成后将被删除。

它怎麽工作?。 LLVM IR 表示和通过`llvm::DIBuilder`类的编程创建略有不同，因此我们将两者都介绍一下。 继续上一节中的示例，我们使用`alloca`指令为`Func`函数内的`i`变量分配本地存储空间，如下所示：

```cpp
@i = alloca i32
```

之后，我们添加对`llvm.dbg.declare`内部函数的调用，如下所示：

```cpp
call void @llvm.dbg.declare(metadata i32* %i,
                        metadata !1, metadata 
                        !DIExpression())
```

第一个参数是局部变量的地址。 第二个参数是描述局部变量的元数据，通过调用`createAutoVariable()`表示局部变量或调用`createParameterVariable()`表示`llvm::DIBuilder`类的参数而创建。 第三个参数描述地址表达式，稍后将对其进行解释。

让我们实现 IR 创建。 通过调用`llvm::IRBuilder<>`类的`CreateAlloca()`方法为`@i`局部变量分配存储空间，如下所示：

```cpp
llvm::Type *IntTy = llvm::Type::getInt32Ty(LLVMCtx);
llvm::Value *Val = Builder.CreateAlloca(IntTy, nullptr, "i");
```

变量`LLVMCtx`是使用的上下文类，`Builder`是`llvm::IRBuilder<>`类的使用实例。

局部变量也需要用元数据来描述，如下所示：

```cpp
llvm::DILocalVariable *DbgLocalVar =
 DBuilder.createAutoVariable(DbgFunc, "i", DbgFile,
                             7, DbgIntTy);
```

使用上一节中的值，我们指定变量是`DbgFunc`函数的一部分，名称为`i`，在文件的*第 7*行定义为`DbgFile`，类型为`DbgIntTy`。

最后，我们使用`llvm.dbg.declare`内部函数将调试元数据与变量地址相关联。 使用`llvm::DIBuilder`可以避免添加呼叫的所有细节。 代码如以下代码片断所示：

```cpp
llvm::DILocation *DbgLoc =
                llvm::DILocation::get(LLVMCtx, 7, 5, 
                                      DbgFunc);
DBuilder.insertDeclare(Val, DbgLocalVar,
                       DBuilder.createExpression(), DbgLoc,
                       Val.getParent());
```

同样，我们必须指定变量的源位置。 `llvm::DILocation`的实例是一个容器，用于保存与作用域关联的位置的行和列。 `insertDeclare()`方法将对 LLVM IR 的内部函数的调用添加到 LLVM IR。 作为参数，它需要变量的地址(存储在`Val`中)和变量的调试元数据(存储在`DbgValVar`中)。 我们还传递一个空地址表达式和前面创建的调试位置。 与普通指令一样，我们需要指定将调用插入到哪个基本块中。 如果我们指定一个基本块，则在末尾插入调用。 或者，我们可以指定一条指令，然后在该指令之前插入调用。 我们有指向`alloca`指令的指针，这是我们插入底层基本块的最后一个指令。 因此，我们使用这个基本块，调用被附加在`alloca`指令之后。

如果局部变量的值发生变化，则必须将对`llvm.dbg.value`的调用添加到 IR 中。 您可以使用`llvm::DIBuilder`的`insertValue()`方法来完成此操作。 这对`llvm.dbg.addr`的工作原理与类似。 不同之处在于，现在指定的不是变量的地址，而是新值。

当我们实现函数的 IR 生成时，我们使用了一种高级算法，该算法主要使用值，避免为局部变量分配存储空间。 对于添加调试信息，这只意味着我们使用`llvm.dbg.value`的频率比您在 Clang 生成的 IR 中看到的要多得多。

如果变量没有专用存储空间，但属于更大的聚合类型，我们该怎么办？ 可能出现这种情况的一种情况是使用嵌套函数。 要实现对调用方堆栈帧的访问，您需要收集结构中所有使用的变量，并将指向此记录的指针传递给被调用的函数。 在被调用的函数内部，您可以引用调用方的变量，就像它们是函数的局部变量一样。 不同的是，这些变量现在是聚合的一部分。

在对`llvm.dbg.declare`的调用中，如果调试元数据描述了第一个参数所指向的整个内存，则使用空表达式。 如果它只描述了内存的一部分，那么您需要添加一个表达式，指示元数据应用于内存的哪一部分。 如果是嵌套框架，则需要计算框架中的偏移。 您需要访问`DataLayout`实例，您可以从要在其中创建 IR 代码的 LLVM 模块获取该实例。 如果将`llvm::Module`实例命名为`Mod`，则保存嵌套框架结构的变量将命名为`Frame`，类型为`llvm::StructType`，并且您可以访问框架的第三个成员。 这将为您提供成员的偏移量，如下面的代码片断所示：

```cpp
const llvm::DataLayout &DL = Mod->getDataLayout();
uint64_t Ofs = DL.getStructLayout(Frame)
               ->getElementOffset(3);
```

该表达式是从一系列操作中创建的。 若要访问帧的第三个成员，调试器需要将偏移量添加到基指针。 您需要创建一个数组和该信息-例如，以这种方式：

```cpp
llvm::SmallVector<int64_t, 2> AddrOps;
AddrOps.push_back(llvm::dwarf::DW_OP_plus_uconst);
AddrOps.push_back(Offset);
```

从该数组中，您可以创建一个表达式，然后将其传递给`llvm.dbg.declare`，而不是空表达式，如下所示：

```cpp
llvm::DIExpression *Expr = DBuilder.createExpression(AddrOps);
```

您不受此偏移操作的限制。 DWARF 知道许多不同的运算符，您可以创建相当复杂的表达式。 您可以在`llvm/include/llvm/BinaryFormat/Dwarf.def`LLVM 包含文件中找到完整的运算符列表。

现在，您可以为变量创建调试信息。 要使调试器能够跟踪源代码中的控制流，还需要提供行号信息，这是下一节的主题。

## 添加行号

调试器允许程序员逐行通过应用。 为此，调试器需要知道哪些机器指令属于源代码中的哪一行。 LLVM 允许将源位置添加到每条指令。 在上一节中，我们创建了`llvm::DILocation`类型的位置信息。 调试位置不仅包含行、列和作用域，还包含更多信息。 如果需要，可以指定此行内联到的作用域。 还可以指示此调试位置属于隐式代码-即前端已生成但不在源代码中的代码。

在将其附加到指令之前，我们必须将调试位置包装在`llvm::DebugLoc`对象中。 为此，只需将从`llvm::DILocation`类获得的位置信息传递给`llvm::DebugLoc`构造函数。 通过这种包装，LLVM 可以跟踪位置信息。 虽然源代码中的位置显然没有改变，但在优化过程中可以删除为源代码级别语句或表达式生成的机器码。 封装有助于处理这些可能的更改。

添加行号信息主要归结为从 AST 检索行号信息，并将其添加到生成的指令中。 `llvm::Instruction`类有`setDebugLoc()`方法，该方法将位置信息附加到指令。

在下一节中，我们将向`tinylang`编译器添加调试信息的生成。

## 向 tinylang 添加调试支持

我们将生成的调试元数据封装在新的`CGDebugInfo`类中。 我们将声明放入`tinylang/CodeGen/CGDebugInfo.h`头文件，将定义放入`tinylang/CodeGen/CGDebugInfo.cpp`文件。

`CGDebugInfo`类有五个重要成员。 我们需要引用模块`CGM`的代码生成器，因为我们需要将类型从 AST 表示转换为 LLVM 类型。 当然，我们还需要一个名为`DBuilder`的`llvm::DIBuilder`类实例，与前面的小节一样。 还需要指向编译单元实例的指针，我们将其存储在名为`CU`的成员中。

为了避免重复创建类型的调试元数据，我们还添加了一个映射来缓存此信息。 该成员称为`TypeCache`。 最后，我们需要一种管理作用域信息的方法，为此，我们基于`llvm::SmallVector<>`类创建了一个堆栈，称为`ScopeStack`。 因此，我们有以下代码：

```cpp
  CGModule &CGM;
  llvm::DIBuilder DBuilder;
  llvm::DICompileUnit *CU;
  llvm::DenseMap<TypeDeclaration *, llvm::DIType *>
      TypeCache;
  llvm::SmallVector<llvm::DIScope *, 4> ScopeStack;
```

`CGDebugInfo`类的以下方法都使用这些成员：

1.  首先，我们需要创建编译单元，这是在构造函数中完成的。 我们还在这里创建了一个包含编译单元的文件。 稍后，我们可以通过`CU`成员引用该文件。 构造函数的代码如以下代码片断所示：

    ```cpp
    CGDebugInfo::CGDebugInfo(CGModule &CGM)
        : CGM(CGM), DBuilder(*CGM.getModule()) {
      llvm::SmallString<128> Path(
          CGM.getASTCtx().getFilename());
      llvm::sys::fs::make_absolute(Path);
      llvm::DIFile *File = DBuilder.createFile(
          llvm::sys::path::filename(Path),
          llvm::sys::path::parent_path(Path));
      bool IsOptimized = false;
      unsigned ObjCRunTimeVersion = 0;
      llvm::DICompileUnit::DebugEmissionKind EmissionKind =
          llvm::DICompileUnit::DebugEmissionKind::FullDebug;
      CU = DBuilder.createCompileUnit(
          llvm::dwarf::DW_LANG_Modula2, File, "tinylang",
          IsOptimized, StringRef(), ObjCRunTimeVersion,
          StringRef(), EmissionKind);
    }
    ```

2.  通常，我们需要提供行号。 这可以从源管理器位置派生，其中是大多数 AST 节点可用的位置。 源代码管理器可以将其转换为行号，如下所示：

    ```cpp
    unsigned CGDebugInfo::getLineNumber(SMLoc Loc) {
      return CGM.getASTCtx().getSourceMgr().FindLineNumber(
          Loc);
    }
    ```

3.  有关作用域的信息保存在堆栈上。 我们需要用于打开和关闭作用域以及检索当前作用域的方法。 编译单位是全局作用域，我们会自动添加，如下所示：

    ```cpp
    llvm::DIScope *CGDebugInfo::getScope() {
      if (ScopeStack.empty())
        openScope(CU->getFile());
      return ScopeStack.back();
    }
    void CGDebugInfo::openScope(llvm::DIScope *Scope) {
      ScopeStack.push_back(Scope);
    }
    void CGDebugInfo::closeScope() {
      ScopeStack.pop_back();
    }
    ```

4.  我们为需要转换的类型的每个类别创建一个方法。 `getPervasiveType()`方法创建基本类型的调试元数据。 请注意，在下面的代码片段中使用了编码参数，将`INTEGER`类型声明为有符号类型，将`BOOLEAN`类型编码为布尔类型：

    ```cpp
    llvm::DIType *
    CGDebugInfo::getPervasiveType(TypeDeclaration *Ty) {
      if (Ty->getName() == "INTEGER") {
        return DBuilder.createBasicType(
            Ty->getName(), 64, llvm::dwarf::DW_ATE_signed);
      }
      if (Ty->getName() == "BOOLEAN") {
        return DBuilder.createBasicType(
            Ty->getName(), 1, 
                llvm::dwarf::DW_ATE_boolean);
      }
      llvm::report_fatal_error(
          "Unsupported pervasive type");
    }
    ```

5.  如果仅重命名类型名称，则将其映射到类型定义。 这里，我们需要首先使用作用域和行号信息，如下所示：

    ```cpp
    llvm::DIType *
    CGDebugInfo::getAliasType(AliasTypeDeclaration *Ty) {
      return DBuilder.createTypedef(
          getType(Ty->getType()), Ty->getName(),
          CU->getFile(), getLineNumber(Ty->getLocation()),
          getScope());
    }
    ```

6.  为数组创建调试信息需要有关大小和对齐的规范。 我们从`DataLayout`类检索此数据。 我们还需要指定数组的索引范围。 我们可以使用以下代码完成此操作：

    ```cpp
    llvm::DIType *
    CGDebugInfo::getArrayType(ArrayTypeDeclaration *Ty) {
      auto *ATy =
          llvm::cast<llvm::ArrayType>(CGM.convertType(Ty));
      const llvm::DataLayout &DL =
          CGM.getModule()->getDataLayout();
      uint64_t NumElements = Ty->getUpperIndex();
      llvm::SmallVector<llvm::Metadata *, 4> Subscripts;
      Subscripts.push_back(
          DBuilder.getOrCreateSubrange(0, NumElements));
      return DBuilder.createArrayType(
          DL.getTypeSizeInBits(ATy) * 8,
          DL.getABITypeAlignment(ATy),
          getType(Ty->getType()),
          DBuilder.getOrCreateArray(Subscripts));
    }
    ```

7.  使用所有这些单一方法，我们创建一个中央方法来创建类型的元数据。 该元数据还负责缓存数据。 代码可以在以下代码片段中看到：

    ```cpp
    llvm::DIType *
    CGDebugInfo::getType(TypeDeclaration *Ty) {
      if (llvm::DIType *T = TypeCache[Ty])
        return T;
      if (llvm::isa<PervasiveTypeDeclaration>(Ty))
        return TypeCache[Ty] = getPervasiveType(Ty);
      else if (auto *AliasTy =
                   llvm::dyn_cast<AliasTypeDeclaration>(Ty))
        return TypeCache[Ty] = getAliasType(AliasTy);
      else if (auto *ArrayTy =
                   llvm::dyn_cast<ArrayTypeDeclaration>(Ty))
        return TypeCache[Ty] = getArrayType(ArrayTy);
      else if (auto *RecordTy =
                   llvm ::dyn_cast<RecordTypeDeclaration>(
                       Ty))
        return TypeCache[Ty] = getRecordType(RecordTy);
      llvm::report_fatal_error("Unsupported type");
      return nullptr;
    }
    ```

8.  我们还需要添加一个方法来发出全局变量的元数据，如下所示：

    ```cpp
    void CGDebugInfo::emitGlobalVariable(
        VariableDeclaration *Decl,
        llvm::GlobalVariable *V) {
      llvm::DIGlobalVariableExpression *GV =
          DBuilder.createGlobalVariableExpression(
              getScope(), Decl->getName(), V->getName(),
              CU->getFile(),
              getLineNumber(Decl->getLocation()),
              getType(Decl->getType()), false);
      V->addDebugInfo(GV);
    }
    ```

9.  要发出过程的调试信息，我们首先需要创建过程类型的元数据。 为此，我们需要一个参数类型列表，其中返回类型是第一个条目。 如果过程没有返回类型，则使用名为`void`的未指定类型，如 C。如果参数是引用，则需要添加引用类型；否则，将类型添加到列表中。 代码如以下代码片断所示：

    ```cpp
    llvm::DISubroutineType *
    CGDebugInfo::getType(ProcedureDeclaration *P) {
      llvm::SmallVector<llvm::Metadata *, 4> Types;
      const llvm::DataLayout &DL =
          CGM.getModule()->getDataLayout();
      // Return type at index 0
      if (P->getRetType())
        Types.push_back(getType(P->getRetType()));
      else
        Types.push_back(
            DBuilder.createUnspecifiedType("void"));
      for (const auto *FP : P->getFormalParams()) {
        llvm::DIType *PT = getType(FP->getType());
        if (FP->isVar()) {
          llvm::Type *PTy = CGM.convertType(FP->getType());
          PT = DBuilder.createReferenceType(
              llvm::dwarf::DW_TAG_reference_type, PT,
              DL.getTypeSizeInBits(PTy) * 8,
              DL.getABITypeAlignment(PTy));
        }
        Types.push_back(PT);
      }
      return DBuilder.createSubroutineType(
          DBuilder.getOrCreateTypeArray(Types));
    }
    ```

10.  对于过程本身，我们现在可以使用上一步中创建的过程类型创建调试信息。 过程还会打开一个新的作用域，因此我们将该过程推入作用域堆栈。 我们还将 LLVM 函数对象与新的调试信息相关联，如下所示：

    ```cpp
    void CGDebugInfo::emitProcedure(
        ProcedureDeclaration *Decl, llvm::Function *Fn) {
      llvm::DISubroutineType *SubT = getType(Decl);
      llvm::DISubprogram *Sub = DBuilder.createFunction(
          getScope(), Decl->getName(), Fn->getName(),
          CU->getFile(), getLineNumber(Decl->getLocation()),
          SubT, getLineNumber(Decl->getLocation()),
          llvm::DINode::FlagPrototyped,
          llvm::DISubprogram::SPFlagDefinition);
      openScope(Sub);
      Fn->setSubprogram(Sub);
    }
    ```

11.  当过程结束时，我们必须通知构建器完成此过程的调试信息的构造。 我们还需要从作用域堆栈中删除该过程。 我们可以使用以下代码完成此操作：

    ```cpp
    void CGDebugInfo::emitProcedureEnd(
        ProcedureDeclaration *Decl, llvm::Function *Fn) {
      if (Fn && Fn->getSubprogram())
        DBuilder.finalizeSubprogram(Fn->getSubprogram());
      closeScope();
    }
    ```

12.  最后，添加完调试信息后，我们需要将`finalize()`方法添加到构建器中。 然后验证生成的调试信息。 这是开发过程中的重要一步，因为它可以帮助您找到错误生成的元数据。 代码可以在以下代码片段中看到：

    ```cpp
    void CGDebugInfo::finalize() { DBuilder.finalize(); }
    ```

仅当用户请求时才应生成调试信息。 为此，我们需要一个新的命令行开关。 我们将把它添加到`CGModule`类的文件中，并且还将在这个类中使用它，如下所示：

```cpp
static llvm::cl::opt<bool>
    Debug("g", llvm::cl::desc("Generate debug information"),
          llvm::cl::init(false));
```

`CGModule`类包含`std::unique_ptr<CGDebugInfo>`类的一个实例。 关于命令行开关的设置，指针在构造函数中初始化，如下所示：

```cpp
  if (Debug)
    DebugInfo.reset(new CGDebugInfo(*this));
```

在 getter 方法中，我们返回指针，如下所示：

```cpp
CGDebugInfo *getDbgInfo() {
  return DebugInfo.get();
}
```

生成调试元数据时的一种常见模式是检索指针并检查它是否有效。 例如，在我们创建了一个全局变量之后，我们以这种方式添加调试信息：

```cpp
VariableDeclaration *Var = …;
llvm::GlobalVariable *V = …;
if (CGDebugInfo *Dbg = getDbgInfo())
  Dbg->emitGlobalVariable(Var, V);
```

为了添加行号信息，我们需要在`CGDebugInfo`类中添加一个`getDebugLoc()`转换方法，将 AST 中的位置信息转换为调试元数据，如下所示：

```cpp
llvm::DebugLoc CGDebugInfo::getDebugLoc(SMLoc Loc) {
  std::pair<unsigned, unsigned> LineAndCol =
      CGM.getASTCtx().getSourceMgr().getLineAndColumn(Loc);
  llvm::DILocation *DILoc = llvm::DILocation::get(
      CGM.getLLVMCtx(), LineAndCol.first, LineAndCol.second,
      getCU());
  return llvm::DebugLoc(DILoc);
}
```

然后可以调用`CGModule`类中的实用程序函数将行号信息添加到指令中，如下所示：

```cpp
void CGModule::applyLocation(llvm::Instruction *Inst,
                             llvm::SMLoc Loc) {
  if (CGDebugInfo *Dbg = getDbgInfo())
    Inst->setDebugLoc(Dbg->getDebugLoc(Loc));
}
```

通过这种方式，您可以为您自己的编译器添加调试信息。

# 摘要

在本章中，您了解了如何在 LLVM 中抛出和捕获异常，以及需要生成哪些 IR 代码来利用此功能。 为了扩大 IR 的范围，您了解了如何将各种元数据附加到指令。 基于类型的别名的元数据为 LLVM 优化器提供附加信息，并帮助进行某些优化以生成更好的机器代码。 用户总是喜欢使用源代码级调试器的可能性，并且通过向 IR 代码添加调试信息，您能够提供编译器的这一重要功能。

优化 IR 代码是 LLVM 的核心任务。 在下一章中，我们将学习 PASS 管理器是如何工作的，以及我们如何影响 PASS 管理器管理的优化管道。