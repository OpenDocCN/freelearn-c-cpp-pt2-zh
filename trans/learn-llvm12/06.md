# *第 6 章*：高级语言构造的 IR 生成

今天的高级语言通常使用聚合数据类型和**面向对象编程**(**OOP**)构造。 **LLVM IR**对聚合数据类型有一些支持，我们必须自己实现类等 OOP 结构。 添加聚合类型会引发聚合类型的参数是如何传递的问题。 不同的平台有不同的规则，这也反映在 IR 上。 遵守调用约定可确保可以调用系统函数。

在本章中，您将学习如何转换聚合数据类型和指向 LLVM IR 的指针，以及如何以系统兼容的方式将参数传递给函数。 您还将学习如何在 LLVM IR 中实现类和虚拟函数。

本章将介绍以下主题：

*   使用数组、结构和指针
*   获得正确的应用程序二进制接口
*   为类和虚函数创建 IR 代码

在本章结束时，您将获得为聚合数据类型和 OOP 创建 LLVM IR 的知识。 您还将了解如何根据平台规则传递聚合数据类型。

# 技术要求

本章的代码文件位于[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter06/tinylang](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter06/tinylang)

您可以在[https://bit.ly/3nllhED](https://bit.ly/3nllhED)上找到动作视频中的代码。

# 使用数组、结构和指针

对于几乎所有的个应用程序，像这样的基本类型是不够的。 例如，要表示矩阵或复数等数学对象，必须基于现有数据类型构造个新数据个类型。 这些新数据类型通常称为**聚合**或**复合类型**。

**数组**是相同类型的元素的序列。 在 LLVM 中，数组始终是静态的：元素的数量是恒定的。 `ARRAY [10] OF INTEGER`的`tinylang`类型或`long[10]`的 C 类型用 IR 表示如下：

```cpp
[10 x i64]
```

结构是不同类型的复合材料。 在编程语言中，它们通常用命名成员表示。 例如，在`tinylang`中，结构被写为`RECORD x, y: REAL; color: INTEGER; END;`，而在 C 中相同的结构被写为`struct { float x, y; long color; };`。 在 LLVM IR 中，仅列出类型名称：

```cpp
{ float, float, i64 }
```

要访问成员，需要使用数字索引。 与数组类似，第一个元素的索引号为`0`。

此结构的成员根据数据布局字符串中的规范在内存中布局。 如有必要，将插入未使用的填充字节。 如果需要控制内存布局，则可以使用压缩结构，其中所有元素都具有 1 字节对齐。 语法略有不同：

```cpp
<{ float, float, i64 }>
```

加载到寄存器中的数组和结构被视为一个单元。 例如，不可能将`%x`数组值寄存器的单个元素称为`%x[3]`。 这是由于**SSA**表单所致，因为无法区分`%x[i]`和`%x[j]`是否引用同一元素。 相反，我们需要特殊的指令来提取单个元素的值并将其插入到数组中。 要读取第二个元素，我们使用以下内容：

```cpp
%el2 = extractvalue [10 x i64] %x, 1
```

我们还可以更新元素，例如，第一个元素：

```cpp
%xnew = insertvalue [10 x i64] %x, i64 %el2, 0
```

这两个说明也适用于结构。 例如，要从`%pt`寄存器访问`color`成员，请编写以下代码：

```cpp
%color = extractvalue { float, float, i64 } %pt, 2
```

这两条指令都有一个重要限制：索引必须是常量。 对于结构而言，这很容易解释。 索引号只是名称的替代品，像 C 这样的语言没有动态计算结构成员名称的概念。 对于数组来说，很简单，它不能有效地实现。 当元素数量较少且已知时，这两条指令在特定情况下都有价值。 例如，复数可以建模为两个浮点数的数组。 传递该数组是合理的，并且在计算期间必须访问该数组的哪部分总是很清楚的。

对于前端的一般用途，我们必须求助于指向内存的指针。 LLVM 中的所有全局值都表示为指针。 让我们将全局变量`@arr`声明为八个`i64`元素的数组，相当于`long arr[8]`C 声明：

```cpp
@arr = common global [8 x i64] zeroinitializer
```

要访问数组的第二个元素，必须执行地址计算以确定索引元素的地址。 然后，可以从该地址加载值。 将放入`@second`函数，此如下所示：

```cpp
define i64 @second() {
  %1 = getelementptr [8 x i64], [8 x i64]* @arr, i64 0, i64 
       1
  %2 = load i64, i64* %1
  ret i64 %2
}
```

`getelementptr`指令是地址计算的主力。 因此，它需要更多的解释。 第一个操作数`[8 x i64]`是指令正在操作的基类型。 第二个操作数`[8 x i64]* @arr`指定基指针。 请注意这里的细微差别：我们声明了一个由 8 个元素组成的数组，但因为所有全局值都被视为指针，所以我们有一个指向该数组的指针。 在 C 语法中，我们使用`long (*arr)[8]`！ 结果是，我们必须先取消引用指针，然后才能索引元素，例如 C 中的`arr[0][1]`。第三个操作数`i64 0`取消引用指针，第四个操作数`i64 1`是元素索引。 此计算的结果是索引元素的地址。 请注意，此指令不会影响内存。

除结构外，索引参数不需要是常量。 因此，可以在循环中使用`getelementptr`指令来检索数组的元素。 这里对待结构的方式不同：只能使用常量，并且类型必须是`i32`。

有了这些知识，就可以很容易地将数组集成到代码生成器中，该代码生成器来自[*第 5 章*](05.html#_idTextAnchor079)，*IR 生成基础*。 必须扩展`convertType()`方法才能创建类型。 如果`Arr`变量包含数组的类型指示符，那么我们可以向该方法添加以下内容：

```cpp
llvm::Type *Component = convertType(Arr->getComponentType());
uint64_t NumElements = Arr->getNumElem();
return llvm::ArrayType::get(Component, NumElements);
```

此类型可以用于声明全局变量。 对于个局部变量，我们需要为数组分配内存。 我们在该过程的第一个基本块中执行此操作：

```cpp
for (auto *D : Proc->getDecls()) {
  if (auto *Var =
          llvm::dyn_cast<VariableDeclaration>(D)) {
    llvm::Type *Ty = mapType(Var);
    if (Ty->isAggregateType()) {
      llvm::Value *Val = Builder.CreateAlloca(Ty);
      Defs.Defs.insert(
          std::pair<Decl *, llvm::Value *>(Var, Val));
    }
  }
}
```

要读写元素，我们必须生成`getelemtptr`指令。 它被添加到`emitExpr()`(读取值)和`emitAssign()`(写入值)方法中。 要读取数组的元素，首先读取变量的值。 然后处理变量的选择器。 对于每个索引，计算表达式并存储值。 根据该列表，计算引用元素的地址，并加载值：

```cpp
auto &Selectors = Var->getSelectorList();
for (auto *I = Selectors.begin(),
          *E = Selectors.end();
     I != E;) {
  if (auto *Idx = llvm::dyn_cast<IndexSelector>(*I)) {
    llvm::SmallVector<llvm::Value *, 4> IdxList;
    IdxList.push_back(emitExpr(Idx->getIndex()));
    for (++ I; I != E;) {
      if (auto *Idx2 =
              llvm::dyn_cast<IndexSelector>(*I)) {
        IdxList.push_back(emitExpr(Idx2->getIndex()));
        ++ I;
      } else
        break;
    }
    Val = Builder.CreateGEP(Val, IdxList);
    Val = Builder.CreateLoad(
        Val->getType()->getPointerElementType(), Val);
  } else {
    llvm::report_fatal_error("Unsupported selector");
  }
}
```

写入数组元素使用相同的代码，不同之处在于不生成`load`指令。 相反，您可以使用指针作为`store`指令中的目标。 对于记录，您可以使用类似的方法。 记录成员的选择器包含名为`Idx`的常量字段索引。 您可以使用以下内容将此常量转换为常量 LLVM 值：

```cpp
llvm::Value *FieldIdx = llvm::ConstantInt::get(Int32Ty, Idx);
```

然后，您可以像使用数组一样在`Builder.CreateGEP()`方法中使用值。

现在您已经掌握了将聚合数据类型转换为 LLVM IR 的知识。 以与系统兼容的方式传递那些类型的值需要注意，您将在下一节中学习如何正确实现它。

# 获得正确的应用程序二进制接口

通过向代码生成器添加最新的数组和记录，您可能会注意到，有时生成的代码不能按预期执行。 原因是到目前为止我们忽略了平台的调用约定。 每个平台都定义了自己的规则，说明一个函数如何调用同一程序或库中的另一个函数。 这些规则在**应用程序二进制接口**(**ABI**)文档中总结。 典型信息包括以下内容：

*   机器寄存器是否用于参数传递？ 如果是，是哪一个？
*   聚合(如数组和结构)如何传递给函数？
*   如何处理返回值？

目前使用的规则种类繁多。 在某些平台上，聚合始终是间接传递的，这意味着聚合的副本被放在堆栈上，并且只将指向该副本的指针作为参数传递。 在其他平台上，在寄存器中传递较小的聚合(例如 128 位或 256 位宽)，并且仅在该阈值以上才使用间接参数传递。 一些平台还使用浮点和向量寄存器进行参数传递，而其他平台则要求在整数寄存器中传递浮点值。

当然，这些都是有趣的、低级的东西。 不幸的是，它泄露到了 LLVM IR 中。 起初，这是令人惊讶的。 毕竟，我们在 LLVM IR 中定义了函数的所有参数的类型！ 事实证明，这是不够的。 为了理解这一点，让我们考虑一下复数。 一些语言具有用于复数的内置数据类型；例如，C99 有`float _Complex`(以及其他)。 较早版本的 C 没有复数类型，但您可以轻松地定义`struct Complex { float re, im; }`并在此类型上创建算术运算。 这两种类型都可以映射到`{ float, float }`LLVM IR 类型。 如果 ABI 现在声明内置复数类型的值在两个浮点寄存器中传递，但用户定义的聚合始终是间接传递的，则该函数提供的信息不足以让 LLVM 决定如何传递此特定参数。 不幸的是，我们需要向 LLVM 提供更多信息，而这些信息是高度特定于 ABI 的。

有两种方式可以将此信息指定给 LLVM：参数属性和类型重写。 您需要使用什么取决于目标平台和代码生成器。 最常用的参数属性如下：

*   `inreg`指定参数在寄存器中传递。
*   `byval`指定按值传递参数。 参数必须是指针类型。 指向的数据生成隐藏副本，该指针被传递给被调用的函数。
*   `zeroext`和`signext`指定传递的整数值应为零扩展或符号扩展。
*   `sret`指定此参数保存指向用于从函数返回聚合类型的内存的指针。

虽然所有代码生成器都支持`zeroext`、`signext`和`sret`属性，但只有一些代码生成器支持`inreg`和`byval`。 可以使用`addAttr()`方法将属性添加到函数的参数中。 例如，要设置`Arg`参数的`inreg`属性，可以调用以下代码：

```cpp
Arg->addAttr(llvm::Attribute::InReg);
```

要设置多个属性，可以使用`llvm::AttrBuilder`类。

提供附加信息的另一种方式是使用类型重写。 使用这种方法，您可以隐藏原始类型。 您可以执行以下操作：

*   拆分参数；例如，您可以传递两个浮点参数，而不是传递一个复杂参数。
*   将参数转换为不同的表示形式，例如，将大小为 64 位或更小的结构转换为`i64`整数。

要在不更改值的位的情况下在类型之间进行转换，可以使用`bitcast`指令。 `bitcast`指令不对聚合类型进行操作，但这不是限制，因为您始终可以使用指针。 如果一个点被建模为具有两个`int`成员的结构，在 LLVM 中表示为类型`{ i32, i32 }`，则可以通过以下方式将其表示为`bitcast`到`i64`：

```cpp
%intpoint = bitcast { i32, i32}* %point to i64*
```

这会将指向结构的指针转换为指向`i64`整数值的指针。 随后，您可以加载此值并将其作为参数传递。 您只需确保这两个类型的大小相同。

向参数添加属性或更改类型并不复杂。 但是你怎么知道你需要实现什么呢？ 首先，您应该对目标平台上使用的调用约定有一个概述。 例如，针对每个支持的 CPU 平台记录了 Linux 上的 ELF ABI。 只要查一下这份文件，让你自己放心就行了。 有关于 LLVM 代码生成器要求的文档。 信息源是[https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp](https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp)文件中的 clang 实现。 此单个文件包含针对所有受支持平台的特定于 ABI 的操作。 它也是收集所有信息的单一地点。

在本节中，您了解了如何生成函数调用的 IR 以符合您平台的 ABI。 下一节将介绍为类和虚拟函数创建 IR 的不同方法。

# 为类和虚函数创建 IR 代码

许多现代编程语言使用类支持面向对象的。 **类**是一种高级语言构造，在本节中，我们将探索如何将类构造映射到 LLVM IR。

## 实现单一继承

类是数据和方法的集合。 一个类可以从另一个类继承，这可能会添加更多的数据字段和方法，或者重写现有的虚方法。 让我们用 Oberon-2 中的类来说明这一点，Oberon-2 也是`tinylang`的一个很好的模型。 `Shape`类定义了具有颜色和面积的抽象形状：

```cpp
TYPE Shape = RECORD
               color: INTEGER;
               PROCEDURE (VAR s: Shape) GetColor(): 
                   INTEGER;
               PROCEDURE (VAR s: Shape) Area(): REAL;
             END;
```

`GetColor`方法仅返回颜色编号：

```cpp
PROCEDURE (VAR s: Shape) GetColor(): INTEGER;
BEGIN RETURN s.color; END GetColor;
```

抽象形状的面积无法计算，因此这是一种抽象方法：

```cpp
PROCEDURE (VAR s: Shape) Area(): REAL;
BEGIN HALT; END;
```

可以扩展`Shape`类型以表示`Circle`类：

```cpp
TYPE Circle = RECORD (Shape)
                radius: REAL;
                PROCEDURE (VAR s: Circle) Area(): REAL;
              END;
```

对于圆，面积可以计算为：

```cpp
PROCEDURE (VAR s: Circle) Area(): REAL;
BEGIN RETURN 2 * radius * radius; END;
```

也可以在运行时查询该类型。 如果`shape`是`Shape`类型的变量，那么我们可以这样制定类型测试：

```cpp
IF shape IS Circle THEN (* … *) END;
```

抛开不同的语法不谈，它的工作原理与 C++ 非常相似。 与 C++ 的一个显著区别是，Oberon-2 语法使隐式`this`指针显式，称其为方法的接收者。

要解决的基本问题是如何在内存中布局类，以及如何实现方法的动态调用和运行时类型检查。 对于内存布局来说，这相当容易。 `Shape`类只有一个数据成员，我们可以将其映射到相应的 LLVM 结构类型：

```cpp
@Shape = type { i64 }
```

`Circle`类添加另一个数据成员。 解决方案是在末尾追加新的数据成员：

```cpp
@Circle = type { i64, float }
```

原因是一个类可以有很多子类。 使用此策略，公共基类的数据成员始终具有相同的内存偏移量，并且还使用相同的索引通过`getelementptr`指令访问字段。

要实现方法的动态调用，我们必须进一步扩展 LLVM 结构。 如果对`Shape`对象调用`Area()`函数，则会调用抽象方法，从而导致应用程序暂停。 如果在`Circle`对象上调用它，则会调用相应的方法来计算圆的面积。 这两个类的对象都可以调用`GetColor()`函数。 实现这一点的基本思想是将具有函数指针的表与每个对象相关联。 在这里，该表将有两个条目：一个用于`GetColor()`方法，另一个用于`Area()`函数。 `Shape`类和`Circle`类都有这样的表。 这两个表在`Area()`函数的条目上有所不同，该函数根据对象的类型调用不同的代码。 该表称为**虚拟方法表**，通常缩写为**vtable**。

仅使用 vtable 是没有用的。 我们必须把它和一个物体联系起来。 为此，我们总是将指向 vtable 的指针作为结构的第一个数据成员添加。 在 LLVM 级别，`@Shape`类型随后变为以下类型：

```cpp
@Shape = type { [2 x i8*]*, i64 }
```

`@Circle`类型被类似地扩展为。 产生的存储器结构如*图 6.1*所示：

![Figure 6.1 – Memory layout of the classes and the virtual method tables ](Images/Figure_6.1_B15647.jpg)

图 6.1-类和虚拟方法表的内存布局

LLVM 没有空指针，而是使用指向字节的指针。 随着隐藏的`vtable`字段的引入，现在还需要有一种方法来初始化它。 在 C++ 中，这是调用构造函数的一部分。 在 Oberon-2 中，该字段在分配内存时自动初始化。

然后，通过以下步骤执行对方法的动态调用：

1.  通过`getelementptr`指令计算 vtable 指针的偏移量。
2.  加载指向 vtable 的指针。
3.  计算 vtable 中函数的偏移量。
4.  加载函数指针。
5.  通过带有`call`指令的指针间接调用函数。

这听起来效率不是很高，但实际上，大多数 CPU 架构只需两条指令就可以执行这种动态调用。 因此，真正冗长的是 LLVM 级别。

要将函数转换为方法，需要引用对象的数据。 这是通过将指向数据的指针作为该方法的第一个参数传递来实现的。 在 Oberon-2 中，这是显式接收器。 在类似于 C++ 的语言中，它是隐式的`this`指针。

使用 vtable，我们在内存中为每个类都有一个唯一的地址。 这对运行时类型测试也有帮助吗？ 答案是，它只能以有限的方式提供帮助。 为了说明这个问题，让我们用一个从`Circle`类继承的`Ellipse`类来扩展类层次结构。 (这不是数学意义上的经典*is-a*关系。)。 如果我们有`Shape`类型的`shape`变量，那么我们可以将`shape IS Circle`类型测试实现为存储在`shape`变量中的 vtable 指针与`Circle`类的 vtable 指针的比较。 仅当`shape`具有确切的`Circle`类型时，此比较才会产生`true`。 但是，如果`shape`确实是`Ellipse`类型的，则比较返回`false`，即使在只需要`Circle`类型的对象的所有位置都可以使用`Ellipse`类型的对象。

显然，我们需要做得更多。 解决方案是使用运行时类型信息扩展虚拟方法表。 您需要存储多少信息取决于源语言。 要支持运行时类型检查，只需存储指向基类的 vtable 的指针就足够了，如*图 6.2*所示：

![Figure 6.2 – Class and vtable layout supporting simple type tests ](Images/Figure_6.2_B15647.jpg)

图 6.2-支持简单类型测试的类和 vtable 布局

如果如前所述测试失败，则使用指向基类的 vtable 的指针重复测试。 重复这一过程，直到测试产生`true`，或者如果没有基类，则产生`false`。 与调用动态函数相比，类型测试是一项开销很大的操作，因为在最坏的情况下，继承层次结构会向上遍历到根类。

如果您知道整个类层次结构，那么一种有效的方法是可能的：按照深度优先的顺序对类层次结构的每个成员进行编号。 然后，类型测试变成对一个数字或间隔的比较，这可以在固定的时间内完成。 事实上，这就是 LLVM 自己的运行时类型测试的方法，我们在上一章中了解到了这一点。

将运行时类型信息与 vtable 耦合是一个设计决策，要么由源语言强制执行，要么只是一个实现细节。 例如，如果您需要详细的运行时类型信息，因为源语言在运行时支持反射，而您的数据类型没有 vtable，则将两者结合起来不是一个好主意。 在 C++ 中，耦合导致具有虚函数的类(因此没有 vtable)没有附加运行时类型数据。

通常，编程语言支持接口，接口是虚拟方法的集合。 接口很重要，因为它们添加了有用的抽象。 我们将在下一节中研究接口的可能实现。

## 使用接口扩展单一继承

语言(如**Java**)支持接口。 接口是抽象方法的集合，类似于没有数据成员而只定义抽象方法的基类。 接口带来了一个有趣的问题，因为实现接口的每个类都可以在 vtable 中的不同位置拥有相应的方法。 原因很简单，因为 vtable 中函数指针的顺序是从源语言的类定义中的函数顺序派生出来的。 接口中的定义与此无关，不同的顺序是规范。

因为接口中定义的方法可以有不同的顺序，所以我们将每个实现的接口的表附加到类。 对于接口的每个方法，该表可以指定 vtable 中方法的索引，也可以是 vtable 中存储的函数指针的副本。 如果在接口上调用了方法，则搜索接口的相应 vtable，然后获取指向该函数的指针并调用该方法。 将两个接口`I1`和`I2`添加到`Shape`类会导致以下布局：

![Figure 6.3 – Layout of vtables for interfaces ](Images/Figure_6.3_B15647.jpg)

图 6.3-接口的 vtable 布局

需要注意的是，我们必须找到正确的 vtable。 我们可以使用类似于*运行时类型测试*的方法：我们可以在接口 vtable 列表中执行线性搜索。 我们可以为每个接口分配一个唯一的编号(例如，内存地址)，并使用该编号标识 vtable。 这种方案的缺点是显而易见的：通过接口调用方法比在类上调用相同的方法需要更多的时间。 要解决这个问题并不容易。

一个不错的方法是用哈希表代替线性搜索。 在编译时，类实现的接口是已知的。 因此，我们可以构造一个完美的散列函数，它将端口号映射到接口的 vtable。 构造可能需要标识接口的已知唯一编号，因此内存无济于事。 但还有其他方法可以计算唯一的数字。 如果源中的符号名称是唯一的，则始终可以计算诸如符号的`MD5`之类的密码散列，并使用该散列作为数字。 计算在编译时进行，因此没有运行时成本。

其结果比线性搜索要快得多，并且只需要固定的时间。 尽管如此，它涉及对一个数字的几个算术运算，并且比类类型的方法调用要慢。

通常，接口还会参与运行时类型测试，这使得要搜索的列表更长。 当然，如果实现了哈希表方法，那么它也可以用于运行时类型测试。

某些语言允许多个父类。 这给实现带来了一些有趣的挑战，我们将在下一节中掌握这一点。

## 添加对多重继承的支持

多重继承增加了另一个挑战。 如果一个类继承自两个或多个基类，那么我们需要以这样一种方式组合数据成员，使它们仍然可以从方法中访问。 与单一继承的情况一样，解决方案是附加所有数据成员，包括隐藏的 vtable 指针。 `Circle`类不仅是几何形状，而且是图形对象。 为了对此建模，我们让`Circle`类继承自`Shape`类和`GraphicObj`类。 在类布局中，来自`Shape`类的字段排在第一位。 然后，我们追加`GraphicObj`类的所有字段，包括隐藏的 vtable 指针。 之后，我们添加`Circle`类的新数据成员，得到如*图 6.4*所示的总体结构：

![Figure 6.4 – Layout of classes and vtables with multiple inheritance ](Images/Figure_6.4_B15647.jpg)

图 6.4-具有多重继承的类和 vtable 的布局

这种方法有几个含义。 现在可以有几个指向该对象的指针。 指向`Shape`或`Circle`类的指针指向对象的顶部，而指向`GraphicObj`类的指针指向此对象内部，指向嵌入的`GraphicObj`对象的开头。 在比较指针时必须考虑到这一点。

调用虚方法也会受到影响。 如果在`GraphicObj`类中定义了方法，则此方法需要`GraphicObj`类的类布局。 如果此方法未在`Circle`类中被覆盖，则有两种可能性。 最简单的情况是使用指向`GraphicObj`实例的指针完成方法调用：在本例中，您在`GraphicObj`类的 vtable 中查找方法地址并调用函数。 更复杂的情况是，如果使用指向`Circle`类的指针调用该方法。 同样，您可以在`Circle`类的 vtable 中查找该方法的地址。 被调用的方法需要一个指向`GraphicObj`类实例的`this`指针，因此我们也必须调整该指针。 我们可以这样做，因为我们知道`GraphicObj`类在`Circle`类中的偏移量。

如果`GrapicObj`的方法在`Circle`类中被覆盖，则如果通过指向`Circle`类的指针调用该方法，则不需要执行任何特殊操作。 但是，如果通过指向`GraphicObj`实例的指针调用方法，则需要进行另一次调整，因为该方法需要指向`Circle`实例的`this`指针。 在编译时，我们不能计算这个调整，因为我们不知道这个`GraphicObj`实例是否是多继承层次结构的一部分。 要解决此问题，我们在调用方法之前将需要对`this`指针所做的调整与 vtable 中的每个函数指针一起存储，如*图 6.5*所示：

![Figure 6.5 – vtable with adjustments to the this pointer ](Images/Figure_6.5_B15647.jpg)

图 6.5-调整了 this 指针的 vtable

现在，方法调用如下所示：

1.  在 vtable 中查找函数指针。
2.  调整`this`指针。
3.  调用该方法。

此方法也可用于实现接口。 因为接口只有方法，所以每个实现的接口都会向对象添加一个新的 vtable 指针。 这更容易实现，而且很可能更快，但它会增加每个对象实例的开销。 在最坏的情况下，如果您的类只有一个 64 位数据字段，但实现了 10 个接口，那么您的对象需要 96 个字节的内存：8 个字节用于类本身的 vtable 指针，8 个字节用于数据成员，10*8 个字节用于每个接口的 vtable 指针。

要支持对对象进行有意义的比较并执行运行时类型测试，需要首先规范化指向对象的指针。 如果我们在 vtable 中添加一个额外的字段，在对象的顶部包含一个偏移量，那么我们总是可以调整指针，使其指向真实的对象。 在`Circle`类的 vtable 中，此偏移量为`0`，但不在嵌入的`GraphicObj`类的 vtable 中。 当然，这是否需要实现取决于源语言的语义。

LLVM 本身并不支持面向对象特性的特殊实现。 如本节所示，我们可以使用可用的 LLVM 数据类型实现所有方法。 如果您想尝试一种新的方法，那么一个不错的方法是先用 C 语言做一个原型。 所需的指针操作可以快速转换为 LLVM IR，但在高级语言中对该功能进行推理会更容易。

有了本节中学到的知识，您就可以在您自己的代码生成器中实现将编程语言中常见的所有 OOP 结构降低到 LLVMIR 中。 您将了解如何在内存中表示单继承、带接口的单继承或多继承，以及如何实现类型测试和如何查找虚函数，这些都是 OOP 语言的核心概念。

# 摘要

在本章中，您学习了如何转换聚合数据类型和指向 LLVM IR 代码的指针。 您还了解了 ABI 的错综复杂之处。 最后，您了解了将类和虚函数转换为 LLVMIR 的不同方法。 有了本章的知识，您将能够为大多数真正的编程语言创建一个 LLVM IR 代码生成器。

在下一章中，您将学习一些高级技术。 异常处理在现代编程语言中相当常见，LLVM 对此有一些支持。 将类型信息附加到指针可以帮助进行某些优化，因此我们也将添加这一点。 最后但并非最不重要的一点是，调试应用程序的能力对于许多开发人员来说是必不可少的，因此我们将在代码生成器中添加调试元数据的生成。