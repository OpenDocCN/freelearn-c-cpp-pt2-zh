# 九、示例——建筑物监控和控制

监控建筑物内的条件，包括温度、湿度和 CO<sub>2</sub>水平正变得越来越普遍，其目标是调整供暖、制冷和通风系统，以保持建筑物的居住者尽可能舒适。在本章中，探索并实施了这样一个系统。将涵盖以下主题:

*   为 ESP8266 创建复杂固件
*   将 MCU 集成到基于 IP 的网络中
*   添加 CO<sub>2</sub>和 I2C-based 传感器
*   使用 GPIO 和 PWM 控制继电器和直流压控风扇
*   使用中央控制器连接网络节点

# 植物、房间及其他

在[第 5 章](05.html)，*示例-带有 wi-fi 的土壤湿度监测器*中，我们研究了为 ESP8266 MCU 开发固件以补充土壤湿度传感器和泵，以确保从水箱中向连接的工厂提供足够的水。

正如我们在那一章中指出的那样，所使用的固件是高度模块化的，并且具有高度灵活的基于 MQTT 的接口，因此它可以用于各种各样的模块。本章介绍了固件起源的系统: **建筑管理和控制** (**BMaC**)，最初开发的只是为了监控房间的温度、湿度和 CO<sup>2</sup>水平，但是后来扩展到密切关注咖啡机和会议室的占用情况，并最终控制整个建筑物的空调。

BMaC 项目的当前开发状态可以在作者的 GitHub 帐户中找到[https://github.com/MayaPosch/BMaC](https://github.com/MayaPosch/BMaC)。我们在这里介绍的版本是目前存在的，我们介绍了这个系统是如何形成的，今天是什么样子，以及为什么。

# 发展历史

BMaC 项目是在办公楼周围添加传感器以测量温度和其他参数 (例如相对湿度) 时开始的。在决定将 ESP8266 mcu 与 DHT22 温度和湿度传感器一起使用后，使用使用 Sming 框架编写的基本固件将一个简单的原型放在一起。

发现 DHT22 传感器通常相当笨重，而且不太精确。所使用的分线板上还安装了不正确的电阻，导致报告了错误的温度。这种传感器类型还具有使用自己的单线协议而不是标准接口方法的缺点。

DHT22 传感器换成了 BME280 MEMS 传感器，该传感器可测量温度，湿度以及气压。还添加了以 MH-Z19 形式的 CO<sub>2</sub>传感器。这也需要固件支持这些额外的传感器。传感器读数将作为 MQTT 消息发送，后端服务订阅这些主题，并将其写入时间序列数据库 (InfluxDB)，以供查看和分析。

当考虑从全自动 Jura 咖啡机中读取产品计数器的可能性时，必须做出决定，以及是否必须开发单独的固件。

决定对所有 ESP8266 节点使用相同的固件，而不是单独的固件。这意味着他们需要具有以某种方式启用单个功能并支持特定传感器和其他功能的功能。这导致了新固件的开发，该固件允许通过 MQTT 发送的远程命令来打开或关闭功能模块以及其他管理功能。

随着新的固件，添加了一个**命令和控制** (**C&C**) 服务器，由各个节点用来检索它们的配置，以及用于添加新节点以及添加或编辑节点配置的管理应用。

有了这个框架，就有可能快速添加新功能。其中包括增加运动传感器，用于检测房间中人员的存在，最终控制空调单元，因为发现办公楼中现有的集中控制不足。

整个系统可以像这样可视化:

![](img/d784b62d-39db-497b-91d4-8914218b0cde.png)

在接下来的部分中，我们将详细介绍这些方面。

# 功能模块

以下是此固件中的模块列表:

| **名称** | **特征** | **说明** |
| THP | 温度、湿度、压力 | THP 传感器的中央等级。默认启用 BME280 功能。 |
| CO<sub>2</sub> | CO<sub>2</sub>值 | 测量 CO<sub>2</sub><indexentry content = “功能模块，建筑物管理和控制 (BMaC):CO<sub>2</sub>” >使用 MH-Z19 或兼容传感器的值。 |
| 汝拉 | Topetronics EEPROM 计数器 | 从 EEPROM 中读出各种产品的计数器。 |
| 陪审员 | 拓普电子遥控器 | 允许远程服务将 TopTronics (经典，v5-style) 命令发送到受支持的咖啡机。 |
| 运动 | 运动检测 | 使用 HC-SR501 PIR 运动传感器或兼容来检测运动。 |
| 脉宽调制 | PWM 输出 | 在一个或多个引脚上设置脉冲宽度调制输出。 |
| I/O | I/O 扩展 | 通过 I2C 支持 MCP23008 八通道 I/O 扩展器模块。 |
| 开关 | 持久开关 | 控制使用闭锁继电器或等效开关的开关。 |
| 植物 | 浇水植物 | 读取模拟土壤传感器以确定土壤湿度，并在需要时启动泵。 |

# 固件源

在本节中，我们将查看与 BMaC 系统一起使用的 ESP8266 固件的源代码。

# 核心

我们在[第 5 章](05.html)，*示例中已经看过的固件的核心-带有 wi-fi*的土壤湿度监测器，包括入口点，`OtaCore`类和`BaseModule`类，它提供了使单个模块初始化并允许使用 MQTT 接口启用和禁用它们所需的所有功能。

# 模块

在固件模块中，我们已经查看了[第 5 章](05.html)，*示例-带有 wi-fi*的土壤湿度监测器。在这里，我们将从 THP 模块开始查看其余模块:

```cpp
#include "base_module.h"
class THPModule {
    public:
    static bool initialize();
    static bool start();
    static bool shutdown();
};
#include "thp_module.h"
#include "dht_module.h"
#include "bme280_module.h"
bool THPModule::initialize() {
    BaseModule::registerModule(MOD_IDX_TEMPERATURE_HUMIDITY, 
    THPModule::start, THPModule::shutdown);
    return true;
}
bool THPModule::start() {
    BME280Module::init();
    return true;
}
bool THPModule::shutdown() {
    BME280Module::shutdown();
    return true;
}
```

该模块具有作为各种温度，湿度和气压传感器的通用接口的规定。由于当时这不是必需的，因此它仅充当 BME280 模块的传递。它在调用时向基本模块注册自己，并在调用其自身时调用 BME280 模块上的相应函数。

为了使其更加通用，该类将被扩展以允许接收命令-可能通过 MQTT 以及它自己的主题-当使用单独的温度和空气压力传感器时，这将启用特定的传感器模块，甚至是它们的集合，例如。

不管它是否在这个固件中被使用，让我们来看看 DHT 模块，这样我们以后就可以和 BME280 模块进行比较了。

```cpp
#include "ota_core.h"

 #include <Libraries/DHTesp/DHTesp.h>

 #define DHT_PIN 5 // DHT sensor: GPIO5 ('D1' on NodeMCU)

 class DHTModule {
    static DHTesp* dht;
    static int dhtPin;
    static Timer dhtTimer;

 public:
    static bool init();
    static bool shutdown();
    static void config(String cmd);
    static void readDHT();
 };
```

值得注意的是，尽管类是静态的，但任何会占用大量内存的变量 (例如库类实例) 都被定义为指针。这形成了使模块易于使用与更复杂，完全动态的解决方案之间的折衷方案。由于大多数 mcu 倾向于在使用 ROM 之前将尽可能多的程序代码保留在 ROM 中，因此应将 SRAM 和 ROM 的使用率保持在最低水平。

```cpp
#include "dht_module.h"

 DHTesp* DHTModule::dht = 0;
 int DHTModule::dhtPin = DHT_PIN;
 Timer DHTModule::dhtTimer;

 bool DHTModule::init() {
    if (!OtaCore::claimPin(dhtPin)) { return false; }
    if (!dht) { dht = new DHTesp(); dht->setup(dhtPin, DHTesp::DHT22); }
    dhtTimer.initializeMs(2000, DHTModule::readDHT).start();    
    return true;
 }
```

为了初始化模块，我们确保我们可以安全地使用我们打算使用的**通用输入/输出** (**GPIO**) 引脚，从库中创建一个传感器类的新实例，并在创建 2 秒计时器之前进行设置，该计时器将执行预定的传感器读出。

由于我们在初始化时创建了一个传感器类的新实例，因此绝不应该有一个该类的现有实例，但是我们检查 init() 函数是否会因为某种原因再次被调用。第二次调用计时器上的初始化函数也可以包含在此块中，但是并不是严格要求的，因为再次初始化计时器不会产生有害影响。

```cpp
bool DHTModule::shutdown() {
    dhtTimer.stop();
    if (!OtaCore::releasePin((ESP8266_pins) dhtPin)) { delete dht; return false; }
    delete dht;
    dht = 0;    
    return true;
 }
```

为了关闭模块，我们停止计时器并释放我们正在使用的 GPIO 引脚，然后清理我们使用的所有资源。正如我们在初始化模块时声称的 pin 所使用的那样，我们应该没有问题再次释放它，但是我们检查以确保。

```cpp

 void DHTModule::config(String cmd) {
    Vector<String> output;
    int numToken = splitString(cmd, '=', output);
    if (output[0] == "set_pin" && numToken > 1) {
          dhtPin = output[1].toInt();
    }
 }
```

这是一个示例，说明以后如何更改模块使用的 GPIO 引脚，此处使用 BMaC 固件的早期版本使用的旧的基于文本的命令格式。我们还可以通过 MQTT 主题或主动查询命令和控制服务器来接收此信息。

请注意，要更改传感器使用的引脚，必须通过删除类实例并创建新实例来重新启动传感器。

```cpp
 void DHTModule::readDHT() {
    TempAndHumidity th;
    th = dht->getTempAndHumidity();

    OtaCore::publish("nsa/temperature", OtaCore::getLocation() + ";" + th.temperature);
    OtaCore::publish("nsa/humidity", OtaCore::getLocation() + ";" + th.humidity);
 }
```

接下来，对于`BME280`传感器模块，其代码如下所示:

```cpp
#include "ota_core.h"

 #include <Libraries/BME280/BME280.h>

 class BME280Module {
    static BME280* bme280;
    static Timer timer;

 public:
    static bool init();
    static bool shutdown();
    static void config(String cmd);
    static void readSensor();
 };
```

最后，它是看起来很熟悉的实现:

```cpp
#include "bme280_module.h"

 BME280* BME280Module::bme280 = 0;
 Timer BME280Module::timer;

 bool BME280Module::init() {
    if (!OtaCore::starti2c()) { return false; }
    if (!bme280) { bme280 = new BME280(); }

    if (bme280->EnsureConnected()) {
          OtaCore::log(LOG_INFO, "Connected to BME280 sensor.");
          bme280->SoftReset();
          bme280->Initialize();
    }
    else {
          OtaCore::log(LOG_ERROR, "Not connected to BME280 sensor.");
          return false;
    }

    timer.initializeMs(2000, BME280Module::readSensor).start();

    return true;
 }

 bool BME280Module::shutdown() {
    timer.stop();
    delete bme280;
    bme280 = 0;

    return true;
 }

 void BME280Module::config(String cmd) {
    Vector<String> output;
    int numToken = splitString(cmd, '=', output);
    if (output[0] == "set_pin" && numToken > 1) {
          //
    }
 }

 void BME280Module::readSensor() {
    float t, h, p;
    if (bme280->IsConnected) {
          t = bme280->GetTemperature();
          h = bme280->GetHumidity();
          p = bme280->GetPressure
          OtaCore::publish("nsa/temperature", OtaCore::getLocation() + ";" + t);
          OtaCore::publish("nsa/humidity", OtaCore::getLocation() + ";" + h);
          OtaCore::publish("nsa/pressure", OtaCore::getLocation() + ";" + p);
    }
    else {
          OtaCore::log(LOG_ERROR, "Disconnected from BME280 sensor.");
    }
 }

```

如我们所见，该模块基本上是从 DHT 复制而来的，然后进行了修改以适合 BME280 传感器。这两个模块之间的相似性是开发 THP 模块的动机之一，以便利用这些相似性。

与 DHT 模块一样，我们可以看到我们依靠外部库来完成繁重的工作，而我们只需要调用库类上的函数来设置传感器并从中获取数据。

# 二氧化碳模块

对于 CO<sub>2</sub>模块，尚未尝试使其与多种类型的 CO<sub>2</sub>传感器一起使用。第一个使用的 CO<sub>2</sub>传感器是 MH-Z14，在它之前<indexentry content = "modules，Building Management and Control (BMaC):CO<sub>2</sub>模块" >切换到更紧凑的 MH-Z19 传感器。但是，这两者在其**通用异步接收器/发送器** (**UART**) 接口上使用相同的协议。

在 ESP8266 上，有两个 uart，尽管只有一个是完整的，带有接收 (RX) 和发送 (TX) 线。第二个 UART 只有一条 TX 线路。这实质上将该 MCU 限制为单个 UART，从而限制为单个基于 UART 的传感器。

除了基于 UART 的接口之外，这些传感器还具有单线接口，其中传感器使用必须使用该信号线上的脉冲之间的特定距离来接收和解码的特定编码来输出当前传感器读数。这类似于 DHT-22 的单线协议。

使用 UART 显然要容易得多，这就是我们最终使用此模块的内容:

```cpp
#include "base_module.h"

 class CO2Module {
    static Timer timer;
    static uint8_t readCmd[9];
    static uint8 eventLevel;
    static uint8 eventCountDown;
    static uint8 eventCountUp;

    static void onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount);

 public:
    static bool initialize();
    static bool start();
    static bool shutdown();
    static void readCO2();
    static void config(String cmd);
 };
```

我们可以在这里看到当我们接收数据时将与 UART 一起使用的回调函数。我们还有一些其他变量，它们的含义将在一瞬间变得清晰:

```cpp
#include "CO2_module.h"

 Timer CO2Module::timer;
 uint8_t CO2Module::readCmd[9] = { 0xFF,0x01,0x86,0x00,0x00,0x00,0x00,0x00,0x79};
 uint8 CO2Module::eventLevel = 0;
 uint8 CO2Module::eventCountDown = 10;
 uint8 CO2Module::eventCountUp = 0;

```

在静态初始化中，我们定义将发送到 CO<sub>2</sub>传感器的命令，该命令将告诉它向我们发送其当前测量值。我们定义了一些计数器和相关的计时器实例，我们将使用它们来分析我们收到的 CO<sub>2</sub>级别。

```cpp
bool CO2Module::initialize() {
    BaseModule::registerModule(MOD_IDX_CO2, CO2Module::start, CO2Module::shutdown);
    return true;
 }

 bool CO2Module::start() {
    if (!OtaCore::claimPin(ESP8266_gpio03)) { return false; }
    if (!OtaCore::claimPin(ESP8266_gpio01)) { return false; }

    Serial.end();
    delay(10);
    Serial.begin(9600);
    Serial.setCallback(&CO2Module::onSerialReceived);

    timer.initializeMs(30000, CO2Module::readCO2).start();
    return true;
 }
```

启动此模块会触发 UART 所需的引脚注册，UART 以 9,600 的波特率启动。我们的接收回调也注册了。核心类中的 pin 注册例程用于内务处理，因此不会真正失败。如果与另一个模块的引脚映射重叠，如果第二个注册失败，我们可能希望释放第一个引脚注册。

串行接口使用的 GPIO 引脚设置在同一核心类中，必须在那里进行修改。缺乏可配置性的主要原因是 ESP8266 上的 GPIO 引脚在它们支持的功能方面相当有限，这就是为什么硬件 UART 基本上总是在这两个引脚上找到，而其他引脚则用于其他功能。

我们启动的计时器将每 30 秒读出一次传感器，请记住，传感器读数的前 3 分钟是无用的，因为传感器需要<indexentry content="modules, Building Management and Control (BMaC):CO<sub xmlns:epub=" http:="">2 模块 “>大约那么长的时间来预热。</indexentry>

```cpp
bool CO2Module::shutdown() {
    if (!OtaCore::releasePin(ESP8266_gpio03)) { return false; }
    if (!OtaCore::releasePin(ESP8266_gpio01)) { return false; }

    timer.stop();
    Serial.end();
    return true;
 }

 void CO2Module::readCO2() {
    Serial.write(readCmd, 9);
 }
```

读出传感器就像将我们在静态初始化阶段定义的一系列字节写入传感器一样容易，并等待传感器通过将数据发送回我们的 RX 缓冲区来响应，这将触发我们的回调函数。

```cpp
 void CO2Module::config(String cmd) {
    Vector<String> output;
    int numToken = splitString(cmd, '=', output);
    if (output[0] == "event" && numToken > 1) {
          // 
    }
 }

```

配置方法在这里也没有实现，但是可以用来禁用事件 (在下一部分中解释) 并动态进行各种调整:

```cpp
void CO2Module::onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount) {
    if (availableCharsCount >= 9) {
          char buff[9];
          Serial.readBytes(buff, 9);

          int responseHigh = (int) buff[2];
          int responseLow = (int) buff[3];
          int ppm = (responseHigh * 0xFF) + responseLow;
          String response = OtaCore::getLocation() + ";" + ppm;
          OtaCore::publish("nsa/CO2", response);

          if (ppm > 1000) { // T3
                if (eventLevel < 2 && eventCountUp < 10) {
                      if (++ eventCountUp == 10) {
                            eventLevel = 2;
                            eventCountDown = 0;
                            eventCountUp = 0;
                            response = OtaCore::getLocation() + ";" + eventLevel + ";1;" + ppm;
                            OtaCore::publish("nsa/events/CO2", response);
                      }
                }
          }
          else if (ppm > 850) { // T2
                if (eventLevel == 0 && eventCountUp < 10) {
                      if (++ eventCountUp == 10) {
                            eventLevel = 1;
                            eventCountDown = 0;
                            eventCountUp = 0;
                            response = OtaCore::getLocation() + ";" + eventLevel + ";1;" + ppm;
                            OtaCore::publish("nsa/events/CO2", response);
                      }
                }
                else if (eventLevel == 2 && eventCountDown < 10) {
                      if (++ eventCountDown == 10) {
                            eventLevel = 1;
                            eventCountUp = 0;
                            eventCountDown = 0;
                            response = OtaCore::getLocation() + ";" + eventLevel + ";0;" + ppm;
                            OtaCore::publish("nsa/events/CO2", response);
                      }
                }
          }
          else if (ppm < 750) { // T1
                if (eventLevel == 1 && eventCountDown < 10) {
                      if (++ eventCountDown == 10) {
                            eventLevel = 0;
                            eventCountDown = 0;
                            eventCountUp = 0;
                            response = OtaCore::getLocation() + ";" + eventLevel + ";0;" + ppm;
                            OtaCore::publish("nsa/events/CO2", response);
                      }
                }
          }
    }
 }
```

在回调中，我们得到字符，因为它们进入 RX 行。我们一直等到 RX 缓冲区中有 9 个字符在等我们，这是我们期望从 CO<sub xmlns:epub="http://www.idpf.org/2007/ops">2</sub>传感器接收到的<indexentry content="modules, Building Management and Control (BMaC):CO<sub xmlns:epub=" http:="">2 模块 “>字节数。我们还可以验证接收到的数据的校验和，MH-Z19 数据表给出了以下 C 代码:</indexentry>

```cpp
char getCheckSum(char* packet) { 
    char i, checksum; 
    for ( i = 1; i < 8; i++) { 
        checksum += packet[i]; 
    } 

    checksum = 0xff – checksum; 
    checksum += 1; 
    return checksum; 
}
```

此例程将接收到的数据的校验和计算为单个字节，然后我们可以将其与接收到的数据的第 9 个字节中包含的值进行比较，以查看值是否匹配。

回到我们自己的代码，我们处理字节来计算传感器检测到的 CO<sub>2</sub>分子的**百万分之几** (**PPM**)。该值立即发布到其各自的 MQTT 主题。

之后，我们比较新的 PPM 值，以查看是否已越过三个预设触发级别中的任何一个，其中第一个表示安全的 CO<sub xmlns:epub="http://www.idpf.org/2007/ops">2</sub>级别，第二个表示升高的 CO<sub xmlns:epub="http://www.idpf.org/2007/ops">【2 T3】级别，第三个是非常高的 CO<sub xmlns:epub="http://www.idpf.org/2007/ops">2</sub>水平，需要注意。当我们超过或返回到较低的触发级别时，将为此在 MQTT 主题上发布一个事件。</sub>

# 汝拉

这是另一个使用 UART 的模块。它与许多 Jura 咖啡机一起使用，这些咖啡机也使用了其他咖啡机制造商使用的常见 TopTronics 电子产品。为了能够读出这些咖啡机，一个 ESP8266 模块被集成到一个小的塑料外壳中，该外壳的一侧只有一个串行连接器。这与标准的九针串行电缆连接到机器背面的所谓服务端口。

机器上的串行端口在通电时提供 5V，因此在咖啡机打开时也打开了 ESP8266 节点。然后可以将塑料外壳隐藏在机器后面。

此功能的模块如下所示:

```cpp
#include "base_module.h"

 class JuraModule {
    static String mqttTxBuffer;
    static Timer timer;

    static bool toCoffeemaker(String cmd);
    static void readStatistics();
    static void onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount);

 public:
    static bool initialize();
    static bool start();
    static bool shutdown();
 };
```

关于这个类声明，唯一真正值得注意的是涉及咖啡机的方法名称。我们将在一秒钟内看到它的作用:

```cpp
#include "jura_module.h"
 #include <stdlib.h>
 Timer JuraModule::timer;
 String JuraModule::mqttTxBuffer;
 bool JuraModule::initialize() {
    BaseModule::registerModule(MOD_IDX_JURA, JuraModule::start, JuraModule::shutdown);
 }
 bool JuraModule::start() {
    if (!OtaCore::claimPin(ESP8266_gpio03)) { return false; }
    if (!OtaCore::claimPin(ESP8266_gpio01)) { return false; }
    Serial.end();
    delay(10);
    Serial.begin(9600);
    Serial.setCallback(&JuraModule::onSerialReceived);
    timer.initializeMs(60000, JuraModule::readStatistics).start();
    return true;
 }
```

通常，咖啡机的 UART 运行在 9,600 波特。我们设置了串行回调方法，并启动了一个计时器，用于读出 EEPROM 的产品计数器。由于我们谈论的是咖啡机，因此每分钟多次读出柜台有些愚蠢:

```cpp
bool JuraModule::shutdown() {
    if (!OtaCore::releasePin(ESP8266_gpio03)) { return false; } // RX 0
    if (!OtaCore::releasePin(ESP8266_gpio01)) { return false; } // TX 0
    timer.stop();
    Serial.end();
    return true;
 }
 void JuraModule::readStatistics() {
    String message = "RT:0000";
    JuraModule::toCoffeemaker(message);
 }
```

要读出 EEPROM 的计数器，我们需要将命令发送到机器的 UART。该命令将告诉它向我们发送 EEPROM 中第一行的内容。不幸的是，机器的协议不使用纯文本，但是需要一些特殊的编码，我们在下一个方法中这样做:

```cpp
bool JuraModule::toCoffeemaker(String cmd) {
    OtaCore::log(LOG_DEBUG, "Sending command: " + cmd);
    cmd += "\r\n";
    for (int i = 0; i < cmd.length(); ++ i) {
          uint8_t ch = static_cast<uint8_t>(cmd[i]);
          uint8_t d0 = 0xFF;
          uint8_t d1 = 0xFF;
          uint8_t d2 = 0xFF;
          uint8_t d3 = 0xFF;
          bitWrite(d0, 2, bitRead(ch, 0));
          bitWrite(d0, 5, bitRead(ch, 1));
          bitWrite(d1, 2, bitRead(ch, 2));
          bitWrite(d1, 5, bitRead(ch, 3));
          bitWrite(d2, 2, bitRead(ch, 4));
          bitWrite(d2, 5, bitRead(ch, 5));
          bitWrite(d3, 2, bitRead(ch, 6)); 
          bitWrite(d3, 5, bitRead(ch, 7));
          delay(1); 
          Serial.write(d0);
          delay(1); 
          Serial.write(d1);
          delay(1); 
          Serial.write(d2);
          delay(1); 
          Serial.write(d3);
          delay(7);
    }     
    return true;
 }
```

此方法包含一个字符串，附加所需的 EOL 字符并将每个字节编码为四个字节，将数据位放入每个新字节的第二位和第五位，其余位均为 1。然后将这四个字节发送到机器的 UART，每次写入之间都有很小的延迟，以确保正确接收:

```cpp
void JuraModule::onSerialReceived(Stream &stream, char arrivedChar, 
unsigned short availableCharsCount) {

    OtaCore::log(LOG_DEBUG, "Receiving UART 0.");
    while(stream.available()){

        delay(1);
        uint8_t d0 = stream.read();
        delay(1);
        uint8_t d1 = stream.read();
        delay(1);
        uint8_t d2 = stream.read();
        delay(1);
        uint8_t d3 = stream.read();
        delay(7);

        uint8_t d4;
        bitWrite(d4, 0, bitRead(d0, 2));
        bitWrite(d4, 1, bitRead(d0, 5));
        bitWrite(d4, 2, bitRead(d1, 2));
        bitWrite(d4, 3, bitRead(d1, 5));
        bitWrite(d4, 4, bitRead(d2, 2));
        bitWrite(d4, 5, bitRead(d2, 5));
        bitWrite(d4, 6, bitRead(d3, 2));
        bitWrite(d4, 7, bitRead(d3, 5));
        OtaCore::log(LOG_TRACE, String(d4));
        mqttTxBuffer += (char) d4;

        if ('\n' == (char) d4) {
            long int espressoCount = strtol(mqttTxBuffer.substring(3, 
            7).c_str(), 0, 16);
            long int espresso2Count = strtol(mqttTxBuffer.substring(7, 
            11).c_str(), 0, 16);
            long int coffeeCount = strtol(mqttTxBuffer.substring(11, 
            15).c_str(), 0, 16);
            long int coffee2Count = strtol(mqttTxBuffer.substring(15, 
            19).c_str(), 0, 16);
            OtaCore::publish("nsa/espresso", OtaCore::getLocation() + 
            ";" + espressoCount);
            OtaCore::publish("nsa/espresso2", OtaCore::getLocation() + 
            ";" + espresso2Count);
            OtaCore::publish("nsa/coffee", OtaCore::getLocation() + ";" 
            + coffeeCount);
            OtaCore::publish("nsa/coffee2", OtaCore::getLocation() + 
            ";" + coffee2Count);
            mqttTxBuffer = "";
          }
    }
 }
```

在串行接收回调中，我们使用与编码发送到机器的数据相同的过程对接收到的每个字节进行解码，缓冲解码后的字节，直到检测到响应 (linefeed，LF) 字符结束为止。然后，我们读出 16 位计数器，然后将其发布在 MQTT 主题上。

# 陪审员

JuraTerm 模块类似于 Jura one，但是它接受远程命令，以与 Jura 模块相同的方式对其进行编码，并返回解码后的响应。在该项目中，它曾经是 Jura 类，直到它被新的 Jura 类取代，并且该类仅委派给终端类。因此，在将来的修订中，该模块的功能将合并到主 Jura 类中。

```cpp
#include "base_module.h" 

class JuraTermModule {
    static String mqttTxBuffer;

    static bool toCoffeemaker(String cmd);
    static void onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount);

 public:
    static bool initialize();
    static bool start();
    static bool shutdown();
    static void commandCallback(String message);
 };#include "juraterm_module.h"

 String JuraTermModule::mqttTxBuffer;

 bool JuraTermModule::initialize() {
    BaseModule::registerModule(MOD_IDX_JURATERM, JuraTermModule::start, JuraTermModule::shutdown);
 }

 bool JuraTermModule::start() {
    if (!OtaCore::claimPin(ESP8266_gpio03)) { return false; } // RX 0
    if (!OtaCore::claimPin(ESP8266_gpio01)) { return false; } // TX 0

    OtaCore::registerTopic("coffee/command/" + OtaCore::getLocation(), 
                            JuraTermModule::commandCallback); 
    Serial.end();
    delay(10);
    Serial.begin(9600);
    Serial.setCallback(&JuraTermModule::onSerialReceived);

    return true;
 }

 bool JuraTermModule::shutdown() {
    if (!OtaCore::releasePin(ESP8266_gpio03)) { return false; } // RX 0
    if (!OtaCore::releasePin(ESP8266_gpio01)) { return false; } // TX 0

    Serial.end();
    OtaCore::deregisterTopic("coffee/command/" + OtaCore::getLocation());
    return true;
 }

 void JuraTermModule::commandCallback(String message) {
    if (message == "AN:0A") { return; }

    JuraTermModule::toCoffeemaker(message);
 }
```

当我们启动这个模块时，我们注册一个 MQTT 主题来接收命令。这使我们能够接收咖啡机的命令。除了这个特定的命令之外，我们基本上充当了这些命令的直接传递。我们过滤掉的这个命令会擦除机器的 EEPROM，这是我们不太可能想要的。

同样，我们使用相同的方法来编码命令:

```cpp
 bool JuraTermModule::toCoffeemaker(String cmd) {
    OtaCore::log(LOG_DEBUG, "Sending command: " + cmd);

    cmd += "\r\n";

    for (int i = 0; i < cmd.length(); ++ i) {
          uint8_t ch = static_cast<uint8_t>(cmd[i]);
          uint8_t d0 = 0xFF;
          uint8_t d1 = 0xFF;
          uint8_t d2 = 0xFF;
          uint8_t d3 = 0xFF;

          bitWrite(d0, 2, bitRead(ch, 0));
          bitWrite(d0, 5, bitRead(ch, 1));
          bitWrite(d1, 2, bitRead(ch, 2));
          bitWrite(d1, 5, bitRead(ch, 3));
          bitWrite(d2, 2, bitRead(ch, 4));
          bitWrite(d2, 5, bitRead(ch, 5));
          bitWrite(d3, 2, bitRead(ch, 6)); 
          bitWrite(d3, 5, bitRead(ch, 7));

          delay(1); 
          Serial.write(d0);
          delay(1); 
          Serial.write(d1);
          delay(1); 
          Serial.write(d2);
          delay(1); 
          Serial.write(d3);
          delay(7);
    }     

    return true;
 }

 void JuraTermModule::onSerialReceived(Stream &stream, char arrivedChar, unsigned short availableCharsCount) {
    OtaCore::log(LOG_DEBUG, "Receiving UART 0.");

    while(stream.available()){
          delay(1);
          uint8_t d0 = stream.read();
          delay(1);
          uint8_t d1 = stream.read();
          delay(1);
          uint8_t d2 = stream.read();
          delay(1);
          uint8_t d3 = stream.read();
          delay(7);

          uint8_t d4;
          bitWrite(d4, 0, bitRead(d0, 2));
          bitWrite(d4, 1, bitRead(d0, 5));
          bitWrite(d4, 2, bitRead(d1, 2));
          bitWrite(d4, 3, bitRead(d1, 5));
          bitWrite(d4, 4, bitRead(d2, 2));
          bitWrite(d4, 5, bitRead(d2, 5));
          bitWrite(d4, 6, bitRead(d3, 2));
          bitWrite(d4, 7, bitRead(d3, 5));

          OtaCore::log(LOG_TRACE, String(d4));

          mqttTxBuffer += (char) d4;
          if ('\n' == (char) d4) {
                OtaCore::publish("coffee/response", OtaCore::getLocation() + ";" + mqttTxBuffer);
                mqttTxBuffer = "";
          }
    }
 }
```

我们没有以任何方式解释数据，而是仅返回其各自 MQTT 主题的响应。

# 运动

运动模块用于与**被动红外** (**PIR**) 传感器配合使用。这些具有板载逻辑，可确定何时达到触发点，在该点，它们将中断引脚更改为高信号。我们可以用它来确定一个人是在房间里，还是在走廊里行走。

它的代码如下所示:

```cpp
#include "base_module.h"

 #define GPIO_PIN 0

 class MotionModule {
    static int pin;
    static Timer timer;
    static Timer warmup;
    static bool motion;
    static bool firstLow;

 public:
    static bool initialize();
    static bool start();
    static bool shutdown();
    static void config(String cmd);
    static void warmupSensor();
    static void readSensor();
    static void IRAM_ATTR interruptHandler();
 };
```

这里值得注意的是，我们用 IRAM_ATTR 关键字显式地将中断处理程序方法移动到 MCU 的 SRAM 中，以防止中断被调用时出现任何延迟。

其实现方式如下:

```cpp
#include "motion_module.h"
int MotionModule::pin = GPIO_PIN;
Timer MotionModule::timer;
Timer MotionModule::warmup;
bool MotionModule::motion = false;
bool MotionModule::firstLow = true;
bool MotionModule::initialize() {
      BaseModule::registerModule(MOD_IDX_MOTION, MotionModule::start, 
      MotionModule::shutdown);
}
bool MotionModule::start() {
    if (!OtaCore::claimPin(ESP8266_gpio00)) { return false; }
    pinMode(pin, INPUT);
    warmup.initializeMs(60000, MotionModule::warmupSensor).start();
   return true;
}
```

PIR 传感器需要预热时间来稳定其读数。我们用预热计时器给它一分钟。我们还为正在使用的 GPIO 引脚设置了模式。

```cpp

 bool MotionModule::shutdown() {
    if (!OtaCore::releasePin(ESP8266_gpio00)) { return false; } // RX 0

    timer.stop();
    detachInterrupt(pin);

    return true;
 }

 void MotionModule::config(String cmd) {
    Vector<String> output;
    int numToken = splitString(cmd, '=', output);
    if (output[0] == "set_pin" && numToken > 1) {
          //
    }
 }

 void MotionModule::warmupSensor() {
    warmup.stop();
    attachInterrupt(pin, &MotionModule::interruptHandler, CHANGE);

    timer.initializeMs(5000, MotionModule::readSensor).start();
 }
```

传感器完成预热后，我们停止其计时器并连接中断以处理来自传感器的任何信号。我们将使用中断例程检查共享变量，以查看该值是否已更改，每 5 秒发布一次当前值:

```cpp
 void MotionModule::readSensor() {
    if (!motion) {
          if (firstLow) { firstLow = false; }
          else {
                OtaCore::publish("nsa/motion", OtaCore::getLocation() + ";0");
                firstLow = true;
          }
    }
    else if (motion) {
          OtaCore::publish("nsa/motion", OtaCore::getLocation() + ";1");
          firstLow = true;
    }
 }
```

在检查当前传感器值时，我们将忽略传感器第一次报告`LOW`作为重点。这是为了确保我们忽略人们在房间里移动不多的时刻。然后在 MQTT 主题上发布结果值:

```cpp
void IRAM_ATTR MotionModule::interruptHandler() {
    int val = digitalRead(pin);
    if (val == HIGH) { motion = true; }
    else { motion = false; }
 }
```

中断处理程序仅更新本地布尔值。由于 PIR 传感器的大多数处理电路的过渡时间相对较长，因此在传感器将再次检测到运动以产生死区之前有相当长的时间 (秒)。在这里，我们跟踪最后的注册值。

# 脉宽调制

开发 PWM 模块的原因是要有一种使用外部 RC 滤波器电路生成模拟输出电压的方法。这是为了控制安装在天花板上的空调单元的风扇，其风扇控制器接受 0 至 10 伏之间的电压。

该模块的一个有趣的功能是它具有自己的二进制协议以允许进行远程控制，这就是空调服务可以通过天花板安装的节点直接控制风扇速度的方式:

```cpp
#include "base_module.h"

 #include <HardwarePWM.h>

 class PwmModule {
    static HardwarePWM* hw_pwm;
    static Vector<int> duty;
    static uint8 pinNum;
    static Timer timer;
    static uint8* pins;

 public:
    static bool initialize();
    static bool start();
    static bool shutdown();
    static void commandCallback(String message);
 };
```

实施如下:

```cpp
#include "pwm_module.h"

 HardwarePWM* PwmModule::hw_pwm = 0;
 uint8 PwmModule::pinNum = 0;
 Timer PwmModule::timer;
 uint8* PwmModule::pins = 0;

 enum {
    PWM_START = 0x01,
    PWM_STOP = 0x02,
    PWM_SET_DUTY = 0x04,
    PWM_DUTY = 0x08,
    PWM_ACTIVE = 0x10
 };
```

我们在这里将 PWM 模块可用的命令定义为枚举:

```cpp

 bool PwmModule::initialize() {
    BaseModule::registerModule(MOD_IDX_PWM, PwmModule::start, PwmModule::shutdown);
 }

 bool PwmModule::start() {
    OtaCore::registerTopic(MQTT_PREFIX + String("pwm/") + OtaCore::getLocation(), PwmModule::commandCallback);

    return true;
 }

 bool PwmModule::shutdown() {
    OtaCore::deregisterTopic(MQTT_PREFIX + String("pwm/") + OtaCore::getLocation());

    if (hw_pwm) {
          delete hw_pwm;
          hw_pwm = 0;
    }

    return true;
 }
```

当我们启动该模块时，我们注册了 MQTT 主题，该模块将能够在该主题上接收命令。关机时，我们再次注销这个话题。我们使用 Sming 的`HardwarePWM`类在各个引脚上启用 PWM。

模块的其余部分只是命令处理器:

```cpp

 void PwmModule::commandCallback(String message) {
    OtaCore::log(LOG_DEBUG, "PWM command: " + message);
    if (message.length() < 1) { return; }
    int index = 0;
    uint8 cmd = *((uint8*) &message[index++ ]);

    if (cmd == PWM_START) {
          if (message.length() < 2) { return; }
          uint8 num = *((uint8*) &message[index++ ]);

          OtaCore::log(LOG_DEBUG, "Pins to add: " + String(num));

          if (message.length() != (2 + num)) { return; }

          pins = new uint8[num];
          for (int i = 0; i < num; ++ i) {
                pins[i] = *((uint8*) &message[index++ ]);
                if (!OtaCore::claimPin(pins[i])) {
                      OtaCore::log(LOG_ERROR, "Pin is already in use: " + String(pins[i]));

                      OtaCore::publish("pwm/response", OtaCore::getLocation() + ";0", 1);

                      return; 
                }

                OtaCore::log(LOG_INFO, "Adding GPIO pin " + String(pins[i]));
          }

          hw_pwm = new HardwarePWM(pins, num);
          pinNum = num;

          OtaCore::log(LOG_INFO, "Added pins to PWM: " + String(pinNum));

          OtaCore::publish("pwm/response", OtaCore::getLocation() + ";1", 1);
    }
    else if (cmd == PWM_STOP) {
          delete hw_pwm;
          hw_pwm = 0;

          for (int i = 0; i < pinNum; ++ i) {
                if (!OtaCore::releasePin(pins[i])) {
                      OtaCore::log(LOG_ERROR, "Pin cannot be released: " + String(pins[i]));

                      OtaCore::publish("pwm/response", OtaCore::getLocation() + ";0", 1);

                      return; 
                }

                OtaCore::log(LOG_INFO, "Removing GPIO pin " + String(pins[i]));
          }

          delete[] pins;
          pins = 0;

          OtaCore::publish("pwm/response", OtaCore::getLocation() + ";1");
    }
    else if (cmd == PWM_SET_DUTY) {
          if (message.length() < 3) { return; }

          uint8 pin = *((uint8*) &message[index++ ]);
          uint8 duty = *((uint8*) &message[index++ ]);
          bool ret = hw_pwm->setDuty(pin, ((uint32) 222.22 * duty));
          if (!ret) {
                OtaCore::publish("pwm/response", OtaCore::getLocation() + ";0");

                return;
          }

          OtaCore::publish("pwm/response", OtaCore::getLocation() + ";1");
    }
    else if (cmd == PWM_DUTY) {
          if (message.length() < 2) { return; }

          uint8 pin = *((uint8*) &message[index++ ]);
          uint32 duty = hw_pwm->getDuty(pin);

          uint8 dutyp = (duty / 222.22) + 1;
          String res = "";
          res += (char) pin;
          res += (char) dutyp;
          OtaCore::publish("pwm/response", OtaCore::getLocation() + ";" + res);
    }
    else if (cmd == PWM_ACTIVE) {
          String res;
          if (pins && pinNum > 0) {
                res = String((char*) pins, pinNum);
          }

          OtaCore::publish("pwm/response", OtaCore::getLocation() + ";" + res);
    }
 }
```

上述方法实现的协议如下:

| **命令** | **意思** | **有效载荷** | **返回值** |
| 0x01 | 启动模块 | uint8 (引脚数)uint8 * (每个引脚一个字节) | 0x00/0x01 |
| 0x02 | 停止模块 | - | 0x00/0x01 |
| 0x04 | 设置 PWM 占空比 | uint8 (引脚号)uint8 (占空比，0-100) | 0x00/0x01 |
| 0x08 | 获取 PWM 占空比 | uint8 (引脚号)。 | uint8 (值班级别) |
| 0x10 | 返回活动引脚 | - | uint8 * (每个字节一个引脚号) |

对于每个命令，我们解析收到的字节字符串，检查字节数以查看是否获得预期的数字，然后将它们解释为命令及其有效负载。我们要么返回 0 (失败)，要么返回 1 (成功)，要么返回具有所需信息的有效载荷。

这里可以做的一个明显的补充是向接收到的命令添加某种校验和，以及对接收到的数据进行健全性检查。虽然像这样的代码在加密的 MQTT 链接和可靠的网络连接的安全环境中工作得很好，但其他环境可能不太宽容，被注入了损坏的数据和虚假数据。

# I/O

有时我们所需要的只是大量的 GPIO 引脚，这些引脚连接到继电器之类的东西，这样我们就可以打开或关闭加热阀。这就是这个模块背后的原因。安装在天花板上的节点不仅具有用于环境传感器的 I2C 总线，还具有用于 CO<sub>2</sub>测量的 UART 和用于 PWM 输出的四个引脚。

由于需要更多的 GPIO 来打开或关闭控制水管上阀门的继电器，因此在 I2C 总线上添加了专用的 GPIO 扩展器芯片，以提供另外八个 GPIO 引脚。

该模块允许像空调服务这样的外部服务直接将这些新的 GPIO 引脚设置为高或低:

```cpp
#include "base_module.h"

 #include <Libraries/MCP23008/MCP23008.h>

 class IOModule {
    static MCP23008* mcp;
    static uint8 iodir;
    static uint8 gppu;
    static uint8 gpio;
    static String publishTopic;

 public:
    static bool initialize();
    static bool start();
    static bool shutdown();
    static void commandCallback(String message);
 };
```

此类包装 MCP23008 I/O 扩展器设备，保留其方向，上拉和 GPIO 状态寄存器的本地副本，以便于更新和控制:

```cpp
#include "io_module.h"

 #include <Wire.h>

 MCP23008* IOModule::mcp = 0;
 uint8 IOModule::iodir;     
 uint8 IOModule::gppu;
 uint8 IOModule::gpio;      
 String IOModule::publishTopic;
```

我们在 I2C GPIO 扩展器设备上保留了三个寄存器的本地副本-I/O 方向 (`iodir`)，上拉寄存器 (`gppu`) 和引脚 I/O 电平 (`gpio` ):

```cpp

 enum {
    IO_START = 0x01,
    IO_STOP = 0x02,
    IO_STATE = 0x04,
    IO_SET_MODE = 0x08,
    IO_SET_PULLUP = 0x10,
    IO_WRITE = 0x20,
    IO_READ = 0x40,
    IO_ACTIVE = 0x80
 };

 enum {
    MCP_OUTPUT = 0,
    MCP_INPUT = 1
 };
```

我们再次以枚举的形式定义了许多命令，以及一个用于 GPIO 扩展器引脚方向的命令:

```cpp
bool IOModule::initialize() {
    BaseModule::registerModule(MOD_IDX_IO, IOModule::start, IOModule::shutdown);
 }

 bool IOModule::start() {   
    publishTopic = "io/response/" + OtaCore::getLocation();
    OtaCore::registerTopic("io/" + OtaCore::getLocation(), IOModule::commandCallback);

    OtaCore::starti2c();
 }

 bool IOModule::shutdown() {
    OtaCore::deregisterTopic("io/" + OtaCore::getLocation());
    if (mcp) {
          delete mcp;
          mcp = 0;
    }
 }
```

初始化和启动模块类似于 PWM 模块，我们注册了一个 MQTT 主题以接收命令。这里的区别在于，由于我们使用的是 I2C 设备，因此我们必须确保 I2C 功能已经启动。

接下来，我们解决命令处理方法:

```cpp
void IOModule::commandCallback(String message) {
    OtaCore::log(LOG_DEBUG, "I/O command: " + message);
    uint32 mlen = message.length();
    if (mlen < 1) { return; }
    int index = 0;
    uint8 cmd = *((uint8*) &message[index++ ]);
    if (cmd == IO_START) {
        if (mlen > 2) {
            OtaCore::log(LOG_INFO, "Enabling I/O Module failed: too 
            many parameters.");
            OtaCore::publish(publishTopic, OtaCore::getLocation() + 
            ";" + (char) 0x01 + (char) 0x00);
            return; 
        }
        // Read out the desired address, or use the default.
        uint8 addr = 0;
        if (mlen == 2) {
            addr = *((uint8*) &message[index++ ]);
            if (addr > 7) {                     
            // Report failure. QoS 1.
            OtaCore::log(LOG_INFO, "Enabling I/O Module failed: invalid 
            i2c address.");
            OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" 
            + (char) 0x01 + (char) 0x00);
            return;
        }
    }
    if (!mcp) {
        mcp = new MCP23008(0x40);
    }           
    // Set all pins to output (0) and low (0)
    mcp->writeIODIR(0x00);
    mcp->writeGPIO(0x00);
    // Read in current chip values.
    iodir = mcp->readIODIR();
    gppu = mcp->readGPPU();
    gpio = mcp->readGPIO();
    // Validate IODIR and GPIO registers.
    if (iodir != 0 || gpio != 0) {
        delete mcp;
        mcp = 0;
        OtaCore::log(LOG_INFO, "Enabling I/O Module failed: not 
        connected.");
         OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" +
         (char) 0x01 + (char) 0x00);
         return;
    }
    OtaCore::log(LOG_INFO, "Enabled I/O Module.");
    OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" +                                                                        
    (char) 0x01 + (char) 0x01);
}
    else if (cmd == IO_STOP) {
        if (mlen > 1) {
            OtaCore::log(LOG_INFO, "Disabling I/O Module failed: too 
            many parameters.");
            OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" 
            + (char) 0x02 + (char) 0x00);
            return; 
        }
        if (mcp) {
            delete mcp;
            mcp = 0;
        }
        OtaCore::log(LOG_INFO, "Disabled I/O Module.");
        OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
        (char) 0x02 + (char) 0x01);
    }
    else if (cmd == IO_STATE) {
          if (mlen > 1) {
                OtaCore::log(LOG_INFO, "Reading state failed: too many parameters.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x04 + (char) 0x00);
                return; 
          }

          OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x04 + (char) 0x01 + 
                                                                      ((char) iodir) + ((char) gppu) +
                                                                      ((char) gpio));
    }
    else if (cmd == IO_SET_MODE) {
          if (mlen != 3) {
                OtaCore::log(LOG_INFO, "Reading state failed: incorrect number of parameters.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x08 + (char) 0x00);
                return; 
          }

          uint8 pnum = *((uint8*) &message[index++ ]);
          uint8 pstate = *((uint8*) &message[index]);
          if (pnum > 7) {
                OtaCore::log(LOG_INFO, "Setting pin mode failed: unknown pin.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x08 + (char) 0x00);
                return; 
          }

          if (pstate > 1) {
                // Report failure. QoS 1.
                OtaCore::log(LOG_INFO, "Setting pin mode failed: invalid pin mode.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x08 + (char) 0x00);
                return; 
          }

          // Set new state of IODIR register.
          if (pstate == MCP_INPUT) { iodir |= 1 << pnum; } 
          else { iodir &= ~(1 << pnum); }

          if (mcp) {
                OtaCore::log(LOG_DEBUG, "Setting pinmode in library...");
                mcp->writeIODIR(iodir);
          }

          OtaCore::log(LOG_INFO, "Set pin mode for I/O Module.");
          OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x08 + (char) 0x01);
    }
    else if (cmd == IO_SET_PULLUP) {          
          if (mlen != 3) {
                OtaCore::log(LOG_INFO, "Reading state failed: incorrect number of parameters.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x10 + (char) 0x00);
                return; 
          }

          uint8 pnum = *((uint8*) &message[index++ ]);
          uint8 pstate = *((uint8*) &message[index]);
          if (pnum > 7) {
                OtaCore::log(LOG_INFO, "Setting pull-up failed: unknown pin.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x10 + (char) 0x00);
                return; 
          }

          if (pstate > 1) {
                OtaCore::log(LOG_INFO, "Setting pull-up failed: invalid state.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x10 + (char) 0x00);
                return; 
          }

          if (pstate == HIGH) { gppu |= 1 << pnum; } 
          else { gppu &= ~(1 << pnum); }

          if (mcp) {
                OtaCore::log(LOG_DEBUG, "Setting pull-up in library...");
                mcp->writeGPPU(gppu);
          }

          OtaCore::log(LOG_INFO, "Changed pull-up for I/O Module.");
          OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x10 + (char) 0x01);
    }
    else if (cmd == IO_WRITE) {
          if (mlen != 3) {
                OtaCore::log(LOG_INFO, "Writing pin failed: incorrect number of parameters.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x20 + (char) 0x00);
                return; 
          }
          // Set the new GPIO pin level.
          uint8 pnum = *((uint8*) &message[index++ ]);
          uint8 pstate = *((uint8*) &message[index]);
          if (pnum > 7) {
                OtaCore::log(LOG_INFO, "Writing pin failed: unknown pin.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x20 + (char) 0x00);
                return; 
          }
          if (pstate > 1) {
                OtaCore::log(LOG_INFO, "Writing pin failed: invalid state.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x20 + (char) 0x00);
                return; 
          }
          String state = "low";
          if (pstate == HIGH) { gpio |= 1 << pnum; state = "high"; } 
          else { gpio &= ~(1 << pnum); }

          OtaCore::log(LOG_DEBUG, "Changed GPIO to: " + ((char) gpio));

          if (mcp) {
                OtaCore::log(LOG_DEBUG, "Setting state to " + state + 
                                        " in library for pin " + ((char) pnum));
                mcp->writeGPIO(gpio);
          }

          OtaCore::log(LOG_INFO, "Wrote pin state for I/O Module.");
          OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x20 + (char) 0x01);
    }

    else if (cmd == IO_READ) {

          if (mlen > 2) {
                OtaCore::log(LOG_INFO, "Reading pin failed: too many 
                parameters.");
                OtaCore::publish(publishTopic, OtaCore::getLocation()
                                                                     (char) 0x40 + (char) 0x00);
                return; 
          }
          // Read the GPIO pin status and return it.
          uint8 pnum = *((uint8*) &message[index]);

        if (pnum > 7) {
            OtaCore::log(LOG_INFO, "Reading pin failed: unknown pin.");
            OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" 
            + (char) 0x40 + (char) 0x00);
        }
          uint8 pstate;

        if (mcp) {
            OtaCore::log(LOG_DEBUG, "Reading pin in library...");
            pstate = (mcp->readGPIO() >> pnum) & 0x1;
        }
        OtaCore::log(LOG_INFO, "Read pin state for I/O Module.");
        OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
        (char) 0x40 + (char) 0x01 + (char) pnum + (char) pstate);
    }

    else if (cmd == IO_ACTIVE) {

        if (mlen > 1) {
            OtaCore::log(LOG_INFO, "Reading active status failed: too 
            many parameters.");
            OtaCore::publish(publishTopic, OtaCore::getLocation() + 
            ";" + (char) 0x80 + (char) 0x00);
            return; 
        }
        uint8 active = 0;
        if (mcp) { active = 1; }
        char output[] = { 0x80, 0x01, active };
        OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
        String(output, 3));
    }
}
```

其协议如下:

| **命令** | **意思** | **有效载荷** | **返回值** |
| 0x01 | 启动模块 | uint8 I2C 地址偏移量 (0-7，可选) | 0x010x00/0x01 |
| 0x02 | 停止模块 | - | 0x020x00/0x01 |
| 0x04 | 返回 I/O 模式、上拉和电平状态 | - | 0x040x00/0x01 (结果)uint8 (iodir 寄存器)uint8 (gppu 寄存器)uint8 (gpio 寄存器) |
| 0x08 | 将引脚设置为特定模式 (输入/输出) | uint8 (引脚号，0-7)uint8 (0: 输出，1: 输入) | 0x080x00/0x01 |
| 0x10 | 设置引脚的上拉电阻 (低/高) | uint8 (引脚号，0-7)uint8 (引脚上拉状态，0/1) | 0x100x00/0x01 |
| 0x20 | 将引脚设置为低或高 | uint8 (引脚号，0-7)uint8 (引脚状态，0/1) | 0x20 0x00/0x01 |
| 0x40 | 读取当前引脚值 (低、高) | uint8 (引脚号) | 0x40 0x00/0x01 uint8 (引脚号) uint8 (引脚值) |
| 0x80 | 返回此模块是否已初始化 | - | 0x80 0x00/0x01 uint8 (模块状态，0/1)。 |

与 PWM 模块的协议类似，返回布尔值以指示成功，或者返回请求的有效负载。我们还返回响应中调用的命令。

该命令是一个字节，最多允许八个命令，因为我们使用的是位标志。如果我们愿意，这可以扩展到 256 命令。

对该模块代码的可能改进包括将重复的代码合并到 (内联) 函数调用中，以及可以想象的使用子类，该子类将使用更高级别的 API 来管理各个位的设置和切换。

# 开关

由于办公室的每个部分都有自己的中央开关，可以切换流向 fcu 的管道中的水，因此也必须从后端服务器进行控制。使用锁存继电器配置，可以在加热和冷却配置之间切换，以及具有可以由节点读出的存储元件:

该系统组装在一块单板上，用于替换原来的手动开关，使用以下模块对其进行控制:

```cpp
#include "base_module.h"

 class SwitchModule {
    static String publishTopic;

 public:
    static bool initialize();
    static bool start();
    static bool shutdown();
    static void commandCallback(String message);
 };
```

其实现方式如下:

```cpp
#include "switch_module.h"
#include <Wire.h>
#define SW1_SET_PIN 5 
#define SW2_SET_PIN 4 
#define SW1_READ_PIN 14 
#define SW2_READ_PIN 12 
String SwitchModule::publishTopic;
enum {
    SWITCH_ONE = 0x01,//Switch the first connected load on, second off.
    SWITCH_TWO = 0x02,//Switch the second connected load on, first off.
    SWITCH_STATE = 0x04,//Returns position of the switch (0x01/0x02).
};
bool SwitchModule::initialize() {
    BaseModule::registerModule(MOD_IDX_SWITCH, SwitchModule::start, 
    SwitchModule::shutdown);
}
bool SwitchModule::start() {
    // Register pins.
    if (!OtaCore::claimPin(ESP8266_gpio05)) { return false; }
    if (!OtaCore::claimPin(ESP8266_gpio04)) { return false; }
    if (!OtaCore::claimPin(ESP8266_gpio14)) { return false; }
    if (!OtaCore::claimPin(ESP8266_gpio12)) { return false; }
    publishTopic = "switch/response/" + OtaCore::getLocation();
    OtaCore::registerTopic("switch/" + OtaCore::getLocation(), 
    SwitchModule::commandCallback);
// Set the pull-ups on the input pins and configure the output pins.
    pinMode(SW1_SET_PIN, OUTPUT);
    pinMode(SW2_SET_PIN, OUTPUT);
    pinMode(SW1_READ_PIN, INPUT_PULLUP);
    pinMode(SW2_READ_PIN, INPUT_PULLUP);
    digitalWrite(SW1_SET_PIN, LOW);
    digitalWrite(SW2_SET_PIN, LOW);
 }
 bool SwitchModule::shutdown() {
    OtaCore::deregisterTopic("switch/" + OtaCore::getLocation());
    // Release the pins.
    if (!OtaCore::releasePin(ESP8266_gpio05)) { return false; }
    if (!OtaCore::releasePin(ESP8266_gpio04)) { return false; }
    if (!OtaCore::releasePin(ESP8266_gpio14)) { return false; }
    if (!OtaCore::releasePin(ESP8266_gpio12)) { return false; }
 }

 void SwitchModule::commandCallback(String message) {
    // Message is the command.
    OtaCore::log(LOG_DEBUG, "Switch command: " + message);

    uint32 mlen = message.length();
    if (mlen < 1) { return; }
    int index = 0;
    uint8 cmd = *((uint8*) &message[index++ ]);
    if (cmd == SWITCH_ONE) {
          if (mlen > 1) {
                // Report failure. QoS 1.
                OtaCore::log(LOG_INFO, "Switching to position 1 failed: too many parameters.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x01 + (char) 0x00);
                return; 
          }

          // Set the relay to its first position (reset condition).
          // This causes pins 3 & 10 on the latching relay to become active.
          digitalWrite(SW1_SET_PIN, HIGH);
          delay(1000); // Wait 1 second for the relay to switch position.
          digitalWrite(SW1_SET_PIN, LOW);

          OtaCore::log(LOG_INFO, "Switched to position 1.");
          OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x01 + (char) 0x01);
    }
    else if (cmd == SWITCH_TWO) {
          if (mlen > 1) {
                OtaCore::log(LOG_INFO, "Switching to position 2 failed: too many parameters.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x02 + (char) 0x00);
                return; 
          }

          // Set the relay to its first position (reset condition).
          // This causes pins 3 & 10 on the latching relay to become active.
          digitalWrite(SW2_SET_PIN, HIGH);
          delay(1000); // Wait 1 second for the relay to switch position.
          digitalWrite(SW2_SET_PIN, LOW);

          OtaCore::log(LOG_INFO, "Switched to position 1.");
          OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x02 + (char) 0x01);
    }
    else if (cmd == SWITCH_STATE) {
          if (mlen > 1) {
                OtaCore::log(LOG_INFO, "Reading state failed: too many parameters.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x04 + (char) 0x00);
                return; 
          }

          // Check the value of the two input pins. If one is low, then that
          // is the active position.
          uint8 active = 2;
          if (digitalRead(SW1_READ_PIN) == LOW) { active = 0; }
          else if (digitalRead(SW2_READ_PIN) == LOW) { active = 1; }

          if (active > 1) {
                OtaCore::log(LOG_INFO, "Reading state failed: no active state found.");
                OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x04 + (char) 0x00);
                return; 
          }

          OtaCore::publish(publishTopic, OtaCore::getLocation() + ";" + 
                                                                      (char) 0x04 + (char) 0x01 + 
                                                                      (char) active);
    }
 }
```

该模块与 PWM 和 I/O 模块非常相似，并注册了 MQTT 主题以允许使用其自己的二进制协议进行通信。在这里，被控制的设备相当简单。它是具有两个侧面的锁存继电器，其中一个侧面连接到正在切换的连接，而另一侧则用作一位存储单元。

由于这种类型的继电器的两侧将同时切换，因此我们可以在连接到 MCU 的一侧进行计数，以匹配连接到系统其余部分的一侧的位置。即使在 MCU 断电或复位后，我们也可以简单地读出连接到继电器的引脚的值，以找出系统的状态。

生成的协议看起来像这样:

| **命令** | **意思** | **有效载荷** | **返回值** |
| 0x01 | 切换到位置 1 | - | 0x010x00/0x01 |
| 0x02 | 切换到位置 2 | - | 0x020x00/0x01 |
| 0x04 | 返回当前状态 | - | 0x040x00/0x01 (结果)uint8 (活动引脚 0x00，0x01) |

# 命令和控制服务器

正如本章前面提到的，所谓的**命令和控制** (**C&C**) 服务器本质上是一个包含单个节点及其配置信息的数据库，供节点本身和下一节中的管理工具使用。

它还包括一个 HTTP 服务器，用于基于 HTTP 的**无线** (**OTA**) 更新。由于 BMaC 系统是基于 MQTT 的，因此此服务器也被编写为 MQTT 客户端:

```cpp
#include "listener.h"  
#include <iostream> 
#include <string> 

using namespace std; 

#include <Poco/Util/IniFileConfiguration.h> 
#include <Poco/AutoPtr.h> 
#include <Poco/Net/HTTPServer.h> 

using namespace Poco::Util; 
using namespace Poco; 
using namespace Poco::Net; 

#include "httprequestfactory.h" 

int main(int argc, char* argv[]) { 
   cout << "Starting MQTT BMaC Command & Control server...\n"; 

   int rc; 
   mosqpp::lib_init(); 

   cout << "Initialised C++ Mosquitto library.\n"; 

   string configFile; 
   if (argc > 1) { configFile = argv[1]; } 
   else { configFile = "config.ini"; } 

   AutoPtr<IniFileConfiguration> config(new IniFileConfiguration(configFile)); 
   string mqtt_host = config->getString("MQTT.host", "localhost"); 
   int mqtt_port = config->getInt("MQTT.port", 1883); 
   string defaultFirmware = config->getString("Firmware.default", "ota_unified.bin"); 

   Listener listener("Command_and_Control", mqtt_host, mqtt_port, defaultFirmware); 

   UInt16 port = config->getInt("HTTP.port", 8080); 
   HTTPServerParams* params = new HTTPServerParams; 
   params->setMaxQueued(100); 
   params->setMaxThreads(10); 
   HTTPServer httpd(new RequestHandlerFactory, port, params); 
   httpd.start(); 

   cout << "Created listener, entering loop...\n"; 

   while(1) { 
         rc = listener.loop(); 
         if (rc){ 
               cout << "Disconnected. Trying to reconnect...\n"; 
               listener.reconnect(); 
         } 
   } 

   cout << "Cleanup...\n"; 

   mosqpp::lib_cleanup(); 

   return 0; 
} 
```

我们正在使用 Mosquitto C MQTT 客户端以及 POCO 框架为我们提供所需的功能。

接下来是`Listener`类:

```cpp
#include <mosquittopp.h> 
#include <string> 

using namespace std; 

#include <Poco/Data/Session.h> 
#include <Poco/Data/SQLite/Connector.h> 

using namespace Poco; 

class Listener : public mosqpp::mosquittopp { 
   Data::Session* session; 
   string defaultFirmware; 

public: 
   Listener(string clientId, string host, int port, string defaultFirmware); 
   ~Listener(); 

   void on_connect(int rc); 
   void on_message(const struct mosquitto_message* message); 
   void on_subscribe(int mid, int qos_count, const int* granted_qos); 
}; 
```

我们包含来自 POCO 的 SQLite 数据库功能的标头，该功能形成了此应用的数据库后端。类本身源自 Mosquitto C 类，为我们提供了所有基本的 MQTT 功能以及一些功能存根，我们仍然需要在一会儿实现:

```cpp
#include "listener.h" 

#include <iostream> 
#include <fstream> 
#include <sstream> 

using namespace std; 

#include <Poco/StringTokenizer.h> 
#include <Poco/String.h> 
#include <Poco/Net/HTTPSClientSession.h> 
#include <Poco/Net/HTTPRequest.h> 
#include <Poco/Net/HTTPResponse.h> 
#include <Poco/File.h> 

using namespace Poco::Data::Keywords; 

struct Node { 
   string uid; 
   string location; 
   UInt32 modules; 
   float posx; 
   float posy; 
}; 
```

我们为单个节点定义了一个结构:

```cpp
Listener::Listener(string clientId, string host, int port, string defaultFirmware) : mosquittopp(clientId.c_str()) { 
   int keepalive = 60; 
   connect(host.c_str(), port, keepalive); 

   Data::SQLite::Connector::registerConnector(); 
   session = new Poco::Data::Session("SQLite", "nodes.db"); 

   (*session) << "CREATE TABLE IF NOT EXISTS nodes (uid TEXT UNIQUE, \ 
         location TEXT, \ 
         modules INT, \ 
         posx FLOAT, \ 
         posy FLOAT)", now; 

   (*session) << "CREATE TABLE IF NOT EXISTS firmware (uid TEXT UNIQUE, \ 
         file TEXT)", now; 

   this->defaultFirmware = defaultFirmware; 
} 
```

在构造函数中，我们尝试使用提供的主机和端口连接到 MQTT 代理。我们还设置了与 SQLite 数据库的连接，并确保它具有有效的节点和固件表:

```cpp
Listener::~Listener() { 
   // 
} 

void Listener::on_connect(int rc) { 
   cout << "Connected. Subscribing to topics...\n"; 

   if (rc == 0) { 
         string topic = "cc/config";   // announce by nodes coming online. 
         subscribe(0, topic.c_str()); 
         topic = "cc/ui/config";       // C&C client requesting configuration. 
         subscribe(0, topic.c_str()); 
         topic = "cc/nodes/new";       // C&C client adding new node. 
         subscribe(0, topic.c_str()); 
         topic = "cc/nodes/update";    // C&C client updating node. 
         subscribe(0, topic.c_str()); 
         topic = "nsa/events/CO2";     // CO2-related events. 
         subscribe(0, topic.c_str()); 
         topic = "cc/firmware";  // C&C client firmware command. 
         subscribe(0, topic.c_str()); 
   } 
   else { 
         cerr << "Connection failed. Aborting subscribing.\n"; 
   } 
} 
```

当与 MQTT 代理建立连接时，我们重新实现回调。在这种方法中，我们订阅了我们感兴趣的所有 MQTT 主题。

当我们收到关于我们订阅的主题之一的 MQTT 消息时，将调用下一个方法:

```cpp
void Listener::on_message(const struct mosquitto_message* message) { 
   string topic = message->topic; 
   string payload = string((const char*) message->payload, message->payloadlen); 

   if (topic == "cc/config") { 
         if (payload.length() < 1) { 
               cerr << "Invalid payload: " << payload << ". Reject.\n"; 
               return; 
         } 
```

我们验证每个主题收到的有效载荷。对于第一个主题，我们希望其有效负载包含要接收其配置的节点的 MAC 地址。我们确保情况似乎如此，然后继续:

```cpp
         Data::Statement select(*session); 
         Node node; 
         node.uid = payload; 
         select << "SELECT location, modules FROM nodes WHERE uid=?", 
                     into (node.location), 
                     into (node.modules), 
                     use (payload); 

         size_t rows = select.execute(); 

         if (rows == 1) { 
               string topic = "cc/" + payload; 
               string response = "mod;" + string((const char*) &node.modules, 4); 
               publish(0, topic.c_str(), response.length(), response.c_str()); 
               response = "loc;" + node.location; 
               publish(0, topic.c_str(), response.length(), response.c_str()); 
         } 
         else if (rows < 1) { 
               // No node with this UID found. 
               cerr << "Error: No data set found for uid " << payload << endl; 
         } 
         else { 
               // Multiple data sets were found, which shouldn't be possible... 
               cerr << "Error: Multiple data sets found for uid " << payload << "\n"; 
         } 
   } 
```

我们尝试在数据库中找到 MAC 地址，如果找到节点，则读出节点的配置，并使其成为返回消息的有效负载。

下一个主题与管理工具一起使用:

```cpp
else if (topic == "cc/ui/config") { 

    if (payload == "map") {

        ifstream mapFile("map.png", ios::binary); 

        if (!mapFile.is_open()) { 

            cerr << "Failed to open map file.\n"; 

            return; 

        } 

        stringstream ss; 

        ss << mapFile.rdbuf(); 

        string mapData = ss.str(); 

        publish(0, "cc/ui/config/map", mapData.length(), 

        mapData.c_str()); 

} 
```

对于此有效负载字符串，我们返回应存在于本地文件夹中的地图图像的二进制数据。此地图包含我们正在管理的建筑物的布局，以便在工具中显示。

```cpp
         else if (payload == "nodes") { 
               Data::Statement countQuery(*session); 
               int rowCount; 
               countQuery << "SELECT COUNT(*) FROM nodes", 
                     into(rowCount), 
                     now; 

               if (rowCount == 0) { 
                     cout << "No nodes found in database, returning...\n"; 
                     return; 
               } 

               Data::Statement select(*session); 
               Node node; 
               select << "SELECT uid, location, modules, posx, posy FROM nodes", 
                           into (node.uid), 
                           into (node.location), 
                           into (node.modules), 
                           into (node.posx), 
                           into (node.posy), 
                           range(0, 1); 

               string header; 
               string nodes; 
               string nodeStr; 
               UInt32 nodeCount = 0; 
               while (!select.done()) { 
                     select.execute(); 
                     nodeStr = "NODE"; 
                     UInt8 length = (UInt8) node.uid.length(); 
                     nodeStr += string((char*) &length, 1); 
                     nodeStr += node.uid; 
                     length = (UInt8) node.location.length(); 
                     nodeStr += string((char*) &length, 1); 
                     nodeStr += node.location; 
                     nodeStr += string((char*) &node.posx, 4); 
                     nodeStr += string((char*) &node.posy, 4); 
                     nodeStr += string((char*) &node.modules, 4); 
                     UInt32 segSize = nodeStr.length(); 

                     nodes += string((char*) &segSize, 4); 
                     nodes += nodeStr; 
                     ++ nodeCount; 
               } 

               UInt64 messageSize = nodes.length() + 9; 
               header = string((char*) &messageSize, 8); 
               header += "NODES"; 
               header += string((char*) &nodeCount, 4); 
               header += nodes; 

               publish(0, "cc/nodes/all", header.length(), header.c_str()); 
         } 
   } 
```

上一节读出数据库中的每个节点，并以二进制序列化格式返回。

接下来，我们创建一个新节点并将其添加到数据库中:

```cpp
   else if (topic == "cc/nodes/new") { 
         UInt32 index = 0; 
         UInt32 msgLength = *((UInt32*) payload.substr(index, 4).data()); 
         index += 4; 
         string signature = payload.substr(index, 4); 
         index += 4; 

         if (signature != "NODE") { 
               cerr << "Invalid node signature.\n"; 
               return; 
         } 

         UInt8 uidLength = (UInt8) payload[index++ ]; 
         Node node; 
         node.uid = payload.substr(index, uidLength); 
         index += uidLength; 
         UInt8 locationLength = (UInt8) payload[index++ ]; 
         node.location = payload.substr(index, locationLength); 
         index += locationLength; 
         node.posx = *((float*) payload.substr(index, 4).data()); 
         index += 4; 
         node.posy = *((float*) payload.substr(index, 4).data()); 
         index += 4; 
         node.modules = *((UInt32*) payload.substr(index, 4).data()); 

         cout << "Storing new node for UID: " << node.uid << "\n"; 

         Data::Statement insert(*session); 
         insert << "INSERT INTO nodes VALUES(?, ?, ?, ?, ?)", 
                     use(node.uid), 
                     use(node.location), 
                     use(node.modules), 
                     use(node.posx), 
                     use(node.posy), 
                     now; 

         (*session) << "INSERT INTO firmware VALUES(?, ?)", 
                     use(node.uid), 
                     use(defaultFirmware), 
                     now; 
   } 
```

更新节点的配置也是可能的:

```cpp
   else if (topic == "cc/nodes/update") { 
         UInt32 index = 0; 
         UInt32 msgLength = *((UInt32*) payload.substr(index, 4).data()); 
         index += 4; 
         string signature = payload.substr(index, 4); 
         index += 4; 

         if (signature != "NODE") { 
               cerr << "Invalid node signature.\n"; 
               return; 
         } 

         UInt8 uidLength = (UInt8) payload[index++ ]; 
         Node node; 
         node.uid = payload.substr(index, uidLength); 
         index += uidLength; 
         UInt8 locationLength = (UInt8) payload[index++ ]; 
         node.location = payload.substr(index, locationLength); 
         index += locationLength; 
         node.posx = *((float*) payload.substr(index, 4).data()); 
         index += 4; 
         node.posy = *((float*) payload.substr(index, 4).data()); 
         index += 4; 
         node.modules = *((UInt32*) payload.substr(index, 4).data()); 

         cout << "Updating node for UID: " << node.uid << "\n"; 

         Data::Statement update(*session); 
         update << "UPDATE nodes SET location = ?, posx = ?, posy = ?, modules = ? WHERE uid = ?", 
                     use(node.location), 
                     use(node.posx), 
                     use(node.posy), 
                     use(node.modules), 
                     use(node.uid), 
                     now; 
   } 
```

接下来，我们看一下删除节点配置的主题处理程序:

```cpp
   else if (topic == "cc/nodes/delete") { 
         cout << "Deleting node with UID: " << payload << "\n"; 

         Data::Statement del(*session); 
         del << "DELETE FROM nodes WHERE uid = ?", 
                     use(payload), 
                     now; 

         (*session) << "DELETE FROM firmware WHERE uid = ?", 
                     use(payload), 
                     now; 
   } 
```

当我们在前面查看固件的 CO<sub>2</sub>模块时，我们看到它生成了 CO<sub>2</sub>事件。在这个例子中，为了生成 JSON 格式的事件，我们将这些事件发送到一些基于 HTTP 的 API。然后，我们使用 POCO 中的 HTTPS 客户端将此 JSON 发送到远程服务器 (此处设置为 localhost):

```cpp
   else if (topic == "nsa/events/CO2") { 
         StringTokenizer st(payload, ";", StringTokenizer::TOK_TRIM | StringTokenizer::TOK_IGNORE_EMPTY); 
         if (st.count() < 4) { 
               cerr << "CO2 event: Wrong number of arguments. Payload: " << payload << "\n"; 
               return; 
         } 

         string state = "ok"; 
         if (st[1] == "1") { state = "warn"; } 
         else if (st[1] == "2") { state = "crit"; } 
         string increase = (st[2] == "1") ? "true" : "false"; 
         string json = "{ \"state\": \"" + state + "\", \ 
                                 \"location\": \"" + st[0] + "\", \ 
                                 \"increase\": " + increase + ", \ 
                                 \"ppm\": " + st[3] + " }"; 

         Net::HTTPSClientSession httpsClient("localhost"); 
         try { 
               Net::HTTPRequest request(Net::HTTPRequest::HTTP_POST, 
                                                   "/", 
                                                   Net::HTTPMessage::HTTP_1_1); 
               request.setContentLength(json.length()); 
               request.setContentType("application/json"); 
               httpsClient.sendRequest(request) << json; 

               Net::HTTPResponse response; 
               httpsClient.receiveResponse(response); 
         } 
         catch (Exception& exc) { 
               cout << "Exception caught while attempting to connect." << std::endl; 
               cerr << exc.displayText() << std::endl; 
               return; 
         } 
   } 
```

最后，为了管理存储的固件映像，我们可以使用以下主题。哪个节点使用哪个固件版本可以在每个节点的配置中设置，尽管正如我们之前看到的，默认是使用最新的固件。

使用此主题，我们可以列出可用的固件映像或上传新的固件映像:

```cpp
   else if (topic == "cc/firmware") { 
         if (payload == "list") { 
               std::vector<File> files; 
               File file("firmware"); 
               if (!file.isDirectory()) { return; } 

               file.list(files); 
               string out; 
               for (int i = 0; i < files.size(); ++ i) { 
                     if (files[i].isFile()) { 
                           out += files[i].path(); 
                           out += ";"; 
                     } 
               } 

               out.pop_back(); 

               publish(0, "cc/firmware/list", out.length(), out.c_str()); 
         } 
         else { 
               StringTokenizer st(payload, ";", StringTokenizer::TOK_TRIM | StringTokenizer::TOK_IGNORE_EMPTY); 

               if (st[0] == "change") { 
                     if (st.count() != 3) { return; } 
                     (*session) << "UPDATE firmware SET file = ? WHERE uid = ?", 
                                             use (st[1]), 
                                             use (st[2]), 
                                             now; 
               } 
               else if (st[0] == "upload") { 
                     if (st.count() != 3) { return; } 

                     // Write file & truncate if exists. 
                     string filepath = "firmware/" + st[1];                       
                     ofstream outfile("firmware/" + st[1], ofstream::binary | ofstream::trunc); 
                     outfile.write(st[2].data(), st[2].size()); 
                     outfile.close(); 
               } 
         } 
   } 
} 
void Listener::on_subscribe(int mid, int qos_count, const int* granted_qos) { 
   // 
} 
```

在每个成功的 MQTT 主题订阅中，都会调用此方法，如果需要，我们可以执行其他操作。

接下来，我们看一下 HTTP 服务器组件，从 HTTP 请求处理程序工厂开始:

```cpp
#include <Poco/Net/HTTPRequestHandlerFactory.h> 
#include <Poco/Net/HTTPServerRequest.h> 

using namespace Poco::Net; 

#include "datahandler.h" 

class RequestHandlerFactory: public HTTPRequestHandlerFactory { 
public: 
   RequestHandlerFactory() {} 
   HTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request) { 
         return new DataHandler(); 
   } 
}; 
```

此处理程序将始终返回以下类的实例:

```cpp
#include <iostream> 
#include <vector> 

using namespace std; 

#include <Poco/Net/HTTPRequestHandler.h> 
#include <Poco/Net/HTTPServerResponse.h> 
#include <Poco/Net/HTTPServerRequest.h> 
#include <Poco/URI.h> 
#include <Poco/File.h> 

#include <Poco/Data/Session.h> 
#include <Poco/Data/SQLite/Connector.h> 

using namespace Poco::Data::Keywords; 

using namespace Poco::Net; 
using namespace Poco; 

class DataHandler: public HTTPRequestHandler { 
public: 
   void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response) { 
         cout << "DataHandler: Request from " + request.clientAddress().toString() << endl; 

         URI uri(request.getURI()); 
         string path = uri.getPath(); 
         if (path != "/") { 
               response.setStatus(HTTPResponse::HTTP_NOT_FOUND); 
               ostream& ostr = response.send(); 
               ostr << "File Not Found: " << path; 
               return; 
         } 

         URI::QueryParameters parts; 
         parts = uri.getQueryParameters(); 
         if (parts.size() > 0 && parts[0].first == "uid") { 
               Data::SQLite::Connector::registerConnector(); 
               Data::Session* session = new Poco::Data::Session("SQLite", "nodes.db"); 

               Data::Statement select(*session); 
               string filename; 
               select << "SELECT file FROM firmware WHERE uid=?", 
                                 into (filename), 
                                 use (parts[0].second); 

               size_t rows = select.execute(); 

               if (rows != 1) { 
                     response.setStatus(HTTPResponse::HTTP_NOT_FOUND); 
                     ostream& ostr = response.send(); 
                     ostr << "File Not Found: " << parts[0].second; 
                     return; 
               } 

               string fileroot = "firmware/"; 
               File file(fileroot + filename); 

               if (!file.exists() || file.isDirectory()) { 
                     response.setStatus(HTTPResponse::HTTP_NOT_FOUND); 
                     ostream& ostr = response.send(); 
                     ostr << "File Not Found."; 
                     return; 
               } 

               string mime = "application/octet-stream"; 
               try { 
                     response.sendFile(file.path(), mime); 
               } 
               catch (FileNotFoundException &e) { 
                     cout << "File not found exception triggered..." << endl; 
                     cerr << e.displayText() << endl; 

                     response.setStatus(HTTPResponse::HTTP_NOT_FOUND); 
                     ostream& ostr = response.send(); 
                     ostr << "File Not Found."; 
                     return; 
               } 
               catch (OpenFileException &e) { 
                     cout << "Open file exception triggered..." << endl; 
                     cerr << e.displayText() << endl; 

                     response.setStatus(HTTPResponse::HTTP_INTERNAL_SERVER_ERROR); 
                     ostream& ostr = response.send(); 
                     ostr << "Internal Server Error. Couldn't open file."; 
                     return; 
               } 
         } 
         else { 
               response.setStatus(HTTPResponse::HTTP_BAD_REQUEST); 
               response.send(); 
               return; 
         } 
   } 
}; 
```

这个类看起来相当令人印象深刻，但大部分只是一个 SQLite 数据库查找节点 ID (MAC 地址)，并返回适当的固件映像 (如果找到)。

# 管理工具

使用 C & C 服务器实现的 api，使用 Qt5 框架创建了基于 GUI 的管理工具，并开发了 Mosquitto MQTT 客户端库，从而可以对节点进行基本管理。它们被覆盖在建筑物的布局图形上。

虽然基本上可以使用，但发现图形工具的开发相当复杂。它也仅限于建筑物的单个楼层，除非要有一个非常大的地图，其中包含所有楼层并将节点映射到该楼层上。显然，这会很笨拙。

在本章提供的源代码中，也可以找到管理工具，以作为如何实现它的示例。为了简洁起见，这里省略了它的代码。

# 空调服务

为了控制空调单元，使用相同的基本模板开发了类似于 C & C 的服务。其来源的有趣部分如下:

```cpp
#include <string>
 #include <vector>

 using namespace std;

 #include <Poco/Data/Session.h>
 #include <Poco/Data/SQLite/Connector.h>

 #include <Poco/Net/HTTPClientSession.h>
 #include <Poco/Net/HTTPSClientSession.h>

 #include <Poco/Timer.h>

 using namespace Poco;
 using namespace Poco::Net;

 class Listener;

 struct NodeInfo {
    string uid;
    float posx;
    float posy;
    float current;    
    float target;
    bool ch0_state;
    UInt8 ch0_duty;
    bool ch0_valid;
    bool ch1_state;
    UInt8 ch1_duty;
    bool ch1_valid;
    bool ch2_state;
    UInt8 ch2_duty;
    bool ch2_valid;
    bool ch3_state;
    UInt8 ch3_duty;
    bool ch3_valid;
    UInt8 validate;
 };

 struct ValveInfo {
    string uid;
    UInt8 ch0_valve;
    UInt8 ch1_valve;
    UInt8 ch2_valve;
    UInt8 ch3_valve;
 };

 struct SwitchInfo {
    string uid;
    bool state;
 };

 #include "listener.h"

 class Nodes {
    static Data::Session* session;
    static bool initialized;
    static HTTPClientSession* influxClient;
    static string influxDb;
    static bool secure;
    static Listener* listener;
    static Timer* tempTimer;
    static Timer* nodesTimer;
    static Timer* switchTimer;
    static Nodes* selfRef;

 public:
    static void init(string influxHost, int influxPort, string influxDb, string influx_sec, Listener* listener);
    static void stop();
    static bool getNodeInfo(string uid, NodeInfo &info);
    static bool getValveInfo(string uid, ValveInfo &info);
    static bool getSwitchInfo(string uid, SwitchInfo &info);
    static bool setTargetTemperature(string uid, float temp);
    static bool setCurrentTemperature(string uid, float temp);
    static bool setDuty(string uid, UInt8 ch0, UInt8 ch1, UInt8 ch2, UInt8 ch3);
    static bool setValves(string uid, bool ch0, bool ch1, bool ch2, bool ch3);
    static bool setSwitch(string uid, bool state);
    void updateCurrentTemperatures(Timer& timer);
    void checkNodes(Timer& timer);

    void checkSwitch(Timer& timer);
    static bool getUIDs(vector<string> &uids);
    static bool getSwitchUIDs(vector<string> &uids);
 };
```

AC 服务中此类的定义很好地概述了此类的功能。它本质上是 SQLite 数据库的包装器，包含有关节点，阀门和冷却/加热开关的信息。它还包含计时器，这些计时器将不断触发应用以检查系统的状态，将其与目标状态进行比较，并在必要时进行调整。

此应用的`Listener`类广泛使用此类来跟踪节点和连接的 AC 单元的状态，以及控制水流的开关和阀门:

```cpp
#include <mosquittopp.h>

#include <string>
#include <map>

using namespace std;

#include <Poco/Mutex.h>

using namespace Poco;

struct NodeInfo;
struct ValveInfo;
struct SwitchInfo;

 #include "nodes.h"

 class Listener : public mosqpp::mosquittopp {
    map<string, NodeInfo> nodes;
    map<string, ValveInfo> valves;
    map<string, SwitchInfo> switches;
    Mutex nodesLock;
    Mutex valvesLock;
    Mutex switchesLock;
    bool heating;
    Mutex heatingLock;

 public:
    Listener(string clientId, string host, int port);
    ~Listener();

    void on_connect(int rc);
    void on_message(const struct mosquitto_message* message);
    void on_subscribe(int mid, int qos_count, const int* granted_qos);
    bool checkNodes();
    bool checkSwitch();
 };
```

这个应用的工作方式是，`Nodes`类计时器将导致`Listener`类发布关于 PWM、IO 和交换机模块的主题，询问应该处于活动状态的设备的状态。

这种主动回路系统在工业应用中很常见，因为它提供了系统的持续验证，以快速检测是否有什么东西不能按预期工作。

# 用于记录传感器读数的 InfluxDB

从一开始就优先记录传感器读数，然后记录从咖啡机读取的统计数据。这类数据的理想数据库是时间序列数据库，其中流入量是常见的。这个数据库最大的问题是它不支持 MQTT，只提供它的 HTTP 和本机接口。

为了解决这个问题，编写了一个简单的 MQTT 到流入 HTTP 线路协议桥，再次使用 Mosquitto 客户端库以及 POCO 框架的 HTTP 功能:

```cpp
#include "mth.h"

#include <iostream>

using namespace std;

#include <Poco/Net/HTTPRequest.h>
#include <Poco/Net/HTTPResponse.h>
#include <Poco/StringTokenizer.h>
#include <Poco/String.h>

using namespace Poco;

MtH::MtH(string clientId, string host, int port, string topics, string influxHost, 
                int influxPort, string influxDb, string influx_sec) : mosquittopp(clientId.c_str()) {
    this->topics  = topics;
    this->influxDb = influxDb;
    if (influx_sec == "true") { 
          cout << "Connecting with HTTPS..." << std::endl;
          influxClient = new Net::HTTPSClientSession(influxHost, influxPort);
          secure = true; 
    } 
    else {
          cout << "Connecting with HTTP..." << std::endl;
          influxClient = new Net::HTTPClientSession(influxHost, influxPort);
          secure = false; 
    }

    int keepalive = 60;
    connect(host.c_str(), port, keepalive);
 }
```

在构造函数中，我们连接到 MQTT 代理，并根据配置文件中设置的协议创建 HTTP 或 HTTPS 客户端:

```cpp

 MtH::~MtH() {
    delete influxClient;
 }

 void MtH::on_connect(int rc) {
    cout << "Connected. Subscribing to topics...\n";

    if (rc == 0) {
          StringTokenizer st(topics, ",", StringTokenizer::TOK_TRIM | StringTokenizer::TOK_IGNORE_EMPTY);
          for (StringTokenizer::Iterator it = st.begin(); it != st.end(); ++ it) {
                string topic = string(*it);
                cout << "Subscribing to: " << topic << "\n";
                subscribe(0, topic.c_str());

                // Add name of the series to the 'series' map.
                StringTokenizer st1(topic, "/", StringTokenizer::TOK_TRIM | StringTokenizer::TOK_IGNORE_EMPTY);
                string s = st1[st1.count() - 1]; // Get last item.
                series.insert(std::pair<string, string>(topic, s));
          }
    }
    else {
          cerr << "Connection failed. Aborting subscribing.\n";
    }
 }
```

我们使用配置文件中定义的主题，而不是固定要订阅的 MQTT 主题，此处作为单个字符串提供给我们，每个主题用逗号分隔。

我们还创建了一个 STL 映射，其中包含要记录主题的时间序列的名称，在最后一个斜线之后取 MQTT 主题的最后一部分。可以使此功能进一步可配置，但是对于 BMaC 系统中使用的主题，无需考虑此限制，因为不必具有更复杂的主题。

```cpp
void MtH::on_message(const struct mosquitto_message* message) {
    string topic = message->topic;      
    map<string, string>::iterator it = series.find(topic);
    if (it == series.end()) { 
          cerr << "Topic not found: " << topic << "\n";
          return; 
    }

    if (message->payloadlen < 1) {
          cerr << "No payload found. Returning...\n";
          return;
    }

    string payload = string((const char*) message->payload, message-
    >payloadlen);
    size_t pos = payload.find(";");
    if (pos == string::npos || pos == 0) {
        cerr << "Invalid payload: " << payload << ". Reject.\n";
        return;
    }

    string uid = payload.substr(0, pos);
    string value = payload.substr(pos + 1);
    string influxMsg; 
    influxMsg = series[topic];
    influxMsg += ",location=" + uid;
    influxMsg += " value=" + value;
    try {
        Net::HTTPRequest request(Net::HTTPRequest::HTTP_POST, 
        "/write?db=" + influxDb, Net::HTTPMessage::HTTP_1_1);
        request.setContentLength(influxMsg.length());
        request.setContentType("application/x-www-form-urlencoded");
        influxClient->sendRequest(request) << influxMsg;

        Net::HTTPResponse response;
        influxClient->receiveResponse(response);
    }
    catch (Exception& exc) {
        cout << "Exception caught while attempting to connect." << 
        std::endl;
        cerr << exc.displayText() << std::endl;
        return;
    }
```

当我们收到一个新的 MQTT 消息时，我们为它找到 Influx 时间序列的名称，然后创建一个字符串发送到 InfluxDB 服务器。这里的假设是，有效负载由发送消息的节点的 MAC 地址组成，然后是分号。

我们简单地获取分号之后的部分以将其设置为值，并使用 MAC 作为位置。然后，我们将其发送给数据库服务器。

# 安全方面

在该系统的开发过程中，很明显，安全性将是系统的首要方面。因此，我们研究了添加传输层安全性 (TLS) 加密。这将使用 Sming 框架中的集成 axTLS 加密库以及 AES 证书 (主机和客户端) 来验证主机 (服务器) 和客户端 (节点) 是他们所说的人，而且还提供安全的加密链接。

在[第 5 章](05.html)，*示例-带有 wi-fi 的土壤湿度监测器*中，我们已经研究了这些客户端证书的处理以及加密的 MQTT 连接的设置。一个不明显的细节是我们在设置此证书系统时遇到的麻烦。如[第 5 章](05.html)，*示例-土壤湿度监控器与 wi-fi*中所述，ESP8266 没有足够的内存来分配默认的 TLS 握手缓冲区，并且需要在服务器 (主机) 侧使用 SSL 片段大小扩展。

不幸的是，我们发现我们使用的常用 MQTT 代理 (蚊子) 不支持此 SSL 扩展，因此需要客户端使用默认的双 16 kB 缓冲区。第一个解决方案是在对其源代码进行一些更改以更改此设置后，重新编译 Mosquitto broker。

更好的解决方案和我们最终实现的一个是安装一个代理软件 (HAProxy)，它作为 TLS 端点，处理证书，并通过本地环回 (localhost) 接口将解密的流量重定向到 MQTT 代理。

随着 SSL 片段大小选项设置为 1-2 kB，一切都按预期工作，我们有一个建筑物范围内的无线监控和控制系统，允许敏感信息和精细控制命令的安全通信。

# 未来发展

仍然可以对该系统进行许多补充。从可以支持的传感器数量，更多的 GPIO 扩展器芯片，空调系统配置，链接到日历后端的房间占用率检测，到清理没有人出现的办公室的预定会议，等等。

还可以选择从 ESP8266 作为 MCU 切换到其他 MCU，例如基于 ARM 的 MCU，以获得有线以太网选项，以及更好的调试和开发工具。拥有带有 wi-fi 的 MCU 既方便又可以在任何地方粘贴，理论上可以正常工作，但 ESP8266 的开发工具并不是那么好，而且缺少有线通信选项 (不使用外部芯片) 意味着一切正常或不取决于 wi-fi 网络的质量。

由于 BMaC 涉及建筑物的自动化，因此希望具有一定水平的可靠性，这很难通过 wi-fi 网络来保证，尽管对于不太重要的组件 (咖啡机统计数据，传感器读数等)，这不太可能成为问题。可以想象，具有有线和无线选项的混合网络可能是未来。

# 摘要

在本章中，我们研究了整个建筑物的监控和管理系统是如何开发的，其组件是什么样的，以及在开发过程中吸取了哪些经验教训。

现在希望读者了解这种大规模嵌入式系统是如何构建和运行的，并且应该能够自己使用 BMaC 系统或实现类似的系统。

在下一章中，我们将研究使用 Qt 框架开发嵌入式项目。