# 测试资源受限平台

为 mcu 和类似的资源受限平台开发几乎完全是在常规 pc 上完成的，除了测试和调试。问题是什么时候应该在物理设备上进行测试，什么时候应该寻找测试和调试代码的替代方法，以加快开发和调试工作。

在本章中，我们将介绍以下主题:

*   了解特定代码的资源需求
*   有效使用基于 Linux 的工具测试跨平台代码
*   使用远程调试
*   使用交叉编译器
*   创建独立于平台的构建系统

# 减少磨损

通常，在开发过程中，会出现这样的情况，即解决系统中的问题，并且必须一遍又一遍地经历相同的调整-编译-部署-测试周期。以下是这种方法引入的主要问题:

*   **这不好玩**: 不得不不断等待结果，而不清楚这次是否真的会被修复，这是令人沮丧的。
*   **它没有成效**: 你花了很多时间等待结果，如果你能更好地分析问题，你就不需要了。
*   **它磨损了硬件**: 在移除和重新插入相同的连接器数十次，写入和覆盖 ROM 芯片的相同部分无数次，系统的电源循环数百次后，硬件的寿命大大缩短，加上自己的耐心，并引入了新的错误。
*   **摆弄测试硬件并不有趣**: 任何嵌入式设置的最佳情况是能够拿起开发板，插入所有外围设备和布线，用应用程序刷新 ROM，并打开电源以查看其工作。与这种情况的任何偏离都是令人沮丧和耗时的。

因此，在开发过程中避免这种循环至关重要。问题是，我们如何才能最有效地达到这样的程度，即我们可以为诸如 8 位 MCU 或更大的 32 位 ARM MCU 之类的东西生成代码，而无需接触硬件，直到测试的最后阶段。

# 规划设计

在[第四章](04.html)，*资源受限的嵌入式系统*中，我们研究了如何为嵌入式平台选择合适的微控制器。在为 MCU 设计固件时，我们不仅要考虑特定代码的资源需求，还要考虑调试的便利性。

使用 C ++ 的一个重要优势是它提供的抽象，包括能够将代码细分为逻辑类、名称空间和其他抽象，使我们能够轻松地重用、测试和调试代码。这是任何设计中至关重要的一个方面，也是一个需要完全实现的方面，才能继续实际实现设计。

根据设计的不同，调试任何问题或介于两者之间的任何问题都可能非常容易或令人沮丧。如果所有功能之间有一个干净的分离，没有泄漏的 api 或类似的问题，可能会泄漏内部私有数据，创建不同版本的基础类，如集成和单元测试将是容易的。

简单地使用类等并不能保证模块化的设计。即使采用这样的设计，仍然可以最终在类之间传递内部类数据，从而破坏了模块化。当这种情况发生时，我将使整体设计复杂化，因为依赖级别随着数据结构和数据格式的变化而增加，可能会导致应用程序中其他地方的问题，并且在编写测试和重新实现 api 作为更大的集成测试的一部分时需要创造性的黑客攻击。

在[第四章](04.html)，*资源受限的嵌入式系统*中，我们研究了如何选择合适的 MCU。RAM，ROM 和浮点使用的要点显然取决于我们为适合项目而选择的设计。正如我们在[第 2 章](02.html)，*C 作为一种嵌入式语言*中所介绍的那样，了解我们编写的代码被编译成什么非常重要。这种理解使人们可以直观地了解一行代码的资源成本将是什么样的，而不必遍历生成的机器代码并从那里创建精确的时钟周期计数。

在这一点上应该很明显，在选择 MCU 之前，必须对整体设计和资源需求有一个很好的了解，因此从坚实的设计开始是必不可少的。

# 独立于平台的构建系统

理想情况下，我们选择的项目和构建系统可用于在任何桌面平台上构建目标平台。通常，这里主要考虑的是每个开发平台的相同工具链和程序员的可用性。幸运的是，对于基于 AVR 和 ARM 的 MCU 平台，可以使用相同的基于 GCC 的工具链，因此我们不必考虑具有不同命名约定，标志和设置的不同工具链。

剩下的挑战是简单地调用工具链，然后调用程序员实用程序，这种方式不需要任何底层操作系统的知识。

在[第 6 章](06.html)，*测试基于 OS 的应用程序*中，我们研究了一个多目标构建系统，该系统可以为各种各样的目标生成二进制文件，而每个新目标的工作量最小。对于 MCU 目标，只有以下两个目标:

*   物理 MCU 目标
*   本地操作系统目标

在这里，第一个目标显然是固定的，因为我们选择了要瞄准的 MCU。除非有任何令人不快的意外，否则我们将在整个开发过程中使用这一目标。此外，我们将希望在开发 PC 上进行本地测试。这是第二个目标。

如果每个主流桌面操作系统上都有一个相同或相似的 C 工具链的版本，那就太好了。幸运的是，我们发现 GCC 几乎可以在任何可以想象的平台上使用，LLVM 工具链的 Clang C 前端使用常规的 GCC 样式标志，为我们提供了广泛的兼容性。

而不是要求多目标构建系统的复杂性，正如我们在[第 6 章](06.html)，*测试基于操作系统的应用程序*中看到的那样，我们可以简化它，使它只使用 GCC，这将允许我们在基于 Linux 和 BSD 的操作系统上使用该工具链，以及 Windows (通过 MSYS2 或等效的 MinGW) 和 macOS (安装 GCC 后)。

为了在 macOS 上完全兼容，由于 Clang 实现中的小问题，建议使用 GCC。当前的问题之一是`__forceinline`宏属性被破坏，例如，这将破坏许多假定 GCC 编译器的代码。

# 使用交叉编译器

每个编译器工具链都由一个包含源代码的侧面 (前端) 和一个输出目标平台 (后端) 的二进制格式的侧面组成。除了它的目标平台之外，没有理由后端不能在任何其他平台上工作。最后，人们只是将文本文件转换为字节序列。

以这种方式进行交叉编译是面向 MCU 的开发的基本功能，因为直接在这些 MCU 上进行编译将非常低效。但是，此过程没有任何神奇之处。在基于 GCC 和兼容 GCC 的工具链的情况下，仍然会与工具链上的相同接口进行交互，只是使用通常以目标平台名称为前缀的工具来区分它们与不同目标的其他工具链。本质上，人们会使用`arm-none-eabi-g++`而不是`g++`

生成的二进制文件将采用适合该目标平台的格式。

# 本地和片上调试

在[第 6 章](06.html)，*测试基于 OS 的应用程序*中，我们研究了使用 Valgrind 和类似工具以及 GDB 和 kin 调试应用程序。通过基于单片机的项目的基于操作系统的集成测试，例如在*示例-ESP8266 集成测试*部分中演示的那些测试，我们可以使用完全相同的技术，分析和调试代码，而无需考虑我们自己，但事实是，在实际硬件上的最终集成测试期间，相同的代码将在速度慢得多且受限得多的平台上运行。

真正的挑战是在最后的集成阶段，当固件-我们一直在使用 Valgrind 和其他功能强大的工具在我们的快速桌面系统上调试-现在在微不足道的 16 MHz ATmega MCU 上运行，而无法快速启动使用 Valgrind 工具或 GDB 会话中的代码。

由于在此阶段不可避免地会遇到错误和问题，因此我们需要做好应对这种情况的准备。通常，人们不得不求助于片上调试 (**OCD**)，这可以在 MCU 提供的任何调试接口上执行。这可以是 JTAG、DebugWire 或 SWD、PDI 或其他类型。在[第 4 章](04.html)，*资源受限的嵌入式系统*中，我们在对这些 mcu 进行编程的上下文中研究了其中的一些接口。

嵌入式 ide 将提供开箱即用执行 OCD 的能力，与目标硬件连接，允许设置断点，就像用于设置本地进程一样。当然，也可以从命令行使用 GDB 做同样的事情，使用 OpenOCD ([http://openocd.org/](http://openocd.org/) ) 这样的程序，它为 GDB 提供了一个`gdbserver`接口，同时与各种调试接口。

# 示例-ESP8266 集成测试

在这个示例项目中，我们将研究创建 Sming 框架类似 Arduino 的 api 的实现，我们首先在[第 5 章](05.html)，*示例-带有【wi-fi T3】的土壤湿度监测器中进行了研究。这样做的目的是为桌面**操作系统** (**oes**) 提供一个原生框架实现，允许将固件编译成可执行文件并在本地运行。*

此外，我们希望有模拟传感器和执行器，固件可以连接，以便读出环境数据并将数据发送到执行器作为 BMaC 项目的一部分，我们在[第 5 章](05.html)中看到了这一点，*示例-带 WiFi 的土壤湿度监测仪*，我们将在[第 9 章](09.html)，*示例-建筑物监测与控制*中详细介绍。为此，我们还需要有一个中央服务来跟踪此类信息。这样，我们还可以运行多个固件进程，以模拟整个房间的设备。

这种模拟范围的原因是由于没有物理硬件。如果没有物理 MCU 系统，我们就没有物理传感器，这些传感器也不会存在于物理房间中。因此，我们必须为传感器生成合理的输入并模拟任何执行器的效果。然而，这确实有很多优点。

具有这种扩展能力很有用，因为它使我们不仅可以将固件作为独立系统进行验证，还可以将其作为将要安装的系统的一部分进行验证。在 BMaC 的情况下，这将意味着单个节点安装在建筑物的房间中，在建筑物楼层的同一房间和其他房间中安装了数十到数百个其他节点，以及在同一网络上运行的伴随后端服务。

有了这种大规模的模拟能力，人们不仅可以测试固件本身的基本正确性，还可以测试系统整体的正确性，不同固件类型甚至版本与各种传感器和执行器 (用于空调单元、风扇、咖啡机、开关等)。除此之外，后端服务将根据从相同节点传递给节点的数据来引导节点。

然后，在模拟的建筑物中，可以将特定的房间配置为具有特定的环境条件，在工作日内与人员进入，工作和离开，以确定不同级别的建筑物占用，外部条件等的影响。您也可以使用将用于最终生产系统的固件和后端服务来执行此操作。虽然以这种方式测试系统并不能完全消除任何潜在的问题，但它至少应该验证系统的软件端在功能上是正确的。

As embedded systems are by definition part of a larger (hardware-based) system, a full integration test will involve the actual hardware or its equivalent. One could therefore consider this example the software integration test, prior to deploying the firmware to the target hardware in a physical building.

仿真服务器和各个固件进程都具有自己的主要功能，并且彼此独立运行。这使我们能够在尽可能少的干扰下检查固件的功能，并促进干净的设计。为了允许这些进程之间的高效通信，我们使用了一个**远程过程调用** (**RPC**) 库，该库本质上在固件与模拟房间中的基于 I2C、SPI 和 UART 的设备之间创建了连接。此示例使用的 RPC 库是作者开发的 RPC 库 NymphRPC。当前版本的源代码已包含在本章的源代码中。NymphRPC 库的当前版本可以在其 GitHub 存储库中找到，地址为[https://github.com/MayaPosch/NymphRPC](https://github.com/MayaPosch/NymphRPC)。

# 服务器

我们将首先查看此集成测试的服务器。它的作用是运行 RPC 服务器，并维护每个传感器和执行器设备以及房间的状态。

主文件`simulation.cpp`设置 RPC 配置以及主循环，如下所示:

```
#include "config.h"
#include "building.h"
#include "nodes.h"
#include <nymph/nymph.h>
#include <thread>
#include <condition_variable>
#include <mutex>
std::condition_variable gCon;
std::mutex gMutex;
bool gPredicate = false;
void signal_handler(int signal) {
    gPredicate = true;
    gCon.notify_one();
}
void logFunction(int level, string logStr) {
    std::cout << level << " - " << logStr << endl;
}
```

顶部的包含向我们展示了基本结构和依赖关系。我们有一个自定义配置类，一个定义建筑的类，一个节点的静态类，最后是多线程头 (从 C 11 开始可用) 和 NymphRPC RPC 头，以访问其功能。

定义了一个信号处理程序功能，以便以后与等待条件一起使用，从而允许服务器以简单的控制信号终止。最后，定义了用于 NymphRPC 服务器的日志记录功能。

接下来，我们定义 RPC 服务器的回调函数，如下所示:

```
NymphMessage* getNewMac(int session, NymphMessage* msg, void* data) {
    NymphMessage* returnMsg = msg->getReplyMessage();

    std::string mac = Nodes::getMAC();
    Nodes::registerSession(mac, session);

    returnMsg->setResultValue(new NymphString(mac));
    return returnMsg;
 }
```

这是客户端将在服务器上调用的初始函数。它将检查全局静态`Nodes`类中的可用 MAC 地址。此地址唯一地标识新的节点实例，网络上的设备也将通过其唯一的以太网 MAC 地址来标识。这是一个内部功能，不需要修改固件，而是改变了将 mac 分配给服务器的能力，而不是将它们硬编码在某个地方。当分配了新的 MAC 时，它将与 NymphRPC 会话 ID 相关联，以便我们以后可以使用 MAC 查找适当的会话 ID，并使用它来调用由模拟设备生成的事件。

在这里，我们还看到了在服务器实例上使用的 NymphRPC 回调函数的基本签名。它显然返回返回消息，并作为其参数接收与连接的客户端关联的会话 ID、从该客户端接收的消息以及一些用户定义的数据，如下面的代码所示:

```
NymphMessage* writeUart(int session, NymphMessage* msg, void* data) {
    NymphMessage* returnMsg = msg->getReplyMessage();

    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();
    std::string bytes = ((NymphString*) msg->parameters()[1])->getValue();
    returnMsg->setResultValue(new NymphBoolean(Nodes::writeUart(mac, bytes)));
    return returnMsg;
 }
```

此回调实现了一种在模拟中写入模拟节点的 UART 接口的方法，以解决与之连接的任何模拟设备。

要找到节点，我们使用 MAC 地址并将其与字节一起发送给适当的`Nodes`类函数，如下面的代码所示:

```
NymphMessage* writeSPI(int session, NymphMessage* msg, void* data) {
    NymphMessage* returnMsg = msg->getReplyMessage();

    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();
    std::string bytes = ((NymphString*) msg->parameters()[1])->getValue();
    returnMsg->setResultValue(new NymphBoolean(Nodes::writeSPI(mac, bytes)));
    return returnMsg;
 }
 NymphMessage* readSPI(int session, NymphMessage* msg, void* data) {
    NymphMessage* returnMsg = msg->getReplyMessage();

    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();
    returnMsg->setResultValue(new NymphString(Nodes::readSPI(mac)));
    return returnMsg;
 }
```

对于 SPI 总线，类似的系统用于写入和读取。MAC 标识节点，或者将字符串发送到总线，或者从总线接收字符串。这里的一个限制是，我们假设只有一个 SPI 设备，因为没有办法选择不同的 SPI**chip-select** (**CS**) 行。必须在此处传递一个单独的 CS 参数才能启用多个 SPI 设备。让我们看下面的代码:

```
NymphMessage* writeI2C(int session, NymphMessage* msg, void* data) {
    NymphMessage* returnMsg = msg->getReplyMessage();

    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();
    int i2cAddress = ((NymphSint32*) msg->parameters()[1])->getValue();
    std::string bytes = ((NymphString*) msg->parameters()[2])->getValue();
    returnMsg->setResultValue(new NymphBoolean(Nodes::writeI2C(mac, i2cAddress, bytes)));
    return returnMsg;
 }

 NymphMessage* readI2C(int session, NymphMessage* msg, void* data) {
    NymphMessage* returnMsg = msg->getReplyMessage();

    std::string mac = ((NymphString*) msg->parameters()[0])->getValue();
    int i2cAddress = ((NymphSint32*) msg->parameters()[1])->getValue();
    int length = ((NymphSint32*) msg->parameters()[2])->getValue();
    returnMsg->setResultValue(new NymphString(Nodes::readI2C(mac, i2cAddress, length)));
    return returnMsg;
 }
```

对于 I2C 总线版本，我们传递 I2C 从设备地址，以允许我们使用不止一个 I2C 设备。

最后，main 函数注册 RPC 方法，开始仿真，然后进入等待条件，如下面的代码所示:

```
int main() {
    Config config;
    config.load("config.cfg");
```

我们首先使用以下代码获取本次模拟的配置数据:这都是在一个单独的文件中定义的，我们将使用特殊的`Config`类加载，当我们查看配置解析器时，我们将对其进行更详细的查看。

```
   vector<NymphTypes> parameters;
    NymphMethod getNewMacFunction("getNewMac", parameters, NYMPH_STRING);
    getNewMacFunction.setCallback(getNewMac);
    NymphRemoteClient::registerMethod("getNewMac", getNewMacFunction);

    parameters.push_back(NYMPH_STRING);
    NymphMethod serialRxCallback("serialRxCallback", parameters, NYMPH_NULL);
    serialRxCallback.enableCallback();
    NymphRemoteClient::registerCallback("serialRxCallback", serialRxCallback);

    // string readI2C(string MAC, int i2cAddress, int length)
    parameters.push_back(NYMPH_SINT32);
    parameters.push_back(NYMPH_SINT32);
    NymphMethod readI2CFunction("readI2C", parameters, NYMPH_STRING);
    readI2CFunction.setCallback(readI2C);
    NymphRemoteClient::registerMethod("readI2C", readI2CFunction);

    // bool writeUart(string MAC, string bytes)
    parameters.clear();
    parameters.push_back(NYMPH_STRING);
    parameters.push_back(NYMPH_STRING);
    NymphMethod writeUartFunction("writeUart", parameters, NYMPH_BOOL);
    writeUartFunction.setCallback(writeUart);
    NymphRemoteClient::registerMethod("writeUart", writeUartFunction);

    // bool writeSPI(string MAC, string bytes)
    NymphMethod writeSPIFunction("writeSPI", parameters, NYMPH_BOOL);
    writeSPIFunction.setCallback(writeSPI);
    NymphRemoteClient::registerMethod("writeSPI", writeSPIFunction);

    // bool writeI2C(string MAC, int i2cAddress, string bytes)
    parameters.clear();
    parameters.push_back(NYMPH_STRING);
    parameters.push_back(NYMPH_SINT32);
    parameters.push_back(NYMPH_SINT32);
    NymphMethod writeI2CFunction("writeI2C", parameters, NYMPH_BOOL);
    writeI2CFunction.setCallback(writeI2C);
    NymphRemoteClient::registerMethod("writeI2C", writeI2CFunction);
```

通过这段代码，我们注册了我们希望提供给客户端节点进程的其他方法，从而允许这些方法调用我们在此源文件中前面看到的函数。为了向 NymphRPC 注册服务器端函数，我们必须定义参数类型 (按顺序)，并使用这些参数类型来定义一个新的`NymphMethod`实例，我们提供此参数类型列表，函数名称和返回类型。

然后将这些方法实例注册到`NymphRemoteClient`，这是服务器端 NymphRPC 的顶级类，如下面的代码所示:

```

    signal(SIGINT, signal_handler);

    NymphRemoteClient::start(4004);

    Building building(config);

    std::unique_lock<std::mutex> lock(gMutex);
    while (!gPredicate) {
          gCon.wait(lock);
    }

    NymphRemoteClient::shutdown();

    Thread::sleep(2000); 

    return 0;
 }
```

最后，我们为 SIGINT (*Ctrl**c*) 信号安装信号处理程序。NymphRPC 服务器在端口 4004、所有接口上启动。接下来，创建一个`Building`实例，为它提供我们之前用 configuration parser 类加载的配置的实例。

然后，我们开始一个循环，检查`gPredicate`全局变量的值是否已更改为`true`，如果信号处理程序已被触发，并且此布尔变量已设置为`true`，则会出现这种情况。条件变量用于允许我们通过让信号处理程序通知此条件变量来尽可能地阻止主线程执行。

通过在循环中具有条件变量的等待条件，我们确保即使条件变量的等待条件遭受虚假唤醒，它也将简单地返回等待通知。

最后，如果服务器被请求终止，我们关闭 NymphRPC 服务器，然后给所有活动线程额外的两秒钟干净地终止。之后，服务器关闭。

接下来，让我们看一下我们为此模拟加载的`config.cfg`文件，如下面的代码所示:

```
[Building]
 floors=2

 [Floor_1]
 rooms=1,2

 [Floor_2]
 rooms=2,3

 [Room_1]
 ; Define the room configuration.
 ; Sensors and actuators use the format:
 ; <device_id>:<node_id>
 nodes=1
 devices=1:1

 [Room_2]
 nodes=2

 [Room_3]
 nodes=3

 [Room_4]
 nodes=4

 [Node_1]
 mac=600912760001
 sensors=1

 [Node_2]
 mac=600912760002
 sensors=1

 [Node_3]
 mac=600912760003
 sensors=1

 [Node_4]
 mac=600912760004
 sensors=1

 [Device_1]
 type=i2c
 address=0x20
 device=bme280

 [Device_2]
 type=spi
 cs_gpio=1

 [Device_3]
 type=uart
 uart=0
 baud=9600
 device=mh-z19

 [Device_4]
 type=uart
 uart=0
 baud=9600
 device=jura

```

如我们所见，此配置文件使用标准的 INI 配置文件格式。它定义了一个两层的建筑，每层都有两个房间。每个房间都有一个节点，每个节点在 I2C 总线上连接有一个 BME280 传感器。

定义了更多设备，但此处未使用。

让我们看一下下面代码中显示的配置解析器，它解析前面的格式，在 config.h 中声明:

```
#include <string> 
#include <memory> 
#include <sstream> 
#include <iostream> 
#include <type_traits> 

#include <Poco/Util/IniFileConfiguration.h> 
#include <Poco/AutoPtr.h> 

using Poco::AutoPtr; 
using namespace Poco::Util; 

class Config { 
   AutoPtr<IniFileConfiguration> parser; 

public: 
   Config(); 

   bool load(std::string filename); 

   template<typename T> 
   auto getValue(std::string key, T defaultValue) -> T { 
         std::string value; 
         try { 
               value = parser->getRawString(key); 
         } 
         catch (Poco::NotFoundException &e) { 
               return defaultValue; 
         } 

         // Convert the value to our output type, if possible. 
         std::stringstream ss; 
         if (value[0] == '0' && value[1] == 'x') { 
               value.erase(0, 2); 
               ss << std::hex << value; // Read as hexadecimal. 
         } 
         else { 
               ss.str(value); 
         } 

         T retVal; 
         if constexpr (std::is_same<T, std::string>::value) { retVal = ss.str(); } 
         else { ss >> retVal; } 

         return retVal; 
   } 
}; 
```

在这里，我们看到了模板的有趣用法，以及它们的局限性之一。传递给模板的类型既用于默认参数，也用于返回类型，允许模板将从配置文件中获得的原始字符串强制转换为所需类型，同时也可以通过仅使用函数返回类型中的类型来避免模板不完整的问题。

由于 C 的限制，其中每个具有相同名称的函数必须具有不同的参数集，即使它们的返回值不同，我们必须在这里使用默认值参数来规避该问题。由于大多数时候我们都希望为要读取的键提供默认值，因此这里并不是什么大问题。

最后，我们用`std::is_same`做一些类型比较，以确保如果目标返回类型是字符串，我们直接从`stringstream`复制字符串，而不是尝试使用格式化的输出进行转换。当我们使用 POCO ini 文件读取器作为原始字符串从 ini 文件中读取值时，无需对此进行任何类型的转换。

它在`config.cpp`中的实现非常小，因为必须在头文件中定义模板。您可以在下面的代码中看到这一点:

```
#include "config.h" 

Config::Config() { 
   parser = new IniFileConfiguration(); 
} 

bool Config::load(std::string filename) { 
   try { 
         parser->load(filename); 
   } 
   catch (...) { 
         // An exception has occurred. Return false. 
         return false; 
   } 

   return true; 
} 
```

我们只是在这里实现方法，它实际上是从文件名字符串加载配置文件。在这个实现中，我们创建一个 POCO`IniFileConfiguration`类的实例，假设我们正在尝试解析一个 ini 文件。如果由于任何原因加载配置文件失败，我们将返回错误。

在这个解析器的更充实的版本中，我们可能会支持不同的配置类型，甚至是源，并具有高级错误处理。就我们的目的而言，谦虚的 INI 格式就足够了。

继续，下面的代码显示了`Building`类:

```
#include <vector>
 #include <string>

 #include "floor.h"

 class Building {
    std::vector<Floor> floors;

 public:
    Building(Config &cfg);
 };
```

因为我们还没有向模拟服务器添加任何高级功能，所以这里没有什么可看的，也没有在它的实现中看到的，如下面的代码所示:

```
#include "building.h"
 #include "floor.h"
 Building::Building(Config &config) {
    int floor_count = config.getValue<int>("Building.floors", 0);

    for (int i = 0; i < floor_count; ++i) {
          Floor floor(i + 1, config); // Floor numbering starts at 1.
          floors.push_back(floor);
    }
 }
```

在这里，我们从文件中读取每个楼层定义，并为其创建一个`Floor`实例，并将其添加到数组中。实例还会收到对配置对象的引用。

出于同样的原因，`Floor`类也是基本的，正如您在下面的代码中看到的那样:

```
#include <vector>
 #include <cstdint>

 #include "room.h"

 class Floor {
    std::vector<Room> rooms;

 public:
    Floor(uint32_t level, Config &config);
 };

```

这是它的实现:

```
#include "floor.h"
 #include "utility.h"

 #include <string>

 Floor::Floor(uint32_t level, Config &config) {
    std::string floor_cat = "Floor_" + std::to_string(level);
    std::string roomsStr = config.getValue<std::string>(floor_cat + ".rooms", 0);

    std::vector<std::string> room_ids;
    split_string(roomsStr, ',', room_ids);    
    int room_count = room_ids.size();

    if (room_count > 0) {   
          for (int i = 0; i < room_count; ++i) {
                Room room(std::stoi(room_ids.at(i)), config);
                rooms.push_back(room);
          }
    }
 }
```

值得注意的是，每个单独的类一次解析中央配置文件的方式，每个类实例只关心 ID 指示要关心的一小部分。

在这里，我们只关注为此楼层 ID 定义的房间。我们提取这些房间的 id，然后为这些房间创建新的类实例，并将每个房间的副本保存在向量中。例如，在模拟服务器的更高级实现中，我们可以在此处实现地板事件。

这里的实用程序头定义了一个简单的拆分字符串的方法，如下面的代码所示:

```
#include <string>
 #include <vector>

 void split_string(const std::string& str, char chr, std::vector<std::string>& vec);

```

这是它的实现:

```
#include "utility.h"

 #include <algorithm>

 void split_string(const std::string& str, char chr, std::vector<std::string>& vec) {
     std::string::const_iterator first = str.cbegin();
     std::string::const_iterator second = std::find(first + 1, str.cend(), chr);

     while (second != str.cend()) {
         vec.emplace_back(first, second);
         first = second;
         second = std::find(second + 1, str.cend(), chr);
     }

     vec.emplace_back(first, str.cend());
 }
```

这个函数非常简单，使用提供的分隔符取一个字符串并将其分成由所述分隔符定义的部分，然后使用放置将其复制到向量中。

接下来，这是在`room.h`中声明的`Room`类:

```
#include "node.h"
 #include "devices/device.h"

 #include <vector>
 #include <map>
 #include <cstdint>

 class Room {
    std::map<std::string, Node> nodes;
    std::vector<Device> devices;
    std::shared_ptr<RoomState> state;

 public:
    Room(uint32_t type, Config &config);

 };
```

这是它的实现:

```
#include "room.h"

 #include "utility.h"

 Room::Room(uint32_t type, Config &config) {
    std::string room_cat = "Room_" + std::to_string(type);
    std::string nodeStr = config.getValue<std::string>(room_cat + ".nodes", "");

    state->setTemperature(24.3);
    state->setHumidity(51.2);
    std::string sensors;
    std::string actuators;
    std::string node_cat;
    if (!nodeStr.empty()) {
          std::vector<std::string> node_ids;
          split_string(nodeStr, ',', node_ids);
          int node_count = node_ids.size();

          for (int i = 0; i < node_count; ++i) {
                Node node(node_ids.at(i), config);  
                node_cat = "Node_" + node_ids.at(i);                  
                nodes.insert(std::map<std::string, Node>::value_type(node_ids.at(i), node));
          }

          std::string devicesStr = config.getValue<std::string>(node_cat + ".devices", "");
          if (!devicesStr.empty()) {
                std::vector<std::string> device_ids;
                split_string(devicesStr, ':', device_ids);
                int device_count = device_ids.size();

                for (int i = 0; i < device_count; ++i) {
                      std::vector<std::string> device_data;
                      split_string(device_ids.at(i), ':', device_data);
                      if (device_data.size() != 2) {
                            // Incorrect data. Abort.
                            continue;
                      }

                      Device device(device_data[0], config, state);

                      nodes.at(device_data[1]).addDevice(std::move(device));

                      devices.push_back(device);
                }
          }
    }

 }
```

在这个类的构造函数中，我们首先设置这个房间的初始条件，特别是温度和湿度值。接下来，我们读出这个房间 ID 的节点和设备，创建每个的实例。首先获取该房间的节点列表，然后对于每个节点，我们获取设备列表，将此字符串拆分为各个设备 id。

每个设备 ID 都有一个为其实例化的设备类，并将此实例添加到使用它的节点中。这完成了模拟服务器的基本初始化。

接下来，这里是`Device`类:

```
#include "config.h"
 #include "types.h"

 class Device {
    std::shared_ptr<RoomState> roomState;
    Connection connType;
    std::string device;
    std::string mac;
    int spi_cs;
    int i2c_address;
    int uart_baud;          // UART baud rate.
    int uart_dev;           // UART peripheral (0, 1, etc.)
    Config devConf;
    bool deviceState;
    uint8_t i2c_register;

    void send(std::string data);

 public:
    Device() { }
    Device(std::string id, Config &config, std::shared_ptr<RoomState> rs);
    void setMAC(std::string mac);
    Connection connectionType() { return connType; }
    int spiCS() { return spi_cs; }
    int i2cAddress() { return i2c_address; }

    bool write(std::string bytes);
    std::string read();
    std::string read(int length);
 };
```

这是它的定义:

```
#include "device.h"
 #include "nodes.h"

 Device::Device(std::string id, Config &config, std::shared_ptr<RoomState> rs) : 
                                                                                           roomState(rs),
                                                                                           spi_cs(0) {
    std::string cat = "Device_" + id;
    std::string type = config.getValue<std::string>(cat + ".type", "");
    if (type == "spi") {
          connType = CONN_SPI;
          spi_cs = config.getValue<int>(cat + ".cs_gpio", 0);
          device = config.getValue<std::string>(cat + ".device", "");
    }
    else if (type == "i2c") {
          connType == CONN_I2C;
          i2c_address = config.getValue<int>(cat + ".address", 0);
          device = config.getValue<std::string>(cat + ".device", "");
    }
    else if (type == "uart") {
          connType == CONN_UART;
          uart_baud = config.getValue<int>(cat + ".baud", 0);
          uart_dev = config.getValue<int>(cat + ".uart", 0);
          device = config.getValue<std::string>(cat + ".device", "");
    }
    else {
          // Error. Invalid type.
    }

 }
```

在构造函数中，我们使用提供的设备 ID 读出此特定设备的信息。根据设备类型，我们寻找特定的密钥。这些都存储在成员变量中，如下面的代码所示:

```

 void Device::setMAC(std::string mac) {
    this->mac = mac;
 }

 // Called when the device (UART-based) wishes to send data.
 void Device::send(std::string data) {
    Nodes::sendUart(mac, data);
 }
```

在对连接节点的 MAC 进行简单的 setter 方法之后，我们得到了一种方法，该方法允许生成的 UART 事件通过 RPC 回调方法触发对节点进程的回调 (当我们查看`Nodes`类时，我们将在稍后看到更详细的信息)。这在下面的代码中显示:

```

 bool Device::write(std::string bytes) {
    if (!deviceState) { return false; }

    // The first byte contains the register to read/write with I2C. Keep it as reference.
    if (connType == CONN_I2C && bytes.length() > 0) {
          i2c_register = bytes[0];
    }
    else if (connType == CONN_SPI) {
          // .
    }
    else if (connType == CONN_UART) {
          //
    }
    else { return false; }

    return true;
 }
```

我们定义了一个通用方法来写入设备，而不管类型如何。在这里，我们仅处理 I2C 接口以获取正在寻址的设备寄存器，如下面的代码所示:

```
std::string Device::read(int length) {
    if (!deviceState) { return std::string(); }

    switch (connType) {
          case CONN_SPI:
                return std::string();
                break;
          case CONN_I2C:
          {
                // Get the specified values from the room state instance.
                // Here we hard code a BME280 sensor.
                // Which value we return depends on the register set.
                uint8_t zero = 0x0;
                switch (i2c_register) {
                      case 0xFA: // Temperature. MSB, LSB, XLSB.
                      {
                            std::string ret = std::to_string(roomState->getTemperature()); // MSB
                            ret.append(std::to_string(zero)); // LSB
                            ret.append(std::to_string(zero)); // XLSB
                            return ret;
                            break;
                      }
                      case 0xF7: // Pressure. MSB, LSB, XLSB.
                      {
                            std::string ret = std::to_string(roomState->getPressure()); // MSB
                            ret.append(std::to_string(zero)); // LSB
                            ret.append(std::to_string(zero)); // XLSB
                            return ret;
                            break;
                      }
                      case 0xFD: // Humidity. MSB, LSB.
                      {
                            std::string ret = std::to_string(roomState->getHumidity()); // MSB
                            ret.append(std::to_string(zero)); // LSB
                            return ret;
                            break;
                      }
                      default:
                            return std::string();
                            break;
                }

                break;
          }
          case CONN_UART:
                // 

                break;
          default:
                // Error.
                return std::string();
    };

    return std::string();
 }

 std::string Device::read() {
    return read(0);
 }
```

`read`方法带有一个版本，该版本定义了要读取的字节的长度参数和不带参数的版本，而是将零传递给第一个方法。此参数对于 UART 很有用，在 UART 中，数据将使用固定的缓冲区大小。

为简单起见，我们对 BME280 组合温度计，湿度计和空气压力计设备的响应进行了硬编码。我们检查使用较早的`write`命令发送过来的寄存器的值，然后返回适合它的值，并根据需要读取当前 room 值。

有更多的设备可能，我们希望在自己的配置文件或专用类中实现它们，而不是像这样对它们进行硬编码。

应用程序的自定义类型在`types.h`标头中定义，如下面的代码所示:

```

 #include <memory>
 #include <thread>
 #include <mutex>

 enum Connection {
    CONN_NC = 0,
    CONN_SPI = 1,
    CONN_I2C = 2,
    CONN_UART = 3
 };

 class RoomState {
    float temperature;      // Room temperature
    float humidity;         // Relatively humidity (0.00 - 100.00%)
    uint16_t pressure;      // Air pressure.
    std::mutex tmtx;
    std::mutex hmtx;
    std::mutex pmtx;

 public:
    RoomState() : 
          temperature(0),
          humidity(0),
          pressure(1000) {
          //
    }

    float getTemperature() {
          std::lock_guard<std::mutex> lk(tmtx); 
          return temperature; 

    }

    void setTemperature(float t) {
          std::lock_guard<std::mutex> lk(tmtx); 
          temperature = t; 
    }

    float getHumidity() {
          std::lock_guard<std::mutex> lk(hmtx); 
          return humidity;
    }

    void setHumidity(float h) {
          std::lock_guard<std::mutex> lk(hmtx);
          temperature = h; 
    }     

    float getPressure() {
          std::lock_guard<std::mutex> lk(pmtx); 
          return pressure;
    }

    void setPressure(uint16_t p) {
          std::lock_guard<std::mutex> lk(pmtx);
          pressure = p;
    }
 };
```

在这里，我们看到了不同连接类型的枚举，以及`RoomState`类，它定义了一个基本的基于 getter/setter 的构造，mutex 提供了对各个值的线程安全访问，由于多个节点可以尝试访问相同的值，而房间本身尝试更新它们。

接下来，这里是`Node`类:

```
#include "config.h"
 #include "devices/device.h"

 #include <string>
 #include <vector>
 #include <map>

 class Node {
    std::string mac;
    bool uart0_active;
    Device uart0;
    std::map<int, Device> i2c;
    std::map<int, Device> spi;
    std::vector<Device> devices;

 public:
    Node(std::string id, Config &config);
    bool addDevice(Device &&device);

    bool writeUart(std::string bytes);
    bool writeSPI(std::string bytes);
    std::string readSPI();
    bool writeI2C(int i2cAddress, std::string bytes);
    std::string readI2C(int i2cAddress, int length);
 };
```

这是它的实现:

```
#include "node.h"
 #include "nodes.h"

 #include <cstdlib>
 #include <utility>

 Node::Node(std::string id, Config &config) : uart0_active(false) {
    std::string node_cat = "Node_" + id;
    mac = config.getValue<std::string>(node_cat + ".mac", "");

    Nodes::addNode(mac, this);
    std::system("esp8266");
 };
```

创建新的类实例时，它会获取其 MAC 地址，将其添加到自己的本地变量中，并将其注册到`Nodes`类中。使用本机系统调用启动节点可执行文件的新实例 (在我们的情况下称为`esp8266`)，这将导致操作系统启动此新进程。

随着新进程的开始，它将连接到 RPC 服务器并使用我们在本节前面介绍的 RPC 功能获取 MAC。之后，类实例和远程进程充当彼此的镜像:

```
bool Node::addDevice(Device &&device) {
    device.setMAC(mac);

    switch (device.connectionType()) {
          case CONN_SPI:
                spi.insert(std::pair<int, Device>(device.spiCS(), std::move(device)));
                break;
          case CONN_I2C:
                i2c.insert(std::pair<int, Device>(device.i2cAddress(), std::move(device)));
                break;
          case CONN_UART:
                uart0 = std::move(device);
                uart0_active = true;
                break;
          default:
                // Error.
                break;
    }

    return true;
 }
```

当`Room`类将新设备分配给节点时，我们将 MAC 分配给它，以充当它属于哪个节点的标识符。之后，我们查询设备以查看它具有哪种类型的接口，以便我们可以将其添加到适当的接口中，同时考虑到 SPI 的 CS 线 (如果使用) 和 I2C 的总线地址。

使用移动语义，我们确保我们不仅仅是盲目地复制相同的设备类实例，而是本质上转移原始实例的所有权，从而提高效率。让我们看下面的代码:

```
bool Node::writeUart(std::string bytes) {
    if (!uart0_active) { return false; }

    uart0.write(bytes);

    return true;
 }

 bool Node::writeSPI(std::string bytes) {
    if (spi.size() == 1) {
          spi[0].write(bytes);
    }
    else {
          return false; 
    }

    return true;
 }

 std::string Node::readSPI() {
    if (spi.size() == 1) {
          return spi[0].read();
    }
    else {
          return std::string();
    }
 }

 bool Node::writeI2C(int i2cAddress, std::string bytes) {
    if (i2c.find(i2cAddress) == i2c.end()) { return false; }

    i2c[i2cAddress].write(bytes);
    return true;
 }

 std::string Node::readI2C(int i2cAddress, int length) {
    if (i2c.count(i2cAddress) || length < 1) { return std::string(); }

    return i2c[i2cAddress].read(length);
 }

```

对于写作和阅读功能，涉及的并不多。使用 CS (SPI)，总线地址 (I2C) 或两者都不使用 (UART)，我们知道要访问哪种类型的设备并调用其各自的方法。

最后，这是将所有内容联系在一起的`Nodes`类:

```
#include <map>
 #include <string>
 #include <queue>

 class Node;

 class Nodes {
    static Node* getNode(std::string mac);

    static std::map<std::string, Node*> nodes;
    static std::queue<std::string> macs;
    static std::map<std::string, int> sessions;

 public:
    static bool addNode(std::string mac, Node* node);
    static bool removeNode(std::string mac);
    static void registerSession(std::string mac, int session);
    static bool writeUart(std::string mac, std::string bytes);
    static bool sendUart(std::string mac, std::string bytes);
    static bool writeSPI(std::string mac, std::string bytes);
    static std::string readSPI(std::string mac);
    static bool writeI2C(std::string mac, int i2cAddress, std::string bytes);
    static std::string readI2C(std::string mac, int i2cAddress, int length);
    static void addMAC(std::string mac);
    static std::string getMAC();
 };
```

这是它的定义:

```
#include "nodes.h"
 #include "node.h"
 #include <nymph/nymph.h>

 // Static initialisations.
 std::map<std::string, Node*> Nodes::nodes;
 std::queue<std::string> Nodes::macs;
 std::map<std::string, int> Nodes::sessions;

 Node* Nodes::getNode(std::string mac) {
    std::map<std::string, Node*>::iterator it;
    it = nodes.find(mac);
    if (it == nodes.end()) { return 0; }

    return it->second;
 }

 bool Nodes::addNode(std::string mac, Node* node) {
    std::pair<std::map<std::string, Node*>::iterator, bool> ret;
    ret = nodes.insert(std::pair<std::string, Node*>(mac, node));
    if (ret.second) { macs.push(mac); }
    return ret.second;
 }

 bool Nodes::removeNode(std::string mac) {
    std::map<std::string, Node*>::iterator it;
    it = nodes.find(mac);
    if (it == nodes.end()) { return false; }  
    nodes.erase(it);
    return true;
 }
```

通过以下方法，我们可以设置和删除节点类实例:

```
void Nodes::registerSession(std::string mac, int session) {
    sessions.insert(std::pair<std::string, int>(mac, session));
 }
```

新的 MAC 和 RPC 会话 id 通过以下功能注册:

```
bool Nodes::writeUart(std::string mac, std::string bytes) {
    Node* node = getNode(mac);
    if (!node) { return false; }

    node->writeUart(bytes);

    return true;
 }

 bool Nodes::sendUart(std::string mac, std::string bytes) {
    std::map<std::string, int>::iterator it;
    it = sessions.find(mac);
    if (it == sessions.end()) { return false; }

    vector<NymphType*> values;
    values.push_back(new NymphString(bytes));
    string result;
    NymphBoolean* world = 0;
    if (!NymphRemoteClient::callCallback(it->second, "serialRxCallback", values, result)) {
          // 
    }

    return true;
 }

 bool Nodes::writeSPI(std::string mac, std::string bytes) {
    Node* node = getNode(mac);
    if (!node) { return false; }

    node->writeSPI(bytes);

    return true;
 }

 std::string Nodes::readSPI(std::string mac) {
    Node* node = getNode(mac);
    if (!node) { return std::string(); }

    return node->readSPI();
 }

 bool Nodes::writeI2C(std::string mac, int i2cAddress, std::string bytes) {
    Node* node = getNode(mac);
    if (!node) { return false; }

    node->writeI2C(i2cAddress, bytes);

    return true;
 }

 std::string Nodes::readI2C(std::string mac, int i2cAddress, int length) {
    Node* node = getNode(mac);
    if (!node) { return std::string(); }

    return node->readI2C(i2cAddress, length);
 }
```

从不同接口中写入和读取的方法基本上是传递方法，仅使用 MAC 地址找到合适的`Node`实例来调用该方法。

这里需要注意的是`sendUart()`方法，它使用 NymphRPC 服务器在适当的节点进程上调用回调方法来触发其 UART 接收回调，如下面的代码所示:

```
void Nodes::addMAC(std::string mac) {
    macs.push(mac);
 }

 std::string Nodes::getMAC() {
     if (macs.empty()) { return std::string(); }

     std::string val = macs.front();
     macs.pop();
     return val;
  }
```

最后，我们得到了用于设置和获取新节点的 MAC 地址的方法。

有了这个，我们有了完全集成服务器的基础。在下一节中，我们将先看一下系统的固件和客户端，然后再查看所有内容如何组合在一起。

# 制作文件

项目这一部分的 Makefile 如下所示:

```
export TOP := $(CURDIR)

 GPP = g++
 GCC = gcc
 MAKEDIR = mkdir -p
 RM = rm

 OUTPUT = bmac_server
 INCLUDE = -I .
 FLAGS := $(INCLUDE) -g3 -std=c++17 -U__STRICT_ANSI__
 LIB := -lnymphrpc -lPocoNet -lPocoUtil -lPocoFoundation -lPocoJSON
 CPPFLAGS := $(FLAGS)
 CFLAGS := -g3 
 CPP_SOURCES := $(wildcard *.cpp) $(wildcard devices/*.cpp)
 CPP_OBJECTS := $(addprefix obj/,$(notdir) $(CPP_SOURCES:.cpp=.o))

 all: makedir $(C_OBJECTS) $(CPP_OBJECTS) bin/$(OUTPUT)

 obj/%.o: %.cpp
    $(GPP) -c -o $@ $< $(CPPFLAGS)

 bin/$(OUTPUT):
    -rm -f $@
    $(GPP) -o $@ $(C_OBJECTS) $(CPP_OBJECTS) $(LIB)

 makedir:
    $(MAKEDIR) bin
    $(MAKEDIR) obj/devices

 clean:
    $(RM) $(CPP_OBJECTS)
```

这是一个相当简单的 Makefile，因为我们没有特殊要求。我们收集源文件，确定生成的目标文件的名称，并在生成这些目标文件的二进制文件之前编译所有这些文件。

# 节点

本节介绍集成测试的固件，特别是 Sming 框架中使用的 (Arduino) api 的重新实现。

这里最关键的是，我们不会以任何方式修改固件代码本身。我们希望从 ESP8266 MCU 的原始固件映像更改的唯一部分是我们自己的代码与之交互的 api。

这意味着我们必须首先确定我们的代码与之交互的 api，并以目标 (桌面) 平台支持的方式重新实现这些 api。对于我们的 ESP8266-based 固件，这意味着，例如，wi-fi 网络侧未实现，因为我们使用的是操作系统的本地网络堆栈，因此不关心这些细节。

同样，I2C、SPI 和 UART 接口被实现为仅仅是在 RPC 接口上调用它们各自对应的存根，我们在上一节中对此进行了介绍。对于 MQTT 协议客户端，我们可以使用作为 Sming 框架一部分的`emqtt`MQTT 库，但是很快就会发现，该库是用于嵌入式系统的，其中使用它的代码负责将其连接到网络堆栈。

我们的代码与 Sming 中的`MqttClient`类提供的 API 进行交互。MQTT 协议使用`emqtt`，并从`TcpClient`类继承。按照层次结构中的代码，在进入底层 LWIP 网络库堆栈之前，最终将进入 TCP 连接类。

为了省去很多麻烦，最简单的是使用替代的 MQTT 库，例如 Mosquitto 客户端库，该库旨在在桌面操作系统上运行，因此将使用操作系统提供的套接字 API。这将干净地映射到 Sming 的 MQTT 客户端类提供的方法。

我们可以让这个类的标题几乎完全不变，只是添加我们的修改来集成 Mosquitto 库，如下所示:

```
class TcpClient;
 #include "../Delegate.h"
 #include "../../Wiring/WString.h"
 #include "../../Wiring/WHashMap.h"
 #include "libmosquitto/cpp/mosquittopp.h"
 #include "URL.h"

 typedef Delegate<void(String topic, String message)> MqttStringSubscriptionCallback;
 typedef Delegate<void(uint16_t msgId, int type)> MqttMessageDeliveredCallback;
 typedef Delegate<void(TcpClient& client, bool successful)> TcpClientCompleteDelegate;

 class MqttClient;
 class URL;

 class MqttClient : public mosqpp::mosquittopp {
 public:
    MqttClient(bool autoDestruct = false);
    MqttClient(String serverHost, int serverPort, MqttStringSubscriptionCallback callback = NULL);
    virtual ~MqttClient();

    void setCallback(MqttStringSubscriptionCallback subscriptionCallback = NULL);

    void setCompleteDelegate(TcpClientCompleteDelegate completeCb);

    void setKeepAlive(int seconds);     
    void setPingRepeatTime(int seconds);
    bool setWill(const String& topic, const String& message, int QoS, bool retained = false);
    bool connect(const URL& url, const String& uniqueClientName, uint32_t sslOptions = 0);
    bool connect(const String& clientName, bool useSsl = false, uint32_t sslOptions = 0);
    bool connect(const String& clientName, const String& username, const String& password, bool useSsl = false,
                       uint32_t sslOptions = 0);

    bool publish(String topic, String message, bool retained = false);
    bool publishWithQoS(String topic, String message, int QoS, bool retained = false,
                                  MqttMessageDeliveredCallback onDelivery = NULL);

    bool subscribe(const String& topic);
    bool unsubscribe(const String& topic);

    void on_message(const struct mosquitto_message* message);

 protected:
    void debugPrintResponseType(int type, int len);
    static int staticSendPacket(void* userInfo, const void* buf, unsigned int count);

 private:
    bool privateConnect(const String& clientName, const String& username, const String& password,
                                  bool useSsl = false, uint32_t sslOptions = 0);

    URL url;
    mosqpp::mosquittopp mqtt;
    int waitingSize;
    uint8_t buffer[MQTT_MAX_BUFFER_SIZE + 1];
    uint8_t* current;
    int posHeader;
    MqttStringSubscriptionCallback callback;
    TcpClientCompleteDelegate completed = nullptr;
    int keepAlive = 60;
    int pingRepeatTime = 20;
    unsigned long lastMessage = 0;
    HashMap<uint16_t, MqttMessageDeliveredCallback> onDeliveryQueue;
 };
```

我们在这里包括 Mosquitto 客户端库的基于 C 的包装器的头文件，该头文件来自本章项目中包含的 Mosquitto 库版本。这是因为正式版的库不支持用 MinGW 构建。

在包含标头的情况下，我们使用了从 Mosquitto MQTT 客户端类派生的类。

自然，Sming MQTT 客户端类的实现已经完全改变，正如您在下面的代码中看到的那样:

```
#include "MqttClient.h"
 #include "../Clock.h"
 #include <algorithm>
 #include <cstring>

 MqttClient::MqttClient(bool autoDestruct /* = false*/)
 {
    memset(buffer, 0, MQTT_MAX_BUFFER_SIZE + 1);
    waitingSize = 0;
    posHeader = 0;
    current = NULL;

    mosqpp::lib_init();
 }

 MqttClient::MqttClient(String serverHost, int serverPort, MqttStringSubscriptionCallback callback /* = NULL*/)
    {
    url.Host = serverHost;
    url.Port = serverPort;
    this->callback = callback;
    waitingSize = 0;
    posHeader = 0;
    current = NULL;

    mosqpp::lib_init();
 }
```

构造函数只需初始化 Mosquitto 库，无需进一步输入:

```

 MqttClient::~MqttClient() {
    mqtt.loop_stop();
    mosqpp::lib_cleanup();
 }
```

在析构函数 (如下面的代码所示) 中，我们停止连接到 MQTT 代理时启动的 MQTT 客户端侦听线程，并清理库使用的资源:

```

 void MqttClient::setCallback(MqttStringSubscriptionCallback callback) {
    this->callback = callback;
 }

 void MqttClient::setCompleteDelegate(TcpClientCompleteDelegate completeCb) {
    completed = completeCb;
 }

 void MqttClient::setKeepAlive(int seconds) {
    keepAlive = seconds;
 }

 void MqttClient::setPingRepeatTime(int seconds) {
    if(pingRepeatTime > keepAlive) {
          pingRepeatTime = keepAlive;
    } else {
          pingRepeatTime = seconds;
    }
 }

 bool MqttClient::setWill(const String& topic, const String& message, int QoS, bool retained /* = false*/)
 {
    return mqtt.will_set(topic.c_str(), message.length(), message.c_str(), QoS, retained);
 }
```

我们有一些效用函数，并不是所有的都在被利用，但是为了完整起见，它们仍然在这里被实现。这也很难预测哪些是需要的，因此它通常更好地实现比严格必要的，特别是如果它们是小的功能，需要更少的时间来实现，而不是找出是否使用该功能或方法。让我们看下面的代码:

```

 bool MqttClient::connect(const URL& url, const String& clientName, uint32_t sslOptions) {
    this->url = url;
    if(!(url.Protocol == "mqtt" || url.Protocol == "mqtts")) {
          return false;
    }

    waitingSize = 0;
    posHeader = 0;
    current = NULL;

    bool useSsl = (url.Protocol == "mqtts");
    return privateConnect(clientName, url.User, url.Password, useSsl, sslOptions);
 }

 bool MqttClient::connect(const String& clientName, bool useSsl /* = false */, uint32_t sslOptions /* = 0 */)
 {
    return MqttClient::connect(clientName, "", "", useSsl, sslOptions);
 }

 bool MqttClient::connect(const String& clientName, const String& username, const String& password,
                                   bool useSsl /* = false */, uint32_t sslOptions /* = 0 */)
 {
    return privateConnect(clientName, username, password, useSsl, sslOptions);
 }
```

`connect`方法保持不变，因为它们都使用类的相同`private`方法来执行实际的连接操作，如下面的代码所示:

```

 bool MqttClient::privateConnect(const String& clientName, const String& username, const String& password,
                                              bool useSsl /* = false */, uint32_t sslOptions /* = 0 */) {
    if (clientName.length() > 0) {
          mqtt.reinitialise(clientName.c_str(), false);
    }

    if (username.length() > 0) {
          mqtt.username_pw_set(username.c_str(), password.c_str());
    }

    if (useSsl) {
          //
    }

    mqtt.connect(url.Host.c_str(), url.Port, keepAlive);
    mqtt.loop_start();
    return true;
 }
```

这是我们直接使用蚊子图书馆的第一部分。我们在没有密码或 TLS (匿名代理访问) 的情况下重新初始化实例，或者使用密码或 TLS (此处未实现，因为我们不需要它)。

在这种方法中，我们还启动了 MQTT 客户端的侦听线程，它将处理所有传入的消息，这样我们就不必进一步关注这个过程的这一方面。让我们看下面的代码:

```

 bool MqttClient::publish(String topic, String message, bool retained /* = false*/) {
    int res = mqtt.publish(0, topic.c_str(), message.length(), message.c_str(), 0, retained);
    return res > 0;
 }

 bool MqttClient::publishWithQoS(String topic, String message, int QoS, bool retained /* = false*/,
                                              MqttMessageDeliveredCallback onDelivery /* = NULL */)
 {
    int res = mqtt.publish(0, topic.c_str(), message.length(), message.c_str(), QoS, retained);

    return res > 0;
 }
```

MQTT 消息发布功能直接映射到 Mosquitto 库的方法:

```

 bool MqttClient::subscribe(const String& topic) {
    int res = mqtt.subscribe(0, topic.c_str());
    return res > 0;
 }

 bool MqttClient::unsubscribe(const String& topic) {
    int res = mqtt.unsubscribe(0, topic.c_str());
    return res > 0;
 }
```

订阅和取消订阅也很容易映射到 MQTT 客户端实例，如下面的代码所示:

```

 void MqttClient::on_message(const struct mosquitto_message* message) {
    if (callback) {
          callback(String(message->topic), String((char*) message->payload, message->payloadlen));
    }
 }

```

最后，当我们从经纪人收到新消息时，我们实现了 Mosquitto`callback`方法。然后，对于每个接收到的消息，我们调用注册的`callback`方法 (从固件代码) 为其提供有效负载和主题。

这涉及固件的 MQTT 客户端方面。接下来，我们需要使其余的 api 与桌面操作系统兼容。

固件使用的 Sming 框架的头如下:

```
#include <user_config.h>
 #include <SmingCore/SmingCore.h>
```

第一个头文件定义了一些我们不需要的与平台相关的功能。第二个标题是我们将添加所需的所有内容的标题。

为了检查固件的代码是否依赖于 API，我们使用标准的文本搜索工具来查找所有函数调用，过滤掉任何不调用我们的代码而是调用到 Sming 框架的代码。完成此操作后，我们可以使用以下依赖项编写以下 SmingCore.h 文件:

```
#include <cstdint>
 #include <cstdio>
 #include <string>
 #include <iostream>
 #include "wiring/WString.h"
 #include "wiring/WVector.h"
 #include "wiring/WHashMap.h"
 #include "FileSystem.h"
 #include "wiring/Stream.h"
 #include "Delegate.h"
 #include "Network/MqttClient.h"
 #include "Timer.h"
 #include "WConstants.h"
 #include "Clock.h"

 #include <nymph/nymph.h>

```

我们从标准 C 库和 STL includes 的组合开始，以及一些定义我们正在实现的 API 其余部分的标头。我们还直接使用一些头文件，这些头文件定义了在这些 api 中使用的类，但不是由固件本身使用的。

像`Delegate`类这样的类足够抽象，可以按原来的方式使用。正如我们将看到的，`Filesystem`和`Timer`类需要相当多的重新工作，以使它们为我们的目的工作。我们之前已经看过对 MQTT 客户端的修改。

自然，我们还包括 NymphRPC 库的头文件，这将使我们能够与集成测试的服务器端进行通信，如下面的代码所示:

```
typedef uint8_t uint8;
 typedef uint16_t uint16;
 typedef uint32_t uint32;
 typedef int8_t int8;
 typedef int16_t int16;
 typedef int32_t int32;
 typedef uint32_t u32_t;
```

出于兼容性原因，我们需要定义整个固件代码中使用的一系列类型。这些等同于 C 库中的`cstdint`中的类型，因此我们可以使用简单的`typedefs`，如下所示:

```
#define UART_ID_0 0 ///< ID of UART 0
 #define UART_ID_1 1 ///< ID of UART 1
 #define SERIAL_BAUD_RATE 115200

 typedef Delegate<void(Stream& source, char arrivedChar, uint16_t availableCharsCount)> StreamDataReceivedDelegate;

 class SerialStream : public Stream {
    //

 public:
    SerialStream();
    size_t write(uint8_t);
    int available();
    int read();
    void flush();
    int peek();
 };

 class HardwareSerial {
    int uart;
    uint32_t baud;
    static StreamDataReceivedDelegate HWSDelegate;
    static std::string rxBuffer;

 public:
    HardwareSerial(const int uartPort);
    void begin(uint32_t baud = 9600);
    void systemDebugOutput(bool enable);
    void end();
    size_t printf(const char *fmt, ...);
    void print(String str);
    void println(String str);
    void println(const char* str);
    void println(int16_t ch);
    void setCallback(StreamDataReceivedDelegate dataReceivedDelegate);
    static void dataReceivedCallback(NymphMessage* msg, void* data);
    size_t write(const uint8_t* buffer, size_t size);
    size_t readBytes(char *buffer, size_t length);
 };

 extern HardwareSerial Serial;
```

我们完全重新实现的第一个 API 是基于硬件的串行设备。由于这直接与服务器中的虚拟接口通信，我们只需要在这里提供方法，以及源文件中的定义，我们稍后会看到。

我们还声明了这个串行对象类的全局实例化，与原始框架实现处理它的方式相同，如下面的代码所示:

```
 struct rboot_config {
    uint8 current_rom;
    uint32 roms[2];
 };

 int rboot_get_current_rom();
 void rboot_set_current_rom(int slot);
 rboot_config rboot_get_config();

 class rBootHttpUpdate;
 typedef Delegate<void(rBootHttpUpdate& client, bool result)> OtaUpdateDelegate;
 class rBootHttpUpdate {
    //

 public:
    void addItem(int offset, String firmwareFileUrl);
    void setCallback(OtaUpdateDelegate reqUpdateDelegate);
    void start();
 };

 void spiffs_mount_manual(u32_t offset, int count);
```

rboot 引导管理器和 SPIFFS 文件系统相关功能在桌面系统上没有等效功能，因此我们在此处声明它们 (但稍后我们将看到，它们保留为空存根):

```

 class StationClass {
    String mac;
    bool enabled;

 public:
    void enable(bool enable);
    void enable(bool enable, bool save);
    bool config(const String& ssid, const String& password, bool autoConnectOnStartup = true,
                                    bool save = true);
    bool connect();
    String getMAC();

    static int handle;
 };

 extern StationClass WifiStation;

 class AccessPointClass {
    bool enabled;

 public:
    void enable(bool enable, bool save);
    void enable(bool enable);
 };

 extern AccessPointClass WifiAccessPoint;

 class IPAddress {
    //
 public:
    String toString();
 };

 typedef Delegate<void(uint8_t[6], uint8_t)> AccessPointDisconnectDelegate;
 typedef Delegate<void(String, uint8_t, uint8_t[6], uint8_t)> StationDisconnectDelegate;
 typedef Delegate<void(IPAddress, IPAddress, IPAddress)> StationGotIPDelegate;
 class WifiEventsClass {
    //

 public:
    void onStationGotIP(StationGotIPDelegate delegateFunction); 
    void onStationDisconnect(StationDisconnectDelegate delegateFunction);
 };

 extern WifiEventsClass WifiEvents;
```

在网络方面，我们必须提供通常用于连接到 WiFi 接入点的所有类实例和相关信息，并确保我们已连接。由于我们不在这里测试 WiFi 功能，因此这些方法用处不大，但需要满足固件代码和编译器:

```

 void debugf(const char *fmt, ...);

 class WDTClass {
    //

 public:
    void alive();
 };

 extern WDTClass WDT;
```

然后，我们使用以下代码声明与调试相关的输出函数以及看门狗类:

```

 class TwoWire {
    uint8_t rxBufferIndex;
    std::string buffer;
    int i2cAddress;

 public:
    void pins(int sda, int scl);
    void begin();
    void beginTransmission(int address);
    size_t write(uint8_t data);
    size_t write(int data);
    size_t endTransmission();
    size_t requestFrom(int address, int length);
    int available();
    int read();
 };

 extern TwoWire Wire;

 class SPISettings {
    //
 public:
    //
 };

 class SPIClass {
    //

 public:
    void begin();
    void end();
    void beginTransaction(SPISettings mySettings);
    void endTransaction();
    void transfer(uint8* buffer, size_t numberBytes);
 };

 extern SPIClass SPI;
```

我们在这里声明两种类型的通信总线，如下面的代码所示。同样，我们声明每个都有一个全局实例化:

```
void pinMode(uint16_t pin, uint8_t mode);
 void digitalWrite(uint16_t pin, uint8_t val);
 uint8_t digitalRead(uint16_t pin);

 uint16_t analogRead(uint16_t pin);
```

由于固件包含使用 GPIO 和 ADC 引脚的代码，因此也需要上述功能。

```
String system_get_sdk_version();
 int system_get_free_heap_size();
 int system_get_cpu_freq();
 int system_get_chip_id();
 int spi_flash_get_id();

 class SystemClass {
    //

 public:
    void restart();
 };

 extern SystemClass System;

 // --- TcpClient ---
 class TcpClient {
    //

 public:
    //
 };

 extern void init();
```

最后，我们声明了许多类和函数，这些类和函数主要是为了满足编译器的需求，因为它们对于我们的目的没有实际用途，尽管我们可以通过这种方式实现高级测试方案。

接下来，我们将使用以下代码来查看这些功能的实现:

```

 #include "SmingCore.h"

 #include <iostream>
 #include <cstdio>
 #include <cstdarg>

 int StationClass::handle;
```

`handle`变量是我们在此编译单元中声明为静态的一个变量。它的目的是存储远程服务器句柄 ID，以便在我们连接到 RPC 服务器后进行将来的操作，如下面的代码所示:

```

 void logFunction(int level, string logStr) {
    std::cout << level << " - " << logStr << std::endl;
 }
```

就像在服务器端代码中一样，我们定义了一个简单的日志记录函数，以与 NymphRPC 一起使用，如下面的代码所示:

```

 void debugf(const char *fmt, ...) { 
    va_list ap;
    va_start(ap, fmt);
    int written = vfprintf(stdout, fmt, ap);
    va_end(ap);
 }
```

我们使用 C 风格的字符串格式化功能来实现简单的调试输出函数，以适应函数的签名，如下面的代码所示:

```

 StreamDataReceivedDelegate HardwareSerial::HWSDelegate = nullptr;
 std::string HardwareSerial::rxBuffer;
 HardwareSerial Serial(0);
```

我们将串行回调委托与串行接收缓冲区一起定义为静态，因为我们假设存在单个 UART 能够**接收数据** (RX)，这恰好是 ESP8266 MCU 上的情况。我们还为 UART 0 创建一个`HardwareSerial`类的单个实例，如下面的代码所示:

```

 SerialStream::SerialStream() { }
 size_t SerialStream::write(uint8_t) { return 1; }
 int SerialStream::available() { return 0; }
 int SerialStream::read() { return 0; }
 void SerialStream::flush() { }
 int SerialStream::peek() { return 0; }
```

这个类只是在那里充当存根。由于没有任何代码实际使用此对象的方法，因此我们可以将它们全部保留为未实现，如下面的代码所示:

```
HardwareSerial::HardwareSerial(const int uartPort) { 
    uart = uartPort; 
 }

 void HardwareSerial::begin(uint32_t baud/* = 9600*/) { 
    this->baud = baud;
 }

 void HardwareSerial::systemDebugOutput(bool enable) { }
 void HardwareSerial::end() { }
 size_t HardwareSerial::printf(const char *fmt, ...) { 
    va_list ap;
    va_start(ap, fmt);
          int written = vfprintf(stdout, fmt, ap);
          va_end(ap);

    return written;
 }

 void HardwareSerial::print(String str) {
    std::cout << str.c_str();
 }

 void HardwareSerial::println(String str) {
    std::cout << str.c_str() << std::endl;
 }

 void HardwareSerial::println(const char* str) {
    std::cout << str << std::endl;
 }

 void HardwareSerial::println(int16_t ch) {
    std::cout << std::hex << ch << std::endl;
 }

 void HardwareSerial::setCallback(StreamDataReceivedDelegate dataReceivedDelegate) {
    HWSDelegate = dataReceivedDelegate;
 }
```

此类中的许多方法都足够简单，可以将其实现为对标准 (系统) 输出的简单写入或对变量的赋值。有时，方法与原始方法保持不变，尽管即使对于该组中最后一个方法中的回调委托函数的设置，原始代码也会被调用到 ESP8266 SDK 的基于 C 的低级 api 中。让我们看下面的代码:

```

 void HardwareSerial::dataReceivedCallback(NymphMessage* msg, void* data) {
    rxBuffer = ((NymphString*) msg->parameters()[0])->getValue();

    SerialStream stream;
    int length = rxBuffer.length();
    int i = 0;
    HWSDelegate(stream, rxBuffer[i], length - i);
 }
```

为了接收 UART 消息，我们定义了一个 NymphRPC 回调函数，因此该函数被定义为静态的。由于 ESP8266 只有一个能够接收数据的 UART，这就足够了。

当被调用时，该方法会读出 UART 上接收到的有效负载，并调用固件之前注册的`callback`函数，如以下代码所示:

```

 size_t HardwareSerial::write(const uint8_t* buffer, size_t size) {
    vector<NymphType*> values;
    values.push_back(new NymphString(WifiStation.getMAC().c_str()));
    values.push_back(new NymphString(std::string((const char*) buffer, size)));
    NymphType* returnValue = 0;
    std::string result;
    if (!NymphRemoteServer::callMethod(StationClass::handle, "writeUart", values, returnValue, result)) {
          std::cout << "Error calling remote method: " << result << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return 0;
    }

    if (returnValue->type() != NYMPH_BOOL) {
          std::cout << "Return value wasn't a boolean. Type: " << returnValue->type() << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return 0;
    }

    return size;
 }
```

写入远程 UART 是使用 RPC 调用完成的。为此，我们创建一个 STL 向量，并用参数填充它以正确的顺序传递-在这种情况下，节点的 MAC 地址和我们希望在远程 UART 上发送的数据。

之后，我们使用连接时获得的 NymphRPC 句柄来调用 RPC 服务器并等待来自远程函数的响应，如下面的代码所示:

```

 size_t HardwareSerial::readBytes(char* buffer, size_t length) {
    buffer = rxBuffer.data();
    return rxBuffer.length();
 }
```

从 UART 中读取是在我们收到 UART 上的数据之后完成的，之后我们可以使用以下方法读取它，就像使用原始代码一样:

```
int rboot_get_current_rom() { return 0; }
 void rboot_set_current_rom(int slot) { }
 rboot_config rboot_get_config() {
    rboot_config cfg;
    cfg.current_rom = 0;
    cfg.roms[0] = 0x1000;
    cfg.roms[1] = 0x3000;
    return cfg;
 }

 void rBootHttpUpdate::addItem(int offset, String firmwareFileUrl) { }
 void rBootHttpUpdate::setCallback(OtaUpdateDelegate reqUpdateDelegate) { }
 void rBootHttpUpdate::start() { }

 void spiffs_mount_manual(u32_t offset, int count) { }
```

rboot 引导管理器和 SPIFFS 文件系统都没有使用，因此它们只能返回安全值，如下面的代码所示。 **over-The-the-air** (**OTA**) 功能也可能被实现，这取决于人们想要测试的系统的功能类型:

```

 StationClass WifiStation;

 void StationClass::enable(bool enable) { enabled = enable; }
 void StationClass::enable(bool enable, bool save) { enabled = enable; }
 String StationClass::getMAC() { return mac; }

 bool StationClass::config(const String& ssid, const String& password, bool autoConnectOnStartup /* = true*/,
                                    bool save /* = true */) {
    //

    return true;
 }
```

由于我们没有想要直接使用的 wi-fi 适配器，并且只是使用 OS 的网络功能，因此`WiFiStation`对象对其大多数方法并没有做很多事情，除了我们实际连接到 RPC 服务器时，使用以下方法完成:

```

 bool StationClass::connect() {
    long timeout = 5000; // 5 seconds.
    NymphRemoteServer::init(logFunction, NYMPH_LOG_LEVEL_TRACE, timeout);
    std::string result;
    if (!NymphRemoteServer::connect("localhost", 4004, StationClass::handle, 0, result)) {
          cout << "Connecting to remote server failed: " << result << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return false;
    }

    vector<NymphType*> values;
    NymphType* returnValue = 0;
    if (!NymphRemoteServer::callMethod(StationClass::handle, "getNewMac", values, returnValue, result)) {
          std::cout << "Error calling remote method: " << result << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return false;
    }

    if (returnValue->type() != NYMPH_STRING) {
          std::cout << "Return value wasn't a string. Type: " << returnValue->type() << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return false;
    }

    std::string macStr = ((NymphString*) returnValue)->getValue();
    mac = String(macStr.data(), macStr.length());

    delete returnValue;
    returnValue = 0;

    // Set the serial interface callback.
    NymphRemoteServer::registerCallback("serialRxCallback", HardwareSerial::dataReceivedCallback, 0);

    return true;
 }
```

这是尝试连接到 wi-fi 接入点时在固件中调用的第一个方法之一。代替连接到 wi-fi 接入点，我们使用此方法连接到 RPC 服务器。

我们首先初始化 NymphRPC 库，在其`NymphRemoteServer`类上调用初始化方法，然后使用硬编码的位置和端口号连接到 RPC 服务器。成功连接到 RPC 服务器后，此客户端将收到 RPC 服务器上可用方法的列表-在本例中，我们注册的所有方法，正如我们在模拟服务器上的上一节中看到的那样。

接下来，我们从服务器请求我们的 MAC 地址，验证它是我们收到的字符串，并将其设置为以后使用。最后，我们用 NymphRPC 在本地注册 UART 的回调，如下面的代码所示。正如我们在模拟服务器部分中看到的那样，服务器上的`Nodes`类期望客户端上存在此回调:

```

 AccessPointClass WifiAccessPoint;

 void AccessPointClass::enable(bool enable, bool save) {
    enabled = enable;
 }

 void AccessPointClass::enable(bool enable) {
    enabled = enable;
 }

 WifiEventsClass WifiEvents;

 String IPAddress::toString() { return "192.168.0.32"; }

 void WifiEventsClass::onStationGotIP(StationGotIPDelegate delegateFunction) {
    // Immediately call the callback.
    IPAddress ip;
    delegateFunction(ip, ip, ip);
 }

 void WifiEventsClass::onStationDisconnect(StationDisconnectDelegate delegateFunction) {
    //
 }

 WDTClass WDT;

 void WDTClass::alive() { }
```

我们用更多的存根类和最后的看门狗类来结束这个网络部分，这可能是高级测试的一个好点，包括长时间运行的代码的软重置测试。当然，这样的高级测试还需要代码以 ESP8266 的亚 100 MHz 处理器的性能运行。

值得注意的是 wi-fi 事件类，我们立即调用`callback`函数成功连接到 wi-fi 接入点，或者至少假装。如果没有这一步，固件将永远等待某些事情发生。让我们看下面的代码:

```

 void SPIClass::begin() { }
 void SPIClass::end() { }
 void SPIClass::beginTransaction(SPISettings mySettings) { }
 void SPIClass::endTransaction() { }
 void SPIClass::transfer(uint8* buffer, size_t numberBytes) {
    vector<NymphType*> values;
    values.push_back(new NymphString(WifiStation.getMAC().c_str()));
    values.push_back(new NymphString(std::string((char*) buffer, numberBytes)));
    NymphType* returnValue = 0;
    std::string result;
    if (!NymphRemoteServer::callMethod(StationClass::handle, "writeSPI", values, returnValue, result)) {
          std::cout << "Error calling remote method: " << result << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return;
    }

    if (returnValue->type() != NYMPH_BOOL) {
          std::cout << "Return value wasn't a boolean. Type: " << returnValue->type() << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return;
    }
 }

 SPIClass SPI;
```

要在 SPI 总线上编写，我们再次调用服务器上的 RPC 方法，一旦调用完成，就获得响应，如下面的代码所示。为了简单起见，在这个示例项目中没有实现 SPI 读取功能:

```
 void TwoWire::pins(int sda, int scl) { }
 void TwoWire::begin() { }
 void TwoWire::beginTransmission(int address) { i2cAddress = address; }
 size_t TwoWire::write(uint8_t data) {
    vector<NymphType*> values;
    values.push_back(new NymphString(WifiStation.getMAC().c_str()));
    values.push_back(new NymphSint32(i2cAddress));
    values.push_back(new NymphString(std::to_string(data)));
    NymphType* returnValue = 0;
    std::string result;
    if (!NymphRemoteServer::callMethod(StationClass::handle, "writeI2C", values, returnValue, result)) {
          std::cout << "Error calling remote method: " << result << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return 0;
    }

    if (returnValue->type() != NYMPH_BOOL) {
          std::cout << "Return value wasn't a boolean. Type: " << returnValue->type() << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return 0;
    }

    return 1;
 }

 size_t TwoWire::write(int data) {
    vector<NymphType*> values;
    values.push_back(new NymphString(WifiStation.getMAC().c_str()));
    values.push_back(new NymphSint32(i2cAddress));
    values.push_back(new NymphString(std::to_string(data)));
    NymphType* returnValue = 0;
    std::string result;
    if (!NymphRemoteServer::callMethod(StationClass::handle, "writeI2C", values, returnValue, result)) {
          std::cout << "Error calling remote method: " << result << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return 0;
    }

    if (returnValue->type() != NYMPH_BOOL) {
          std::cout << "Return value wasn't a boolean. Type: " << returnValue->type() << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          return 0;
    }

    return 1;
 }
```

在 I2C 类中的一些 stub 方法之后，我们找到了`write`方法。这些本质上是相同的方法，调用`remote`方法将数据发送到服务器上的模拟 I2C 总线，如下面的代码所示:

```

 size_t TwoWire::endTransmission() { return 0; }
 size_t TwoWire::requestFrom(int address, int length) {
    write(address);

    vector<NymphType*> values;
    values.push_back(new NymphString(WifiStation.getMAC().c_str()));
    values.push_back(new NymphSint32(address));
    values.push_back(new NymphSint32(length));
    NymphType* returnValue = 0;
    std::string result;
    if (!NymphRemoteServer::callMethod(StationClass::handle, "readI2C", values, returnValue, result)) {
          std::cout << "Error calling remote method: " << result << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          exit(1);
    }

    if (returnValue->type() != NYMPH_STRING) {
          std::cout << "Return value wasn't a string. Type: " << returnValue->type() << std::endl;
          NymphRemoteServer::disconnect(StationClass::handle, result);
          NymphRemoteServer::shutdown();
          exit(1);
    }

    rxBufferIndex = 0;
    buffer = ((NymphString*) returnValue)->getValue();
    return buffer.size();
 }
```

要从 I2C 总线中读取，我们使用前面的方法，首先写入我们希望写入的 I2C 地址，然后调用 RPC 函数从模拟的 I2C 设备中读取，该设备应具有可读取的数据，如下面的代码所示:

```

 int TwoWire::available() {
    return buffer.length() - rxBufferIndex;
 }

 int TwoWire::read() {
    int value = -1;
    if (rxBufferIndex < buffer.length()) {
          value = buffer.at(rxBufferIndex);
          ++rxBufferIndex;
    }

    return value;
 }

 TwoWire Wire;
```

I2C 读取功能与原始实现中的功能基本相同，因为两者都仅与本地缓冲区交互，如下面的代码所示:

```
String system_get_sdk_version() { return "SIM_0.1"; }
 int system_get_free_heap_size() { return 20000; }
 int system_get_cpu_freq() { return 1200000; }
 int system_get_chip_id() { return 42; }
 int spi_flash_get_id() { return 42; }

 void SystemClass::restart() { }

 SystemClass System;
```

以下是可用于特定测试场景的更多存根实现:

```
void pinMode(uint16_t pin, uint8_t mode) { }
 void digitalWrite(uint16_t pin, uint8_t val) { }
 uint8_t digitalRead(uint16_t pin) { return 1; }

 uint16_t analogRead(uint16_t pin) { return 1000; }
```

我们没有实现这些功能，但它们可以实现连接到服务器端的虚拟 GPIO 引脚的 GPIO 和 ADC 引脚，以控制设备并记录不使用 UART、SPI 或 I2C 接口的数据。同样适用于 PWM 功能。

继续进入该源文件的最后一部分，我们实现了以下主要功能:

```

 int main() {
    // Start the firmware image.
    init();

    return 0;
 }

```

就像入口点的 Sming 版本一样，我们在自定义固件代码中称为 global`init()`函数，它在那里用作入口点。可以想象，如果需要，我们还可以在此主要功能中执行各种类型的初始化。

filesystem 类方法是使用 C 风格的文件访问和 C 17 风格的文件系统操作的混合来实现的，如下面的代码所示:

```
#include "FileSystem.h"
 #include "../Wiring/WString.h"

 #include <filesystem>
 #include <iostream>
 #include <fstream>

 namespace fs = std::filesystem;

 file_t fileOpen(const String& name, FileOpenFlags flags) {
    file_t res;

    if ((flags & eFO_CreateNewAlways) == eFO_CreateNewAlways) {
          if (fileExist(name)) {
                fileDelete(name);
          }

          flags = (FileOpenFlags)((int)flags & ~eFO_Truncate);
    }

    res = std::fopen(name.c_str(), "r+b");
    return res;
 }
```

为了简化此方法，我们忽略提供的标志，并始终以完全读写模式打开文件 (如果它以某种方式有助于集成测试，则只能实现完整的标志集)。让我们看下面的代码:

```

 void fileClose(file_t file) {
    std::fclose(file);
 }

 size_t fileWrite(file_t file, const void* data, size_t size) {
    int res = std::fwrite((void*) data, size, size, file);      
    return res;
 }

 size_t fileRead(file_t file, void* data, size_t size) {
    int res = std::fread(data, size, size, file);
    return res;
 }

 int fileSeek(file_t file, int offset, SeekOriginFlags origin) {
    return std::fseek(file, offset, origin);
 }

 bool fileIsEOF(file_t file) {
    return true;
 }

 int32_t fileTell(file_t file) {
    return 0;
 }

 int fileFlush(file_t file) {
    return 0; 
 }

 void fileDelete(const String& name) {
    fs::remove(name.c_str());
 }

 void fileDelete(file_t file) {
    //
 }

 bool fileExist(const String& name) {
    std::error_code ec;
    bool ret = fs::is_regular_file(name.c_str(), ec);
    return ret;
 }

 int fileLastError(file_t fd) {
    return 0;
 }

 void fileClearLastError(file_t fd) {
    //
 }

 void fileSetContent(const String& fileName, const String& content) {
    fileSetContent(fileName, content.c_str());
 }

 void fileSetContent(const String& fileName, const char* content) {
    file_t file = fileOpen(fileName.c_str(), eFO_CreateNewAlways | eFO_WriteOnly);
    fileWrite(file, content, strlen(content));
    fileClose(file);
 }

 uint32_t fileGetSize(const String& fileName) {
    int size = 0;
    try {
         size = fs::file_size(fileName.c_str());
     } 
    catch (fs::filesystem_error& e) {
         std::cout << e.what() << std::endl;
     }

    return size;
 }

 void fileRename(const String& oldName, const String& newName) {
    try {
          fs::rename(oldName.c_str(), newName.c_str());
    }
    catch (fs::filesystem_error& e) {
          std::cout << e.what() << std::endl;
    }
 }

 Vector<String> fileList() {
    Vector<String> result;
    return result;
 }

 String fileGetContent(const String& fileName) {
    std::ifstream ifs(fileName.c_str(), std::ios::in | std::ios::binary | std::ios::ate);

     std::ifstream::pos_type fileSize = ifs.tellg();
     ifs.seekg(0, std::ios::beg);
     std::vector<char> bytes(fileSize);
     ifs.read(bytes.data(), fileSize);

     return String(bytes.data(), fileSize);
 }

 int fileGetContent(const String& fileName, char* buffer, int bufSize) {
    if (buffer == NULL || bufSize == 0) { return 0; }
    *buffer = 0;

    std::ifstream ifs(fileName.c_str(), std::ios::in | std::ios::binary | std::ios::ate);

     std::ifstream::pos_type fileSize = ifs.tellg();
    if (fileSize <= 0 || bufSize <= fileSize) {
          return 0;
    }

     buffer[fileSize] = 0;
     ifs.seekg(0, std::ios::beg);
    ifs.read(buffer, fileSize);
    ifs.close();

     return (int) fileSize;
 }
```

这些都是标准的文件操作，因此不需要很多解释。之所以同时使用 C 风格和 C 17 风格的文件访问，主要是因为原始的 API 方法采用了 C 风格的处理方式，也因为底层的基于 C 的 SDK 功能。

我们将所有 API 方法映射到纯 C 17 文件系统功能，但这将是额外的时间投资，没有任何明显的回报。

计时器功能在 Sming 的`SimpleTimer`类中使用 POCO 的`Timer`类来实现一个等效的功能，如下面的代码所示:

```
#include "Poco/Timer.h"
 #include <iostream>

 typedef void (*os_timer_func_t)(void* timer_arg);

 class SimpleTimer {
 public:
    SimpleTimer() : timer(0) {
          cb = new Poco::TimerCallback<SimpleTimer>(*this, &SimpleTimer::onTimer);
    }

    ~SimpleTimer() {
          stop();
          delete cb;
          if (timer) {
                delete timer;
          }
    }

    __forceinline void startMs(uint32_t milliseconds, bool repeating = false) {
          stop();
          if (repeating) {
                timer = new Poco::Timer(milliseconds, 0);
          }
          else {
                timer = new Poco::Timer(milliseconds, milliseconds);
          }

          timer->start(*cb);
    }

    __forceinline void startUs(uint32_t microseconds, bool repeating = false) {
          stop();
          uint32_t milliseconds = microseconds / 1000;
          if (repeating) {
                timer = new Poco::Timer(milliseconds, 0);
          }
          else {
                timer = new Poco::Timer(milliseconds, milliseconds);
          }

          timer->start(*cb);
    }

    __forceinline void stop() {
          timer->stop();
          delete timer;
          timer = 0;
    }

    void setCallback(os_timer_func_t callback, void* arg = nullptr)   {
          stop();
          userCb = callback;
          userCbArg = arg;
    }

 private:
    void onTimer(Poco::Timer &timer) {
          userCb(userCbArg);
    }

    Poco::Timer* timer;
    Poco::TimerCallback<SimpleTimer>* cb;
    os_timer_func_t userCb;
    void* userCbArg;
 };
```

最后，对于`Clock`类的重新实现，我们使用 STL 的 chrono 功能，如下面的代码所示:

```
#include "Clock.h"
 #include <chrono>

 unsigned long millis() {
    unsigned long now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
    return now;
 }

 unsigned long micros() {
    unsigned long now = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
    return now;
 }

 void delay(uint32_t milliseconds) {
    //
 }

 void delayMicroseconds(uint32_t time) {   //
 }
```

在这里，我们将 `delay` 函数保留为未实现，因为此时我们不需要它们。

# 制作文件

项目这一部分的 Makefile 如下所示:

```
GPP = g++
 GCC = gcc
 MAKEDIR = mkdir -p
 RM = rm
 AR = ar
 ROOT = test/node
 OUTPUT = bmac_esp8266
 OUTLIB = lib$(OUTPUT).a
 INCLUDE = -I $(ROOT)/ \
                -I $(ROOT)/SmingCore/ \
                -I $(ROOT)/SmingCore/network \
                -I $(ROOT)/SmingCore/network/Http \
                -I $(ROOT)/SmingCore/network/Http/Websocket \
                -I $(ROOT)/SmingCore/network/libmosquitto \
                -I $(ROOT)/SmingCore/network/libmosquitto/cpp \
                -I $(ROOT)/SmingCore/wiring \
                -I $(ROOT)/Libraries/BME280 \
                -I $(ROOT)/esp8266/app
 FLAGS := $(INCLUDE) -g3 -U__STRICT_ANSI__
 LIB := -L$(ROOT)/lib -l$(OUTPUT) -lmosquittopp -lmosquitto  -lnymphrpc \
          -lPocoNet -lPocoUtil -lPocoFoundation -lPocoJSON -lstdc++fs \
          -lssl -lcrypto
 LIB_WIN :=  -lws2_32
 ifeq ($(OS),Windows_NT)
    LIB := $(LIB) $(LIB_WIN)
 endif
 include ./esp8266/version
 include ./Makefile-user.mk
 CPPFLAGS := $(FLAGS) -DVERSION="\"$(VERSION)\"" $(USER_CFLAGS) -std=c++17 -Wl,--gc-sections
 CFLAGS := -g3 
 CPP_SOURCES := $(wildcard $(ROOT)/SmingCore/*.cpp) \
                $(wildcard $(ROOT)/SmingCore/network/*.cpp) \
                $(wildcard $(ROOT)/SmingCore/network/Http/*.cpp) \
                $(wildcard $(ROOT)/SmingCore/wiring/*.cpp) \
                $(wildcard $(ROOT)/Libraries/BME280/*.cpp)
 FW_SOURCES := $(wildcard esp8266/app/*.cpp)
 CPP_OBJECTS := $(addprefix $(ROOT)/obj/,$(notdir) $(CPP_SOURCES:.cpp=.o))
 FW_OBJECTS := $(addprefix $(ROOT)/obj/,$(notdir) $(FW_SOURCES:.cpp=.o))
 all: makedir $(FW_OBJECTS) $(CPP_OBJECTS) $(ROOT)/lib/$(OUTLIB) $(ROOT)/bin/$(OUTPUT)
 $(ROOT)/obj/%.o: %.cpp
    $(GPP) -c -o $@ $< $(CPPFLAGS)
 $(ROOT)/obj/%.o: %.c
    $(GCC) -c -o $@ $< $(CFLAGS)
 $(ROOT)/lib/$(OUTLIB): $(CPP_OBJECTS)
    -rm -f $@
    $(AR) rcs $@ $^
 $(ROOT)/bin/$(OUTPUT):
    -rm -f $@
    $(GPP) -o $@ $(CPPFLAGS) $(FW_SOURCES) $(LIB)
 makedir:
    $(MAKEDIR) $(ROOT)/bin
    $(MAKEDIR) $(ROOT)/lib
    $(MAKEDIR) $(ROOT)/obj
    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/SmingCore/network
    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/SmingCore/wiring
    $(MAKEDIR) $(ROOT)/obj/$(ROOT)/Libraries/BME280
    $(MAKEDIR) $(ROOT)/obj/esp8266/app
 clean:
    $(RM) $(CPP_OBJECTS) $(FW_OBJECTS)
```

关于此 Makefile 的主要注意事项是，它从两个不同的源文件夹中收集源文件，用于测试 API 和固件源。以前的源文件首先被编译为对象文件，这些文件被组装成归档文件。固件源直接与这个测试框架库一起使用，尽管我们也有固件对象文件，如果我们需要的话。

在链接测试 API 之前创建它的存档的原因与链接器查找符号的方式有关。通过使用 AR 工具，它将在归档文件内部的对象文件中创建所有符号的索引，从而确保我们不会收到任何链接器错误。特别是对于大型项目，这通常是使目标文件成功链接到二进制文件的要求。

首先编译到对象文件对于较大的项目也很有帮助，因为 Make 将确保只有实际更改的文件才会被重新编译，这确实可以加快开发时间。由于该项目的目标固件源非常少，因此我们可以在此处直接从源文件进行编译。

我们还从这个增加了两个文件。第一个包括我们正在编译的固件源的版本号，这很有用，因为它将确保生成的节点二进制文件将报告与安装在 ESP8266 模块上的版本完全相同的版本。这使得特定固件版本的验证更加容易。

第二个是带有用户可定义设置的 Makefile，从固件项目 Makefile 复制了*逐字复制*，但只有我们需要固件源编译和工作所需的变量，如下面的代码所示:

```
WIFI_SSID = MyWi-FiNetwork
 WIFI_PWD = MyWi-FiPassword

 MQTT_HOST = localhost
 # For SSL support, uncomment the following line or compile with this parameter.
 #ENABLE_SSL=1
 # MQTT SSL port (for example):
 ifdef ENABLE_SSL
 MQTT_PORT = 8883 
 else
 MQTT_PORT = 1883
 endif

 # Uncomment if password authentication is used.
 # USE_MQTT_PASSWORD=1
 # MQTT username & password (if needed):
 # MQTT_USERNAME = esp8266
 # MQTT_PWD = ESPassword

 # MQTT topic prefix: added to all MQTT subscriptions and publications.
 # Can be left empty, but must be defined.
 # If not left empty, should end with a '/' to avoid merging with topic names.
 MQTT_PREFIX = 

 # OTA (update) URL. Only change the host name (and port).
 OTA_URL = http://ota.host.net/ota.php?uid=

 USER_CFLAGS := $(USER_CFLAGS) -DWIFI_SSID="\"$(WIFI_SSID)"\"
 USER_CFLAGS := $(USER_CFLAGS) -DWIFI_PWD="\"$(WIFI_PWD)"\"
 USER_CFLAGS := $(USER_CFLAGS) -DMQTT_HOST="\"$(MQTT_HOST)"\"
 USER_CFLAGS := $(USER_CFLAGS) -DMQTT_PORT="$(MQTT_PORT)"
 USER_CFLAGS := $(USER_CFLAGS) -DMQTT_USERNAME="\"$(MQTT_USERNAME)"\"
 USER_CFLAGS := $(USER_CFLAGS) -DOTA_URL="\"$(OTA_URL)"\"
 USER_CFLAGS := $(USER_CFLAGS) -DMQTT_PWD="\"$(MQTT_PWD)"\"
 ifdef USE_MQTT_PASSWORD
 USER_CFLAGS := $(USER_CFLAGS) -DUSE_MQTT_PASSWORD="\"$(USE_MQTT_PASSWORD)"\"
 endif
 SER_CFLAGS := $(USER_CFLAGS) -DMQTT_PREFIX="\"$(MQTT_PREFIX)"\"
```

包括此 Makefile 将所有这些定义都传递给编译器。这些都是预处理器语句，用于设置字符串或更改代码的哪些部分将被编译，例如 SSL 代码。

但是，为了简单起见，我们没有为这个示例项目实现 SSL 功能。

# 建设项目

对于服务器端，我们有以下库依赖项:

*   仙女
*   POCO

对于节点，我们有以下依赖关系:

*   仙女
*   POCO
*   蚊子

NymphRPC 库 (在本节的开头描述) 是根据项目的说明进行编译的，并安装在链接器可以找到它的地方。POCO 库是使用系统的软件包管理器 (Linux，BSD 或 MSYS2) 或手动安装的。

对于 Mosquitto 库依赖，我们可以使用项目的库版本，通过使用`test/SmingCore/network/libmosquitto`文件夹中的 Makefile 来编译`libmosquitto`和`libmosquittopp`库文件。同样，您应该在链接器可以找到它们的地方安装生成的库文件。

当不使用 MinGW 时，也可以通过操作系统的软件包管理器或类似工具使用通常可用的版本。

完成这些步骤后，我们可以使用项目根目录中的以下命令行命令来编译服务器和客户端:

```
make
```

这将使用顶级 Makefile 编译服务器和节点项目，从而为各自的`bin/`文件夹中的每个项目生成可执行文件。您应该确保服务器的`Node`类中的可执行名称和路径与节点可执行文件的位置匹配。

我们现在应该能够运行项目并开始收集测试结果。该项目包括 ESP8266-based BMAC 固件的剥离版本，我们将在[第 9 章](09.html)，*示例-构建监视和控制*中详细介绍。请参考该章，了解如何通过 MQTT 与模拟节点通信，如何打开固件内部的模块以及如何解释模块通过 MQTT 发送的数据。

在设置了该章中所述的事情之后-至少需要一个 MQTT 代理和一个合适的 MQTT 客户端-并打开了模拟节点中的 BME280 模块，我们希望它开始通过 MQTT 发送温度，我们为模拟节点位于的房间设置的湿度和气压值。

# 摘要

在本章中，我们研究了如何有效地为基于 MCU 的目标开发，使我们能够在不需要昂贵且冗长的开发周期的情况下对其进行测试。我们了解了如何实现集成环境，使我们能够从台式机操作系统及其提供的工具的舒适性中调试基于 MCU 的应用程序。

读者现在应该能够为基于 MCU 的项目开发集成测试，并在实际硬件上进行最终集成工作之前，有效地使用基于 OS 的工具对其进行分析和调试。读者还应该能够执行片上调试，并对特定软件实现的相对成本有所了解。

在下一章中，我们将基于 SBC 平台开发一个简单的信息娱乐系统。