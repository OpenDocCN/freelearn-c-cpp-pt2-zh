# 第五章 STL 之外的有效数据结构

C++ 标准库提供了一组丰富的**泛型容器**，可用于各种常见编程任务。 其中包括序列容器，如`std::vector`、`std::deque`、`std::list`、`std::forward_list`，以及有序和无序的关联容器，如`std::map`、`std::set`、`std::unordered_map`、`std::unordered_set`等。

使用**迭代器**遍历容器，并访问它们的各个元素。 C++ 根据迭代器类别提供的对容器元素的访问类型(读、写、前向遍历、双向遍历和随机访问)定义迭代器类别的层次结构。 可用于遍历容器的迭代器类型取决于容器的内部结构。

与容器一起提供的是一个**泛型算法**库，这些算法使用一个或多个迭代器读取和操作泛型容器。 这些库在很大程度上依赖于**泛型编程**，在泛型编程中，程序接口是从数据类型中抽象出来并参数化的。

这个通用容器、算法和一系列附带实用程序的集合起源于由 Alexander Stepanov 和 Meng Lee 在 HP 实验室开发的**标准模板库**或**STL**，并于 1994 年被接受为 C++ 标准库的一部分。 STL 这个名字一直沿用于标准库中起源于这项工作的那些部分，我们将大致使用它来指代库的这些部分。 自那以后，STL 容器和算法一直在 C++ 软件中大量使用，但有几个限制。 在 C++ 11 之前，您只能将可复制对象存储在容器中。 标准库中缺少某些容器类(如基于散列的关联容器)，而其他类容器(如优先级队列)则表示不足。

在 C++ 14 中，标准库中还没有适合存储指向动态分配对象的指针的容器，尽管有了`std::unique_ptr`，这在 C++ 11 之后就更容易处理了。您不能有效地搜索关联容器的内容，如`std::map`按值而不是按键，也不能轻松地为您的自定义容器类编写迭代器，这些迭代器可以很好地使用 STL 算法。 没有从各种标准格式(XML、JSON 等)读取属性集或键-值对的简易库。 转换成内存中的数据结构。 如果您局限于标准库，那么还有更多这样的例程使用需要付出巨大的努力。

在本章和下一章中，我们将介绍填补这些空白的领先 Boost 库。 本章分为以下几节：

*   Boost 容器库
*   使用 Boost 无序容器进行快速查找
*   用于动态分配对象的容器
*   使用 Boost.Assign 进行富有表现力的初始化和赋值
*   带 Boost.Iterator 的迭代模式

本章应该为您在 Boost 中使用种类繁多的数据结构库奠定坚实的基础。

# Boost 容器库

Boost 容器库除了提供一些漂亮的非标准容器外，还实现了大多数 STL 容器模板。 那么，重新实现 STL 容器有什么意义呢？ 为了理解这一点，让我们看看 STL 容器中可以存储哪些类型的对象，而不能存储哪些类型的对象。

例如，要将类型`T`的对象存储在`std::vector`中，类型`T`必须是定义类型`std::vector<T>`的点上的完整类型(即，必须完全定义，而不是仅仅声明)。 此外，在 C++ 11 之前的版本中，`T`类型的对象必须是可复制和可赋值的。 这些要求通常适用于除`std::vector`以外的其他 STL 容器。 通常，在 C++ 11 之前，STL 是一个复制密集型框架：您将对象复制到 STL 容器中来存储它们，容器在调整大小或重构时复制它们，当这些副本超出作用域时，容器会销毁这些副本。 复制在时间和内存方面是一项昂贵的操作，也更容易出错，因此 STL 容器上的几个操作的异常安全性较弱。

C++ 11 引入了移动语义，使得通过移动或篡改现有对象的状态来**移动构造**新对象成为可能，通常只通过交换整数和指针并完全避免任何重要且容易出错的复制操作。 同样，在称为**Move-Assignment**的操作中，可以将对象的状态或内容移动到另一个现有对象中。 默认情况下，从临时对象构造或赋值时应用移动语义，而从 l 值对象复制时可以显式强制应用移动语义(请参阅[附录](12.html "Appendix A. C++ 11 Language Features Emulation")、*C++ 11 语言功能仿真*)。 这些功能允许对 C++ 11 中的标准库容器的操作进行显著优化，并且独立于**复制语义**。 如果存储在 C++ 11 STL 容器中的对象是**可移动构造的**，则它们不必是**可复制的**。 C++ 11 还允许在容器的布局中就地构造对象，而不是要求先构造对象，然后再复制它们。

Boost Container库提供标准库容器的移动感知实现，不仅可用于 C++ 11 编译器，还可用于 C++ 03 编译器的 Boost 移动仿真(请参阅[附录](12.html "Appendix A. C++ 11 Language Features Emulation")，*C++ 11 语言功能仿真仿真*)。 此外，它们还支持对象的在位构建。 如果您使用的是 C++ 03 编译器，这是一个重要的功能。 此外，Boost Container 库中的容器可以保存不完整类型的对象，从而可以定义标准容器无法实现的有趣的递归结构。

除了标准容器之外，Boost Container 库还实现了几个有用的非标准容器，这些容器可用于各种特定用途。

## 移动感知和就地施工

考虑以下用于封装`char`字符串的类，它是可移动的，但不可复制。 我们使用 Boost 移动仿真宏来定义其移动语义。 在 C++ 11 环境中，此代码转换为 C++ 11 MOVE 语法，而在 C++ 03 环境中，它模拟 MOVE 语义：

**清单 5.1：可移动但不可复制的字符串**

```cpp
 1 #include <boost/move/move.hpp>
 2 #include <boost/swap.hpp>
 3 #include <cstring>
 4
 5 class String
 6 {
 7 private:
 8   BOOST_MOVABLE_BUT_NOT_COPYABLE(String)
 9
10 public:
11   String(const char *s = nullptr) : str(nullptr), sz(0) {
12     str = heapcpy(s, sz);
13   }
14
15   ~String() {
16     delete[] str;
17     sz = 0;
18   }
19
20   String(BOOST_RV_REF(String) that) : str(nullptr), sz(0) {
21     swap(that);
22   }
23
24   String& operator = (BOOST_RV_REF(String) rhs) {
25     String tmp(boost::move(rhs));
28
29    return *this;
30   }
31
32   void swap(String& rhs) {
33     boost::swap(this->sz, rhs.sz);
34     boost::swap(this->str, rhs.str);
35   }
36
37   const char *get() const {
38     return str;
39   }
40
41 private:
42   char *str;
43   size_t sz;
44
45  static char *heapcpy(const char *str, size_t& sz) {
46     char *ret = nullptr;
47
48     if (str) {
49       sz = std::strlen(str) + 1;
50       ret = new char[sz];
51       std::strncpy(ret, str, sz);
52     }
53
54     return ret;
55   }
56 };
```

在 C++ 11 之前的编译器上，试图将`String`的实例存储在标准的容器中会导致编译器错误，因为`String`是不可复制的。 以下是将字符串实例移动到`boost::container::vector`中的一些代码，后者是`std::vector`的 Boost 对应项：

**清单 5.2：将字符串对象推送到 Boost 向量**

```cpp
 1 #include <boost/container/vector.hpp>
 2 #include "String.h"  // for class String
 3 #include <cassert>
 4 
 5 int main() {
 6   boost::container::vector<String> strVec;
 7   String world("world");
 8   // Move temporary (rvalue)
 9   strVec.push_back(String("Hello"));
10   // Error, copy semantics needed
11   //strVec.push_back(world);
12   // Explicit move
13   strVec.push_back(boost::move(world));
14   // world nulled after move
15   assert(world.get() == nullptr);
16   // in-place construction
17   strVec.emplace_back("Hujambo Dunia!"); // Swahili
18
19   BOOST_FOREACH(String& str, strVec) {
20     std::cout <<str.get() << '\n';
21   }
22 }
```

在前面的代码中，我们创建了一个 Boost`vector`(第 6 行)，并向其追加了一个临时字符串`"Hello"`(第 9 行)。 这会自动调用移动语义，因为表达式`String("Hello")`是**右值**。 我们构造了一个名为`world`的`String`变量(第 7 行)，但是如果我们试图将其附加到`strVec`，它将失败，因为它将尝试复制`world`，但是它是不可复制的(第 11 行)。

为了将`world`放入`strVec`，我们需要使用`boost::move`显式移动它(第 13 行)。 一旦将`world`移入`strVec`，其内容将移出到存储在`strVec`中的`String`对象中，因此其内容变为空(第 15 行)。最后，我们通过调用向量的`emplace_back`成员并将 String 的构造函数参数传递给它来就地构造`String`对象(第 17 行)。 清单 5.1 和 5.2 中的代码可以在 C++ 11 之前的编译器以及 C++ 11 上正确编译和工作。此外，在 C++ 11 上，用于移动仿真的 Boost 宏只需转换为 C++ rvalue 引用语法。 请注意，我们使用`BOOST_FOREACH`宏而不是基于 C++ 11 范围的 for 循环来迭代向量(请参阅[附录](12.html "Appendix A. C++ 11 Language Features Emulation")、*C++ 11 语言功能仿真*)。

该代码打印以下行：

```cpp
Hello
world
Hujambo Dunia!
```

请注意，在基于范围的 for 循环中，循环变量`str`是使用`auto&`引入的。 如果我们没有在`auto`之后使用尾随的与号，编译器将尝试生成代码来将`strVec`的每个元素复制到`str`中，这将失败，因为`String`是不可复制的。 使用尾随的与号可确保`str`是对连续元素的引用。

除了`vector`之外，Boost 容器库还实现了其他标准容器，如`deque`、`list`、`set`、`multiset`、`map`和`multimap`以及`basic_string`。 这些容器是支持移动的容器，非常类似于它们的 C++ 11 对应容器，并且可以使用移动仿真(通过 Boost.Move)在 C++ 11 之前的环境中使用。

## 非标集装箱

除了标准的容器之外，Boost Container 库还提供了几个有用的非标准容器。 本节是对这些容器及其适用性的快速概述。

### 扁平缔合容器

标准关联容器有两种风格：**有序**和**无序**。 像`std:set`、`std::multiset`、`std::map`和`std::multimap`这样的有序容器通常使用平衡搜索树实现(优化的红黑树实现是**事实**)。 因此，它们按排序顺序存储它们的元素。 无序容器`std::unordered_set`、`std::unordered_multiset`、`std::unordered_map`和`std::unordered_multimap`基于哈希表。 它们起源于 Boost 容器库，之后成为 C++ TR1 发行版和 C++ 11 标准库的一部分。 这些容器根据为对象计算的散列值将对象存储在称为**散列表**、的存储桶数组中。 在哈希表中存储对象的方式没有固有的顺序，因此称为无序容器。

关联容器支持快速查找。 有序容器使用支持对数时间搜索的平衡搜索树，而无序容器使用支持分期恒定时间搜索的哈希表。 这些并不是支持快速查找的唯一数据结构。 对允许随机位置访问其元素的排序序列的二进制搜索也在对数时间内执行。 四个平面关联容器`flat_set`、`flat_multiset`、`flat_map`和`flat_multimap`使用排序向量来存储数据，并对向量使用二进制搜索来执行查找。 它们是标准库中有序和无序对应项的替代产品，但在插入和查找方面具有不同的性能特征：

**清单 5.3：使用平面映射**

```cpp
 1 #include <iostream>
 2 #include <string>
 3 #include <boost/container/flat_map.hpp>
 4 
 5 int main()
 6 {
 7   boost::container::flat_map<std::string, std::string> 
 8           newCapitals;
 9 
10   newCapitals["Sri Lanka"] = "Sri Jayawardenepura Kotte";
11   newCapitals["Burma"] = "Naypyidaw";
12   newCapitals["Tanzania"] = "Dodoma";
13   newCapitals["Cote d'Ivoire"] = "Yamoussoukro"; 
14   newCapitals["Nigeria"] = "Abuja";
15   newCapitals["Kazakhstan"] = "Astana";
16   newCapitals["Palau"] = "Ngerulmud";
17   newCapitals["Federated States of Micronesia"] = "Palikir";
18 
19   for (const auto& entries : newCapitals) {
20     std::cout<< entries.first << ": " << entries.second
21               << '\n';
22   }
23 }
```

第一个例子列出了一组国家，它们的首都在过去几十年里搬迁了。 如果你认为拉各斯仍然是尼日利亚的首都，你会大吃一惊。 撇开地理位置不谈，前面的代码中并没有太多令人惊讶的事情。 我们为`boost::container::flat_map<std::string, std::string>`创建一个`typedef`，并实例化此类型的映射`newCapitals`，插入国家及其新首都的字符串对。 如果我们将`boost::container::flat_map`替换为`std::map`，代码将在不做任何更改的情况下运行。

扁平关联容器可以存储可复制或可移动的对象。 对象存储在连续布局中，不使用间接指针。 因此，为了存储特定类型的给定数量的对象，平面容器也将比基于树和基于散列的容器占用更少的内存。 插入保持排序顺序，因此比其他关联容器中的成本更高；特别是对于可复制但不可移动的值类型。 此外，与标准关联容器不同，插入任何新元素或删除现有元素都会使所有迭代器失效。

由于二进制搜索的连续布局和更快的性能，迭代和查找往往更快，并且缓存性能比标准容器更好。 如果超出平面容器的初始容量，则插入平面容器可能会导致重新分配和元素被移动或复制。 这可以通过在执行插入之前使用`reserve`成员函数预留足够的空间来防止。 以下示例说明了这一方面：

**清单 5.4：使用平面集合**

```cpp
 1 #include <boost/container/flat_set.hpp>
 2 #include <iostream>
 3 #include <string>
 4
 5 template<typename C>
 6 void printContainerInternals(const C& container) {
 7   std::cout << "Container layout" << '\n'
 8             << "-------------\n";
 9 
10   for (const auto& elem : container) {
11     std::cout << "[Addr=" << &elem
12               << "] : [value=" << elem << "]\n";
13   }
14 }
15 
16 int main()
17 {
18   boost::container::flat_set<std::string> someStrings;
19   someStrings.reserve(8);
20 
21   someStrings.insert("Guitar");
22   printContainerInternals(someStrings);
23 
24   someStrings.insert("Mandolin");
25   printContainerInternals(someStrings);
26 
27   someStrings.insert("Cello");
28   printContainerInternals(someStrings);
29 
30   someStrings.insert("Sitar");
31   printContainerInternals(someStrings);
32 }
```

此示例显示了一种计算平面关联容器的内部布局如何随连续插入而变化的方法。 我们定义了一个名为`someStrings`的`flat_set`容器(第 18 行)，并插入 8 个弦乐乐器的名称。 在每次插入之后，在容器上调用`printContainer`模板，以打印出内部向量中的连续地址，其中每个字符串都存在。 我们在插入之前为 8 个元素预留容量(第 19 行)，然后再插入 8 个元素。 因为一开始有足够的容量，所以所有插入都不会触发重新分配，您应该会看到一组相当稳定的地址，只有字符串的顺序会改变以保持排序顺序。 如果我们注释掉保留调用(第 19 行)并运行代码，我们可能会看到重新分配和更改地址。

### 名单

`boost::container::slist`容器是一个单链表抽象，类似于 SGI STL 实现中提供但从未达到标准的同名容器模板。 `std::list`容器是一个双向链表。 C++ 终于有了自己的单链表，在 C++ 11 中引入了`std::forward_list`。`slist`是移动感知的。

尽管某些操作的时间复杂度从常量变为线性，但单链表的内存开销比双向链表小。 如果您需要支持相对频繁的插入的序列容器，并且不需要向后遍历，则单链表是一个很好的选择：

**清单 5.5：使用 slist**

```cpp
 1 #include <boost/container/slist.hpp>
 2 #include <iostream>
 3 #include <string>
 4 
 5 int main()
 6 {
 7   boost::container::slist<std::string> geologic_eras;
 8 
 9   geologic_eras.push_front("Neogene");
10   geologic_eras.push_front("Paleogene");
11   geologic_eras.push_front("Cretaceous");
12   geologic_eras.push_front("Jurassic");
13   geologic_eras.push_front("Triassic");
14   geologic_eras.push_front("Permian");
15   geologic_eras.push_front("Carboniferous");
16   geologic_eras.push_front("Devonian");
17   geologic_eras.push_front("Silurian");
18   geologic_eras.push_front("Ordovician");
19   geologic_eras.push_front("Cambrian");
20 
21   for (const auto& str : geologic_eras) {
22     std::cout << str << '\n';
23   }
24 }
```

在这个简单的例子中，我们使用`slist`来存储连续的地质年代。 与标准序列容器`std::list`不同，`slist`没有将元素追加到列表末尾的`push_back`方法。 这是因为计算每个追加的列表末尾将使其成为线性运算，而不是常量运算。 相反，我们使用`push_front`成员将每个新元素添加到列表的顶部。 列表中字符串的最后顺序与插入顺序相反(按照句号的时间顺序，最旧的在前)。

在单链表上的某些操作比在双向链表上的等价物具有更高的时间复杂度。 在一个元素之前插入另一个元素的`insert`方法在`std::list`中是恒定时间，但在`slist`中是线性时间。 这是因为插入位置之前的元素可以使用指向双链表(如`std::list`中的前一个元素的链接)来定位，但需要从`slist`中的列表开头开始遍历。 出于同样的原因，用于在给定位置擦除元素的`erase`成员函数和用于在之前就地构造元素的`emplace`成员函数与它们的`std::list`对应函数相比也具有线性复杂性。 为此，`slist`提供了成员函数`insert_after`、`erase_after`和`emplace_after`，它们提供了类似的功能，但语义稍有改变，即在给定位置之后以固定时间插入、擦除和放置对象。 为了允许这些函数将元素添加到`slist`的开头，您可以使用`before_begin`成员函数来获得指向`head`指针的迭代器-一个不可取消引用的迭代器，它在递增时指向`slist`中的第一个元素。

我们现在可以重写清单 5.5，按照时间顺序将地质时期插入到`slist`中：

**清单 5.6：将元素添加到 slist**的末尾

```cpp
 1 #include <boost/container/slist.hpp>
 2 #include <iostream>
 3 #include <string>
 4 #include <cassert>
 5
 6 int main()
 7 {
 8   boost::container::slist<std::string> eras;
 9   boost::container::slist<std::string>::iterator last = 
10                                          eras.before_begin();
11
12   const char *era_names [] = {"Cambrian", "Ordovician", 
13                      "Silurian", "Devonian", "Carboniferous", 
14                      "Permian", "Triassic", "Jurassic", 
15                      "Cretaceous", "Paleogene", "Neogene"};
16
17   for (const char *period :era_names) {
18     eras.emplace_after(last, period);
19     ++ last;
20   }
21
22   int i = 0;
23   for (const auto& str : eras) {
24     assert(str == era_names[i++ ]);
25   }
26 }
```

#### 拼接

除了`insert`和`emplace`之外，还可以使用名为`splice`的操作在`slist`中的任何给定位置添加元素。 拼接是对链表的一种有用的操作，在这种操作中，一个给定列表中的一个或多个连续元素被移动到另一个链接列表中的特定位置，或者移动到同一列表中的不同位置。 `std::list`容器提供了一个`splice`成员函数，允许您在固定时间内执行此操作。 在`slist`中，由于需要线性遍历以在插入位置之前定位元素，因此`splice`成员函数的时间复杂度与拼接的元素的数量呈线性关系。 与`insert_after`和`emplace_after`一样，`splice_after`成员函数将元素移动到列表中指定位置之后：

**清单 5.7：拼接幻灯片**

```cpp
 1 #include <boost/container/slist.hpp>
 2 #include <string>
 3 #include <iostream>
 4 
 5 typedef boost::container::slist<std::string> list_type;
 6 typedef list_type::iterator iter_type;
 7 
 8 int main()
 9 {
10   list_type dinos;
11   iter_type last = dinos.before_begin();
12 
13   const char *dinoarray[] = {"Elasmosaurus", "Fabrosaurus",
14                        "Galimimus", "Hadrosaurus", "Iguanodon",
15                        "Appatosaurus", "Brachiosaurus",
16                        "Corythosaurus", "Dilophosaurus"};
17 
18   // fill the slist
19   for (const char *dino : dinoarray) {
20     dinos.insert_after(last, dino);
21     ++ last;
22   }
23 
24   // find the pivot
25   last = dinos.begin();
26   iter_type iter = last;
27
28   while (++ iter != dinos.end()) {
29     if (*last > *iter) {
30       break;
31     }
32     ++ last;
33   }
34 
35   // find the end of the tail
36   auto itend = last;
37   while (iter != dinos.end()) {
38     ++ itend;
39     ++ iter;
40   }
41
42   // splice after
43   dinos.splice_after(dinos.before_begin(), dinos,
44                   last, itend);
45   for (const auto& str: dinos) {
46    std::cout <<str<< '\n';
47   }
48 }
```

在此代码示例中，我们有一个由 8 个恐龙名称组成的数组，从英语字母表的前 8 个字母开始(第 13-16 行)。 它是一个排序列表，旋转了四个位置，因此它以`Elasmosaurus`开头，中间的某个位置有`Appatosaurus`。 我们使用`insert_after`(第 20 行)从这些字符串中生成一个`slist`，然后定位词法最小的字符串所在的轴心点(第 29-30 行)。 在循环结束时，`iter`指向`dinos`列表中词汇量最小的字符串，`last`指向紧接在`iter`之前的元素。 下面是我们要用来将列表尾部移到开头的`splice_after`重载的原型：

```cpp
void splice_after(const_iterator add_after, slist& source,
          const_iterator start_after, const_iterator end);
```

要从源容器移动到目标的元素序列开始于`start_after`之后的元素，结束于`end`，两端都包括在内，即半开间隔(`start_after`，`end`)。 在位置由`add_after`标识之后，这些元素被插入到目标`slist`中。 我们可以使用迭代器`last`作为第三个参数。 对于第四个参数，我们计算列表中最后一个元素的位置(第 36-40 行)。 迭代器`itend`现在指向列表中的最后一个元素。 使用所选的`splice_after`重载，我们将`last`之后直到列表末尾的所有元素移动到列表的开头(第 43-44 行)。

`std::forward_list`容器不提供`size`成员函数来返回列表中的元素数量。 这有助于确保其`splice_after`实现是恒定时间。 否则，在每个`splice_after`操作期间，将需要计算传输到列表的元素的数量，并且需要将元素的总计数增加那么多。 仅为了支持这一点，`splice_after` 必须在传输的元素数量上是线性的，而不是恒定的时间。 `slist`容器提供一个`size`成员和几个`splice_after`重载。 我们使用的`splice_after`的重载与传输的元素数量成线性关系，因为它使用线性遍历来计算这个数字。 但是，如果我们在没有额外循环的情况下在代码中计算这个数字，并将其传递给`splice_after`函数，那么它就可以避免再次迭代，而使用传递的数字。 `splice_after`有两个重载，它们从用户获取元素计数并避免线性计算，从而提供恒定时间拼接。

以下是用于执行此操作的稍作修改的代码片段：

```cpp
35   // find the end of the tail
36   size_t count = 0;
37   auto itend = last;
38
39   while (iter != dinos.end()) {
40     ++ itend;
41     ++ iter;
42     ++ count;
43   }
44
45   // splice after
46   dinos.splice_after(dinos.before_begin(), dinos,
47                   last, itend, count);

```

我们在确定要移动的迭代器范围时计算`count`，并将其传递给`splice_after`。 我们必须确保我们对`count`的计算是正确的，否则行为将是未定义的。 这种重载非常有用，因为我们有一种方法可以在不增加调用代码复杂性的情况下确定计数。

对于`std::forward_list`，`splice_after`签名在语义上与`boost::container::slist`略有不同。 以下是`std::forward_list`的`splice_after`成员的一个重载的原型：

```cpp
void splice_after(const_iterator pos, std::forward_list& list,const_iterator before_first, const_iterator after_last);
```

迭代器`before_first`和`after_last`标识开放区间，并且实际传送的元素将是从`before_first`之后的元素开始到`after_last`之前的元素结束的序列，即开放区间(`before_first`，`after_last`)。 使用此函数，我们不需要编写循环来确定本例中的最后一个元素，因为我们只需使用`dinos.end()`作为一次过终点位置的标记即可。 如果`dinos`是`std::forward_list`的实例，我们将编辑清单 5.7，从而节省 6 行代码：

```cpp
37   dinos.splice_after(dinos.before_begin(), dinos,
38                      last, dinos.end());
```

传输一定范围的元素的`std::forward_list`中的所有`splice_after`重载在所传输的元素数量上都是线性的。 虽然我们在`boost::container::slist`中看到了常量时间重载，但我们必须编写线性复杂性逻辑来向其传递正确的元素计数。 因此，在许多情况下，如果不使用固定时间的`size`成员函数，使用`std::forward_list`的代码可能更易维护，效率也不会降低。

### 稳定向量

`std::vector`容器将对象存储在连续内存中。 `vector`重新分配内部存储空间，并根据需要将对象复制或移动到新存储空间，以容纳个额外的新对象。 它允许使用索引快速随机访问存储的对象。 与在结尾处追加元素相比，在向量中的任意位置插入元素代价较高，因为插入需要移动插入点之后的元素，以便为新元素腾出空间。 这一行为还有另一个含义。 请考虑以下代码：

**清单 5.8：std：：Vector**中的迭代器无效

```cpp
 1 #include <vector>
 2 #include <cassert>
 3 
 4 int main() {
 5   std::vector<int>v{1, 2, 3, 5};
 6   auto first = v.begin();
 7   auto last = first + v.size() - 1;
 8   assert(*last == 5);
 9   v.insert(last, 4);
10   // *last = 10;  // undefined behavior, invalid iterator
11   for (int i = 0; i < 1000; ++ i) {
12     v.push_back(i);
13   }
14 
15   // *first = 0; // likely invalidated
16 }
```

在前面的代码中，我们创建了一个整数`v`的`vector`，并用四个整数对其进行初始化(第 5 行)。 用大括号括起来的逗号分隔值列表用于初始化向量，这是一个非常方便的 C++ 11 结构，称为**初始化式列表**。 在 C++ 11 之前的版本中，您必须手动附加值，或者，正如我们将在本章后面看到的那样，使用`Boost.Assign`库。 然后，我们计算对象最后一个元素的迭代器作为第一个迭代器的偏移量(第 7 行)。 我们断言最后一个元素是 5(第 8 行)。 接下来，我们在最后一个元素之前插入一个元素(第 9 行)。 超过这一点，迭代器`last`将失效，对迭代器`last`的任何访问都将是未定义的行为。 事实上，在两个随机访问容器(向量和数据队列)中，迭代器无效的情况发生得太频繁了。 对向量的任何写入操作都可能使迭代器无效。 例如，如果擦除特定迭代器位置上的元素，则到后面位置的所有现有迭代器都将无效。 即使在向量的末尾追加一个元素，也会触发向量内部存储的大小调整，需要移动个元素。 这样的事件将使所有现有迭代器失效。 标准库`vector`是**不稳定容器**。 `boost::container::stable_vector`是一个序列容器，它提供与稳定迭代器相结合的随机访问，除非它们所指向的元素被擦除，否则这些迭代器不会失效。 请查看 STRATE_VECTOR([http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector](http://www.boost.org/doc/libs/1_58_0/doc/html/container/non_standard_containers.html#container.non_standard_containers.stable_vector))上 Boost 文档页面中的下图：

![stable_vector](graphics/1217OT_05_01.jpg)

如这里所示，`stable_vector`不以连续的内存布局存储对象。 相反，每个对象都存储在单独的节点中，并且连续的数组按插入顺序存储指向这些节点的指针。 每个节点都包含实际对象以及指向其在数组中位置的指针。 迭代器指向这些节点，而不是数组中的位置。 因此，在插入新对象或删除某些现有对象之后，具有现有对象的节点不会更改，其迭代器也保持有效。 然而，当它们由于插入/移除而改变位置时，它们的后指针被更新。 节点指针的连续数组仍然允许随机访问元素。 由于额外的指针和间接性，`stable_vector`往往比`std::vector`慢，但这是稳定迭代器的权衡。 下面是一些要引导的代码：

**清单 5.9：稳定向量示例**

```cpp
 1 #include <boost/container/stable_vector.hpp>
 2 #include <cassert>
 3 #include <string>
 4
 5 int main()
 6 {
 7   const char *cloud_names[] = {"cumulus", "cirrus", "stratus",
 8                 "cumulonimbus", "cirrostratus", "cirrocumulus",
 9                 "altocumulus", "altostratus"};
10
11   boost::container::stable_vector<std::string> clouds;
12   clouds.reserve(4);
13   clouds.resize(4);   // To circumvent a bug in Boost 1.54
14
15   size_t name_count = sizeof(cloud_names)/sizeof(const char*);
16   size_t capacity = clouds.capacity();
17
18   size_t i = 0;
19   for (i = 0; i < name_count && i < capacity; ++ i) {
20     clouds[i] = cloud_names[i];
21   }
22
23   auto first = clouds.begin();
24
25   for (; i < name_count; ++ i) {
26     clouds.push_back(cloud_names[i]);
27   }
28
29   auto sixth = clouds.begin() + 5;
30
31   // 1 erase @4
32   clouds.erase(clouds.begin() + 4);
33   // 2 inserts @3
34   clouds.insert(clouds.begin() + 3, "stratocumulus");
35   clouds.insert(clouds.begin() + 3, "nimbostratus");
36
37   assert(*first == cloud_names[0]);
38   assert(sixth == clouds.begin() + 6); // not +5
39   assert(*sixth == cloud_names[5]);
40 }
```

使用`stable_vector`与使用`vector`没有什么不同，而且它也是可移动的。 在前面的示例中，我们希望将不同类型的云的名称存储在`std::string`的`stable_vector`中。 名为`cloud_names`的数组中有八个云名称(第 7-9 行)。 我们创建名为`clouds`的`stable_vector`来存储这些名称，并仅为四个元素预留容量(第 12-13 行)。 我们要展示的是，一旦我们添加了超出`stable_vector`容量的元素(需要扩展底层的数组并移动现有数据)，在容量变化之前计算的迭代器仍然有效。 `reserve`完全有可能分配比请求的容量更多的容量，如果这超过了我们拥有的云名称总数，那么我们的例子就没有意义了。

我们首先在不超出容量的情况下存储云的名称(第 18-21 行)，然后计算第一个元素的迭代器(第 23 行)。 然后，我们附加剩余的云名称(如果有的话)(第 25-27 行)。 如果还有任何剩余的云名称，那么当第一个云名称被存储时，它们就会导致调整大小。

我们计算第六个元素的迭代器(第 29 行)，删除第五个元素(第 32 行)，并在第四个元素之前再插入两个云名(第 34-35 行)。 在所有这些之后，迭代器`first`仍然指向第一个元素(第 37 行)。 在我们计算迭代器`sixth`时，它指向第六个元素，它的值是`"cirrocumulus"`，即`cloud_names`数组中的第六个字符串。 现在，前面有一次删除和两次插入，它应该是第七个元素(第 38 行)，但是它的值应该保持不变(第 39 行)-尽可能地稳定迭代器！

### 提示

从 Boost 1.54 开始，`stable_vector`的`capacity`成员函数在调用`reserve`后返回错误的容量值。 通过使用与调用`capacity`之前传递给`reserve`的参数一样大的参数调用`resize`成员函数(第 13 行)，我们可以绕过错误，并确保后续调用`capacity`返回正确的值。 在以后的版本中修复该错误后，应该不需要在调用`reserve`之后调用`resize`。

### 静态矢量

`boost::container::static­_vector`模板是一个类似向量的容器，其大小上限是在编译时定义的。 它在布局中分配固定大小的未初始化存储，而不是在单独的缓冲区中动态分配。 与`vector`或`stable_vector`不同，它不会在实例化时尝试对所有元素进行值初始化，这两种方法都会在将初始大小指定为构造函数参数时尝试对元素进行值初始化。 由于没有堆分配和值初始化，`static_vector`实例化的开销几乎为零。

`static_vector`仅用作常规向量，但有一个重要的注意事项。 尝试在`static_vector`中插入太多元素会导致运行时错误，因此在尝试插入其他元素之前，应始终确保在`static_vector`中有足够的空间：

**清单 5.10：使用 static_Vector**

```cpp
 1 #include <boost/current_function.hpp>
 2 #include <boost/container/static_vector.hpp>
 3 #include <iostream>
 4
 5 class ChattyInit
 6 {
 7 public:
 8   ChattyInit() {
 9     std::cout << BOOST_CURRENT_FUNCTION << '\n';
10   }
11 };
12
13 int main()
14 {
15   boost::container::static_vector<ChattyInit, 10> myvector;
16   std::cout << "boost::container::static_vector initialized"
17             <<'\n';
18   while (myvector.size() < myvector.capacity()) {
19     myvector.push_back(ChattyInit());
20   }
21
22   // cisv.push_back(ChattyInit()); // runtime error
23 }
```

我们构造了一个由`ChattyInit`个对象组成的`static_vector`个对象，`ChattyInit`是一个简单的类，它的构造函数打印自己的名称。 将`static_vector`的固定大小指定为数字模板参数(第 15 行)。 使用 g++ 4.9 编译器在我的 GNU Linux 机器上运行上述代码将打印以下内容：

```cpp
boost::container::static_vector initialized
ChattyInit::ChattyInit()
ChattyInit::ChattyInit()
… 8 more lines …
```

我们可以看到，在`static_vector`初始化过程中没有创建任何对象，单个对象在追加时被实例化。 我们确保插入的元素总数不超过容器的容量(第 18 行)。 因为默认情况下`static_vector`的元素不是值初始化的，所以当没有显式添加元素时，`size`成员函数返回零。 请将其与`std::vector`进行比较：

```cpp
std::vector<ChattyInit> myvector(10); // 10 elems value-inited
assert(myvector.size() == 10);
```

如果我们实际尝试添加过多的一个元素(第 22 行)，程序将崩溃。 如果您正在寻找一个快速的、大小受限的`vector`替代方案，`boost::container::static_vector`是一个有用的容器。

# 使用 Boost 无序容器进行快速查找

C++ 03 中的四个标准关联容器：`std::set`、`std::map`、`std::multiset`和`std::multimap`是有序容器，并使用个平衡二叉搜索树以某种排序顺序存储它们的键。 它们需要为其键定义排序关系，并提供对数复杂度的插入和查找。 给定排序关系和两个键(A 和 B)，我们可以确定关系中 A 在 B 之前还是 B 在 A 之前。 如果两个键都不在另一个键之前，则称键 A 和 B 相等；这并不意味着 A 和 B 相等。 事实上，有序的容器对平等是不可知的，根本不需要定义平等的概念。 这就是为什么这样的关系称为**严格弱序**。

请考虑以下示例：

```cpp
 1 #include <string>
 2 #include <tuple>
 3 
 4 struct Person  {
 5   std::string name;
 6   int age;
 7   std::string profession;
 8   std::string nationality;
 9 };
10
11 bool operator < (const Person& p1, const Person& p2)
12 {
13   return std::tie(p1.nationality, p1.name, p1.age)
14          < std::tie(p2.nationality, p2.name, p2.age);
15 }
```

我们使用字段`name`、`age`、`profession`和`nationality`定义表示人类个体的类型`Person`(第 3-9 行)，然后使用不考虑`profession`字段的`operator<`定义排序关系(第 11-15 行)。 这允许对`Person`个对象进行排序，但不能进行相等比较。 如果`!(p1 < p2)`和`!(p2 < p1)`都成立，则认为两个`Person`对象`p1`和`p2`是等价的。 对于具有相同`name`、`age`和`nationality`的任何两个`Person`对象，无论它们的`profession`是什么，都是如此。 有序容器`std::set`不允许多个彼此等价的键，而`std::multiset`允许。 同样，`std::map`不允许键相等的多个键-值对，而`std::multimap`允许。 因此，向已包含等效键的`std::map`添加键-值对会覆盖较旧的值。

有序容器是使用一种称为红黑树的平衡二叉搜索树实现的，并进行了几项优化。 除了在对数时间内查找和插入密钥的能力外，它们还提供一种密钥功能-有序遍历容器中的密钥。 但是，如果您不需要有序遍历，那么有更有效的替代方案可用-哈希表是最明显的一个。 哈希表的适当实现平均支持恒定时间查找，并且分期恒定时间插入的性能优于有序容器，具有更好的高速缓存性能，同时具有稍高的空间开销。

Boost 无序库引入了四个基于散列表的有序容器的对应物：`boost::unordered_set`、`boost::unordered_map`、`boost::unordered_multiset`和`boost::unordered_multimap`，它们于 2007 年成为 C++ TR1 版本的一部分，并包含在 C++ 11 的标准库中。当然，即使在 C++ 03 编译器中也可以使用 Boost 无序容器。

无序容器需要为它们存储的对象定义相等的概念，但不需要定义排序的概念。 因此，对于无序容器，等价性是根据相等而不是排序来定义的。 此外，无序容器需要一种方法来计算每个键的散列值，以确定表中存储键的位置。 在下面的代码示例中，我们将看到如何使用无序容器并重新使用前面介绍的`Person`类型计算对象的哈希值：

**清单 5.11：使用 unorder_sets**

```cpp
 1 #include <boost/unordered_set.hpp>
 2 #include <boost/functional/hash.hpp>
 3 #include <iostream>
 4 #include <cassert>
 5 #include "Person.h" // struct Person definition
 6
 7 bool operator==(const Person& left, const Person& right){
 8   return (left.name == right.name
 9          && left.age == right.age
10          && left.profession == right.profession
11          && left.nationality == right.nationality);
12 }
13
14 namespace boost
15 {
16   template <>
17   struct hash<Person>
18   {
19     size_t operator()(const Person& person) const{
20       size_t hash = 0;
21       boost::hash_combine(hash, 
22                          boost::hash_value(person.name)); 
23       boost::hash_combine(hash, 
24                        boost::hash_value(person.nationality)); 
25       return hash;
26     }
27   };
28 }
29
30 int main() {
31   boost::unordered_set<Person> persons;
32
33   Person p{"Ned Land", 40, "Harpooner","Canada"};
34   persons.insert(p); // succeeds
35
36   Person p1{"Ned Land", 32, "C++ Programmer","Canada"};
37   persons.insert(p1);  // succeeds
38
39   assert(persons.find(p) != persons.end());
40   assert(persons.find(p1) != persons.end());
41
42   Person p2 = p;
43   persons.insert(p2);   // fails
44   assert(persons.size() == 2);
45 }
```

前面的示例显示了如何使用`unordered_set`来存储我们在前面的清单中定义的用户定义类型`Person`的对象。 我们定义了一个`Person`对象的`unordered_set`(第 31 行)，创建了两个`Person`对象`p`和`p1`，并将它们插入到名为`Persons`的`unordered_set`中(第 34、37 行)。 我们定义了第三个`Person`对象`p2`，它是`p`的副本，并尝试插入该元素但失败了(第 43 行)。 作为集合的容器(`unordered_set`)包含唯一元素。 由于`p2`是`p`的副本并且与之相等，因此其插入失败。

`unordered_set`有两种方法可以计算它存储的每个对象的散列值。 我们演示了一种这样的方法：打开`boost`名称空间(第 14 行)，为所讨论的类型`Person`的函数模板`boost::hash`定义专门化(第 21-24 行)。 为了计算`Person`对象的散列，我们只考虑它的两个字段：`name`和`nationality`。 我们使用实用函数`boost::hash_value`和`boost::hash_combine`(为各个字段生成散列值并将其组合)。 因为我们在确定那个`Person`对象的散列值时只考虑了一个人的姓名和国籍，所以对象`p`和`p1`(它们都表示具有相同姓名和国籍的个人)最终具有相同的散列值。 但是，它们并不相等，因为它们的其他字段不同，因此，两个对象都成功地添加到集合中。 另一方面，对象`p2`是`p`的副本，当我们尝试将`p2`插入到`persons`集合中时，插入失败，因为集合不包含副本，而`p2`是`p`的副本。 `boost::unordered_multiset`和`boost::unordered_multimap`容器是基于散列的容器，可以存储重复的对象。

计算良好的哈希值对于确保对象在哈希表中均匀分布非常重要。 虽然`boost::hash_value`和`boost::hash_combine`实用函数模板可以帮助计算更复杂对象的散列值，但不加区别地使用它们可能会导致散列算法效率低下。 对于用户定义的类型，在许多情况下，最好是推出一个数学验证的散列算法，该算法利用用户定义类型的语义。 如果在`unordered_set`或`unordered_map`中使用原语或标准类型(如`std::string`)作为键，那么就不需要推出自己的散列函数，因为`boost::hash`做得很好。

查找值通常使用无序关联容器的`find`和`count`成员函数来完成。 `find`返回容器中存储的实际对象的迭代器(对应于传递的键)，而`count`只返回键的出现次数。 `unordered_multiset`和`unordered_multimap`的`equal_range`成员函数返回匹配对象的范围。 对于`unordered_set`和`unordered_map`，Count 成员函数永远不能返回大于 1 的值。

# 用于动态分配对象的容器

面向对象的编程在很大程度上依赖于使用多态基类引用来操作整个类层次结构的对象。 这些对象通常是动态分配的。 在处理这类对象的整个集合时，STL 容器来得很快；它们存储单一类型的具体对象，并且需要复制或移动语义。 不可能定义一个容器来存储层次结构中不同类的对象。 虽然您可以将多态基类指针存储在容器中，但指针被视为 POD 类型，几乎不支持深度复制语义。 动态分配对象的生命周期与 STL 无关。 但是，定义一个指针容器是很麻烦的，这些指针的生存期必须在没有容器任何帮助的情况下单独管理。

Boost 指针容器库通过存储指向动态分配的对象的指针并在容器生命周期结束时释放它们来解决这些空白。 指针容器提供了一个接口，您可以通过该接口对底层对象进行操作，而不需要间接指针。 因为它们存储指向对象的指针，所以这些容器自然支持多态容器，而不需要任何额外的机器。

下表显示了指针容器及其对应的标准库：

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

来自 Boost 的指针容器

 | 

标准库容器

 |
| --- | --- |
| BOOST：：PTR_ARRAY | Std：：Array |
| BOOST：：PTR_VECTOR | Std：：Vector |
| Boost：：ptr_deque | 性病：：那是什么？ |
| BOOST：：PTR_LIST | Std：：List |
| Boost：：ptr_set/Boost：：ptr_multiset | Std：：set/std：：multiset |
| BOOST：：PTR_UNORDERED_SET/BOOST：：PTR_UNORDERED_MULTIST | Std：：unordered_set/std：：unordered_multiset |
| Boost：：ptr_map/Boost：：ptr_Multimap | Std：：map/std：：Multimap |
| Boost：：PTR_UNORDERED_MAP/Boost：：PTR_UNORDERED_Multimap | STD：：UNORDERED_MAP/STD：：UNORDERED_Multimap |

Boost 定义了所有标准容器的指针容器等效项。 这些容器可用于存储多态指针，并且存储的指针所指向的底层对象不需要是可复制或可移动的。 下面是一个基本的入门示例：

**清单 5.12：使用 Boost 指针容器**

```cpp
1 #include <boost/ptr_container/ptr_vector.hpp>
 2 #include <boost/noncopyable.hpp>
 3 #include <iostream>
 4 #include <boost/current_function.hpp>
 5
 6 class AbstractJob {
 7 public:
 8   virtual ~AbstractJob() {}
 9
10   void doJob() {
11     doStep1();
12     doStep2();
13   }
14
15 private:
16   virtual void doStep1() = 0;
17   virtual void doStep2() = 0;
18 };
19
20 class JobA : public AbstractJob
21 {
22   void doStep1() override {
23     std::cout << BOOST_CURRENT_FUNCTION << '\n';
24   }
25
26   void doStep2() override {
27     std::cout << BOOST_CURRENT_FUNCTION << '\n';
28   }
29 };
30
31 class JobB : public AbstractJob
32 {
33   void doStep1() override {
34     std::cout << BOOST_CURRENT_FUNCTION << '\n';
35   }
36
37   void doStep2() override {
38     std::cout << BOOST_CURRENT_FUNCTION << '\n';
39   }
40 };
41
42 int main()
43 {
44   boost::ptr_vector<AbstractJob> basePtrVec;
45
46   basePtrVec.push_back(new JobA);
47   basePtrVec.push_back(new JobB);
48
49   AbstractJob& firstJob = basePtrVec.front();
50   AbstractJob& lastJob = basePtrVec.back();
51
52   for (auto& job : basePtrVec) {
53     job.doJob();
54   }
55 }
```

在前面的示例中，`AbstractJob`是一个抽象基类(第 5 行)，它定义了两个私有纯虚拟函数`doStep1`和`doStep2`(第 16、17 行)，以及一个调用这两个函数的非虚拟公共函数`doJob`(第 10 行)。 `JobA`和`JobB`是`AbstractJob`的两个具体实现，它们实现虚拟函数`doStep1`和`doStep2`。 函数签名后面的`override`关键字(第 22、26、33 和 37 行)是一个 C++ 11 特性，它阐明了特定函数覆盖了基础类中的虚拟函数。 在 main 函数中，我们创建了`AbstractJobs`的`ptr_vector`。 请注意，模板参数不是指针类型(第 44 行)。 然后，我们将`JobA`和`JobB`的两个具体实例附加到向量(第 46 和 47 行)。 我们使用`front`(第 49 行)和`back`(第 50 行)成员函数访问向量中的第一个和最后一个元素，这两个函数都返回对底层对象的引用，而不是它们的指针。 最后，我们读出基于范围的 for 循环中存储的对象(第 52 行)。 循环变量`job`被声明为引用(`auto&`)，而不是指针。 指针容器的成员函数以及迭代器返回的不是对存储的指针的引用，而是对它们所指向的底层对象的引用，这提供了语法上的简单性。

虽然基于范围的 for 循环和`BOOST_FOREACH`使得迭代集合变得很容易，但是如果需要，您也可以直接使用迭代器接口：

```cpp
49   typedef boost::ptr_vector<AbstractJob>::iterator iter_t;
50 
51   for (iter_t it = basePtrVec.begin(); 
52        it != basePtrVec.end(); ++ it) {
53     AbstractJob& job = *it;
54     job.do();
55   }
```

同样，请注意，迭代器返回对底层对象的引用，而不是对指针的引用(第 53 行)，即使容器存储指针也是如此。 变量`job`是引用，因为`AbstractJob`是抽象的，不能实例化。 但是如果基类不是抽象的呢？ 考虑以下非抽象多态基类的示例：

**清单 5.13：可复制混凝土基类的缺陷**

```cpp
 1 struct ConcreteBase
 2 {
 3   virtual void doWork() {}
 4 };
 5
 6 struct Derived1 : public ConcreteBase
 7 {
 8   Derived1(int n) : data(n) {}
 9   void doWork() override { std::cout <<data <<"\n"; }
10   int data;
11 };
12
13 struct Derived2 : public ConcreteBase
14 {
15   Derived2(int n) : data(n) {}
16   void doWork() override { std::cout <<data << "\n"; }
17   int data;
18 };
19
20 int main()
21 {
22   boost::ptr_vector<ConcreteBase> vec;
23   typedef boost::ptr_vector<ConcreteBase>::iterator iter_t;
24                                                     
25   vec.push_back(new Derived1(1));
26   vec.push_back(new Derived2(2));
27
28   for (iter_t it = vec.begin(); it != vec.end(); ++ it) {
29     ConcreteBase obj = *it;
30     obj.doWork();
31   }
32 }
```

前面的代码编译得很干净，但可能不会执行预期的操作。 在 for 循环的主体中，我们将派生类的每个对象分配给一个基类实例(第 29 行)。 `ConcreteBase`的复制构造函数生效，我们得到的是一个切片对象和不正确的行为。

因此，最好在开始时通过从`boost::noncopyable`派生基类本身来防止复制，如下所示：

```cpp
 1 #include <boost/noncopyable.hpp>
 2 
 3 class ConcreteBase : public boost::noncopyable
```

这将通过将此类代码标记为编译错误来防止因意外复制而导致的切片。 请注意，这将使层次结构中的所有类都不可复制。 在下一节中，我们将研究如何将复制语义添加到这样的层次结构中。 但在此之前，我们先来看看如何使用关联指针容器。

我们可以存储动态分配的对象，包括`boost::ptr_set`或`boost::ptr_multiset`中的多态对象。 因为这些是有序容器，所以我们必须为容器中存储的值类型定义严格的弱排序关系。 这通常由定义该类型的`bool operator<`的来完成。 如果存储指向类层次结构的对象的多态指针，则必须为层次结构的所有对象定义排序关系，而不仅仅是在特定具体类型的对象之间定义排序关系：

**清单 5.14：使用关联指针容器-ptr_set**

```cpp
 1 #include <boost/ptr_container/ptr_set.hpp>
 2 #include <boost/noncopyable.hpp>
 3 #include <string>
 4 #include <iostream>
 5 
 6 class Animal : boost::noncopyable
 7 {
 8 public:
 9   virtual ~Animal()
10   {};
11 
12   virtual std::string name() const = 0;
13 };
14 
15 class SnowLeopard : public Animal
16 {
17 public:
18   SnowLeopard(const std::string& name) : name_(name) {}
19 
20   virtual ~SnowLeopard() { std::cout << "~SnowLeopard\n"; }
21 
22   std::string name() const override
23   {
24     return name_ + ", the snow leopard";
25   }
26 
27 private:
28   std::string name_;
29 };
30 
31 class Puma : public Animal
32 {
33 public:
34   Puma(const std::string& name) : name_(name) {}
35   virtual ~Puma() { std::cout << "~Puma\n"; }
36 
37   virtual std::string name() const
38   {
39     return name_ + ", the puma";
40   }
41 
42 private:
43   std::string name_;
44 };
45 
46 bool operator<(const Animal& left, const Animal& right)
47 {
48   return left.name() < right.name();
49 }
50 
51 int main()
52 {
53   boost::ptr_set<Animal>animals;
54   animals.insert(new Puma("Kaju"));
55   animals.insert(new SnowLeopard("Rongi"));
56   animals.insert(new Puma("Juki"));
57 
58   for (auto&animal :animals) {
59     std::cout <<animal.name() << '\n';
60   }
61 }
```

这显示了如何使用`std::ptr_set`存储指向动态分配对象的多态指针。 `Animal`抽象基声明一个纯虚函数`name`。 两个派生类`SnowLeopard`和`Puma`(表示两个真实的哺乳动物物种)覆盖它们。 我们定义了名为`animals`的`Animal`指针的`ptr_set`(第 53 行)。 我们创建了两个名为`Kaju`和`Juki`的美洲狮和一个名为`Rongi`的雪豹，并将它们插入到集合`animals`中(第 54-56 行)。 当我们遍历列表时，我们得到的是对动态分配的对象的引用，而不是指针(第 58、59 行)。 `operator<`(第 46 行)比较任意两个动物，并按名称对它们进行词汇排序。 如果没有这个运算符，我们将无法定义`ptr_set`。 以下是前面代码的输出：

```cpp
Juki, the puma
Kaju, the puma
Rongi, the snow leopard
~Puma
~Puma
~SnowLeopard
```

这三个动物列在前三行中，然后调用每个对象的析构函数，并在`ptr_set`容器实例超出作用域时打印其标识。

关联指针容器的另一个常见用法是在映射或多映射中存储多态对象：

**清单 5.15：使用关联指针容器**

```cpp
 1 #include <boost/ptr_container/ptr_map.hpp>
 2 #include <iostream>
 3 // include definitions of Animal, SnowLeopard, Puma
 4 
 5 int main() {
 6   boost::ptr_multimap<std::string, Animal> animals;
 7   std::string kj = "Puma";
 8   std::string br = "Snow Leopard";
 9 
10   animals.insert(kj, new Puma("Kaju"));
11   animals.insert(br, new SnowLeopard("Rongi"));
12   animals.insert(kj, new Puma("Juki"));
13 
14   for (const auto&entry : animals) {
15     std::cout << "[" << entry.first << "]->" 
16               << entry.second->name() << '\n';
17   }
18 }
```

我们创建了一个名为`animals`的多映射(第 6 行)，它将物种名称保存为`std::string`类型的键，并为每个键存储一个或多个指向该物种动物的多态指针(第 10-12 行)。 我们使用与清单 5.14 相同的`Animal`层次结构。 我们循环遍历 Multimap 中的所有条目，打印物种名称，后跟特定动物的给定名称。 以下是输出：

```cpp
[SnowLeopard]->Rongi, the snow leopard
[Puma]->Kaju, the puma
[Puma]->Juki, the puma
```

每个`Animal`条目都是`std::pair<std::string, Animal*>`类型，因此可以使用成员`first`和`second`访问键和值。 注意，`entry.second`返回存储的指针，而不是对底层对象的引用(第 16 行)。

## 指针容器的所有权语义

我们已经看到，个指针容器“拥有”我们存储在其中的个动态分配的对象，从这个意义上说，容器负责在它自己的生命周期结束时释放它们。 对象本身既不需要支持复制语义，也不需要支持移动语义，所以很自然会想知道复制指针容器意味着什么。 实际上，指针容器是可复制的，并且支持简单的复制语义-在复制构造或复制分配指针容器时，它会动态分配源容器中每个对象的副本，并将指针存储到该对象。 这对于 POD 类型或具有复制构造函数的任何非多态类型都可以很好地工作。 对于多态类型，当基类是抽象的或不可复制时，此行为会导致切片或编译失败。 为了使用个多态对象创建容器的深层副本，这些对象必须支持克隆接口。

要支持在命名空间`X`中创建多态类型`T`的对象副本，必须使用以下签名在命名空间`X`中定义一个自由函数：

```cpp
1 namespace X {
2   // definition of T
3   ...
4 
5   T* new_clone(const T& obj);
6 }
```

函数`new_clone`通过**参数相关查找**(**ADL**)找到，预计会返回传递给它的对象`obj`的副本，其运行时类型应与`obj`相同。 我们可以扩展动物示例；我们可以通过定义在`Animal`的每个子类中被覆盖的`clone`虚拟函数来实现这一点，以返回对象的副本。 然后，`new_clone`free 函数只需在传递的对象上调用克隆函数，并返回克隆的指针：

**清单 5.16：使对象和指针容器可克隆**

```cpp
1 #include <boost/ptr_container/ptr_vector.hpp>
 2 #include <boost/noncopyable.hpp>
 3 #include <string>
 4 #include <iostream>
 5 
 6 namespace nature
 7 {
 8 
 9 class Animal : boost::noncopyable
10 {
11 public:
12   // ...
13   virtual Animal *clone() const = 0;
14 };
15 
16 class SnowLeopard : public Animal
17 {
18 public:
19   // ...
20   SnowLeopard *clone() const override
21   {
22     return new SnowLeopard(name_);
23   }
24 
25 private:
26   std::string name_;
27 };
28 
29 class Puma : public Animal
30 {
31 public:
32   // ...
33   Puma *clone() const override
34   {
35     return new Puma(name_);
36   }
37 
38 private:
39   std::string name_;
40 };
41 
42 Animal *new_clone(const Animal& animal)
43 {
44   return animal.clone();
45 }
46 
47 } // end of namespace nature
48 
49 int main()
50 {
51   boost::ptr_vector<nature::Animal> animals, animals2;
52 
53   animals.push_back(new nature::Puma("Kaju"));
54   animals.push_back(new nature::SnowLeopard("Rongi"));
55   animals.push_back(new nature::Puma("Juki"));
56 
57   animals2 = animals.clone();
58 
59   for (auto&animal : animals2) {
60     std::cout <<animal.name() << '\n';
61   }
62 }
```

为了实现完全的通用性，我们将`Animal`及其派生类放入一个名为`nature`的名称空间(第 6 行)，并在`Animal`中添加一个名为`clone`的纯虚函数(第 13 行)。 我们覆盖两个派生类中的每个派生类中的 clone 方法(第 33 行，42 行)，并根据`clone`方法实现`new_clone`free 函数。 我们声明了两个`nature::Animal`指针的`ptr_vector`容器：`animals`和`animals2`(第 51 行)，用三个毛茸茸的哺乳动物初始化`animals`(第 53-55 行)，最后将`animals`的克隆赋值给`animals2`(第 57 行)。 如果不是调用`clone`，而是编写以下代码：

```cpp
57   animals2 = animals;
```

在这种情况下，该行将无法编译，因为`Animal`是抽象的和不可复制的，前面的行将尝试对`animals`中的每个存储对象进行切片，并将其复制到`animals2`。 如果`Animal`是可复制的和非抽象的，那么这样的行本可以编译，但是`animals2`会包含一些倒霉的切片`Animals`。

指针容器支持将对象的所有权从一个容器移动到另一个容器，即使这些容器的类型不同。 您可以将单个元素、一系列元素或一个容器的全部内容移动到另一个容器，其操作类似于 Standard Library`std::list`中的`slice`。 下面的示例说明了其中一些技术：

**清单 5.17：在容器**之间移动指针

```cpp
 1 #include <boost/ptr_container/ptr_vector.hpp>
 2 #include <boost/ptr_container/ptr_list.hpp>
 3 #include <cassert>
 4 #include <iostream>
 5 // definitions of Animal, SnowLeopard, Puma in namespace nature 
 6 
 7 int main()
 8 {
 9   boost::ptr_vector<nature::Animal> mountA;
10   boost::ptr_vector<nature::Animal> mountB;
11   boost::ptr_list<nature::Animal> mountC;
12 
13   mountA.push_back(new nature::Puma("Kaju"));
14   mountA.push_back(new nature::SnowLeopard("Rongi"));
15   mountA.push_back(new nature::Puma("Juki"));
16   mountA.push_back(new nature::SnowLeopard("Turo"));
17 
18   size_t num_animals = mountA.size();
19 
20   for (auto&animal : mountA) {
21     std::cout << "MountA: " <<animal.name() << '\n';
22   }
23 
24   // Move all contents
25   mountB = mountA.release();
26   assert(mountA.size() == 0);
27   assert(mountB.size() == num_animals);
28 
29   // move one element
30   mountC.transfer(mountC.begin(), mountB.begin() + 1, mountB);
31   assert(mountB.size() == num_animals - 1);
32   assert(mountC.size() == 1);
33 
34   // move one element, second way
35   auto popped = mountB.pop_back();
36   mountC.push_back(popped.release());
37 
38   assert(mountB.size() + mountC.size() == num_animals);
39   assert(mountC.size() == 2);
40 
41   // move a range of elements
42   mountC.transfer(mountC.end(), mountB.begin(),
43                   mountB.end(), mountB);
44   assert(mountB.size() + mountC.size() == num_animals);
45   assert(mountC.size() == num_animals);
46 
47   for (auto&animal : mountC) {
48     std::cout << "MountC: " <<animal.name() << '\n';
49   }
50 }
```

前面的示例说明了将元素从一个容器移动到另一个容器的所有不同技术。 两个`Puma`s(`Kaju`和`Juki`)和两个`SnowLeopard`s(`Rongi`和`Turo`)在 A 山上，所以向量`mountA`存储了 A 山上的动物。四个动物决定搬到 B 山；向量`mountB`一开始就是空的。 然后，4`Animals`移动到山 B，因此我们使用`mountA`的释放方法将`mountA`的内容移动到`mountB`(第 25 行)。 之后，在`mountA`(第 26 行)中不再有`Animals`，而`mountB`包含所有四个(第 27 行)。 现在动物们想要穿越到 C 山，这是一种很难攀登的不同类型的山。 在名为`mountC`的`ptr_list`(而不是`ptr_vector`)中跟踪 C 山上的动物。 首先，`Rongi`雪豹(`mountB`中的第二个元素)为我们指路，并且是第一个登上 C 山的。因此，我们使用`mountC`的`transfer`成员函数(第 30 行)将`mountB`的第二个元素移到`mountC`的开头。 接下来，另一只雪豹 Turo 冒险跨越到 C。我们将`mountB`的最后一个元素移到`mountC`的末尾，方法是首先将其从`mountB`的末尾弹出(第 35 行)，然后在`popped`对象上调用`release`，并将返回的指针附加到`mountC`(第 36 行)。 此时，`mountB`(第 39 行)上还有两个`Animals`。 通过调用`mountC`的`transfer`成员函数，将剩余的元素(两个美洲狮)从`mountB`移动到`mountC`的末尾(第 42、43 行)，从而完成动物的迁出(第 45 行)。

`transfer`的第一个参数是标识目标容器中插入移动元素的位置的迭代器。 在包含三个参数的重载(第 30 行)中，第二个参数标识源容器中需要移动的元素的迭代器，第三个参数是对源容器的引用。 在由四个参数组成的重载中，第二个和第三个参数标识源容器中需要移动的元素范围，第四个参数是对源容器的引用。

如果您使用的是 C++ 11 之前的版本，则不能使用`auto`关键字来删除您不关心的类型名称(第 35 行)。 在这种情况下，您需要将`pop_back()`的结果(或从容器中移除并返回元素的其他方法)存储在类型为`container::auto_type`的变量中。 例如：

```cpp
33   boost::ptr_vector<nature::Animal>::auto_type popped = 
34                                           mountB.pop_back();
```

## 指针容器中的空指针

考虑到指针容器存储指针并提供对底层对象的引用，如果存储空指针会发生什么？ 默认情况下，指针容器不允许空指针，尝试存储空指针会在运行时适时引发异常。 您可以重写此行为，并告诉编译器允许存储空值。 为此，您必须稍微修改容器定义，以使用：

```cpp
boost::ptr_container<boost::nullable<Animal>> animals;
```

而不是：

```cpp
boost::ptr_container< Animal> animals;
```

优点是有限的，您还必须确保不会取消引用潜在的空指针。 您的代码会变得复杂，并且很难使用基于范围的 for 循环。 下面是一个例子：

```cpp
 1 std::ptr_vector< boost::nullable<Animal>> animalsAndNulls;
 2 ... // assign animals
 3
 4 for (auto it = animalsAndNulls.begin();
 5 it != animalsAndNulls.end(); ++ it)
 6 {
 7    if (!boost::is_null(it)) {
 8      Animal& a = *it;
 9      // do stuff ...
10    }
11 }
```

最好避免存储空指针，而使用库作者推荐的空对象模式。 有关空对象模式([http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible](http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible))的更多详细信息，请参阅Boost 在线文档。

总之，Boost 指针容器是一组功能齐全的容器，用于指向动态分配的对象的指针，非常适合处理多态对象。 在 C++ 11 中，实现相似语义的另一种方法是通过`std::unique_ptr<T>`的容器。 在充分优化的情况下，`unique_ptr`包装器的开销可能最小，其性能可与 Boost 的指针容器相媲美。 虽然使用`boost::shared_ptr<T>`容器(`T`是动态分配的对象的类型)服务于这里描述的用例，但它们有较高的内存和运行时开销，除非需要共享所有权语义，否则不是最佳的。

# 使用 Boost.Assign 进行富有表现力的初始化和赋值

使用单个语句初始化对象或为其赋一些文字值是生成对象内容的一种简洁方式。 对于数值变量或字符串这样的简单变量很容易做到这一点，因为有现成的文字。 另一方面，没有简单的语法方法可以用任意值集初始化容器。 这是因为很难将具有重要内部数据结构的更复杂的对象表示为文字。 通过使用一些巧妙的模式和重载操作符，Boost.Assign 库可以使用非常富有表现力的语法对整个 STL 和 Boost 容器进行初始化和赋值。

利用 C++ 11 中新的**初始化器列表**和**统一初始化**语法，这些任务无需 Boost.Assigned 即可完成。 尽管如此，Boost.Assign 是在 C++ 11 之前完成这项工作的唯一方法，它还提供了一些很好的附加功能，这些功能通过初始化器列表和统一初始化是不容易获得的。

## 将值列表分配给容器

Boost.Assign 是 Boost 中的一个漂亮的小库，您会养成在最小的机会使用它的习惯。 下面是一个例子：

**清单 5.18：为向量**赋值列表

```cpp
 1 #include <string>
 2 #include <vector>
 3 #include <boost/assign.hpp>
 4 #include <cassert>
 5
 6 using namespace boost::assign;
 7
 8 int main()
 9 {
10   std::vector<std::string>greetings;
11   greetings += "Good morning", "Buenos dias", "Bongiorno";
12   greetings += "Boker tov", "Guten Morgen", "Bonjour";
13
14   assert(greetings.size() == 6);
15 }
```

为向量赋值列表从来没有 Boost.Assign 那么有趣。 通过重载逗号运算符(`operator,`)和`operator+=`，Boost 赋值库提供了一种将值列表追加到向量的简单方法。 为了使用运算符，我们包括`boost/assign.hpp`(第 3 行)。 `using namespace`指令使 Boost Assign 中定义的运算符在全局作用域中可用(第 6 行)。 没有这一点，我们就不能自由使用运算符，表现力就会消失。 我们将英语、法语和意大利语的三个“早上好”问候语附加到向量`greetings`(第 11 行)，然后再附加三个希伯来语、德语和法语的问候语(第 12 行)。 最终结果是一个具有六个字符串的向量(第 14 行)。 我们本可以用双曲球代替向量，但这还是可以用的。 如果您需要另一种插入模式，如在列表或双队列的头部插入或插入到映射中，Boost Assign 仍然可以为您工作。 这里还有一个例子：

**清单 5.19：将元素分配给其他容器**

```cpp
 1 #include <string>
 2 #include <map>
 3 #include <list>
 4 #include <deque>
 5 #include <boost/assign.hpp>
 6 #include <iostream>
 7 #include <boost/tuple/tuple.hpp>
 8
 9 using namespace boost::assign;
10
11 int main(){
12   std::deque<std::string>greets;
13   push_front(greets) = "Good night", "Buenas noches", 
14       "Bounanotte", "Lyla tov", "Gute nacht", "Bonne nuit";
15
16   std::map<std::string, std::string> rockCharacters;
17   insert(rockCharacters)
18         ("John Barleycorn", "must die")       // Traffic
19         ("Eleanor Rigby", "lives in a dream") // Beatles
20         ("Arnold Layne", "had a strange hobby")   // Floyd
21         ("Angie", "can't say we never tried")    // Stones
22         ("Harry", "play the honkytonk"); // Dire Straits
23
24   std::list<boost::tuple<std::string, std::string, 
25                         std::string>> trios;
25   push_back(trios)("Athos", "Porthos", "Aramis")
26                   ("Potter", "Weasley", "Granger")
27                   ("Tintin", "Snowy", "Haddock")
28                   ("Geller", "Bing", "Tribbiani")
29                   ("Jones", "Crenshaw", "Andrews");
30
31   std::cout << "Night greets:\n";
32   for (const auto& greet: greets) {
33     std::cout << greet << '\n';
34   }
35
36   std::cout << "\nPeople:\n";
37   for (const auto&character: rockCharacters) {
38     std::cout << character.first << ": "
39               << character.second << '\n';
40   }
41
42   std::cout << "Trios:\n";
43   for (auto& trio: trios) {
44     std::cout << boost::get<0>(trio) << ", " 
45               << boost::get<1>(trio) << ", " 
46               << boost::get<2>(trio) << '\n';
47   }
48 }
```

在这里，我们看到了为三种不同类型的容器赋值的示例。 我们首先将 6 个不同语言的“晚安”问候语放入 a`std::deque`的头部(第 13-14 行)。 我们使用 Boost Assign 中的`push_front`适配器来实现这一点，该适配器在 deque`greets`上调用同名的方法`push_front`。 应该清楚的是，在此操作之后，列表中的最后一个字符串(`"Bonne nuit"`)位于队列的前面。

如果你对摇滚乐情有独钟，而且和我一样大，你也许会认出下一个例子中的人物：摇滚乐和专辑中的人物`std::map`，以及他们做了什么(根据那些歌曲)。 使用调用同名方法的`insert`适配器在映射`rockCharacters`上插入五对字符串-每对字符串将一个字符映射到一个动作(第 17-22 行)。 `insert`适配器和其他类似适配器返回一个具有可以链接的重载`operator()`的对象。 通过链接对该操作符的调用，可以创建值列表。

我们使用的最后一个容器是`std::list`，为了好玩，我们列出了小说中著名的三重奏。 `boost::tuple`模板可用于定义任意数量的不同类型元素的元组。 在这里，我们使用由三个字符串组成的`boost::tuple`来表示一个三元组，并在变量`trios`中保存这样一个三元组的列表(第 24 行)。 Boost Assign 中的`push_back`适配器用于将三元组追加到列表的末尾。 清单 5.17 中使用的运算符`+=`和`std::vector`在底层容器上调用`push_back`。 然而，在这种情况下，需要使用`push_back`适配器来允许将值的元组推入列表。

接下来，我们打印数据结构的内容。 要访问列表`trios`中每个元组的每个元素，我们使用`boost::get`模板，该模板通过从 0 开始的索引访问元组中的元素(第 44-45 行)。 运行此代码将打印以下输出：

```cpp
Night greets:
Bonne nuit
Gute nacht
Lyla tov
Bounanotte
Buenas noches
Good night
People:
Angie: can't say we never tried
Arnold Layne: had a strange hobby
Eleanor Rigby: lives in a dream
John Barleycorn: must die
Harry: play the honkytonk
People:
Athos,Porthos, Aramis
Potter,Weasley, Granger
Tintin,Snowy, Haddock
Jones,Crenshaw, Andrews
```

## 使用值列表初始化容器

在前面的示例中，我们看到了向容器追加或插入值的各种方法，但是 Boost.Assign 还允许您在构造时使用值来初始化容器。 语法与用于赋值的语法略有不同：

**清单 5.20：使用 Boost Assign**进行聚合初始化

```cpp
 1 #include <boost/assign.hpp>
 2 #include <boost/rational.hpp>
 3 #include <iterator>
 4 
 5 using namespace boost::assign;
 6 
 7 int main()
 8 {
 9   std::cout << "Catalan numbers:\n";
10   const std::vector<int> catalan = list_of(1)(1)(2)(5)
11                        (14)(42) (132)(429)(1430)(4862);
12
13   std::ostream_iterator<int>os(std::cout, " ");
14   std::copy(catalan.begin(), catalan.end(), os);
15
16   std::cout << "\nBernoulli numbers:\n";
17   const std::map<int, boost::rational<int>>bernoulli = 
18                       map_list_of(0, boost::rational<int>(1))
19                             (1, boost::rational<int>(1, 2))
20                             (2, boost::rational<int>(1, 6))
21                             (3, boost::rational<int>(0))
22                             (4, boost::rational<int>(-1, 30))
23                             (5, boost::rational<int>(0))
24                             (6, boost::rational<int>(1, 42))
25                             (7, boost::rational<int>(0));
26
27   for (auto&b : bernoulli) {
28     std::cout << 'B' << b.first << ": " << b.second << ", ";
29   }
30   std::cout << '\n';
31 }
```

前面的示例构造了一个包含前十个加泰罗尼亚数字的向量。 第 n 个加泰罗尼亚数(`n`为非负整数)等于包含`n`个左括号和`n`个右括号的字符串的排列数，其中所有括号都正确匹配。 我们使用来自`boost::assign`名称空间的`list_of`适配器来构造用于初始化向量`catalan`的前十个加泰罗尼亚数字的列表(第 10-11 行)。 我们使用`ostream_iterator`打印该列表(第 13-14 行)。

接下来，我们创建一个包含前 8 个 Bernoulli 数的`std::map`：键是序号位置，值是数字本身。 伯努利数是数论和组合学中出现的有理数序列(可表示为两个整数的比率)。 为了初始化这样的映射，我们使用`map_list_of`适配器传递键和值，如图所示(第 17-25 行)。 为了表示有理数，我们使用标题`boost/rational.hpp`中定义的`boost::rational`模板。

此代码打印以下输出：

```cpp
Catalan numbers:
1 1 2 5 14 42 132 429 1430 4862
Bernoulli numbers:
B0: 1/1, B1: 1/2, B2: 1/6, B3: 0/1, B4: -1/30, B5: 0/1, B6: 1/42, B7: 0/1,
```

有趣的是，您还可以使用 Boost Assign 创建匿名序列。 这些序列可以构造为非常数 l 值引用序列，也可以构造为可接受文字的常量 l 值引用序列。 它们的构造效率比`list_of`更高，并且可以用来代替它们来初始化序列容器(如载体)。 这些序列符合升压范围的概念，可以在任何可以使用范围的地方使用。 下面是一个例子：

**清单 5.21：创建匿名序列**

```cpp
1 #include <boost/assign.hpp>
 2 #include <iostream>
 3 
 4 using namespace boost::assign;
 5 
 6 template<typename RangeType>
 7 int inspect_range(RangeType&& rng)
 8 {
 9   size_t sz = boost::size(rng);
10 
11   if (sz > 0) {
12     std::cout << "First elem: " << *boost::begin(rng) << '\n';
13     std::cout <<"Last elem: " << *(boost::end(rng) - 1) << '\n';
14   }
15 
16   return sz;
17 }
18 
19 int main()
20 {
21   std::cout << inspect_range(
22                  cref_list_of<10>(1)(2)(3)(4)(5)(6)(7)(8));
23 
24   typedef std::map<std::string, std::string> strmap_t;
25   strmap_t helloWorlds =
26          cref_list_of<3, strmap_t::value_type>
27             (strmap_t::value_type("hello", "world"))
28             (strmap_t::value_type("hola", "el mundo"))
29             (strmap_t::value_type("hallo", "Welt"));
30 }
```

我们使用`cref_list_of`适配器创建了一个大小为 10 的匿名序列，但实际上只在其中放入了 8 个值(第 22 行)。 如果我们有变量而不是字符文字放入序列中，我们可以使用`ref_list_of`适配器，这将创建一个可变序列。 我们使用`boost::size`、`boost::begin`和`boost::end`函数对范围进行运算，以确定序列的长度(第 9 行)及其第一个和最后一个元素(第 12-13 行)。 接下来，我们使用字符串对的匿名列表来初始化 a`std::map`(第 26-29 行)。 请注意，映射中的`value_type`个嵌套 tyecif 表示映射中每个键-值对的类型。

C++ 11 引入了非常方便的聚合初始化语法，使用该语法可以初始化任意容器。 使用聚合初始化器语法执行初始化在语法上比 Boost Assign 更简单，而且效率可能更高。 在 C++ 11 之前的环境中，Boost Assign 的初始化语法仍然是唯一的选择。 下面是几个 C++ 11 聚合初始化的示例：

```cpp
 1 std::vector<std::string>scholars{"Ibn Sina", "Ibn Rushd",
 2                                   "Al Khwarizmi", "Al Kindi"};
 3std::map<std::string, std::string> scholarsFrom
 4={{scholars[0], "Bukhara"},
 5      {scholars[1], "Cordoba"},
 6{scholars[2], "Khwarezm"},
 7                             {scholars[3], "Basra"}};
```

这段代码显示了如何使用用大括号括起来的逗号分隔的值列表来初始化集合。 用中世纪四位穆斯林学者的名字初始化`scholars`向量，然后以这些学者的名字为关键字，以他们的出生地为值来初始化`scholarsFrom`映射。 请注意每个键-值对是如何用大括号括在逗号分隔的此类对列表中的。 另外，请注意，我们可以在初始化器中自由使用 l 值(如`scholars[0]`)和文字。

## 初始化指针容器并赋值

Boost 赋值库以异常安全的方式为指针容器赋值和初始化指针容器提供特殊支持。

以下简短示例总结了用法：

**清单 5.22：使用指针容器**进行 Boost 赋值

```cpp
 1 #include <boost/ptr_container/ptr_vector.hpp>
 2 #include <boost/ptr_container/ptr_map.hpp>
 3 #include <boost/assign/ptr_list_inserter.hpp>
 4 #include <boost/assign/ptr_map_inserter.hpp>
 5 #include <boost/assign/ptr_list_of.hpp>
 6 #include <string>
 7 #include <iostream>
 8 
 9 using namespace boost::assign;
10 
11 struct WorkShift
12 {
13   WorkShift(double start = 9.30, double end = 17.30)
14     : start_(start), end_(end)
15   {}
16 
17   double start_, end_;
18 };
19 
20 std::ostream& operator<<(std::ostream& os, const WorkShift& ws)
21 {
22   return os << "[" << ws.start_ <<" till " << ws.end_ << "]";
23 }
24 
25 int main()
26 {
27   boost::ptr_vector<WorkShift> shifts = ptr_list_of<WorkShift>
28                               (6.00, 14.00)();
29   ptr_push_back(shifts)(14.00, 22.00)(22.00, 6.00);
30 
31   boost::ptr_map<std::string, WorkShift> shiftMap;
32   ptr_map_insert(shiftMap)("morning", 6.00, 14.00)("day")
33             ("afternoon", 14.00, 22.00)("night", 22.00, 6.00);
34 
35   for (const auto& entry: shiftMap) {
36     std::cout << entry.first <<" " <<shiftMap.at(entry.first)
37               << '\n';
38   }
39 }
```

在本例中，我们定义了一个类型`WorkShift`，它表示工作场所的班次，并封装特定班次的工作时间信息。 它的构造函数接受两个参数，即班次的开始时间和结束时间，并将它们缺省为 9.30 和 17.30(第 12 行)。 我们创建`WorkShift`个对象的`ptr_vector`个对象，并使用`ptr_list_of`适配器对其进行初始化。 我们不传递构造的对象，而是传递两个对象的构造函数参数：6.00 到 14.00 之间的移位和默认开始和结束时间的移位(第 28 行)。

`ptr_list_of`的模板参数表示要实例化的类型。 我们使用`ptr_push_back`适配器向名为`shifts`的`ptr_vector`添加另外两个移位。 接下来，我们使用字符串键创建名为`shiftMap`的`ptr_map`，标识移位类型和指向移位对象的值的指针(第 31 行)。 然后，我们使用`ptr_map_insert`适配器将元素插入到映射中。 我们通过调用`operator()`创建每个条目，将字符串键作为第一个参数传递，将`WorkShift`对象的构造函数参数作为其余参数传递(第 32-33 行)。 我们使用`WorkShift`的重载流运算符(第 19 行)打印`ptr_map`的内容(第 35-38 行)。 以下是该程序的输出：

```cpp
afternoon [14 till 22]
general [9.3 till 17.3]
morning [6 till 14]
night [22 till 6]
```

理解为什么要使用单独的适配器类来初始化指针容器，这一点很重要。 例如，下面是一个完全有效的代码：

```cpp
 1 boost::ptr_vector<WorkShift> shifts;
 2 boost::assign:push_back(shifts)(new WorkShift())
 3                              (new WorkShift(6.00, 14.00));
```

然而，在本例中，库的用户(即我们)手动分配了两个新的`WorkShift`对象。 编译器不保证这些数据的分配顺序。 仅保证它们附加到`shifts`的顺序(通过调用由`boost::assign::push_back`返回的适配器中的重载`operator()`)。 因此，对于前面的示例，编译器可以生成大致相当于以下内容的代码：

```cpp
 1 boost::ptr_vector<WorkShift> shifts;
 2 WorkShift *w1 = new WorkShift(6.00, 14.00);
 3 WorkShift *w2 = new WorkShift();
 4 boost::assign::push_back(shifts)(w2)(w1);
```

如果在构造`w2`时抛出`WorkShift`的构造函数(第 3 行)，则会泄漏`w1`。 为了确保异常安全，我们应该使用`ptr_push_back`：

```cpp
1 boost::ptr_vector<WorkShift> shifts;
2 boost::assign::ptr_push_back(shifts)()(6.00, 14.00);
```

相反，`boost::assign::ptr_push_back`适配器中的重载`operator()`获取需要位于`shifts`容器中的每个`WorkShift`对象的构造函数参数，并构造每个`WorkShift`对象，将这些参数转发给`WorkShift`构造函数。 该调用仅在构造的对象位于容器中之后才返回。 这确保在构造`WorkShift`对象时，所有先前构造的`WorkShift`对象已经是容器的一部分。 因此，如果构造函数抛出，容器以及先前构造的对象将被释放。

# 使用 Boost.Iterator 的迭代模式

迭代是大多数编程问题中的基本任务，无论是迭代容器的元素、一系列自然数还是目录中的文件。 通过抽象值集合的遍历方式，我们可以编写泛型代码来处理这样的个集合，而不需要依赖于特定于每个集合的迭代方法。

标准库容器为此公开迭代器，并且标准库中的泛型算法可以通过迭代器对任何符合要求的容器进行操作，而不依赖于容器的特定类型或其内部结构。

Boost.Iterator 库提供了一个框架，用于为符合标准并与标准库中的算法兼容的自定义类编写迭代器。 它还有助于将迭代概念概括为更抽象的对象集合，而不限于容器。

## 使用 Boost.Iterator 的智能迭代

Boost Iterator 库提供了许多迭代器适配器，使迭代遍历容器和值序列更具表现力和效率。 迭代器适配器包装一个迭代器以产生另一个迭代器。 自适应迭代器可以迭代也可以不迭代底层迭代器寻址的个元素的整个范围。 此外，它们还可以设计为返回不同的值，可能与基础迭代器的类型不同。 在本节中，我们将查看 Boost 提供的几个此类迭代器适配器的示例。

过滤器迭代器在底层元素序列的子序列上迭代。 它们包装一个底层迭代器序列，并接受一个一元布尔谓词，该谓词用于确定从底层范围中包括哪些元素，以及跳过哪些元素。 谓词将底层序列的一个元素作为单个参数，并返回 TRUE 或 FALSE。 返回 TRUE 的那些被包括在迭代中，其余的被过滤掉；因此得名。

您可以使用`boost::make_filter_iterator`函数模板创建过滤器迭代器。 将返回`bool`的一元函数对象(函数器、lambda 或函数指针)传递给它。 您还传递给它的不是一个，而是两个迭代器：它包装的一个迭代器和另一个标记序列结束的迭代器。 在下面的示例中，我们有一个`Person`对象列表，并且我们需要编写代码来向每个 70 岁或 70 岁以上的人的银行帐户支付 100 美元：

**清单 5.23：使用过滤器迭代器**

```cpp
 1 #include <boost/iterator/filter_iterator.hpp>
 2 #include <boost/assign.hpp>
 3 #include <vector>
 4 #include <string>
 5 #include <iostream>
 6
 7 struct Person
 8 {
 9   std::string name;
10   int age;
11   std::string bank_ac_no;
12
13   Person(const std::string& name, int years,
14          const std::string& ac_no) : 
15          name(name), age(years), bank_ac_no(ac_no) {}
16 };
17
17 void payout(double sum, const std::string& ac_no) {
19   std::cout << "Credited a sum of "<< sum
20             <<" to bank account number " << ac_no << '\n';
21 }
22
23 template<typename Itertype>
24 void creditSum(Itertype first, Itertype last, double sum)
25 {
26   while (first != last) {
27     payout(sum, first->bank_ac_no);
28     first++ ;
29   }
30 }
31
32 bool seventyOrOlder(const Person& person)
33 {
34   return person.age >= 70;
35 }
36
37 int main()
38 {
39   std::vector<Person> people{{"A Smith", 71, "5702750"},
40                 {"S Bates", 56, "3920774"}, 
41                 {"L Townshend", 73, "9513914"}, 
42                 {"L Milford", 68, "1108419"}, 
43                 {"F Cornthorpe", 81, "8143919"}}; 
44                 
45   auto first = boost::make_filter_iterator(seventyOrOlder,
46                                people.begin(), people.end());
47
48   auto last = boost::make_filter_iterator(seventyOrOlder,
49                                people.end(), people.end());
50
51   creditSum(first, last, 100);
52 }
```

在本例中，函数`payout`接受帐号和金额，并开始向帐户付款(第 17 行)。 函数`creditSum`获取一对迭代器，该迭代器定义一系列`Person`对象和一个金额，并开始向序列中的每个`Person`支付该金额，为每个对象调用`payout`(第 23-24 行)。 我们有一个由`Person`个对象组成的向量(第 39 行)，我们使用 C++ 11 中的统一初始化语法使用 5 个人的详细信息对其进行初始化。我们不能对向量中的整个元素范围直接调用`creditSum`，因为我们只想将它归功于 70 岁或岁的人。 为此，我们首先定义帮助我们选择候选条目的谓词函数`seventyOrOlder`(第 32 行)，然后定义过滤器迭代器`first`和`last`(第 45-49 行)。 最后，我们使用这对过滤器迭代器和要记入的总和调用`creditSum`(第 51 行)。

### 变换迭代器

转换迭代器允许您遍历序列，当取消引用时，返回将一元函数应用于序列底层元素的结果。 您可以使用`boost::make_tranform_iterator`构造转换迭代器，向其传递一元函数对象和底层迭代器。

考虑将包含主题名称的`std::map`个对象作为关键字，将主题分数作为值。 我们使用变换迭代器来计算所有科目的分数之和，如下例所示：

**清单 5.24：使用转换迭代器**

```cpp
 1 #include <iostream>
 2 #include <string>
 3 #include <vector>
 4 #include <map>
 5 #include <algorithm>
 6 #include <functional>
 7 #include <boost/assign.hpp>
 8 #include <boost/iterator/transform_iterator.hpp>
 9 #include <numeric> // for std::accumulate
10 using namespace boost::assign;
11
12 typedef std::map<std::string, int> scoremap;
13
14 struct GetScore : std::unary_function<
15                         const scoremap::value_type&, int>
16 {
17   result_type operator()(argument_type entry) const
18   {
19     return entry.second;
20   }
21 };
22
23 int main()
24 {
25   scoremap subjectScores{{"Physics", 80}, {"Chemistry", 78},
26                      {"Statistics", 88}, {"Mathematics", 92}};
27
28   boost::transform_iterator<GetScore,
29                             scoremap::iterator>
30                      first(subjectScores.begin(), GetScore()),
31                      last(subjectScores.end(), GetScore());
32
33   std::cout << std::accumulate(first, last, 0) << '\n';
34 }
```

地图`subjectScores`包含针对每个主题名称存储的各个主题的分数。 我们使用 C++ 11 统一初始化语法来初始化映射(第 25-26 行)。 我们希望迭代此映射中的值，并计算它们的总和。 迭代通过`subjectScores`将得到主题名称和分数的键值对。 为了从一对中提取分数，我们定义了一个函数`GetScore`(第 14-15 行)。 然后，我们定义一对转换迭代器`first`和`last`，每个迭代器都是使用`GetScore`函数器和底层迭代器的实例构造的，并指向`subjectScores`映射的开始和结束(第 28-31 行)。 通过从`first`到`last`调用`std::accumulate`，我们对地图中的分数求和(第 33 行)并打印结果。

请注意，`GetScore`派生自`std::unary_function<ArgType, RetType>`，其中`ArgType`是函数器的单个参数类型，`RetType`是函数器的返回类型。 这对于 C++ 11 不是必需的，您也不需要从 C++ 11 中的任何特定类派生`GetScore`。

与`boost::transform_iterator`类似，`std::transform`算法允许对序列中的每个元素应用转换，但您还必须将结果存储在序列中。 转换迭代器允许您创建一个延迟序列，它的元素会被计算，因为访问这些元素时不需要绑定将它们存储在任何地方。

### 函数输出迭代器

函数输出迭代器将一元函数应用于分配给它们的每个元素。 您可以使用`boost::make_function_output_iterator`函数模板创建函数输出迭代器，并将其传递给一个一元函数对象。 然后，您可以使用`std::copy`或类似的算法将序列中的元素分配给函数输出迭代器。 函数输出迭代器只对分配给它的每个元素调用函数。 您可以将任何逻辑封装在您提供的 Function 对象中，将它们用引号括起来打印，将它们添加到另一个容器中，保持已处理元素的计数，等等。

在下面的示例中，我们有一个目录名列表，并使用`boost::function_output_iterator`将它们连接在一起，用空格分隔，确保将任何带有嵌入空格的字符串引起来：

**清单 5.25：使用函数输出迭代器**

```cpp
 1 #include <iostream>
 2 #include <string>
 3 #include <vector>
 4 #include <algorithm>
 5 #include <boost/assign.hpp>
 6 #include <boost/function_output_iterator.hpp>
 7
 8 struct StringCat
 9 {
10   StringCat(std::string& str) : result_(str) {}
11
12   void operator()(const std::string& arg) {
13     if (arg.find_first_of(" \t") != std::string::npos) {
14       result_ += " \"" + arg + "\"";
15     } else {
16       result_ += " " + arg;
17     }
18   }
19
20   std::string& result_;
21 };
22
23 int main()
24 {
25   std::vector<std::string> dirs{"photos", "videos",
26                             "books", "personal docs"};
27 
28   std::string dirString = "";
29   std::copy(dirs.begin(), dirs.end(),
30            boost::make_function_output_iterator(
31   StringCat(dirString)));
32   std::cout << dirString << '\n';
33 }
```

我们定义了一个函数器`StringCat`，它在名为`result_`的成员中存储对传递给其构造函数(第 12 行)的`std::string`的非常数引用。 它定义了一个一元`operator()`，它接受单个字符串参数并将其附加到`result_`。 如果传递的字符串中嵌入了个空格或制表符，则会加引号并附加一个前导空格(第 14 行)。 否则，它将附加一个不带引号的前导空格(第 16 行)。

我们有一个名为`dirs`的目录名列表(第 25-27 行)，我们希望将它们附加到此方案之后的名为`dirString`的字符串(第 28 行)。 为此，我们创建`StringCat`的一个实例，向其传递对`dirString`的引用(第 31 行)，并将其传递给`boost:: make_function_output_iterator`，后者返回一个输出迭代器(第 30 行)。 我们使用`std::copy`将元素从`dirs`复制到返回的输出迭代器中，其效果是通过重复调用`StringCat`函数来连接字符串。 当`std::copy`返回时，`dirString`包含以下内容：

```cpp
photos videos books "personal docs"
```

您可以看到，`personal docs`，这是单个目录的名称，被适当地引了起来。

除了上面列出的迭代器适配器之外，还有其他我们在这里没有介绍的迭代器适配器，包括`boost::indirect_iterator`、`boost::function_input_iterator`、`boost::zip_iterator`、`boost::counting_iterator`和`boost::permutation_iterator`。 使用 Boost 网站上的文档熟悉它们的使用模式，并探索如何在您自己的代码中使用它们。

迭代器适配器提供了一组来自函数式编程语言和库(如 Python 的**itertools**)的常用习惯用法。 当您的 API 接受一对迭代器，但没有通过函数器或谓词过滤或调整元素的选项时，迭代器适配器特别有用。 迭代器适配器支持的大部分功能也可以通过使用更现代的 Boost Range 适配器来实现，可能只需要较少的冗长语法。 但是，如果您的 API 需要迭代器而不是范围，那么这些迭代器适配器将非常方便。

## 为自定义类创建符合要求的迭代器

除了提供个迭代器适配器模板外，Boost.Iterator 库还提供了创建符合规范的迭代器的框架。 在本节中，我们将使用 Boost.Iterator 库为线程化二叉搜索树创建符合要求的迭代器。 二叉搜索树是一种抽象数据类型，将元素存储在树结构中。 粗略地说，树中的每个节点都有零个、一个或两个子节点。 节点的左子树中的所有元素都小于该节点，而节点的右子树中的所有元素都大于该节点。 具有零子节点的节点称为叶。 线程二叉搜索树被优化为以排序顺序遍历其元素，即所谓的**顺序遍历**。

我们实现了一个线程化二叉搜索树的天真版本，在该树中，我们将维护指向每个节点中节点的前辈和后继者的指针。 然后，我们将提供一个双向迭代器接口，该接口将允许按照树元素的顺序向前和向后遍历树。

**清单 5.26：天真的线程化二叉搜索树**

```cpp
  1 #include <iostream>
  2 #include <algorithm>
  3 #include <vector>
  4 #include <boost/assign.hpp>
 5 #include <boost/iterator.hpp>
 6 #include <boost/iterator/iterator_facade.hpp>
  7
  8 template<typename T>
  9 struct TreeNode
 10 {
 11   T data;
 12   TreeNode<T> *left, *right;
 13   TreeNode<T> *prev, *next;
 14
 15   TreeNode(const T& elem) : data(elem),
 16          left(nullptr), right(nullptr),
 17          prev(nullptr), next(nullptr)
 18   {}
 19
 20   ~TreeNode()
 21   {
 22     delete left;
 23     delete right;
 24   }
 25 };
 26
 27 template<typename T>
 28 class BSTIterator :
 29   public boost::iterator_facade <BSTIterator<T>, T,
 30                   boost::bidirectional_traversal_tag>
 31 {
 32 public:
 33   BSTIterator() : node_ptr(nullptr) {}
 34   explicit BSTIterator(TreeNode<T> *node) :
 35      node_ptr(node) {}
 36   BSTIterator(const BSTIterator<T>& that) :
 37      node_ptr(that.node_ptr) {}
 38
 39 private:
 40   TreeNode<T> *node_ptr;
 41
 42   friend class boost::iterator_core_access;
 43
 44   void increment() { node_ptr = node_ptr->next; }
 45   void decrement() { node_ptr = node_ptr->prev; }
 46
 47   bool equal(const BSTIterator<T>& that) const {
 48     return node_ptr == that.node_ptr;
 49   }
 50
 51   T& dereference() const { return node_ptr->data; }
 52 };
 53
 54 template<typename T>
 55 class BinarySearchTree
 56 {
 57 public:
 58   BinarySearchTree() : root(nullptr), first(nullptr),
 59                        last(nullptr) {}
 60   ~BinarySearchTree() {
 61     delete root;
 62     delete last;
 63   }
 64
 65   void insert(const T& elem) {
 66     if (!root) {
 67       root = new TreeNode<T>(elem);
 68       first = root;
 69       last = new TreeNode<T>(T());
 70       first->next = last;
 71       last->prev = first;
 72     } else {
 73       insert(elem, root);
 74     }
 75   }
 76
 77   BSTIterator<T>begin() { return BSTIterator<T>(first); }
 78   BSTIterator<T>end() { return BSTIterator<T>(last); }
 79
 80   BSTIterator<T>begin() const {
 81     return BSTIterator<const T>(first);
 82   }
 83   BSTIterator<T>end() const {
 84     return BSTIterator<const T>(last);
 85   }
 86
 87 private:
 88   TreeNode<T> *root;
 89   TreeNode<T> *first;
 90   TreeNode<T> *last;
 91
 92   void insert(const T& elem, TreeNode<T> *node) {
 93     if (elem < node->data) {
 94       if (node->left) {
 95         insert(elem, node->left);
 96       } else {
 97         node->left = new TreeNode<T>(elem);
 98         node->left->prev = node->prev;
 99         node->prev = node->left;
100         node->left->next = node;
101
102         if (!node->left->prev) {
103           first = node->left;
104         } else {
105           node->left->prev->next = node->left;
106         }
107       }
108     } else if (node->data < elem) {
109       if (node->right) {
110         insert(elem, node->right);
111       } else {
112         node->right = new TreeNode<T>(elem);
113         node->right->next = node->next;
114         node->next = node->right;
115         node->right->prev = node;
116
117         if (node->right->next) {
118           node->right->next->prev = node->right;
119         }
120       }
121     }
122   }
123 };
```

我们可以在以下代码中使用`BinarySearchTree`模板：

```cpp
125 int main() 
126 {
127   BinarySearchTree<std::string> bst;
128   bst.insert("abc");
129   bst.insert("def");
130   bst.insert("xyz");
131
132   for(auto& x: bst) {
133     std::cout << x << '\n';
134   }
135 }
```

此示例帮助我们说明了使用 Boost Iterator 框架为不太普通的数据结构创建自定义迭代器的技术。 线程树实现被故意简化以帮助理解。 `TreeNode<T>`表示包含参数化类型`T`的值的树中的每个节点。 `BinarySearchTree<T>`表示支持顺序遍历的二叉搜索树。 它存储了三个类型`TreeNode<T>`的指针：树根、指向最小元素的指针`first`和表示遍历结束的前哨指针`last`(第 68-70 行)。 最后，`BSTIterator<T>`表示到`BinarySearchTree<T>`的双向迭代器的类型，该迭代器允许在两个方向上按顺序遍历树的元素。

`TreeNode<T>`存储两个指向其`left`和`right`子对象的指针，以及另外两个指向其前面(`prev`)和后面(`next`)的节点的指针，按照它们存储的值的顺序(第 12-13 行)。 新节点总是作为叶节点插入，并且新节点的`prev`和`next`指针以及按遍历顺序在其前面和后面的指针被适当地重新调整。 使用`insert`public 方法将新元素插入到树中，插入的实际逻辑在`insert`方法的私有重载中(第 72-102 行)。`BinarySearchTree`的`begin`和`end`方法将迭代器返回到树中的第一个元素和另一个节点，标志着遍历的结束。

`BSTIterator`模板是我们最感兴趣的迭代器实现，它派生自`boost::iterator_facade`的专门化(第 29-30 行)。 专门化有三个参数：`BSTIterator<T>`本身、类型参数`T`和一个标记`boost::bidirectional_traversal_tag`来标识迭代器支持的遍历类型(在本例中是双向的)。 以派生类为参数的基模板是一个众所周知的 C++ 习惯用法，称为**，奇怪地重复出现模板参数**，用于实现虚方法调用的效果，而不会产生运行时成本。 现在我们定义一组成员来完成实现。

`BSTIterator`模板保留指向树中节点的`TreeNode<T>`指针(第 40 行)。 这是使用默认构造函数和接受节点指针的构造函数进行初始化的(第 33-35 行)。 此外，重要的是，我们必须使`BSTIterator`可复制(第 36-37 行)。 我们定义了一组私有成员函数，Boost Iterator 框架可以访问它们。 框架代码通过名为`boost::iterator_core_access`的类访问这些函数，因此将其定义为`friend`类(第 42 行)。 当我们使用`operator++ `或`operator--`递增或递减迭代器时，会调用函数`increment`(第 44 行)和`decrement`(第 45 行)。 它们将内部节点指针更改为指向遍历顺序中的下一个或上一个节点(按顺序)。 当我们使用`operator*`取消对迭代器的引用时，会调用函数`dereference`。 它返回对每个节点中存储的数据元素的引用(第 51 行)。 `equal`方法用于检查两个迭代器是否相等。 例如，当您使用如下代码检查迭代器是否已到达容器中值序列的末尾时，将调用此函数：

```cpp
if (it == container.end())
```

这就是我们定义全功能迭代器所需做的全部工作。 容器内还有一项额外的工作需要完成。 我们定义了返回容器中的值序列的开始和结束的`begin`和`end`方法(第 77-78 行)。 这些指针`first`(第 89 行)和`last`(第 90 行)作为附加成员保留，并由`BinarySearchTree`模板适当更新。 每次将新的最小元素插入容器中时，更新指针`first`。 指针`last`表示前向遍历永远不能继续的前哨，它最初被创建并且从未被更新(第 69 行)。 每次向树中添加一个新的最大元素时，其`next`指针指向`last`。 提供了`begin`和`end`成员函数的常量版本(第 80-85 行)，以确保在常量容器上调用它们会产生不可变的迭代器。 遵循基本上相同的模式，您可以为您的容器推出自己的迭代器，这些迭代器符合标准库的迭代器概念。 通过这样的迭代器接口，可以在您的自定义容器上使用许多标准库算法。 Boost Iterator 框架提供的抽象使得迭代器的简明实现(第 27-51 行)成为可能。

# 自测题

对于多项选择题，请选择适用的所有选项：

1.  Which of the following are true for flat associative containers compared to ordered/unordered associative containers?

    A.需要更少的内存

    B.插入速度更快

    C.遍历速度较慢

    D.查找速度更快

2.  The `std::forward_list` does not provide a `size()` member function because:

    A.单链表不支持线性时间大小成员

    B.拼接和尺寸成员不能都是恒定时间

    C.这将是线程不安全的

    D.以上所有事项

3.  Where is the internal memory of a `static_vector` allocated:

    A.堆栈

    B.取决于静态向量的创建位置

    C.免费商店

    D.取决于使用的分配器

4.  In order to store objects of type X in an unordered container, which of the following must be defined/available for objects of type X?

    A.排序关系

    B.哈希函数

    C.平等比较

    D.复制构造函数

5.  Which data structure allows random access to its elements and supports iterators that are not invalidated upon insertion and erase of other elements?

    A.°T0_

    B.`unordered_map`

    C. 089

    D.`circular_buffer`

# 摘要

本章介绍了大量的 Boost 库，这些库提供了不同类型的容器，或者使使用它们变得更容易。 我们查看了扩展 Standard Library 容器的几个有用的非标准容器，查看了设计用于存储动态分配的对象指针的容器，了解了将元素分配给容器的一些表达方式，了解了基于散列的无序容器，并了解了迭代集合和启用自定义集合迭代的不同模式。

在下一章中，我们将继续研究 Boost 中的容器库，重点介绍支持基于多标准高效查找对象的专用容器。

# 发文：2013 年 2 月 10 日星期日下午 12：00

避免容器中的空指针(如果可能)：[http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible](http://www.boost.org/doc/libs/1_57_0/libs/ptr_container/doc/guidelines.html#avoid-null-pointers-in-containers-if-possible)