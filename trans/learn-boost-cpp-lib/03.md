# 第三章内存管理和异常安全

C++ 与 C 编程语言有很大的兼容性。 C++ 保留表示和访问特定内存地址的指针，并通过`new`和`delete`操作符提供手动内存管理原语。 您还可以从 C++、C 标准库函数和 C 系统调用或大多数主要操作系统的平台 API 无缝访问。 自然，C++ 代码经常处理*句柄*到各种操作系统资源，如堆内存、打开文件、套接字、线程和共享内存。 获取这些资源并不释放它们可能会给您的程序带来不良后果，表现为潜在的错误，包括内存泄漏和死锁。

在本章中，我们将介绍使用**智能指针**封装指向动态分配的对象的指针的方法，以确保在不再需要它们时自动释放它们。 然后，我们将这些技术扩展到非内存资源。 在这个过程中，我们理解了什么是异常安全代码，并使用智能指针来编写这样的代码。

这些主题分为以下几个部分：

*   动态内存分配和异常安全
*   智能指针
*   唯一所有权语义
*   共享所有权语义

对于本章的某些部分，您需要访问支持 C++ 11 的编译器。 这将在单独的章节中通过附加说明进行说明。

# 动态内存分配和异常安全

想象一下，您必须编写一个程序来旋转图像。 您的程序将文件名和旋转角度作为输入，读取文件内容、执行处理并返回输出。 以下是一些示例代码。

```
 1 #include <istream>
 2 #include <fstream>
 3 typedef unsigned char byte;
 4 
 5 byte *rotateImage(std::string imgFile, double angle, 
 6                   size_t& sz) {
 7   // open the file for reading
 8   std::ifstream imgStrm(imgFile.c_str(), std::ios::binary);
 9 
10   if (imgStrm) {
11     // determine file size
12     imgStrm.seekg(0, std::ios::end);
13     sz = imgStrm.tellg();
14     imsStrm.seekg(0);        // seek back to start of stream
15
16     byte *img = new byte[sz]; // allocate buffer and read
17     // read the image contents
18     imgStrm.read(reinterpret_cast<char*>(img), sz);
19     // process it
20     byte *rotated = img_rotate(img, sz, angle);
21     // deallocate buffer
22     delete [] img;
23 
24     return rotated;
25   }
26 
27   sz = 0;
28   return 0;
29 }
```

旋转图像的实际工作是由一个虚构的名为`img_rotate`的 C++ API 完成的(第 20 行)。 `img_rotate`函数接受三个参数：作为字节数组的图像内容、非常数引用中数组的大小和旋转角度。 它将旋转图像的内容作为动态分配的字节数组返回。 此数组的大小通过作为第三个参数传递的引用返回。 这是一个不完美的代码，更让人想起 C 代码。像这样的代码在“野外”非常普遍，这就是为什么知道它的缺陷是很重要的。 那么，让我们来剖析一下这个问题。

为了读取图像文件的内容，我们首先确定文件的大小(第 12-13 行)，然后分配一个字节数组`img`，其大小刚好足以容纳文件中的全部数据(第 16 行)。 我们读取图像内容(第 18 行)，并在通过调用`img_rotate`执行图像旋转之后，删除包含原始图像的缓冲区`img`(第 22 行)。 最后，我们返回包含旋转图像的字节数组(第 24 行)。 为简单起见，我们不检查读取错误(第 18 行)。

在前面的代码中有两个突出的问题。 如果图像的旋转失败(第 19 行)并且`img_rotate`抛出异常，则函数`rotateImage`将返回而不释放字节缓冲区`img`，因此字节缓冲区*将被*泄漏*。 这是一个明确的代码在异常面前表现不佳的例子，也就是说，它不是*异常安全的*。 此外，即使一切正常，函数也会返回旋转后的缓冲区(第 24 行)，该缓冲区本身是动态分配的。 因此，我们将其释放完全由调用者决定，没有任何保证。 我们应该做得更好。*

还有第三个不那么明显的问题。 `img_rotate`函数应该记录了它是如何分配内存的，以便我们知道如何释放它-通过调用数组删除(`delete []`)操作符(第 22 行)。 但是，如果`img_rotate`的开发人员发现并希望在下一个版本中使用更高效的自定义内存管理方案，该怎么办呢？ 它们会避免这样做；否则，它们的所有客户端代码都会崩溃，因为`delete []`操作符可能不再是释放内存的正确方式。 理想情况下，这是`img_rotate`API 的客户端永远不必操心的一个细节。

## 异常安全性和可靠性

在前面的示例中，我们非正式地介绍了异常安全的概念。 我们看到，从`img_rotate`API 抛出的潜在异常可能会泄漏`rotateImage`函数中的资源。 事实证明，您可以根据一组称为**亚伯拉罕异常安全保证**的标准来推断代码在面对异常时的行为。 它们是以 Dave Abrahams 的名字命名的，Dave Abrahams 是 Boost 的联合创始人，也是著名的 C++ 标准委员会成员，他在 1996 年正式确定了这些保证。 自那以后，其他人(包括赫布·萨特(Herb Sutter))对它们进行了进一步的改进，并列出了以下内容：

*   **基本保证**：中途终止的操作保留不变量，不会泄漏资源
*   **强保证**：中途终止的操作不会有任何影响，即操作是原子的
*   **防抛保证**：不能失败的操作

不满足这些标准中的任何一个的操作被称为“非异常安全”，或者更通俗地说，是异常不安全。 操作的适当异常安全级别是程序员的特权，但异常不安全的代码很少被接受。

使代码异常安全的最基本、最有效的 C++ 技术有个奇怪的名字：**资源获取是 Initialization**(**RAII**)。 RAII 习惯用法提出以下模型来封装需要手动管理的资源：

1.  将资源获取封装在包装对象的构造函数中。
2.  将资源释放封装在包装对象的析构函数中。
3.  此外，为包装器对象定义一致的复制和移动语义或禁用它们。

如果包装器对象是在堆栈上创建的，则它的析构函数将被调用，用于正常作用域退出以及由于异常而退出。 否则，包装器对象本身应该由 RAII 习惯用法管理。 简单地说，您可以在堆栈上创建对象，也可以使用 RAII 管理它们。 现在，一些示例已经准备就绪，我们可以直接返回到图像旋转示例，并使用 raii 进行修复：

```
 1 struct ScopeGuard
 2 {
 3   ScopeGuard(byte *buffer) : data_(buffer) {}
 4   ~ScopeGuard() { delete [] data_; }
 5
 6   byte *get() { return data_; }
 7 private:
 8   byte *data_;
 9 };
10 
11 byte *rotateImage(std::string imgFile, double angle, size_t& sz)
12 {
13   // open the file for reading
14   std::ifstream imgStrm(imgFile.c_str(), std::ios::binary);
15 
16   if (imgStrm) {
17     // determine file size
18     imgStrm.seekg(0, std::ios::end);
19     sz = imgStrm.tellg();
20     imgStrm.seekg(0);
21
22     // allocate buffer and read
23     ScopeGuard img(new byte[sz]);
24     // read the image contents
25     imgStrm.read(reinterpret_cast<char*>(img.get()), sz);
26     // process it
27     return img_rotate(img.get(), sz, angle);
28   } // ScopeGuard destructor
29 
30   sz = 0;
31   return 0;
32 }
```

如果`img_rotate`函数本身是异常安全的，则前面的代码是使`rotateImage`函数异常安全的一次适度尝试。 首先，我们定义一个名为`ScopeGuard`(第 1-9 行)的`struct`，用于封装由数组`new operator`分配的字符数组。 它将指向已分配数组的指针作为其构造函数参数，并将数据成员`data_`设置为该指针(第 3 行)。 它的析构函数使用 ARRAY`delete`操作符(第 4 行)释放其`data_`成员指向的数组。 `get`成员函数(第 6 行)提供了从`ScopeGuard`对象获取底层指针的方法。

在`rotateImage`函数内部，我们实例化一个名为`img`的`ScopeGuard`对象，包装使用 array`new`操作符分配的字节数组(第 23 行)。 我们在打开的文件流上调用`read`，并将通过调用`img`上的`get`方法获得的原始字节数组传递给它(第 25 行)。 我们假设读取总是成功的，但是在生产代码中，我们应该总是有适当的错误检查。 最后，我们调用`img_rotate`API 并返回它返回的旋转图像(第 27 行)。 当我们退出作用域时，调用`ScopeGuard`析构函数并自动释放封装的字节数组(第 28 行)。 即使`img_rotate`抛出异常，仍将调用`ScopeGuard`析构函数作为堆栈展开的一部分。 通过`ScopeGuard`类使用 raii，我们可以断言`rotateImage`函数永远不会泄漏包含图像数据的缓冲区。

另一方面，包含由`rotateImage`*返回的旋转图像的缓冲区可能会泄露*，除非调用者小心地将其分配给指针，然后以异常安全的方式适当地释放它。 当前形式的`ScopeGuard`类在那里并不好用。 事实证明，Boost 附带了不同类型的智能指针模板来解决类似的各种用例，理解这些智能指针和资源获取模式以及它们帮助解决的异常安全问题是值得的。

# 智能指针

SMART指针最终是封装对指针的访问的类，通常管理与指针相关的内存。 如果您仔细观察，就会注意到智能指针与菠萝的相似之处-智能指针是类，而不是指针，就像菠萝不是真正的苹果一样。 除了水果的类比之外，不同类型的智能指针通常还具有边界检查、空检查和访问控制等附加功能。 在 C++ 中，智能指针通常会重载取消引用运算符(`operator->`)，这允许使用`operator->`在智能指针上调用的任何方法调用都绑定到底层指针。

Boost 包括一组具有不同语义的四个不同的智能指针。 此外，由于 C++ 经常使用指针来标识和操作对象数组，Boost 提供了两种不同的智能数组模板，它们通过指针封装数组访问。 在接下来的几节中，我们将研究 Boost 中的不同类型的智能指针及其语义。 我们还将介绍`std::unique_ptr`，这是一个 C++ 11 智能指针类，它取代了 Boost 智能指针之一，并支持 Boost 无法提供的语义。

## 独特的所有权语义

请考虑下面的代码片段，该代码片段用于实例化一个对象并对其调用一个方法：

```
 1 class Widget;
 2 
 3 // …
 4 
 5 void useWidget()
 6 {
 7   Widget *wgt = new Widget;
 8   wgt->setTitle(...);
 9   wgt->setSize(...);
10   wgt->display(...);
11   delete wgt;
12 }
```

正如我们在上一节中看到的，前面的代码不是异常安全的。 在动态内存上构造`Widget`对象之后(第 7 行)、销毁`Widget`对象之前(第 11 行)的操作引发的异常可能会导致`Widget`对象的动态分配内存泄漏。 要解决这个问题，我们需要一些类似于我们在上一节中编写的`ScopeGuard`类的内容，并且 Boost 需要使用`boost::scoped_ptr`模板。

### Boost：：Scope_Ptr

下面是前面使用`scoped_ptr`修复的示例中的。 可以从头文件`boost/scoped_ptr.hpp`中获得`scoped_ptr`模板。 它是一个仅包含头文件的库，您不需要将您的程序链接到任何其他库：

**清单 3.1：使用 SCOPED_PTR**

```
 1 #include <boost/scoped_ptr.hpp>
 2 #include "Widget.h"  // contains the definition of Widget
 3 
 4 // …
 5 
 6 void useWidget()
 7 {
 8   boost::scoped_ptr<Widget> wgt(new Widget);
 9   wgt->setTitle(...);
10   wgt->setSize(...);
11   wgt->display(...);
12 }
```

在前面的代码中，`wgt`是`scoped_ptr<Widget>`类型的对象，它是`Widget*`指针的替代对象。 我们使用动态分配的`Widget`对象对其进行初始化(第 8 行)，并删除对`delete`的调用。 这是使此代码异常安全所需的仅有的两个更改。

Smart指针，如`scoped_ptr`和Boost 中的其他指针，负责在其析构函数中的封装指针上调用`delete`。 当`useWidget`完成或异常中途终止时，将调用`scoped_ptr`实例`wgt`的析构函数，并销毁`Widget`对象并释放其内存。 `scoped_ptr`中的重载取消引用运算符(`operator->`)允许通过`wgt`智能指针访问`Widget`成员(第 9-11 行)。

`boost::scoped_ptr`模板的析构函数使用`boost::checked_delete`释放封装指针所指向的动态分配的内存。 因此，封装指针指向的对象类型必须在`boost::scoped_ptr`实例超出作用域时完全定义；否则，代码将无法编译。

`boost::scoped_ptr`是 Boost 智能指针中最简单的。 它取得传递的动态分配指针的所有权，并在其自己的析构函数中调用`delete`。 这将底层对象的生命周期绑定到封装`scoped_ptr`操作的作用域-因此命名为`scoped_ptr`。 本质上，它在封装的指针上实现 RAII。 此外，不能复制`scoped_ptr`。 这意味着在任何给定的时间点，动态分配的对象只能由一个`scoped_ptr`实例包装。 因此，`scoped_ptr`被认为展现了*唯一的所有权语义*。 请注意，`scoped_ptr`实例不能存储在标准库容器中，因为它们既不能从 C++ 11 意义上复制，也不能从其中移动。

在下面的示例中，我们将探索`scoped_ptr`的更多功能：

**清单 3.2：详细的 SCOPED_PTR**

```
 1 #include <boost/scoped_ptr.hpp>
 2 #include <cassert>
 3 #include "Widget.h" // Widget definition
 4 // …
 5 
 6 void useTwoWidgets()
 7 {
 8   // default constructed scoped_ptr 
 9   boost::scoped_ptr<Widget> wgt;
10   assert(!wgt);          // null test - Boolean context
11 
12   wgt.reset(new Widget); // create first widget
13   assert(wgt);          // non-null test – Boolean context
14   wgt->display();        // display first widget
15   wgt.reset(new Widget); // destroy first, create second widget
16   wgt->display();        // display second widget
17   
18   Widget *w1 = wgt.get();  // get the raw pointer
19   Widget& rw1 = *wgt;      // 'dereference' the smart pointer
20   assert(w1 == &rw1);      // same object, so same address
21
22   boost::scoped_ptr<Widget> wgt2(new Widget);
23   Widget *w2 = wgt2.get();
24   wgt.swap(wgt2);
25   assert(wgt.get() == w2);  // effect of swap
26   assert(wgt2.get() == w1); // effect of swap
27 }
```

在本例中，我们首先使用`scoped_ptr<Widget>`类型的默认构造函数构造一个对象(第 9 行)。 这将创建一个包含空指针的`scoped_ptr`。 任何取消引用此类智能指针的尝试都将导致未定义的行为，通常会导致崩溃。 `scoped_ptr`支持隐式转换为布尔值；因此我们可以在布尔上下文中使用类似`wgt`的`scoped_ptr`对象来检查封装的指针是否为空。 在本例中，我们知道它应该为 NULL，因为它是缺省构造的；因此，我们断言`wgt`为 NULL(第 10 行)。

有两种方法可以更改`scoped_ptr`中包含的指针，其中一种是使用`scoped_ptr`的`reset`成员方法。 当我们在`scoped_ptr`上调用`reset`时，封装的指针被释放，`scoped_ptr`取而代之的是新传递的指针的所有权。 因此，我们可以使用`reset`更改`scoped_ptr`实例拥有的指针(第 12 行)。 接着，`scoped_ptr`包含一个非空指针，我们使用隐式将`scoped_ptr`转换为布尔值的功能来断言同样多的值(第 13 行)。 接下来，我们再次调用`reset`在`wgt`中存储一个新指针(第 15 行)。 在这种情况下，将释放较早存储的指针，并在存储新指针之前销毁底层对象。

通过调用`scoped_ptr`的`get`成员函数(第 18 行)，我们可以在底层指针处获得。 我们还可以通过取消对智能指针的引用来获得对智能指针指向的对象的引用(第 19 行)。 我们断言这个引用和`get`返回的指针都指向同一个对象(第 20 行)。

当然，还有第二种方法可以更改包含在`scoped_ptr`中的指针。 通过交换两个`scoped_ptr`对象，可以交换它们封装的指针(第 24-26 行)。 这是更改动态分配对象的所有权`scoped_ptr`的唯一方法。

总之，我们可以说，一旦将对象包装在`scoped_ptr`中，它就永远不能从`scoped_ptr`中分离。 `scoped_ptr`可以销毁该对象并采用一个新对象(使用`reset`成员函数)，或者它可以将其指针与另一个`scoped_ptr`中的指针交换。 从这个意义上说，`scoped_ptr`表现出独特的、可转移的所有权语义。

#### SCOPED_PTR 的用法

`scoped_ptr`是一个轻量级、多功能的智能指针，不仅能充当作用域保护。 下面我们来看看如何在代码中使用它。

##### 创建异常安全作用域

当对象在某个作用域中动态分配时，`scoped_ptr`在创建异常安全作用域时非常有用。 C++ 允许在堆栈上创建对象，通常这是创建对象而不是动态分配对象的方法。 但是，在某些情况下，您需要通过调用返回指向动态分配对象的指针的工厂函数来实例化对象。 这可能来自一些遗留的库，`scoped_ptr`可能是这类指针的方便包装器。 在下面的示例中，`makeWidget`是一个这样的工厂函数，它返回动态分配的`Widget`：

```
 1 class Widget { ... };
 2
 3 Widget *makeWidget() // Legacy function
 4 {
 5   return new Widget;
 6 }
 7 
 8 void useWidget()
 9 {
10   boost::scoped_ptr<Widget> wgt(makeWidget());
11   wgt->display();              // widget displayed
12 }   // Widget destroyed on scope exit
```

通常，如果从`useWidget`内部调用的函数`makeWidget`也是异常安全的，则前面形式的`useWidget`将是异常安全的。

##### 跨函数转移对象所有权

作为不可复制对象，`scoped_ptr`对象不能通过函数的值传递或返回。 可以将对`scoped_ptr`的非常数引用作为参数传递给函数，该函数将重置其内容并将一个新指针放入`scoped_ptr`对象。

**清单 3.3：使用 SCOPED_PTR**进行所有权转移

```
 1 class Widget { ... };
 2
 3 void makeNewWidget(boost::scoped_ptr<Widget>& result)
 4 {
 5   result.reset(new Widget);
 6   result->setProperties(...);
 7 }
 8 
 9 void makeAndUseWidget()
10 {
11   boost::scoped_ptr<Widget> wgt; // null wgt
12   makeNewWidget(wgt);         // wgt set to some Widget object.
13   wgt->display();              // widget #1 displayed
14 
15   makeNewWidget(wgt);        // wgt reset to some other Widget.
16                              // Older wgt released.
17   wgt->display();            // widget #2 displayed
18 }
```

`makeNewWidget`函数使用传递给它的`scoped_ptr<Widget>`引用作为输出参数，使用它返回动态分配的对象(第 5 行)。 每次调用`makeNewWidget`(第 12，15 行)都会用动态分配的新`Widget`对象替换其先前的内容，并删除先前的对象。 这是将函数内动态分配的对象的所有权转移到函数外部作用域的一种方法。 它并不经常使用，在 C++ 11 中使用`std::unique_ptr`实现相同的效果还有更多惯用的方法，下一节将对此进行讨论。

##### 作为班级成员

在 Boost 的智能指针中，`scoped_ptr`通常只用作函数中的局部作用域保护，而实际上，作为类成员，它也可以是确保异常安全的有用工具。

考虑以下代码，其中类`DatabaseHandler`创建了两个虚构类型`FileLogger`和`DBConnection`的动态分配对象，用于记录到文件和连接到数据库。 `FileLogger`和`DBConnection`以及它们的构造函数参数都是用于说明目的的虚构类。

```
// DatabaseHandler.h
 1 #ifndef DATABASEHANDLER_H
 2 #define DATABASEHANDLER_H
 3
 4 class FileLogger;
 5 class DBConnection;
 6
 7 class DatabaseHandler
 8 {
 9 public:
10   DatabaseHandler();
11   ~DatabaseHandler();
12   // other methods here
13
14 private:
15   FileLogger *logger_;
16   DBConnection *dbconn_;
17 };
18
19 #endif /* DATABASEHANDLER_H */
```

前面的代码是头文件`DatabaseHandler.h`中`DatabaseHandler`类定义的清单。 `FileLogger`和`DBConnection`是仅向前声明的不完整类型。 我们只声明指向它们的指针，由于指针的大小不依赖于底层类型的大小，因此编译器不需要知道`FileHandler`和`DBConnection`的定义就可以根据其指针组成来确定`DatabaseHandler`类的总大小。

设计这样的类有一个好处。 `DatabaseHandler`的客户端包括前面列出的`DatabaseHandler.h`文件，但不依赖于`FileLogger`或`DBConnection`的实际定义。 如果它们的定义更改，客户端将保持不受影响，不需要重新编译。 从本质上讲，这是 Herb Sutter 作为**Pimpl 成语**推广的成语。 类的实际实现抽象在一个单独的源文件中：

```
// DatabaseHandler.cpp
 1 #include "DatabaseHandler.h"
 2 
 3 // Dummy concrete implementations
 4 class FileLogger
 5 {
 6 public:
 7   FileLogger(const std::string& logfile) {...}
 8 private:
 9   ...
10 };
11
12 class DBConnection
13 {
14 public:
15   DBConnection(const std::string& dbhost,
16                const std::string& username,
17                const std::string& passwd) {...}
18 private:
19   ...
20 };
21
22 // class methods implementation
23 DatabaseHandler::DatabaseHandler(const std::string& logFile,
24           const std::string& dbHost,
25           const std::string& user, const std::string& passwd)
26         : logger_(new FileLogger(logFile)), 
27           dbconn_(new DBConnection(dbHost, user, passwd))
28 {}
29
30 ~DatabaseHandler()
31 {
32   delete logger_;
33   delete dbconn_;
34 }
35 
36 // Other methods
```

在这个源文件中，我们可以访问`FileLogger`和`DBConnection`的具体定义。 即使这些定义和我们实现的其他部分改变了，只要`DatabaseHandler`的公共方法和类布局不改变，`DatabaseHandler`的客户端就不需要改变或重新编译。

但此代码非常脆弱，可能会泄漏内存和其他资源。 考虑一下如果`FileLogger`构造函数抛出异常(第 26 行)会发生什么。 分配给`logger_`指针的内存会自动释放，不会造成进一步的损坏。 异常从`DatabaseHandler`构造函数传播到调用上下文，并且没有实例化`DatabaseHandler`的对象；到目前为止一切正常。

现在考虑是否成功构造了`FileLogger`对象，然后`DBConnection`构造函数抛出了一个异常(第 27 行)。 在这种情况下，一旦出现异常，分配给`dbconn_`指针的内存将自动释放，但不会释放分配给`logger_`指针的内存。 当发生异常时，将调用非 POD 类型的任何完全构造成员的析构函数。 但是`logger_`是一个原始指针，它是 POD 类型的，因此它没有析构函数。 因此，`logger_`指向的内存被泄露。

通常，如果您的类有多个指向动态分配的对象的指针，那么确保异常安全就成了一个挑战，而且大多数使用 try/catch 块的过程性解决方案的伸缩性都很差。 智能指针是用极少的可伸缩代码来解决这类问题的完美元素。 我们使用下面的`scoped_ptr`修复前面的示例。 以下是头文件：

**清单 3.4：使用 SCOPED_PTR 作为类成员**

```
// DatabaseHandler.h
 1 #ifndef DATABASEHANDLER_H
 2 #define DATABASEHANDLER_H
 3
 4 #include <boost/scoped_ptr.hpp>
 5
 6 class FileLogger;
 7 class DBConnection;
 8
 9 class DatabaseHandler
10 {
11 public:
12   DatabaseHandler(const std::string& logFile,
13        const std::string& dbHost, const std::string& user,
14        const std::string& passwd);
15   ~DatabaseHandler();
16   // other methods here
17
18 private:
19   boost::scoped_ptr<FileLogger> logger_;
20   boost::scoped_ptr<DBConnection> dbconn_;
21 
22   DatabaseHandler(const DatabaseHandler&);
23   DatabaseHandler& operator=(const DatabaseHandler&);
24 };
25 #endif /* DATABASEHANDLER_H */
```

现在，`logger_`和`dbconn_`是`scoped_ptr`实例，而不是原始指针(第 19 和 20 行)。 在的反面，`scoped_ptr`是不可复制的，编译器不能生成默认的复制构造函数和复制赋值运算符。 我们可以像我们在这里所做的那样禁用它们(第 22 和 23 行)，也可以自己定义它们。 通常，定义`scoped_ptr`的复制语义只有在封装的类型是可复制的情况下才有意义。 另一方面，使用`scoped_ptr`的`swap`成员函数可能更容易定义移动语义。 现在让我们看一下源文件的更改：

```
// DatabaseHandler.cpp
 1 #include "DatabaseHandler.h"
 2 
 3 // Dummy concrete implementations
 4 class FileLogger
 5 {
 6 public:
 7   FileLogger(const std::string& logfile) {...}
 8 private:
 9   ...
10 };
11
12 class DBConnection
13 {
14 public:
15   DBConnection(const std::string& dbhost,
16                const std::string& username,
17                const std::string& passwd) {...}
18 private:
19   ...
20 };
21
22 // class methods implementation
23 DatabaseHandler::DatabaseHandler(const std::string& logFile,
24             const std::string& dbHost, const std::string& user,
25             const std::string& passwd)
26         : logger_(new FileLogger(logFileName)),
27           dbconn_(new DBConnection(dbsys, user, passwd))
28 {}
29
30 ~DatabaseHandler()
31 {}
32 
33 // Other methods
```

我们初始化构造函数初始化列表中的两个`scoped_ptr`实例(第 26 和 27 行)。 如果`DBConnection`构造函数抛出(第 27 行)，则调用`logger_`的析构函数(即`scoped_ptr`)，并干净地释放它封装的动态分配的`FileLogger`对象。

`DatabaseHandler`析构函数为空(第 31 行)，因为没有 POD 类型的成员，并且会自动调用`scoped_ptr`成员的析构函数。 但我们还是要定义析构函数。 你能猜到为什么吗？ 如果我们让编译器来生成定义，它就会在头文件的类定义范围内生成析构函数定义。 在该作用域中，`FileLogger`和`DBConnection`没有完全定义，`scoped_ptr`析构函数将无法编译，因为它们使用的是`boost::checked_delete`([第 2 章](02.html "Chapter 2. The First Brush with Boost's Utilities")，*The First Brush with Boost‘s Utilities*)

### Boost：：Scope_Array

`scoped_ptr`类模板非常适合单个动态分配的对象。 现在，如果您还记得我们编写图像旋转实用程序的鼓舞人心的示例，我们需要在自定义的`ScopeGuard`类中包装一个动态数组，以确保`rotateImage`函数的异常安全。 Boost 提供了`boost::scoped_array`模板作为`boost::scoped_ptr`的数组模拟。 `boost::scoped_array`的语义与`boost::scoped_ptr`的语义相同，不同之处在于它有一个重载的下标操作符(`operator[]`)来访问包装数组的各个元素，并且没有为其他形式的间接(`operator*`和`operator->`)提供重载操作符。 在这一点上，使用`scoped_array`重写`rotateImage`函数是有指导意义的。

**清单 3.5：使用作用域 _ 数组**

```
 1 #include <boost/scoped_array.hpp>
 2
 3 typedef unsigned char byte;
 4
 5 byte *rotateImage(const std::string &imgFile, double angle, 
 6                   size_t& sz) {
 7   // open the file for reading
 8   std::ifstream imgStrm(imgFile, std::ios::binary);
 9 
10   if (imgStrm) {
11     imgStrm.seekg(0, std::ios::end);
12     sz = imgStrm.tellg();            // determine file size
13     imgStrm.seekg(0);
14 
15     // allocate buffer and read
16     boost::scoped_array<byte> img(new byte[sz]);
17     // read the image contents
18     imgStrm.read(reinterpret_cast<char*>(img.get()), sz);
19 
20     byte first = img[0];  // indexed access
21     return img_rotate(img.get(), sz, angle);
22   }
23 
24   sz = 0;
25   return 0;
26 }
```

现在，我们使用`boost::scoped_array`模板代替`ScopeGuard`类包装动态分配的数组(第 16 行)。 在作用域退出时，由于正常执行或异常，`scoped_array`的析构函数将调用包含的动态数组上的数组删除运算符(`delete[]`)，并以异常安全的方式释放它。 为了突出显示从`scoped_array`接口访问数组元素的能力，我们使用`scoped_array`的重载`operator[]`(第 20 行)访问第一个字节。

在处理具有大量动态数组的遗留代码时，`scoped_array`模板主要有用。 多亏了重载的下标操作符，`scoped_array`可以替代动态分配的数组。 因此，在`scoped_array`中打包动态数组是实现异常安全的快速途径。 C++ 提倡在动态数组上使用`std::vector`，这可能是您的最终目标。 然而，由于与向量相比几乎没有任何空间开销的包装器，`scoped_array`可以帮助更快地过渡到异常安全代码。

### std：：UNIQUE_PTR

C++ 11 引入了`std::unique_ptr`SMART指针模板，它取代了废弃的`std::auto_ptr`，支持`boost::scoped_ptr`和`boost::scoped_array`的功能，并且可以存储在标准库容器中。 它与 C++ 11 中引入的其他智能指针一起在标准头文件`memory`中定义。

`std::unique_ptr`的成员函数很容易映射到`boost::scoped_ptr`的成员函数：

*   默认构造的`unique_ptr`包含空指针(`nullptr`)，就像默认构造的`scoped_ptr`一样。
*   您可以调用`get`成员函数来访问包含的指针。
*   `reset`成员函数释放较旧的指针并取得新指针(可能为空)的所有权。
*   `swap`成员函数交换两个`unique_ptr`实例的内容，并且总是成功。
*   您可以使用`operator*`取消引用非空的`unique_ptr`实例，并使用`operator->`访问成员。
*   您可以使用实例在布尔上下文中检查是否为空，就像`scoped_ptr`实例一样。
*   然而，在某些事情上，`std::unique_ptr`比`boost::scoped_ptr`更多才多艺。
*   与`scoped_ptr`不同，`unique_ptr`是可移动的。 因此，它可以存储在 C++ 11 标准库容器中，并从函数返回。
*   您可以分离`std::unique_ptr`拥有的指针，并在必要时手动管理它。
*   动态分配的数组有`unique_ptr`部分专门化可用。 `scoped_ptr`不支持数组，为此您必须使用`boost::scoped_array`模板。

#### 使用 UNIQUE_PTR 进行所有权转移

`std::unique_ptr`SMART指针可以用作作用域保护，就像`boost::scoped_ptr`一样。 与`boost::scoped_ptr`类似，封装指针指向的对象类型在`unique_ptr`超出作用域时必须完全已知。 但是，与`boost::scoped_ptr`不同的是，`a unique_ptr instance`不需要绑定到单个作用域，可以从一个作用域移动到另一个作用域。

无法复制`std::unique_ptr`智能指针模板，但支持移动语义。 对移动语义的支持使得可以使用`std::unique_ptr`作为函数返回值来跨函数转移动态分配的对象的所有权。 下面就是这样一个例子：

**清单 3.6a：使用 UNIQUE_PTR**

```
// Logger.h
 1 #include <memory>
 2
 3 class Logger
 4 {
 5 public:
 6   Logger(const std::string& filename) { ... }
 7   ~Logger() {...}
 8   void log(const std::string& message, ...) { ... }
 9   // other methods
10 };
11
12 std::unique_ptr<Logger> make_logger(
13                       const std::string& filename) {
14   std::unique_ptr<Logger> logger(new Logger(filename));
15   return logger;
16 }
```

`make_logger`函数是一个工厂函数，它返回包装在`unique_ptr`中的`Logger`的新实例(第 14 行)。 函数可以这样使用`make_logger`：

**清单 3.6b：使用 UNIQUE_PTR**

```
 1 #include "Logger.h"
 2 
 3 void doLogging(const std::string& msg, ...)
 4 {
 5   std::string logfile = "/var/MyApp/log/app.log";
 6   std::unique_ptr<Logger> logger = make_logger(logfile);
 7   logger->log(msg, ...);
 8 }
```

在函数`doLogging`中，局部变量`logger`由从`make_logger`返回的`unique_ptr`移动初始化(第 6 行)。 因此，在`make_logger`内创建的`unique_ptr`实例的内容被移到变量`logger`中。 当`logger`在`doLogging`返回(第 8 行)时超出作用域时，其析构函数将销毁底层的`Logger`实例并释放其内存。

#### 在 UNIQUE_PTR 中包装数组

为了说明如何使用`unique_ptr`包装动态数组，我们将再次重写图像旋转示例(清单 3.5)，将`scoped_ptr`替换为`unique_ptr`：

**清单 3.7：使用 UNIQUE_PTR 包装数组**

```
 1 #include <memory>
 2
 3 typedef unsigned char byte;
 4
 5 byte *rotateImage(std::string imgFile, double angle, size_t& sz)
 6 {
 7   // open the file for reading
 8   std::ifstream imgStrm(imgFile, std::ios::binary);
 9 
10   if (imgStrm) {
11     imgStrm.seekg(0, std::ios::end);
12     sz = imgStrm.tellg();      // determine file size
13     imgStrm.seekg(0);
14     
15     // allocate buffer and read
16     std::unique_ptr<byte[]> img(new byte[sz]);
17     // read the image contents
18     imgStrm.read(reinterpret_cast<char*>(img.get()),sz);
19     // process it
20     byte first = img[0];  // access first byte
21     return img_rotate(img.get(), sz, angle);
22   }
23 
24   sz = 0;
25   return 0;
26 }
```

除了包含不同的头文件(`memory`代替`boost/scoped_ptr.hpp`)外，只有一行代码需要编辑。 代替`boost::scoped_array<byte>`，声明的`img`类型被更改为`std::unique_ptr<byte[]>`(第 16 行)-一个明确的临时替换。 重载的`operator[]`仅适用于`unique_ptr`的数组专门化，并用于引用数组的元素。

#### C++ 14 中的 Make_Unique

C++ 14 标准库包含一个函数模板`std::make_unique`，它是一个工厂函数，用于在动态内存上创建对象的实例并将其包装在`std::unique_ptr`中。 下面的示例是清单 3.6b 的重写，它说明了`make_unique`的用法：

**清单 3.8：使用 Make Unique**

```
 1 #include "Logger.h"  // Listing 3.6a
 2 
 3 void doLogging(const std::string& msg, ...)
 4 {
 5   std::string filename = "/var/MyApp/log/app.log";
 6   std::unique_ptr<Logger> logger = 
 7                 std::make_unique<Logger>(filename);
 8   logger->log(msg, ...);
 9 }
```

`std::make_unique`函数模板将要构造的底层对象的类型作为模板参数，并将对象构造函数的参数作为函数参数。 我们直接传递给文件名参数`make_unique`，它将其转发给`Logger`的构造函数(第 7 行)。 `make_unique`是一个可变模板；它接受数量和类型都与实例化类型的构造函数参数匹配的可变数量的参数。 如果有一个`Logger`的双参数构造函数，比如接受文件名和默认日志级别的构造函数，我们将向`make_unique`传递两个参数：

```
// two argument constructor
Logger::Logger(const std::string& filename, loglevel_t level) {
  ...
}

std::unique_ptr<Logger> logger =
 std::make_unique<Logger>(filename, DEBUG);

```

假设`loglevel_t`描述了用于表示日志级别的类型，`DEBUG`描述了该类型的有效值，前面的代码片段说明了`make_unique`与多个构造函数参数的用法。

如果您已经将代码库转移到 C++ 11，那么您应该更喜欢使用`std::unique_ptr`而不是`boost::scoped_ptr`。

## 共享所有权语义

独特的所有权语义具有转移所有权的能力，对于您使用智能指针的大多数目的来说已经足够好了。 但在一些实际应用程序中，您需要跨多个上下文共享资源，而这些上下文中的任何一个都不是明确的所有者。 只有当持有对共享资源的引用的所有上下文都释放它们时，才能释放这样的资源。 这种情况发生的时间和地点无法事先确定。

让我们用一个具体的例子来理解这一点。 单个进程中的两个线程从内存中同一动态分配区域的不同部分读取数据。 每个线程对数据进行一些处理，然后读取更多数据。 我们需要确保在最后一个线程终止时完全释放动态分配的内存区域。 任何一个线程都可以在另一个线程之前终止；那么是谁释放缓冲区呢？

通过将缓冲区封装在智能包装器中，该智能包装器可以保持引用它的上下文数量的计数，并且只有在计数变为零时才释放缓冲区，这样我们就可以完全封装释放的逻辑。 缓冲区的用户应该改用智能包装器，他们可以自由复制，当所有副本都超出范围时，引用计数变为零，缓冲区被释放。

### Boost：：Shared_PTR 和 STD：：Shared_PTR

`boost::shared_ptr`智能指针模板提供引用计数的共享所有权语义。 它使用与包装的动态分配对象一起维护的共享引用计数来跟踪对它的引用数量。 与我们到目前为止看到的其他智能指针模板一样，它实现了 RAII 习惯用法，负责销毁和释放析构函数中包装的对象，但只有当对它的所有引用都被销毁(即引用计数为零)时，它才会这样做。 它是一个仅包含标题的库，通过包含`boost/shared_ptr.hpp`使其可用。

`shared_ptr`包含在 2007 年的 C++ 标准委员会技术报告(俗称 TR1)中，该报告是 C++ 11 标准的前身，以`std::tr1::shared_ptr`的形式提供。 它现在是 C++ 11 标准库的一部分，因为可以通过标准 C++ 头文件`memory`获得`std::shared_ptr`。 如果您已将代码库转移到 C++ 11，则应使用`std::shared_ptr`。 本节中的大部分讨论都适用于这两个版本；如果有差异，请注意。

您可以创建`shared_ptr`个实例来取得动态分配的对象的所有权。 与`boost::scoped_ptr`和`std::unique_ptr`不同，您可以复制`shared_ptr`实例。 `std::shared_ptr`还支持移动语义。 它存储动态分配的指针和共享引用计数对象。 每次通过复制构造复制`shared_ptr`时，指针和引用计数对象被浅复制。 复制`shared_ptr`个实例会导致引用计数增加。 `shared_ptr`实例超出范围会导致引用计数减少。 `use_count`成员函数可用于获取当前引用计数。 下面的示例实际显示了`shared_ptr`：

**清单 3.9：SHARED_PTR 正在执行**

```
 1 #include <boost/shared_ptr.hpp>
 2 #include <iostream>
 3 #include <cassert>
 4 
 5 class Foo {
 6 public:
 7   Foo() {}
 8   ~Foo() { std::cout << "~Foo() destructor invoked." << '\n';}
 9 };
10 
11 typedef boost::shared_ptr<Foo> SPFoo;
12   
13 int main()
14 {
15   SPFoo f1(new Foo);
16   // SPFoo f1 = new Foo; // Won't work, explicit ctor
17   assert(f1.use_count() == 1);
18
19   // copy construction
20   SPFoo f2(f1);
21   assert(f1.use_count() == f2.use_count() && 
22          f1.get() == f2.get() && f1.use_count() == 2);
23   std::cout << "f1 use_count: " << f1.use_count() << '\n';
24          
25   SPFoo f3(new Foo);
26   SPFoo f4(f3);
27   assert(f3.use_count() == 2 && f3.get() == f4.get());
28   std::cout << "f3 use_count: " << f3.use_count() << '\n';
29  
30   // copy assignment
31   f4 = f1;
32   assert(f4.use_count() == f1.use_count() && 
33         f1.use_count() == 3 && f1.get() == f4.get());
34   assert(f3.use_count() == 1);
35   std::cout << "f1 use_count: " << f1.use_count() << '\n';
36   std::cout << "f3 use_count: " << f3.use_count() << '\n';
37 }
```

在前面的代码中，我们定义了一个类`Foo`，其中有一个默认的构造函数和一个打印一些消息的析构函数(第 5-9 行)。 我们包括`boost/shared_ptr.hpp`(第 1 行)，它提供了`boost::shared_ptr`模板。

在main 函数中，我们定义了两个`shared_ptr<Foo>`实例`f1`(第 15 行)和`f3`(第 25 行)，使用类`Foo`的两个不同的动态分配实例进行初始化。 注意，`shared_ptr`构造函数是显式的，因此不能使用赋值表达式通过隐式转换复制初始化`shared_ptr`(第 16 行)。 构造后每个`shared_ptr<Foo>`实例的引用计数为 1(第 17 和 25 行)。 接下来，我们创建`f2`作为`f1`的副本(第 20 行)和创建`f4`作为`f3`的副本(第 26 行)。 复制会导致引用计数增加。 `shared_ptr`的`get`成员函数返回封装的指针，`shared_ptr`的`use_count`成员函数返回当前引用计数。 使用`use_count`，我们断言`f1`和`f2`具有相同的引用计数，使用`get`，我们断言它们包含相同的指针(第 21-22 行)。 类似的断言适用于`f3`和`f4`(第 27 行)。

接下来，我们将`f1`复制赋值给`f4`(第 31 行)。 因此，`f4`现在包含与`f1`和`f2`相同的指针，不再与`f3`共享指针。 现在，`f1`、`f2`和`f4`是三个`shared_ptr<Foo>`实例，将指向同一指针，并且它们共享的引用计数变为 3(第 32-33 行)。 `f3`不再与另一个实例共享其指针，因此其引用计数为 1(第 34 行)。

运行前面的代码，您可以预期以下输出：

```
f1 use_count: 2
f3 use_count: 2
f1 use_count: 3
f3 use_count: 1
~Foo() destructor invoked.
~Foo() destructor invoked.
```

引用计数在`main`函数结束时适时变为零，`Foo`的两个动态创建的实例都会被`shared_ptr`析构函数销毁。

#### SHARED_PTR 的用法

在 C++ 11 之前的代码中，与`boost::scoped_ptr`相比，`boost::shared_ptr`或`std::tr1::shared_ptr`往往是智能指针的默认选择，因为其灵活性和易用性。 它的用途超出了纯共享所有权语义，这使其成为最知名的智能指针模板。 在 C++ 11 中，这种普遍使用应该受到限制，以支持`std::unique_ptr`，并且`shared_ptr`应该只用于建模真正的共享所有权语义。

##### 作为班级成员

考虑一下这样一种场景，其中应用程序的多个组件可能共享单个数据库连接以获得更好的性能。 只要有组件在使用，就可以在第一次请求和缓存时创建这样的连接。 当所有组件都使用完毕后，应关闭连接。 这是共享所有权语义的确定性，`shared_ptr`在此场景中很有用。 让我们看看应用程序组件如何使用`shared_ptr`封装共享数据库连接：

**清单 3.10：使用 SHARED_PTR 作为类成员**

```
 1 class AppComponent
 2 {
 3 public:
 4  AppComponent() : spconn_(new DatabaseConnection(...))
 5  {}
 6 
 7  AppComponent( 
 8         const boost::shared_ptr<DatabaseConnection>& spc)
 9      : spconn_(spc) {}
11 
12  // Other public member
13  ...
14
15  boost::shared_ptr<DatabaseConnection> getConnection() {
16    return spconn_;
17  }
18 
19 private:
20  boost::shared_ptr<DatabaseConnection> spconn_;
21  // other data members
22 };
```

`AppComponent`是应用程序的一个组件，它使用包装在`shared_ptr`(第 20 行)中的数据库连接。 缺省构造的`AppComponent`创建一个新的数据库连接(第 4 行)，但是您总是可以通过向`AppComponent`实例传递包装在`shared_ptr`中的现有数据库连接来创建它(第 7-9 行)。 成员函数`getConnection`检索包装在 shared_ptr 中的共享指针包装的`DatabaseConnection`对象(第 16 行)。 下面是一个例子：

```
 1 AppComponent c1;
 2 AppComponent c2(a.getConnection());
```

在本例中，我们创建了两个共享同一数据库连接的`AppComponent`实例`c1`和`c2`。 第二个实例是使用第一个实例缓存的`shared_ptr`包装的数据库连接创建的，该连接使用`getConnection`方法获得。 不管`c1`和`c2`被销毁的顺序如何，只有当两者中的最后一个被销毁时，共享连接才被销毁。

##### 在标准库容器中存储动态分配的对象

由标准库容器存储的对象被复制或移动到容器中，并随容器一起销毁。 也可以通过复制或移动来检索对象。 在 C++ 11 之前，不支持移动语义，复制是在容器中存储对象的唯一机制。 标准库容器不支持引用语义。 您可以将指向动态分配的对象的指针存储在容器中，但在其生命周期结束时，容器不会尝试通过它们的指针销毁和释放这些对象。

您可以将动态分配的对象包装在`shared_ptr`或`unique_ptr`中，并将它们存储在容器中。 假设您可以使用 C++ 11，如果您只需要将它们存储在一个容器中，那么`std::unique_ptr`就足够了。 但是，如果您需要跨多个容器存储相同的动态分配对象，则`shared_ptr`是包装器的最佳选择。 当容器被销毁时，调用每个`shared_ptr`实例的析构函数，并递减该`shared_ptr`的引用计数。 如果任何`shared_ptr`的引用计数为零，则释放存储在其中的底层动态对象。 下面的示例说明如何将`shared_ptr`中包装的对象存储在多个 STL 容器中：

**清单 3.11：在容器**中存储 SHARED_PTR

```
 1 class Person;
 2 typedef boost::shared_ptr<Person> PersonPtr;
 3 std::vector<PersonPtr> personList;
 4 std::multimap<std::string, PersonPtr> personNameMap;
 5 ...
 6 
 7 for (auto it = personList.begin(); 
 8      it != personList.end(); ++ it) {
 9   personNameMap.insert(std::make_pair((*it)->name(), *it));
10 }
```

在前面的示例中，让我们假设有一个名为`Person`的类(第 1 行)。 现在，给定类型为`Person`的对象列表，我们希望创建名称到`Person`对象的映射。 假设无法复制`Person`对象，因此需要将它们作为指针存储在容器中。 我们为`shared_ptr<Person>`定义了一个名为`PersonPtr`的类型别名(第 2 行)。 我们还定义了用于存储`Person`对象列表的数据结构(`std::vector<PersonPtr>`(第 3 行))和`Person`名称到`Person`对象的映射(`std::multimap<std::string, PersonPtr>`(第 4 行))。 最后，我们从列表构造映射(第 7-9 行)。

将`personNameMap`容器中的每个条目创建为人名和`PersonPtr`对象的`std::pair`(使用`std::make_pair`)。 每个这样的条目都使用其`insert`成员函数插入到`multimap`中(第 9 行)。 我们假设在`Person`中有一个名为`name`的成员函数。 作为`shared_ptr`的`PersonPtr`对象在`vector`和`multimap`容器之间共享。 销毁两个容器中的最后一个时，将销毁`Person`对象。

除了`shared_ptr`之外，Boost 的指针容器还提供了另一种在容器中存储动态分配的对象的方法。 我们在[第 5 章](05.html "Chapter 5. Effective Data Structures beyond STL")，*STL*之外的有效数据结构中介绍了指针容器。 在[第 9 章](09.html "Chapter 9. Files, Directories, and IOStreams")，*文件、目录和 IOStream*中，我们将看到如何在线程之间共享`shared_ptr`实例。

#### 不拥有别名-Boost：：Ware_ptr 和 std：：ware_ptr

在最后一节中，我们查看的示例之一是在多个应用程序组件之间共享的数据库连接。 这种使用方式有一定的缺点。 在实例化旨在重用打开的数据库连接的应用程序组件时，需要引用另一个使用该连接的现有组件，并将该连接传递给新对象的构造函数。 一种更具伸缩性的方法是将连接创建和应用程序组件创建分离，以便应用程序组件甚至不知道它们获得的是新连接还是现有的可重用连接。 但要求仍然是，该连接必须在所有客户端之间共享，并且必须在最后一个对它的引用消失时将其关闭。

构建这种机制的一种方法是使用数据库连接工厂，它根据调用者传递的连接参数创建到特定数据库实例的连接。 然后，它将连接传递回包装在`shared_ptr`中的调用方，并将其存储在可查找的映射中。 当新客户端为同一数据库用户请求到同一实例的连接时，工厂只需从映射中查找现有连接并返回包装在`shared_ptr`中的连接即可。 下面的说明性代码实现了这一逻辑。 它假定连接到数据库实例所需的所有信息都封装在一个`DBCredentials`对象中：

```
 1 typedef boost::shared_ptr<DatabaseConnection> DBConnectionPtr;
 2
 3 struct DBConnectionFactory
 4 {
 5   typedef std::map<DBCredentials, DBConnectionPtr> 
 6                                             ConnectionMap;
 7
 8   static DBConnectionPtr connect(const DBCredentials& creds)
 9   {
10     auto iter = conn_map_.find(creds);
11
12     if (iter != conn_map_.end()) {
13       return iter->second;
14     } else {
15       DBConnectionPtr dbconn(new DatabaseConnection(creds));
16       conn_map_[creds] = dbconn;
17       return dbconn;
18     }
19   }
20 
21   static ConnectionMap conn_map_;
22 };
23 
24 DBConnectionFactory::ConnectionMap 
25                                DBConnectionFactory::conn_map_;
26 int main()
27 {
28   DBCredentials creds(...);
29   DBConnectionPtr dbconn = DBConnectionFactory::connect(creds);
30   DBConnectionPtr dbconn2 =DBConnectionFactory::connect(creds);
31   assert(dbconn.get() == dbconn2.get() 
32          && dbconn.use_count() == 3);
33 }
```

在前面的代码中，`DBConnectionFactory`提供了一个名为`connect`的静态方法，该方法接受一个`DBCredentials`对象，并返回一个`shared_ptr`包装的`DatabaseConnection`(`DBConnectionPtr`)(第 8-19 行)。 我们调用`DBConnectionFactory::connect`两次，传递相同的凭据。 第一个调用(第 28 行)应该导致创建一个新连接(第 15 行)，而第二个调用应该只查找并返回相同的连接(第 10-13 行)。

这段代码有一个主要问题：`DBConnectionFactory`将包装在`shared_ptr`中的连接存储在名为`conn_map_`的静态`std::map`中(第 21 行)。 因此，只有在程序结束时，当`conn_map_`被销毁时，其引用计数才变为 0。 否则，即使没有上下文使用该连接，引用计数也保持为 1。我们要求，当所有使用共享连接的上下文退出或过期时，应该销毁该连接。 这显然没有得到满足。

在映射中存储原始指针(`DatabaseConnection*`)而不是`shared_ptr`(`DBConnectionPtr`)是不好的，因为我们需要为该连接分配的第一个`shared_ptr`实例，以便能够为该连接创建更多`shared_ptr`实例。 即使有办法绕过这个问题(正如我们稍后将在`enable_shared_from_this`中看到的那样)，仅通过在连接映射中查找原始指针，我们也无法知道它是否仍在使用或已被释放。

`boost::weak_ptr`模板(在 C++ 11 中也以`std::weak_ptr`的形式提供)是解决此问题的正确工具。 您可以使用一个或多个`weak_ptr`实例引用`shared_ptr`实例，而不会影响决定其生存期的引用计数。 使用`weak_ptr`实例，您可以安全地确定它引用的`shared_ptr`仍然是活动的还是过期的。 如果没有过期，您还可以使用`weak_ptr`实例创建另一个引用同一对象的`shared_ptr`实例。 现在，我们将使用`weak_ptr`重写前面的示例：

**清单 3.12：使用 WINK_PTR**

```
 1 typedef boost::shared_ptr<DatabaseConnection> DBConnectionPtr;
 2 typedef boost::weak_ptr<DatabaseConnection> DBConnectionWkPtr;
 3
 4 struct DBConnectionFactory
 5 {
 6   typedef std::map<DBCredentials, DBConnectionWkPtr> 
 7                                             ConnectionMap;
 8
 9   static DBConnectionPtr connect(const DBCredentials& creds) {
10      ConnectionIter it = conn_map_.find(creds);
11      DBConnectionPtr connptr;
12
13     if (it != conn_map_.end() &&
14         (connptr = it->second.lock())) {
15       return connptr;
16     } else {
17       DBConnectionPtr dbconn(new DatabaseConnection(creds));
18       conn_map_[creds] = dbconn;  // weak_ptr = shared_ptr;
19       return dbconn;
20     }
21   }
22 
23   static ConnectionMap conn_map_;
24 };
25 
26 DBConnectionFactory::ConnectionMap 
27                                DBConnectionFactory::conn_map_;
28 int main()
29 {
30   DBCredentials creds(...);
31   DBConnectionPtr dbconn = DBConnectionFactory::connect(creds);
32   DBConnectionPtr dbconn2 =DBConnectionFactory::connect(creds);
33   assert(dbconn.get() == dbconn2.get() 
34          && dbconn.use_count() == 2);
35 }
```

在这个示例中，我们将`ConnectionMap`的定义更改为存储`weak_ptr<DatabaseConnection>`而不是`shared_ptr<DatabaseConnection>`(第 6-7 行)。 当使用适当的凭据调用`DBConnectionFactory::connect`函数时，代码将查找条目(第 10 行)，如果失败，则创建一个新的数据库连接，将其包装在`shared_ptr`中(第 17 行)，并将其存储为映射中的`weak_ptr`(第 18 行)。 请注意，我们使用复制赋值操作符将`shared_ptr`赋值给`weak_ptr`。 返回新构造的`shared_ptr`(第 19 行)。 如果查找成功，它将对检索到的`weak_ptr`调用`lock`方法，试图从它构造一个`shared_ptr`(第 12 行)。 如果由`it->second`表示的检索到的`weak_ptr`引用了有效的`shared_ptr`，则`lock`调用将自动返回另一个引用同一对象的`shared_ptr`，这将被赋给`connptr`变量并返回(第 15 行)。 否则，`lock`调用将返回 NULL`shared_ptr`，我们将在`else`块中创建一个新连接，如前所述。

如果您只想检查`weak_ptr`实例是否引用了有效的`shared_ptr`，而没有创建新的`shared_ptr`引用对象，那么只需在`weak_ptr`上调用`expired`方法即可。 只有当至少有一个`shared_ptr`实例仍然存在时，它才会返回`false`。

`weak_ptr`是如何做到这一点的？ 实际上，`shared_ptr`和`weak_ptr`被设计为相互协作。 每个`shared_ptr`实例都有两块内存：它封装的动态分配对象和称为共享计数器的内存块，后者包含两个原子引用计数，而不是一个。 这两个内存块在所有相关的`shared_ptr`实例之间共享。 共享计数器块还与引用这些`shared_ptr`个实例的所有`weak_ptr`个实例共享。

共享计数器中的第一引用计数，即*使用计数*，保持对`shared_ptr`的引用数量的计数。 当此计数为零时，封装的动态分配的对象将被删除，`shared_ptr`过期。 第二个引用计数，即*弱计数*，是`weak_ptr`个引用的数量，当且仅当周围有`shared_ptr`个实例时加 1。 仅当弱计数变为零时，即当所有`shared_ptr`和`weak_ptr`实例都已过期时，才删除共享计数器块。 因此，任何剩余的`weak_ptr`实例都能够通过检查仍可访问的使用计数并查看它是否为 0 来判断`shared_ptr`是否已过期。 `weak_ptr`的`lock`方法自动检查使用计数并仅在它为非零时递增，返回封装指针的有效`shared_ptr`。 如果使用计数已经为零，LOCK 将返回空`shared_ptr`。

#### Shared_PTR 评论-Make_Shared 和 Enable_Shared_From_This

`shared_ptr`除了共享所有权语义的适当用例之外，已经被广泛使用了吗？ 这在一定程度上是因为它可以作为 2007 年发布的 C++**技术报告 1**(**TR1**)版本的一部分，而其他可行的选项，如 Boost 的指针容器(参见[第 5 章](05.html "Chapter 5. Effective Data Structures beyond STL")，*STL*以外的有效数据结构)不是 TR1 的一部分。 但是`shared_ptr`需要为共享计数器额外分配空间，因此构建和销毁比`unique_ptr`和`scoped_ptr`要慢。 共享计数器本身是一个包含两个原子整数的对象。 如果您从来不需要共享所有权语义，而是使用`shared_ptr`，则需要为共享计数器的额外分配以及原子计数器上的递增和递减操作买单，这会使复制`shared_ptr`变慢。 如果您需要共享所有权语义，但不关心`weak_ptr`个观察者，那么您需要为弱引用计数器占用的额外空间买单，而这些空间是您不需要的。

缓解此问题的一种方法是以某种方式将两个分配-一个用于对象，另一个用于共享计数器-合并为一个。 `boost::make_shared`函数模板(在 C++ 11 中也是`std::make_shared`)是一个执行此操作的可变函数模板。 以下是您将如何使用它：

**清单 3.13：使用 make_shared**

```
 1 #include <boost/make_shared.hpp>
 2
 3 struct Foo {
 4   Foo(const std::string& name, int num);
 5   ...
 6 };
 7
 8 boost::shared_ptr<Foo> spfoo = 
 9             boost::make_shared<Foo>("Foo", 10);
10
```

`boost::make_shared`函数模板将对象类型作为模板参数，并将对象构造函数的参数作为函数参数。 我们调用`make_shared<Foo>`，向其传递要用来构造`Foo`对象的参数(第 8-9 行)。 然后，该函数分配单个内存块，在其中布局对象，并一举追加两个原子计数。 请注意，您需要包括头文件`boost/make_shared.hpp`才能使用`make_shared`。 这并不像看起来那么完美，但可能是一个足够好的权衡。 它并不完美，因为现在它是单个内存块，而不是两个内存块，并且在所有`shared_ptr`和`weak_ptr`引用之间共享。

即使所有的`shared_ptr`对象都消失了，对象也被销毁了，只有当最后一个`weak_ptr`消失时，它的内存才会被回收。 同样，只有当您使用延迟的`weak_ptr`实例并且您的对象大小大到足以令人担忧时，这才是一个问题。

我们之前简要介绍了`shared_ptr`的另一个问题。 如果我们从同一个原始指针创建两个独立的`shared_ptr`实例，那么它们都有独立的引用计数，并且都会在适当的时候尝试删除封装的对象。 第一个实例将成功，但第二个实例的析构函数很可能会崩溃，试图删除已删除的实体。 此外，在第一个`shared_ptr`超出范围之后通过第二个`shared_ptr`取消引用对象的任何尝试都将同样是灾难性的。 这个问题的一般解决方案是根本不使用`shared_ptr`，而使用`boost::intrusive_ptr`-我们将在下一节中探讨这一点。 解决此问题的另一种方法是配置包装类的实例方法，以使用`this`指针返回`shared_ptr`。 为此，您的类必须从`boost::enable_shared_from_this`类模板派生。 下面是一个例子：

**清单 3.14：使用 ENABLE_SHARED_FROM_this**

```
 1 #include <boost/smart_ptr.hpp>
 2 #include <boost/current_function.hpp>
 3 #include <iostream>
 4 #include <cassert>
 5
 6 class CanBeShared
 7        : public boost::enable_shared_from_this<CanBeShared> {
 8 public:
 9   ~CanBeShared() {
10     std::cout << BOOST_CURRENT_FUNCTION << '\n';
11   }
12   
13   boost::shared_ptr<CanBeShared> share()
14   {
15     return shared_from_this();
16   }
17 };
18 
19 typedef boost::shared_ptr<CanBeShared> CanBeSharedPtr;
20 
21 void doWork(CanBeShared& obj)
22 {
23   CanBeSharedPtr sp = obj.share();
24   std::cout << "Usage count in doWork "<<sp.use_count() <<'\n';
25   assert(sp.use_count() == 2);
26   assert(&obj == sp.get());
27 }
28 
29 int main()
30 {
31   CanBeSharedPtr cbs = boost::make_shared<CanBeShared>();
32   doWork(*cbs.get());
33   std::cout << cbs.use_count() << '\n';
34   assert(cbs.use_count() == 1);
35 }
```

在前面的代码中，类`CanBeShared`派生自`boost:: enable_shared_from_this<CanBeShared>`(第 7 行)。 如果您想知道`CanBeShared`是如何从以`CanBeShared`本身作为模板参数的类模板实例化继承而来的，那么让我向您介绍一下奇怪的重复出现的模板模式，这是一个可以在 Web 上阅读到更多信息的 C++ 习惯用法。 现在，`CanBeShared`定义了一个名为`share`的成员函数，该函数返回包装在`shared_ptr`中的`this`指针(第 13 行)。 它使用成员函数`shared_from_this`(第 15 行)完成此操作，该成员函数继承自其基类。

在`main`函数中，我们从类型`CanBeShared`的动态分配对象创建`CanBeSharedPtr`的实例`cbs`(它是`boost::shared_ptr<CanBeShared>`的`typedef`)(第 31 行)。 接下来，我们调用函数`doWork`，向其传递`cbs`内部的原始指针(第 32 行)。 向`doWork`函数传递对`CanBeShared`的引用(`obj`)，并对其调用`share`方法以获取同一对象的`shared_ptr`包装器(第 23 行)。 现在，这个`shared_ptr`的引用计数变为 2(第 25 行)，它包含的指针指向`obj`(第 26 行)。 一旦`doWork`返回，`cbs`上的使用计数返回到 1(第 34 行)。

从调用`shared_from_this`返回的`shared_ptr`实例是从`enable_shared_from_this<>`基中的`weak_ptr`成员实例构造的，并且仅在包装对象的构造函数的末尾构造。 因此，如果在类的构造函数内调用`shared_from_this`，则会遇到运行时错误。 您还应该避免在尚未包装在`shared_ptr`对象中的原始指针上调用它，或者避免在一开始就没有动态构造的对象上调用它。 C++ 11 标准将此功能标准化为可通过标准头文件`memory`获得的`std::enable_shared_from_this`。 在[第 11 章](11.html "Chapter 11. Network Programming Using Boost Asio")，*《使用 Boost ASIO 进行网络编程》*中，我们在编写异步 TCP 服务器时广泛使用了`enable_shared_from_this`。

如果您眼光敏锐，就会注意到我们只包含了一个头文件`boost/smart_ptr.hpp`。 这是一个方便的头文件，它将所有可用的智能指针功能集中到一个头文件中，这样您就不必记住包含多个头文件。

### 提示

如果您可以使用 C++ 11，那么您应该在大多数情况下使用`std::unique_ptr`，只有在需要共享所有权时才使用`shared_ptr`。 如果您出于某种原因仍在使用 C++ 03，那么您应该尽可能地利用`boost::scoped_ptr`，或者将`boost::shared_ptr`与`boost::make_shared`结合使用以获得更好的性能。

### 侵入式智能指针-Boost：：Intrusive_PTR

考虑一下当您将同一指针包装在两个不同的`shared_ptr`实例中(这两个实例彼此不是副本)时会发生什么情况。

```
 1 #include <boost/shared_ptr.hpp>
 2 
 3 int main()
 4 {
 5   boost::shared_ptr<Foo> f1 = boost::make_shared<Foo>();
 6   boost::shared_ptr<Foo> f2(f1.get());  // don't try this
 7
 8   assert(f1.use_count() == 1 && f2.use_count() == 1);
 9   assert(f1.get() == f2.get());
10 } // boom!
```

在前面的代码中，我们创建了一个`shared_ptr<Foo>`实例(第 5 行)和第二个独立的`shared_ptr<Foo>`实例，使用的指针与第一个实例的指针相同(第 6 行)。 的净效果是两个`shared_ptr<Foo>`实例的引用计数都是 1(在第 8 行断言)，并且都包含相同的指针(在第 9 行断言)。 在作用域结束时，`f1`和`f2`的引用计数都变为零，并且都尝试在同一指针上调用`delete`(第 10 行)。 代码几乎肯定会因为双重删除而崩溃。 从编译的意义上讲，代码是结构良好的，但很难表现良好。 您需要警惕`shared_ptr<Foo>`的这种用法，但它也指出了`shared_ptr`的限制。 这一限制是由于这样一个事实，即在给定原始指针的情况下，没有机制来判断它是否已经被某些智能指针引用。 共享引用计数在`Foo`对象之外，不是该对象的一部分。 `shared_ptr`据说是非侵入性的。

另一种方法是将引用计数作为对象本身的一部分进行维护。 这在某些情况下可能不可行，但在其他情况下完全可以接受。 甚至可能存在实际维护这种引用计数的现有对象。 如果您曾经使用过 Microsoft 的组件对象模型，那么您就已经使用过这样的对象。 `boost::intrusive_ptr`模板是`shared_ptr`的侵入性替代方案，它让用户承担维护引用计数的责任，并使用用户提供的钩子来递增和递减引用计数。 如果用户愿意，引用计数可以是类布局的一部分。 这有两个好处。 对象和引用计数在内存中相邻，因此有更好的缓存性能。 其次，`boost::intrusive_ptr`的所有实例都使用相同的引用计数来管理对象的生命周期。 因此，独立的`boost::intrusive_ptr`实例不会产生任何双重删除问题。 事实上，只要多个不同的智能指针包装使用相同的介入式引用计数，您就可以对同一对象同时使用多个不同的智能指针包装。

#### 使用 INTERSIVE_PTR

要管理类型`X`的动态分配的实例，可以像创建其他智能指针实例一样创建`boost::intrusive_ptr<X>`实例。 您只需确保有两个全局函数`intrusive_ptr_add_ref(X*)`和`intrusive_ptr_release(X*)`可用，这两个函数负责递增和递减引用计数，并在引用计数变为零时对动态分配的对象调用`delete`。 如果`X`是名称空间的一部分，那么理想情况下，两个全局函数也应该定义在同一个名称空间中，以方便参数相关的查找。 因此，引用计数和删除机制都在用户的控制之下，`boost::intrusive_ptr`提供了一个 RAII 框架，它们连接到该框架中。 请注意，如何维护引用计数是用户的特权，不正确的实现可能会导致泄漏、崩溃，或者至少会导致低效代码。 最后，下面是一些使用`boost::intrusive_ptr`的示例代码：

**清单 3.15：使用 INTERSIVE_PTR**

```
 1 #include <boost/intrusive_ptr.hpp>
 2 #include <iostream>
 3 
 4 namespace NS {
 5 class Bar {
 6 public:
 7   Bar() : refcount_(0) {}
 8  ~Bar() { std::cout << "~Bar invoked" << '\n'; }
 9 
10   friend void intrusive_ptr_add_ref(Bar*);
11   friend void intrusive_ptr_release(Bar*);
12 
13 private:
14   unsigned long refcount_;
15 };
16 
17 void intrusive_ptr_add_ref(Bar* b) {
18   b->refcount_++ ;
19 }
20 
21 void intrusive_ptr_release(Bar* b) {
22   if (--b->refcount_ == 0) {
23     delete b;
24   }
25 }    
26 } // end NS
27 
28 
29 int main()
30 {
31   boost::intrusive_ptr<NS::Bar> pi(new NS::Bar, true);
32   boost::intrusive_ptr<NS::Bar> pi2(pi);
33   assert(pi.get() == pi2.get());
34   std::cout << "pi: " << pi.get() << '\n'
35             << "pi2: " << pi2.get() << '\n';
36 }
```

我们使用`boost::intrusive_ptr`包装类`Bar`的动态分配的对象(第 31 行)。 我们还可以将一个`intrusive_ptr<NS::Bar>`实例复制到另一个实例中(第 32 行)。 类`Bar`在类型为`unsigned long`的成员变量`refcount_`中维护其引用计数(第 14 行)。 `intrusive_ptr_add_ref`和`intrusive_ptr_release`函数被声明为类`Bar`的朋友(第 10 行和第 11 行)，它们与`Bar`位于相同的名称空间`NS`(第 3-26 行)。 `intrusive_ptr_add_ref`每次调用时递增`refcount_`。 `intrusive_ptr_release`递减`refcount_`，并在`refcount_`变为零时调用传递给它的指针参数`delete`。

类`Bar`将变量`refcount_`初始化为零。 我们将布尔第二个参数的`true`传递给`intrusive_ptr`构造函数，以便构造函数通过调用`intrusive_ptr_add_ref(NS::Bar*)`递增`Bar`的`refcount_`(第 31 行)。 这是默认行为，`intrusive_ptr`构造函数的第二个布尔参数缺省为`true`，因此我们实际上不需要显式传递它。 另一方面，如果我们处理的类在初始化时将其引用计数设置为 1，而不是像`Bar`那样设置为 0，那么我们不希望构造函数再次增加引用计数。 在这种情况下，我们应该将第二个参数的`false`传递给`intrusive_ptr`构造函数。 复制构造函数总是通过调用`intrusive_ptr_add_ref`来递增引用计数。 每个`intrusive_ptr`实例的析构函数调用`intrusive_ptr_release`，将封装的指针传递给它。

虽然前面的示例说明了如何使用`boost::intrusive_ptr`模板，但是 Boost 在管理动态分配的对象时提供了一些便利。 `boost::intrusive_ref_counter`封装了一些通用样板代码，这样您就不必自己推出这么多代码。 以下示例说明了此用法：

**清单 3.16：使用 INTERSIVE_PTR**的较少代码

```
 1 #include <boost/intrusive_ptr.hpp>
 2 #include <boost/smart_ptr/intrusive_ref_counter.hpp>
 3 #include <iostream>
 4 #include <cassert>
 5
 6 namespace NS {
 7 class Bar : public boost::intrusive_ref_counter<Bar> {
 8 public:
 9   Bar() {}
10   ~Bar() { std::cout << "~Bar invoked" << '\n'; }
11 };
12 } // end NS
13
14 int main() {
15   boost::intrusive_ptr<NS::Bar> pi(new NS::Bar);
16   boost::intrusive_ptr<NS::Bar> pi2(pi);
17   assert(pi.get() == pi2.get());
18   std::cout << "pi: " << pi.get() << '\n'
19             << "pi2: " << pi2.get() << '\n';
20   
21   assert(pi->use_count() == pi2->use_count()
22          && pi2->use_count() == 2);
23   std::cout << "pi->use_count() : " << pi->use_count() << '\n'
24          << "pi2->use_count() : " << pi2->use_count() << '\n';
25 }
```

我们没有维护引用计数并为`intrusive_ptr_add_ref`和`intrusive_ptr_release`提供命名空间级别重载，而是公开地从`boost::intrusive_ref_counter<Bar>`继承了类`Bar`。 这就是我们需要做的一切。 这也使得使用从`intrusive_ref_counter<>`继承到`Bar`的`use_count()`公共成员在任何时候获取引用计数都很容易。 注意，`use_count()`不是`intrusive_ptr`本身的成员函数，所以我们必须使用取消引用操作符(`operator->`)来调用它(第 21-24 行)。

上例中使用的引用计数器不是线程安全的。 如果要确保引用计数线程安全，请编辑该示例以使用`boost::thread_safe_counter`策略类作为`boost::intrusive_ref_counter`的第二个类型参数：

```
 7 class Bar : public boost::intrusive_ref_counter<Bar, 
 8                               boost::thread_safe_counter>
```

奇怪的是，`Bar`继承自`boost::intrusive_ref_counter`模板的实例化，该模板将`Bar`本身作为模板参数。 这又是一种奇怪的重复出现的模板模式。

### SHARED_ARRAY

就像`boost::scoped_ptr`有一个专门用于管理动态分配的数组的相应模板一样，有一个名为`boost::shared_array`的模板可用于包装动态分配的数组，并使用共享所有权语义管理它们。 与`scoped_array`类似，`boost::shared_array`也有一个重载的下标运算符(`operator[]`)。 与`boost::shared_ptr`一样，它使用共享引用计数来管理封装数组的生存期。 与`boost::shared_ptr`不同，`shared_array`没有`weak_array`。 这是一个方便的抽象，可以用作引用计数的向量。 我把它留给您来进一步探索。

## 使用智能指针管理非内存资源

到目前为止，我们看到的所有智能指针类都假定它们的资源是使用 C++ `new`运算符动态分配的，并且需要使用`delete`运算符删除。 `scoped_array`和`shared_array`类以及`unique_ptr`的数组部分专门化假设它们的资源是动态分配的数组，并使用数组`delete`运算符(`delete[]`)释放它们。动态内存不是程序需要以异常安全的方式管理的唯一资源，如果忽略这个用例，智能指针将是一种疏忽。

`shared_ptr`和`std::unique_ptr`模板可以使用用户指定的替代删除策略。 这使得它们不仅适合管理动态内存，而且适合管理几乎任何具有用于创建和删除的显式 API 的资源，例如使用`malloc`和`free`的 C 样式堆内存分配和释放、打开文件流、Unix 打开文件描述符和套接字、特定于平台的同步原语、各种资源的 Win32API 句柄，甚至用户定义的抽象。 下面是一个简短的例子来完善本章：

```
 1 #include <boost/shared_ptr.hpp>
 2 #include <stdio.h>
 3 #include <time.h>
 4 
 5 struct FILEDeleter
 6 {
 7   void operator () (FILE *fp) const {
 8     fprintf(stderr, "Deleter invoked\n");
 9     if (fp) {
10       ::fclose(fp);
11     }
12   }
13 };
14 
15 int main()
16 {
18   boost::shared_ptr<FILE> spfile(::fopen("tmp.txt", "a+"), 
19                                  FILEDeleter());
20   time_t t;
21   time(&t);
22 
23   if (spfile) {
24     fprintf(spfile.get(), "tstamp: %s\n", ctime(&t));
25   }
26 }
```

我们将`fopen`返回的`FILE`指针包装在一个`shared_ptr<FILE>`对象中(第 18 行)。 但是，`shared_ptr`模板对`FILE`指针一无所知，因此我们还必须指定删除策略。 为此，我们定义了一个名为`FILEDeleter`的函数对象(第 5 行)，它的重载函数调用操作符(`operator()`，第 7 行)接受类型为`FILE`的参数，如果它不为空，则调用`fclose`(第 10 行)。 将`FILEDeleter`的临时实例作为第二个 Deleter 参数传递给`shared_ptr<FILE>`的构造函数(第 19 行)。 `shared_ptr<FILE>`的析构函数调用传递的 deleter 对象上的重载函数调用操作符，将存储的`FILE`指针作为参数传递。 在这种情况下，几乎没有使用重载的`operator->`，因此对回绕指针的所有操作都是通过使用`get`成员函数访问原始指针来执行的(第 24 行)。 我们还可以使用 lambda 表达式代替`FILEDeleter`函数对象。 我们在[第 7 章](07.html "Chapter 7. Higher Order and Compile-time Programming")、*高阶和编译时编程*中介绍了 lambda 表达式。

如果您有权使用 C++ 11，那么最好使用`std::unique_ptr`来实现这些目的。 使用`std::unique_ptr`时，您必须为删除程序的类型指定第二个模板参数。 前面的示例将使用只进行以下编辑的`std::unique_ptr`：

```
 1 #include <memory>
...
18   std::unique_ptr<FILE, FILEDeleter> spfile(::fopen("tmp.txt", 
19                                             "a+"), FILEDeleter());
```

我们包含 C++ 标准头文件`memory`而不是`boost/shared_ptr.hpp`(第 1 行)，并将调用`fopen`返回的`FILE`指针包装在一个`unique_ptr`实例中(第 18 行)，向其传递一个临时实例`FILEDeleter`(第 19 行)。 唯一额外的细节是`unique_ptr`模板的第二个类型参数，它指定了删除器的类型。 我们还可以使用 C++ 11 Lambda 表达式代替 FILEDeleter 函数对象。 在我们介绍了 Lambda 表达式之后，我们将在后面的章节中讨论这种用法。

# 自测题

对于多项选择题，请选择适用的所有选项：

1.  What are the Abraham's Exception Safety Guarantees?

    A.基础、弱、强

    B.基本型、强力型和非投掷型

    C.弱者、强者和不可投掷者

    D.无、基本、强

2.  What are the main differences between `boost::scoped_ptr` and `std::unique_ptr`?

    A.`boost::scoped_ptr`不支持移动语义

    B.`std::scoped_ptr`没有阵列的部分专门化

    C.`std::unique_ptr`可以存储在 STL 容器中

    D.`std::unique_ptr`支持自定义删除参数

3.  Why is `boost::shared_ptr` heavier than other smart pointers?

    A.它使用共享引用计数器

    B.支持复制和移动语义

    C.它对每个封装对象使用两个分配

    D.它并不比其他智能指针重

4.  What is the disadvantage of using `boost::make_shared` to create a `shared_ptr`?

    A.比直接实例化`boost::shared_ptr`慢

    B.它不是线程安全的

    C.在所有`weak_ptr`引用过期之前，它不会释放对象内存

    D.它在 C++ 11 标准版中不可用

5.  What are the primary differences between `boost::shared_ptr` and `std::unique_ptr`?

    A.`std::unique_ptr`不支持复制语义

    B.`std::unique_ptr`不支持移动语义

    C.`boost::shared_ptr`不支持自定义删除参数

    D.`boost::shared_ptr`不能用于数组

6.  If you want to return a `shared_ptr<X>` wrapping the `this` pointer from a member function of class `X`, which of the following would work?

    A.°T0_

    B.`boost::enable_shared_from_this`

    C. 089

    D.`boost::enable_shared_from_raw`

# 摘要

本章形式化了一段代码的异常安全要求，然后定义了使用智能指针以异常安全的方式管理动态分配的对象的各种方法。 我们研究了 Boost 的智能指针模板和新的 C++ 11 标准引入的智能指针模板，并理解了不同的所有权语义和侵入式和非侵入式引用计数。 我们还有机会了解如何调整一些智能指针模板来管理非内存资源。

希望您已经理解了各种所有权语义，并能够明智地将本章中的技术应用于此类场景。 智能指针库中有一些我们没有详细介绍的工具，比如`boost::shared_array`和`boost::enable_shared_from_raw`。 您应该自己进一步探索它们，重点放在它们的适用性和陷阱上。 在下一章中，我们将学习使用 Boost 的字符串算法处理文本数据的一些巧妙而有用的技术。

# 发文：2013 年 2 月 10 日星期日下午 12：00

*   零律：[http://en.cppreference.com/w/cpp/language/rule_of_three](http://en.cppreference.com/w/cpp/language/rule_of_three)
*   *设计 C++ 接口-异常安全*，*Mark Radford*：[http://accu.org/index.php/journals/444](http://accu.org/index.php/journals/444)
*   *异常安全分析*，*Andrei Alexandresu 和 David B.Hold*：[http://erdani.com/publications/cuj-2003-12.pdf](http://erdani.com/publications/cuj-2003-12.pdf)