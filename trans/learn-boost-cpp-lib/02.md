# 二、使用 Boost 工具的第一个刷子

在本书中，我们将重点介绍一些 Boost 库，它们处理不同的子系统，例如文件系统、线程、网络 I/O 和各种容器等。 在每一章中，我们将深入研究几个这样的库的细节。 这一章是不同的，在这个意义上，我们将学习一组有用的和不同的技巧，这些技巧将在几乎所有编程情况下帮助您。 为此，我们准备了以下主题：

*   简单的数据结构
*   使用不同的值
*   处理命令行参数
*   其他工具和编译时检查

这是厨房水槽这一章，你可以不断地回到这里，寻找一种有趣的技术，它似乎适用于手头的问题。

# 简单数据结构

在本节中，我们将介绍两个不同的库，它们将帮助您创建立即有用的简单数据结构：Boost.Optional和 Boost.Tuple。 Boost.Optional可用于表示可选值；对象可能在那里，也可能不在那里。 Boost.Tuple 用于创建异构值的有序集。

## 启动。可选

让我们考虑一下您需要在数据存储中维护有关音乐家的。 除此之外，你还可以查阅艺人发行的最新专辑。 为此，您已经用 C++ 编写了一个简单的 API：

```cpp
std::string find_latest_album_of(const std::string& artisteName);
```

为简单起见，我们将忽略两个或两个以上艺人同名的可能性。 下面是此函数的简单实现：

```cpp
 1 #include <string>
 2 #include <map>
 3
 4 typedef std::map<std::string, std::string> artiste_album_map;
 5
 6 extern artiste_album_map latest_albums;
 7
 8 std::string find_latest_album_of(
 9                     const std::string& artiste_name) {
10   auto iter = latest_albums.find(artiste_name);
11
12   if (iter != latest_albums.end()) {
13     return iter->second;
14   } else {
15     return "";
16   }
17 }
```

我们将艺人的名字和他们的最新专辑存储在名为`latest_albums`的地图中。 `find_latest_album_of`函数接受艺人的名字，并使用`std::map`的`find`成员函数查找最新专辑。 如果没有找到条目，则返回空字符串。 现在，有可能一些艺人还没有发行专辑。 在这种情况下，返回空字符串似乎是合法的，直到你意识到音乐家有他们独特的突发奇想，有时，他们发行了一张没有名字的专辑。 那么，你如何区分音乐家尚未发行专辑的情况和音乐家的最新专辑未命名的情况呢？ 在一种情况下，没有要返回的值，而在另一种情况下，它是一个空字符串。

`boost::optional<T>`模板可用于表示可选值；该值可能存在，也可能不存在。 在这种情况下，它是为我们的问题量身定做的。 要表示可能存在也可能不存在的`std::string`值，可以使用`boost::optional<std::string>`。 我们可以使用`boost::optional`重写`find_latest_album_of`函数，如以下代码清单所示：

**清单 2.1：使用 Boost.Optional**

```cpp
 1 #include <string>
 2 #include <map>
 3 #include <boost/optional.hpp>
 4
 5 typedef std::map<std::string, std::string> artiste_album_map;
 6
 7 extern artiste_album_map latest_albums;
 8 
 9 boost::optional<std::string> find_latest_album_of(
10                             const std::string& artiste_name) {
11   auto iter = latest_albums.find(artiste_name);
12
13   if (iter != latest_albums.end()) {
14     return iter->second;
15   } else {
16     return boost::none;
17   }
18 }
```

我们只返回找到的值(第 14 行)，它自动包装在一个`boost::optional`容器中。 如果没有要返回的值，我们将返回一个特殊对象`boost::none`(第 16 行)。 这会导致返回一个空的`boost::optional`对象。 使用`boost::optional`的代码做的正是我们所需要的；它检查容器中是否存在键并返回该值，或者没有任何歧义地指示它不存在(即，空的和无标题的)。

### 提示

默认初始化的`boost::optional`实例始终为空。 如果存储在`boost::optional`中的值是可移动的(参见[附录](12.html "Appendix A. C++ 11 Language Features Emulation")，*C++ 11 语言功能仿真*)，则包装器`optional`对象也是可移动的。 如果存储值是可复制的，则包装器`optional`对象也是可复制的。

我们可以将清单 2.1 中的查找函数推广到任何具有映射或字典接口的容器，如下所示：

**清单 2.2：使用可选的**进行泛型查找

```cpp
 1 #include <boost/optional.hpp>
 2
 3 template <typename C>
 4 boost::optional<typename C::mapped_type>
 5 lookup(const C& dict, const typename C::key_type& key)
 6 {
 7   typename C::const_iterator it = dict.find(key);
 8   if (it != dict.end()) {
 9     return it->second;
10   } else {
11     return boost::none;
12   }
13 }
```

在前面的代码中，我们将`lookup`转换为可以在任何`map`、`multimap`、它们的无序变体或任何其他非标准容器上调用的函数模板，从而公开了一个类似的接口。 它在容器类型`C`上参数化。 容器类型`C`必须有嵌套的类型定义：`key_type`和`mapped_type`，与映射存储的键和值的类型相对应；`std:map`和来自标准库的其他关联容器所满足的约束。

关键字`typename`的使用(第 4、5、7 行)可能需要一些解释。 如果在这些行中省略关键字`typename`，编译器将无法将`C::mapped_type`、`C::key_type`和`C::const_iterator`识别为类型名称。 因为`mapped_type`、`key_type`和`const_iterator`是依赖于类型模板参数`C`的名称，所以需要告知编译器它们标识类型。 我们使用`typename`关键字来执行此操作。

### 访问 Boost：：Optional 中存储的值

您可以检查`optional`对象是否包含值或为空，并提取存储在非空`optional`对象中的值：

```cpp
 1 std::string artiste("Korn");
 2 boost::optional<std::string> album = 
 3                             find_latest_album_of(artiste);
 4 if (album) {
 5   std::cout << "The last album from " << artiste;
 6
 7   if (album->empty()) {
 8     std::cout << " is untitled\n";
 9   } else {
10     std::cout << " is named " << *album << '\n';
11   }
12 } else {
13   std::cout << "No information on albums from " 
14             << artiste << '\n';
15 }
```

在调用`find_latest_album_of`的代码中，为了测试返回值是否为空，我们在布尔上下文中调用对象(第 4 行)。 如果它的计算结果为`true`，则表示`album`不为空。 如果它有一个值，我们可以使用重载的`operator*`(第 10 行)获得对包含的值的引用。 我们可以使用重载的`operator->`来访问底层对象的成员；在本例中，我们调用`std::string`的空成员函数(第 7 行)。 我们还可以使用非空`boost::optional`对象的 GET 成员函数而不是重载的`operator*`来访问存储的值。 通过调用`operator*`、`get`或`operator->`来取消引用空的可选值会导致运行时错误，这就是为什么我们在尝试取消引用之前首先检查`optional`对象是否为空。

### GET_VALUE_OR

使用`optional`，我们指出可能存在也可能没有专辑的值。 但我们有时需要使用本应采用可选值但没有采用的 API。 在这种情况下，我们可能希望返回带有一些默认值的空值。 想象一下，巴黎居民被问及他们最喜欢的城市，那些没有说出城市名字的人，巴黎被默认为最喜欢的城市：

```cpp
 1 void printFavoriteCity(const std::string& name,
 2                        const std::string& city)
 3 {
 4   std::cout << name "'s favorite city is " << city << '\n';
 5 }
 6
 7 boost::optional<std::string> getFavoriteCity(
 8                           const std::string& resident_id);
 9 ...
10 std::string resident = "Serge";
11 boost::optional<std::string> fav_city = 
12                                     getFavoriteCity(resident);
13
14 printFavoriteCity(fav_city.get_value_or("Paris"));
```

如果虚构的`getFavoriteCity`函数返回空值，我们希望将`Paris`传递给`printFavoriteCity`函数。 我们使用`get_value_or`成员函数(第 14 行)来实现这一点。

### 启动。可选与指针

如果我们没有使用而不使用`optional`，那么函数`find_last_album_of`或`lookup`将返回什么以指示没有找到值？ 它们需要返回指向动态分配对象的指针，如果没有找到值，则需要返回`nullptr`。 除了使用动态内存之外，它还要求调用方函数管理返回的动态分配对象的生存期。 使用智能指针([第 3 章](03.html "Chapter 3. Memory Management and Exception Safety")、*内存管理和异常安全*)可以缓解这种情况，但它不会消除代价高昂的空闲存储分配。 `boost::optional`类取消空闲存储分配，并将封装的对象存储在其布局中。 此外，它还存储一个布尔标志，以跟踪它是否已初始化。

## Boost.Tuple

Boost Tuples 是一种很酷的方式，可以将不同类型的数据组合成有序的元组，并将它们传递。 结构做同样的事情，但有两件事将元组区分开来：

*   您可以编写泛型代码来操作所有类型的元组，例如，打印它们的所有成员并比较两个元组在结构和类型上的相似性。
*   每个新结构或类都会在软件中定义一个新类型。 类型应该表示接口和行为。 用类型表示每个即席数据块都会导致在问题空间或其抽象中没有意义的类型激增。

Boost Tuple 是一个非常有用的库，它可以帮助您方便地创建用于一起移动相关数据的模式，比如在函数之间交换数据。 Boost Tuples 是`std::pair`的泛化，用于创建 2 元素元组。

### 提示

如果您使用的是具有良好 C++ 11 支持的 C++ 编译器，则应该使用标准库中的`std::tuple`工具，标准库是实现 C++ 11 标准的 Boost 库之一。 要包括的报头是`<tuple>`。 我们在这里讨论的大部分内容都适用于`std::tuple`。

### 创建元组

让我们看一个例子。 在给定个不同时间点的一系列股票价格的情况下，我们希望找出买卖股票的最佳两个时间点，以实现利润最大化。 我们可以假设没有卖空的选择，也就是说，你必须在卖出之前买入。 为简单起见，可以假设输入是双精度向量。 在此向量中，我们感兴趣的是代表买卖股票以实现利润最大化的最佳时机的那对指数：

**清单 2.3：使用元组**

```cpp
 1 #include <boost/tuple/tuple.hpp>
 2 #include <vector>
 3
 4 boost::tuple<size_t, size_t, double>
 5      getBestTransactDays(std::vector<double> prices)
 6 {
 7   double min = std::numeric_limits<double>::max();
 8   double gain = 0.0, max_gain = 0.0;
 9   size_t min_day, max_day;
10   size_t buy_day;
11   for (size_t i = 0, days = prices.size(); i < days; ++ i) {
12     if (prices[i] < min) {
13       min = prices[i];
14       min_day = i;
15     } else if ((gain = prices[i] - min) > max_gain) {
16       max_gain = gain;
17       buy_day = min_day;
18       max_day = i;
19     }
20   }
21
22   return boost::make_tuple(buy_day, max_day, max_gain);
23 }
```

函数`getBestTransactDays`返回一个由两个无符号整数(`size_t`)和一个双精度数(第 4 行)组成的元组，表示买卖股票将最大化利润的两个指数，以及可能的最大利润。 函数的返回类型为`boost::tuple<size_t, size_t, double>`。 Header`boost/tuple/tuple.hpp`提供了使用元组所需的函数和类型(第 1 行)。

函数`getBestTransactDays`实现了一个简单的线性算法，该算法遍历向量，跟踪到目前为止的最低股价。 如果当前元素的值小于到目前为止的最低股价，则将其设置为新的最低值，并记录其索引(第 12-14 行)。 该函数还跟踪最大收益，即到目前为止注意到的最大价格差异。 如果我们遇到一个元素，其与最低价格的差值高于最大收益，则我们将此差值记为新的最大收益(第 15 行)，并记下实现此收益所需的交易天数(第 16-18 行)。

我们使用`boost::make_tuple`(第 22 行)创建元组，这是一个方便的函数，用于在没有显式模板实例化的情况下从其元素创建元组。 您还可以创建并返回如下所示的元组来代替第 22 行：

```cpp
22 boost::tuple<size_t, size_t, double> best_buy(buy_day, max_day, 
23                                         max_gain);
24 return best_buy;
```

如您所见，`boost::make_tuple`更加紧凑，作为函数模板，它自动解析其参数的类型以创建正确类型的元组。 这是一种常见的模式，其中使用工厂函数模板实例化一个类模板，从而自动进行类型检测。

### 访问元组元素

有几种方法可以访问元组中的元素。 请看下面调用`getBestTransactDays`函数的示例：

```cpp
 1 std::vector<double> stockPrices;
 2 ...
 3 boost::tuple<size_t, size_t, double> best_buy = 
 4                              getBestTransactDays(stockPrices);
 5 
 6 size_t buyDay = boost::get<0>(best_buy);  // Access 0th element
 7 size_t sellDay = boost::get<1>(best_buy); // Access 1st element
 8 double profit = boost::get<2>(best_buy); // Access 2nd element
```

我们还可以使用`boost::tie`将元组中的元素解包到单个变量中：

```cpp
 1 size_t buyDay, sellDay;
 2 double profit;
 3 boost::tie(buyDay, sellDay, profit) =  
 4                 getBestTransactDays(stockPrices);
```

前面的代码行将元组的第一个元素赋值给`buyDay`，第二个元素赋值给`sellDay`，第三个元素赋值给`profit`。 如果我们只对元组中元素的一个子集感兴趣，我们可以使用`boost::tuples::ignore`忽略其他元素。 下面是相同的示例，但这次我们使用`boost::tuples::ignore`忽略了`sellDay`：

```cpp
 1 size_t buyDay, sellDay;
 2 boost::tie(buyDay, sellDay, boost::tuples::ignore) =
 3                              getBestTransactDays(stockPrices);
```

### 比较元组

长度相同的元组可以与关系运算符进行比较，例如`==`、`<`、`>`、`<=`和`>=`。 在任何这样的比较中，比较在每个位置的对应的个元素。 相应位置上的元素类型不需要相同；它们只需使用相关的关系运算符进行比较即可：

```cpp
 1 boost::tuple<int, int, std::string> t1 = 
 2                          boost::make_tuple(1, 2, "Hello");
 3 boost::tuple<double, double, const char*> t2 = 
 4                         boost::make_tuple(1, 2, "Hi");
 5 assert(t1 < t2);   // because Hello < Hi
```

请注意，元组`t1`和`t2`中的实际类型不同，但都具有相同的长度，并且相应位置的元素彼此具有可比性。 通常，比较止于确定比较结果的第一对元素。 在此示例中，所有三个元素都进行了比较，因为前两个元素比较相等。

```cpp
 1 boost::tuple<int, int, std::string> t1 = 
 2                          boost::make_tuple(1, 20, "Hello");
 3 boost::tuple<double, double, const char*> t2 = 
 4                        boost::make_tuple(1, 2, "Hi");
 5 assert(t1 > t2);    // because 20 > 2
```

以下代码用于用很少的代码定义结构的关系运算符：

```cpp
 1 struct my_type {
 2   int a;
 3   double b;
 4   char c;
 5 };
 6
 7 bool operator<(const my_type& left, const my_type& right) {
 8   return boost::make_tuple(left.a, left.b, left.c) <
 9                 boost::make_tuple(right.a, right.b, right.c);
10 }
```

### 使用元组编写泛型代码

现在我们将编写一个泛型函数来查找元组中的元素数量：

```cpp
 1 template <typename T>
 2 size_t tuple_length(const T&) {
 3   return boost::tuples::length<T>::value;
 4 }
```

此函数简单地使用`boost::tuples::length<T>`元函数来计算元组中的元素数量。 此计算在编译时进行。 **元函数**只是一个类模板，它有一个可访问的静态成员或一个在编译时从其模板参数计算的嵌套类型(有关更严格的定义，请参阅[第 7 章](07.html "Chapter 7. Higher Order and Compile-time Programming")、*高阶和编译时编程*)。 在本例中，`boost::tuples::length<T>`元函数有一个名为`value`的公共静态成员，其计算方式为元组`T`中的元素数。 如果使用标准库中的元组，则应该使用`std::tuple_size<T>`而不是`boost::tuples::length<T>`。 这只是使用元函数和类型计算的泛型编程的一个小示例。

# 使用异类值

在程序的生命周期中，需要一个值可以在不同时间保存不同类型的数据并不是什么新鲜事。 C++ 支持 C 的`union`构造，这实质上允许您拥有单个类型，该类型可以在不同的时间采用不同的底层 POD 类型的值。 **POD**或**普通旧数据**类型粗略地说是不需要任何特殊初始化、销毁和复制步骤的类型，其语义等价物可以通过逐字节复制其存储器布局来创建。

这些限制意味着大多数 C++ 类，包括来自标准库的大多数类，永远不能成为联合的一部分。 从 C++ 11 开始，对联合的这些限制有所放松，现在可以在联合中存储具有重要构造、销毁和复制语义的类型对象(即非 POD 类型)。 但是，存储在联合中的此类对象的生命周期管理不是自动的，可能会令人头疼，因此最好避免这种情况。

Boost、Variant 和 Any 的两个库提供了有用的 VARIANT 类型，它们提供与联合相同的功能，没有很多限制。 使用 VARIANT 和 ANY，在标准库容器中存储异构数据变得非常容易，而且没有错误。 这些库表示区分的联合类型。 一系列类型的值可以存储在区分的联合中，类型信息与值一起存储。

除了存储异构类型的数据外，我们还经常需要在相同数据的不同表示之间进行转换，例如，从文本转换为数字，反之亦然。 Boost 转换提供了一种使用统一语法在类型之间进行无缝转换的方法。 在接下来的几节中，我们将查看任何、变体和转换库。

## 发帖主题：Re：Колибри0.7.0

Boost 变体避免了 C++ UNION的所有错误，并提供了在一组固定的任意类型上定义的类似 UNION 的构造，而不仅仅是 POD 类型。 通过使用类型列表实例化`boost::variant`模板，我们可以使用 Boost Variant Header Only 库定义 VARIANT 数据类型。 类型列表标识变化对象在不同时间点可以采用的不同类型的值。 列表中的不同类型可以是不同的和不相关的，只符合一个绑定条件-即每个类型都是可复制的或至少是可移动的。 您甚至可以创建包含其他变体的变体。

在我们的第一个示例中，我们创建了整数、`std::string`以及两个用户定义类型`Foo`和`Bar`的变体。 至此，我们将说明有关创建变量类型和可对这些变量值执行操作的约束：

**清单 2.4：创建和使用变体**

```cpp
 1 #include <boost/variant.hpp>
 2 #include <string>
 3
 4 struct Foo {
 5   Foo(int n = 0) : id_(n) {} // int convertible to Foo
 6 private:
 7   int id_;
 8 };
 9 
10 struct Bar {
11   Bar(int n = 0) : id_(n) {} // int convertible to Bar
12 private:
13   int id_;
14 };  
15 
16 int main()
17 {
18   boost::variant<Foo, int, std::string> value; // error if Foo 
19                                 // not be default constructible
20   boost::variant<std::string, Foo, Bar> value2;
21 
22   value = 1;                 // sets int, not Foo
23   int *pi = boost::get<int>(&value);
24   assert(pi != 0);
25   value = "foo";             // sets std::string
26   value = Foo(42);           // sets Foo
27
28   // value2 = 1;             // ERROR: ambiguous - Foo or Bar?
29   // std::cout << value << ' ' << value2 << '\n'; // ERROR:
30                   // Foo, Bar cannot be streamed to ostream
31 }
```

我们创建了两个基本类型：`Foo`(第 4 行)和`Bar`(第 10 行)；我们可以从`int`隐式初始化这两个类型。 我们在三种类型`Foo`、`int`和`std::string`上定义了一个名为`value`(第 18 行)的变量。 第二个变体`value2`(第 20 行)在`std::string`、`Foo`和`Bar`上定义。

默认情况下，每个变体实例都被值初始化为其第一个类型的对象。 因此，`value`默认构造为`Foo`实例-变量的类型参数列表中的第一个类型。 同样，`value2`默认构造为`std::string`，即其类型参数列表中的第一个类型。 如果第一个类型是 POD 类型，则它被零初始化。 因此，第一个类型必须是默认可构造的，变量才是默认可构造的。

我们将一个整数赋给`value`(第 22 行)。 这会将其设置为`int`而不是`Foo`，整数可以隐式转换为`Foo`。 我们使用`value`的`T=int`地址上的`boost::get<T>`函数模板来确认这一点(第 23 行)，并且我们确认它不为空(第 24 行)。

我们将`const char*`赋给`value`(第 25 行)，它隐式转换为存储在`value`中的`std::string`，覆盖前面存储的整数值。 接下来，我们分配一个对象`Foo`(第 26 行)，它覆盖前面的`std::string`值。

如果我们试图将整数赋给`value2`(第 28 行，注释)，将导致编译错误。 变量`value2`是在`std::string`、`Foo`和`Bar`上定义的变量，整数可以隐式转换为`Foo`或`Bar`，两者都不是更好的选择-因此，它会导致歧义，编译器会抛出错误。 通常，变量初始化和赋值不应导致在变量中实例化哪种类型的歧义。

如果我们尝试将`value`的内容流式传输到`std::cout`(第 29 行，注释)，那么我们将再次遇到编译错误。 这是因为变体支持的类型之一(`Foo`)不是*流的*，这意味着它不能使用插入运算符(`<<`)写入`ostreams`。

### 访问变量中的值

我们使用`boost::get<T>`函数模板来访问变量中类型`T`的值，其中`T`是我们需要的值的具体类型。 当调用变量引用时，此函数返回对存储值的引用，或者如果存储值不是指定的类型，则抛出`boost::bad_get`异常。 在指向变量的指针上调用时，它返回存储值的地址，如果存储值不是指定类型，则返回空指针。 后一种行为可用于测试变量是否存储特定类型的值，如清单 2.4 所示(第 23 行)。 `get<>`的这一行为与`dynamic_cast`的行为非常相似：

**清单 2.5：访问变量**中的值

```cpp
 1 #include <boost/variant.hpp>
 2 #include <string>
 3 #include <cassert>
 4 
 5 int main() {
 6   boost::variant<std::string, int> v1;
 7   v1 = "19937";                    // sets string
 8   int i1;
 9 
10   try {    
11     i1 = boost::get<int>(v1);      // will fail, throw
12   } catch (std::exception& e) {
13     std::cerr << e.what() << '\n';
14   }
15 
16   int *pi = boost::get<int>(&v1);  // will return null
17   assert(pi == 0);
18 
19   size_t index = v1.which();        // returns 0
20 }
```

在前面的代码中，我们创建了一个可以存储`std::string`或`int`值的变量`v1`(第 6 行)。 我们将`v1`设置为字符串`"19937"`(第 7 行)。 我们使用`boost::get<int>`函数尝试从`v1`获取一个整数(第 11 行)，但是，由于`v1`在此时存储了一个`string`，这会导致抛出异常。 接下来，我们使用`boost::get<int>`的指针重载，它获取变量`v1`的地址。 如果存储值的类型与通过`get`函数的模板参数请求的类型匹配，则返回指向存储值的指针。 如果不是，如本例所示，则返回空指针(第 16 和 17 行)。 最后，通过调用`which`成员函数，我们可以获得当前存储在变量中的值类型的从零开始的索引。 由于`v1`包含`std::string`，并且`v1`的声明类型是`boost::variant<std::string, int>`，因此在本例中，`v1.which()`应该在变量的声明中返回`std::string`的索引-0(第 19 行)。

#### 编译时访问

如何使用变量中存储的值通常取决于值的类型。 使用 If-Else 阶梯检查每个可能类型的变体会迅速增加代码的可读性和可维护性。 当然，我们可以使用变量的`which`成员方法找出当前值类型的从零开始的索引，但它不会立即起到什么作用。 取而代之的是，我们将研究 Boost 变异库提供的一种非常优雅和通用的编译时访问机制，如果没有该机制，处理变体将非常麻烦。

其想法是创建一个包含重载函数调用操作符(`operator()`)的访问器类来处理可能存储在变量中的每种类型。 使用函数`boost::apply_visitor`，我们可以根据变量对象所包含的值类型，在 Variant 对象的访问者类中调用适当的重载。

访问者类应该公开继承自`boost::static_visitor<T>`模板，其中`T`是重载函数调用操作符的返回类型。 默认情况下，`T`为`void`。 让我们看一个例子：

**清单 2.6：变体的编译时访问**

```cpp
 1 #include <boost/variant.hpp>
 2 
 3 struct SimpleVariantVisitor :public boost::static_visitor<void>
 4 {
 5   void operator() (const std::string& s) const
 6   { std::cout << "String: " << s << '\n'; }
 7 
 8   void operator() (long n) const
 9   { std::cout << "long: " << n << '\n'; }
10 };
11 
12 int main()
13 {
14   boost::variant<std::string, long, double> v1;
15   v1 = 993.3773;
16 
17   boost::apply_visitor(SimpleVariantVisitor(), v1);
18 }
```

我们在类型`std::string`、`long`和`double`上创建一个名为`v1`的变量(第 14 行)。 我们将其设置为类型`double`的值(第 15 行)。 最后，我们在`v1`上调用类型为`SimpleVariantVistor`的访问器(第 17 行)。 `SimpleVariantVisitor`继承自`boost::apply_visitor<void>`(第 3 行)，包含`std::string`(第 5 行)和`long`(第 8 行)的`operator()`重载，但不包含`double`的重载。 每个重载都将其参数打印到标准输出。

重载的解析发生在编译时而不是运行时。 因此，对于变量可能包含的每种类型的值，重载都必须可用。 如果特定重载的参数类型与变量中存储的值的类型最匹配，则调用该重载。 此外，如果所有类型都可转换为重载参数的类型，则单个重载可以处理多个类型。

有趣的是，在前面的示例中，`double`没有可用的重载。 但是，允许缩小转换范围，并且调用`long`的重载时可能会缩小范围。 在这种情况下，`long`的重载同时处理`long`和`double`类型。 另一方面，如果我们为`double`和`long`提供了单独的重载，但没有为`std::string`提供重载，那么就会出现编译错误。 这会发生，因为即使是从`std::string`到`long`或`double`的缩小转换也不可用，并且重载解析将失败。 作为一种编译时机制，这个在任何时候都与存储在变量对象中的实际值的类型无关。

#### 普通访问者

您可以创建处理类型族的成员函数模板。 在处理不同类型的代码差别不大的情况下，拥有这样的成员模板可能是有意义的。 下面是一个打印变量内容的访问者示例：

**清单 2.7：通用编译时访问**

```cpp
 1 #include <boost/variant.hpp>
 2
 3 struct PrintVisitor : boost::static_visitor<>
 4 {
 5    template <typename T>
 6    void operator() (const T& t) const {
 7      std::cout << t << '\n';
 8    }
 9 };
10
11 boost::variant<std::string, double, long, Foo> v1;
12 boost::apply_visitor(PrintVisitor(), v1);
```

在前面的代码中，我们定义了类型`std::string`、`double`、`long`和`Foo`上的变量。 访问者类`PrintVisitor`包含一个泛型`operator()`。 只要变量中的所有类型都是*流的*，此代码就会编译变量的值并将其打印到标准输出。

#### 将访问者应用于容器中的变体

通常，我们有一个包含各种对象的 STL 容器，并且我们希望使用我们的访问器访问每个对象。 为此，我们可以利用`std::for_each`STL 算法和`boost::apply_visitor`的单参数重载。 `boost::apply_visitor`的单参数重载接受一个访问者实例，并返回一个将访问者应用于传递的元素的函数器。 以下示例最好地说明了用法：

```cpp
 1 #include <boost/variant.hpp>
 2
 3 std::vector<boost::variant<std::string, double, long> > vvec;
 4 …
 5 std::for_each(vvec.begin(), vvec.end(),
 6                  boost::apply_visitor(SimpleVariantVisitor()));
```

### 定义递归变量

在过去几年中，一种特殊的数据交换格式--JavaScript Object Notation 或 JSON--的普及率有了惊人的增长。 它是一种简单的基于文本的格式，通常不太冗长的 XML。 该格式最初用作 JavaScript 中的对象文字，比 XML 更具可读性。 它也是一种相对简单的格式，易于理解和解析。 在本节中，我们将使用`boost::variants`表示格式良好的 JSON 内容，并了解变体如何处理递归定义。

#### JSON 格式

首先，我们将查看一个使用 JSON 表示法的人员记录示例：

```cpp
    {
        "Name": "Lucas",
        "Age": 38,
        "PhoneNumbers" : ["1123654798", "3121548967"],
        "Address" : { "Street": "27 Riverdale", "City": "Newtown", 
                             "PostCode": "902739"}
    }
```

前面的代码是一个JSON 对象的示例-它包含标识未命名对象属性的键-值对。 属性名称是带引号的字符串，如`"Name"`、`"Age"`、`"PhoneNumbers"`(可以有多个)和`"Address"`。 它们的值可以是简单字符串(`"Name"`)或数值(`"Age"`)，也可以是这些值的数组(`"PhoneNumbers"`)或其他对象(`"Address"`)。 单个冒号(`:`)将键与值隔开。 键-值对用逗号分隔。 对象中的键-值对列表用大括号括起来。 此格式允许任意级别的嵌套，如值本身为对象的`"Address"`属性所示。 您可以创建更多嵌套对象，这些嵌套对象是其他嵌套对象的属性值。

您可以将许多这样的记录组合在一个数组中，该数组用方括号括起来，并用逗号分隔：

```cpp
[
    {
        "Name": "Lucas",
        "Age": 38,
        "PhoneNumbers" : ["1123654798", "3121548967"],
        "Address" : { "Street": "27 Riverdale", "City": "Newtown", 
                             "PostCode": "902739"}
    },
    {
        "Name": "Damien",
        "Age": 52,
        "PhoneNumbers" : ["6427851391", "3927151648"],
        "Address": {"Street": "11 North Ave.", "City" : "Rockport", 
                        "PostCode": "389203"}
    },
    … 
]
```

格式良好的 JSON 文本包含一个对象或由零个或多个对象、数值、字符串、布尔值或空值组成的数组。 对象本身包含零个或多个唯一属性，每个属性由唯一字符串表示。 每个属性的值可以是字符串、数值、布尔值、空值、另一个对象或此类值的数组。 因此，JSON 内容中的基本标记是数值、字符串、布尔值和空值。 聚合是对象和数组。

#### 用递归变量表示 JSON 内容

如果我们声明一个变量来表示 JSON 中的基本令牌，它将如下所示：

```cpp
 1 struct JSONNullType {};
 2 boost::variant<std::string, double, bool, JSONNullType> jsonToken;
```

类型`JSONNullType`是空类型，可用于表示 JSON 中的空元素。

为了扩展此变体以表示更复杂的 JSON 内容，我们将尝试将 JSON 对象(键-值对)表示为类型。 键始终是字符串，但值可以是上面列出的任何类型或其他嵌套对象。 因此，JSON 对象的定义本质上是递归的，这就是为什么我们需要递归变体定义来对其建模的原因。

为了在前面的变量类型中包含 JSON 对象的定义，我们使用了一个名为`boost::make_recursive_variant`的元函数。 它获取类型列表，并将结果递归变量类型定义为称为`type`的嵌套类型。 因此，下面是我们如何编写变量的递归定义的方法：

```cpp
 1 #define BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT
 2 #include <boost/variant.hpp>
 3
 4 struct JSONNullType {};
 5
 6 typedef boost::make_recursive_variant<
 7                      std::string,
 8                      double,
 9                      bool,
10                      JSONNullType,
11                      std::map<std::string,
12                               boost::recursive_variant_>
13                     >::type JSONValue;
```

对于许多支持递归变量(尤其是使用`make_recursive_variant`)的编译器来说，第 1 行上的`#define`语句可能是必需的。

我们使用`boost::make_recursive_variant`元函数定义递归变量(第 6 行)。 在类型列表中，我们添加了一个新类型`std::map`，其键类型为`std::string`(第 11 行)，值类型为`boost::recursive_variant_`(第 12 行)。 特殊类型`boost::recursive_variant_`用于指示外部变量类型可以作为值出现在映射本身中。 因此，我们在 VARIANT 定义中捕获了 JSON 对象的递归性质。

这个定义仍然不完整。 格式良好的 JSON 内容可能包含所有这些不同类型的元素数组。 这样的数组也可以是对象属性的值，或者嵌套在其他数组中。 如果我们选择用向量表示数组，那么扩展前面的定义就很容易了：

**清单 2.8a：JSON**的递归变体

```cpp
 1 #define BOOST_VARIANT_NO_FULL_RECURSIVE_VARIANT_SUPPORT
 2 #include <boost/variant.hpp>
 3
 4 struct JSONNullType {};
 5
 6 typedef boost::make_recursive_variant<
 7                      std::string,
 8                      double,
 9                      bool,
10                      JSONNullType,
11                      std::map<std::string,
12                               boost::recursive_variant_>,
13                      std::vector<boost::recursive_variant_>
14                     >::type JSONValue;
15
16 typedef std::vector<JSONValue> JSONArray;
17 typedef std::map<std::string, JSONValue> JSONObject;
```

我们再添加一个类型-`std::vector<boost::recursive_variant_>`(第 13 行)-它表示一个由`JSONValue`对象组成的数组。 由于这一行的增加，我们现在支持更多的可能性：

*   由 JSON 对象、其他 JSON 数组和基本类型的令牌组成的顶级数组
*   对象的数组值属性
*   另一个 JSON 数组中的数组值元素

这是`JSONValue`的完整定义。 此外，我们还为递归聚合类型-JSON 数组和 JSON 对象创建了 typedefs(第 16 和 17 行)。

#### 访问递归变量

现在，我们将编写一个访问器来打印 JSON 数据，该数据以 JSON 数据的标准表示法存储在变量中。 访问递归变量与访问非递归变量没有什么不同。 我们仍然需要定义可以处理变量可能存储的所有类型的值的重载。 此外，在递归聚合类型(在本例中为 `JSONArray`和`JSONObject`)的重载中，我们可能需要递归访问其每个元素：

**清单 2.8b：访问递归变体**

```cpp
 1 void printArrElem(const JSONValue& val);
 2 void printObjAttr(const JSONObject::value_type& val); 
 3
 4 struct JSONPrintVisitor : public boost::static_visitor<void>
 5 {
 6   void operator() (const std::string& str) const
 7   {
 8     std::cout << '"' << escapeStr(str) << '"';
 9   }
10
11   void operator() (const JSONNullType&) const
12   {
13     std::cout << "null";
14   }
15
16   template <typename T>
17   void operator()(const T& value) const
18   {
19     std::cout << std::boolalpha << value;
20   }
21
22   void operator()(const JSONArray& arr) const
23   {
24     std::cout << '[';
25
26     if (!arr.empty()) {
27       boost::apply_visitor(*this, arr[0]);
28       std::for_each(arr.begin() + 1, arr.end(), printArrElem);
29     }
30 
31     std::cout << "\n";
32   }
33
34   void operator()(const JSONObject& object) const
35   {
36     std::cout << '{';
37 
38     if (!object.empty()) {
39       const auto& kv_pair = *(object.begin());
40       std::cout << '"' << escapeStr(kv_pair.first) << '"';
41       std::cout << ':';
42       boost::apply_visitor(*this, kv_pair.second);
43
44       auto it = object.begin();
45       std::for_each(++ it, object.end(), printObjAttr);
46     }
47     std::cout << '}';
48   }
49
50 };
51
52 void printArrElem(const JSONValue& val) {
53   std::cout << ',';
54   boost::apply_visitor(JSONPrintVisitor(), val);
55 }
56
57 void printObjAttr(const JSONObject::value_type& val) {
58   std::cout << ',';
59   std::cout << '"' << escapeStr(val.first) << '"';
60   std::cout << ':';
61   boost::apply_visitor(JSONPrintVisitor(), val.second);
62 }
```

访问器`JSONPrintVisitor`公开继承自`boost::static_visitor<void>`，并为不同的可能类型的 JSON 值提供`operator()`的重载。 `std::string`(第 6 行)有一个重载，它在转义所有嵌入的引号和其他需要转义的字符之后，打印双引号中的字符串(第 8 行)。 为此，我们假设有一个名为`escapeStr`的函数可用。 我们有针对`JSONNullType`的第二个重载(第 11 行)，它只打印不带引号的字符串`null`。 其他类型的值，如`double`或`bool`由成员模板处理(第 17 行)。 对于`bool`值，它使用`std::boolalpha``ostream`操作器(第 19 行)打印不带引号的字符串`true`和`false`。

主要工作由`JSONArray`(第 22 行)和`JSONObject`(第 34 行)的两个重载完成。 `JSONArray`重载打印用方括号括起来并用逗号分隔的数组元素。 它打印`JSONValues`向量的第一个元素(第 27 行)，然后对该向量应用`std::for_each`通用算法，从第二个元素开始打印用逗号分隔的后续元素(第 28 行)。 为此，它将作为第三个参数传递给`std::for_each`，即指向函数`printArrElem`的指针。 函数`printArrElem`(第 52 行)通过应用`JSONPrintVisitor`(第 54 行)打印每个元素。

`JSONObject`重载将映射的元素打印为逗号分隔的键-值对列表。 第一对被打印为带引号的转义键(第 40 行)，然后是冒号(第 41 行)，然后是对`boost::apply_visitor`的调用(第 42 行)。 通过使用`std::for_each`和`printObjAttr`函数指针迭代映射的其余元素，以逗号分隔打印后面的对(第 45 行)。 该逻辑类似于`JSONArray`过载中的逻辑。 `printObjAttr`函数(第 57 行)打印传递给它的每个键-值对，在前面加上逗号(第 58 行)，打印转义的带引号的键(第 59 行)，打印冒号(第 60 行)，并调用变量值上的访问器(第 61 行)。

## 启动。任何

Boost Any 库采用与 Boost 变体不同的方式来存储异构数据。 与变体不同，Any 允许您存储几乎任何类型的数据，而不限于固定的集合，并维护存储数据的运行时类型信息。 因此，它根本不使用模板，并要求启用**运行时类型标识**(**RTTI**)，同时使用 Boost Any 编译代码(大多数现代编译器默认保持启用状态)。

### 提示

要使 Boost Any 库正常工作，您不能禁用为您的程序生成 RTTI。

在下面的示例中，我们创建`boost::any`的实例来存储数字数据、字符数组和非 POD 类型的对象：

**清单 2.9：使用 Boost Any**

```cpp
 1 #include <boost/any.hpp>
 2 #include <vector>
 3 #include <iostream>
 4 #include <string>
 5 #include <cassert>
 6 using boost::any_cast;
 7
 8 struct MyValue {
 9   MyValue(int n) : value(n) {}
10
11   int get() const { return value; }
12
13   int value;
14 };
15
16 int main() {
17   boost::any v1, v2, v3, v4;
18
19   assert(v1.empty());
20   const char *hello = "Hello";
21   v1 = hello;
22   v2 = 42;
23   v3 = std::string("Hola");
24   MyValue m1(10);
25   v4 = m1;
26
27   try {
28     std::cout << any_cast<const char*>(v1) << '\n';
29     std::cout << any_cast<int>(v2) << '\n';
30     std::cout << any_cast<std::string>(v3) << '\n';
31     auto x = any_cast<MyValue>(v4);
32     std::cout << x.get() << '\n';
33   } catch (std::exception& e) {
34     std::cout << e.what() << '\n';
35   }
36 }
```

您还可以通过传递`any`对象的地址而不是引用来使用的非抛出版本的`any_cast`。 这将返回空指针，而不是在存储类型与其强制转换为的类型不匹配时引发异常。 以下代码片段说明了这一点：

```cpp
 1 boost::any v1 = 42;2 boost::any v2 = std::string("Hello");
 3 std::string *str = boost::any_cast<std::string>(&v1);
 4 assert(str == nullptr);
 5 int *num = boost::any_cast<int>(&v2);
 6 assert(num == nullptr);
 7
 8 num = boost::any_cast<int>(&v1);
 9 str = boost::any_cast<std::string>(&v2);
10 assert(num != nullptr);
11 assert(str != nullptr);
```

我们将`any`对象的地址传递给`any_cast`(第 3、5、8 和 9 行)，除非`any_cast`的类型参数与存储在`any`对象中的值的类型匹配，否则返回 NULL。 使用`any_cast`的指针重载，我们可以编写一个泛型谓词来检查`any`变量是否存储了给定类型的值：

```cpp
template <typename T>
bool is_type(boost::any& any) {
  return ( !any.empty() && boost::any_cast<T>(&any) );
}
```

您可以这样使用它：

```cpp
boost::any v1 = std::string("Hello");
assert( is_type<std::string>(v1) );
```

`boost::any_cast`的此行为模拟`dynamic_cast`的工作方式。

在清单 2.9 中，我们使用类型`boost::any`的不同实例来存储不同类型的值。 但是，`boost::any`的同一实例可以在不同时间存储不同类型的值。 以下代码片段使用`any`的`swap`成员函数说明了这一点：

```cpp
 1 boost::any v1 = 19937;
 2 boost::any v2 = std::string("Hello");
 3
 4 assert(boost::any_cast<int>(&v1) != nullptr);
 5 assert(boost::any_cast<std::string>(&v2) != nullptr);
 6
 7 v1 = 22.36;
 8 v1.swap(v2);
 9 assert(boost::any_cast<std::string>(&v1) != nullptr);
10 assert(boost::any_cast<double>(&v2) != nullptr);
```

我们首先将类型为`double`的值赋给`v1`(第 7 行)，该值携带类型为`int`的值(第 1 行)。 接下来，我们将`v1`的内容与`v2`交换(第 8 行)，后者携带类型为`std::string`的值(第 2 行)。 我们现在可以预期`v1`包含`std::string`值(第 9 行)，而`v2`包含`double`值(第 10 行)。

除了使用`any_cast`的指针重载之外，我们还可以使用`any`的`type`成员函数来访问存储值的类型：

**清单 2.10：访问任何**中的类型信息

```cpp
boost::any value;
value = 20;
if (value.type().hash_code() == typeid(int).hash_code()) {
  std::cout << boost::any_cast<int>(value) << '\n';
}
```

`any`的类型成员函数返回`std::type_info`的对象(在标准库头`<typeinfo>`中定义)。 为了检查此类型是否与给定类型相同，我们将其与通过对给定类型应用`typeid`运算符(在本例中为`int`)获得的`type_info`对象进行比较。 我们不是直接比较这两个`type_info`对象，而是比较使用`type_info`的`hash_code`成员函数获得的散列码。

## Boost.Conversion

如果您曾经尝试过解析文本输入(来自文件、标准输入、网络等)，并尝试过对It 中的数据进行语义转换，那么您可能会觉得需要一种简单的方法将文本转换为数值。 相反的问题是基于数值和文本程序变量的值编写文本输出。 `basic_istream`和`basic_ostream`类为读取和写入特定类型的值提供了便利。 但是，用于此类用途的编程模型不是非常直观或健壮。 C++ 标准库及其扩展提供了各种转换函数，具有不同程度的控制、灵活性，但普遍缺乏可用性。 例如，存在一系列在数字和字符格式之间或相反方向转换的函数(例如，`atoi`、`strtol`、`strtod`、`itoa`、`ecvt`、`fcvt`等等)。 如果我们试图编写用于在类型之间转换的泛型代码，我们甚至不能选择使用这些函数中的任何一个，这些函数只适用于特定类型之间的转换。 我们如何定义可以扩展到任意类型的泛型转换语法？

Boost`Conversion`库引入了几个函数模板，它们提供了非常直观和统一的转换语法，也可以通过用户定义的专门化进行扩展。 我们将逐一查看转换模板。

### 词汇转换

`lexical_cast`函数模板可用于将源类型转换为目标类型。 它的语法类似于各种 C++ 强制转换的语法：

```cpp
#include <boost/lexical_cast.hpp>
namespace boost {
template <typename T, typename S>
T lexical_cast (const S& source);
}
```

下面的示例显示如何使用`lexical_cast`将字符串转换为整数：

**清单 2.11：使用 lexical_cast**

```cpp
 1 std::string str = "1234";
 2
 3 try {
 4   int n = boost::lexical_cast<int>(str);
 5   assert(n == 1234);
 6 } catch (std::exception& e) {
 7   std::cout << e.what() << '\n';
 8 }
```

我们应用`lexical_cast`(第 4 行)将类型为`std::string`的值转换为值`int`。 这种方法的优点在于，它可以为所有转换提供统一的语法，并且可以扩展到新类型。 如果字符串不包含有效的数字字符串，则`lexical_cast`调用将抛出`bad_lexical_cast`类型的异常。

提供`lexical_cast`函数模板的重载以允许转换字符数组的一部分：

```cpp
#include <boost/lexical_cast.hpp>
namespace boost {
template <typename T >
T lexical_cast (const char* str, size_t size);
}
```

我们可以通过以下方式使用前面的函数：

```cpp
 1 std::string str = "abc1234";
 2
 3 try {
 4   int n = boost::lexical_cast<int>(str.c_str() + 3, 4);
 5   assert(n == 1234);
 6 } catch (std::exception& e) {
 7   std::cout << e.what() << '\n';
 8 }
```

当转换可流类型的对象时，`lexical_cast`将对象流到`ostream`对象(如`stringstream`的实例)，并将其作为目标类型读回。

### 提示

可以将可流式对象转换为字符流，并将其插入到`ostream`对象中，例如`stringstream`的实例。 换言之，定义了`ostream& operator<<(ostream&, const T&)`的类型`T`被认为是可流传输的。

为每个这样的操作设置和拆卸流对象会产生一些开销。 因此，在某些情况下，默认版本的`lexical_cast`可能无法提供最佳的性能。 在这种情况下，您可以为所涉及的一组类型专门化`lexical_cast`模板，并使用快速库函数或提供您自己的快速实现。 `Conversion`库已经负责优化所有常见类型对的`lexical_cast`。

除了`lexical_cast`模板，还有其他模板可用于不同数值类型(`boost::numeric_cast`)之间的转换，类层次结构(`polymorphic_downcast`，`polymorphic_cast`)中的向下转换和交叉转换。 有关这些功能的详细信息，请参阅在线文档。

# 处理命令行参数

与 API 参数一样，命令行参数也是帮助您调整命令行为的远程控制按钮。 一组精心设计的命令行选项是命令大部分功能的背后。 在本节中，我们将了解 Boost.Program_Options 库如何帮助您将对丰富且标准化的命令行选项集的支持添加到您自己的程序中。

## 设计命令行选项

C 为程序的命令行提供了最原始的抽象。 使用传递给main 函数的两个参数-参数数量(`argc`)和参数列表(`argv`)-您可以了解传递给程序的每个参数及其相对顺序。 下面的程序打印`argv[0]`，它是调用程序时使用的程序本身的路径。 当使用一组命令行参数运行时，程序还会在单独的行上打印每个参数。

大多数程序需要添加更多的逻辑和验证来验证和解释命令行参数，因此，需要一个更详细的框架来处理命令行参数：

```cpp
1 int main(int argc, char *argv[])
2 {
3   std::cout << "Program name: " << argv[0] << '\n';
4
5   for (int i = 1; i < argc; ++ i) {
6     std::cout << "argv[" << i << "]: " << argv[i] << '\n';
7   }
8 }
```

### diff 命令-案例研究

程序通常记录一组修改其行为的命令行选项和开关。 让我们看一下 Unix 中的`diff`命令示例。 `diff`命令按如下方式运行：

```cpp
$ diff file1 file2

```

它打印两个文件的内容之间的差异。 有几种方式可以选择打印差异。 对于找到的每个不同的块，您可以选择在差异周围多打印几行，以便更好地理解出现不同部分的上下文。 这两个文件的周围行或“上下文”没有什么不同。 要执行此操作，可以使用以下备选方案之一：

```cpp
$ diff -U 5 file1 file2
$ diff --unified=5 file1 file2

```

在这里，您选择打印另外五行上下文。 您还可以通过指定以下内容来选择默认值三个：

```cpp
$ diff --unified file1 file2

```

在前面的示例中，`-U`或`--unified`是命令行选项的示例。 前者是一个短选项，由一个前导连字符和一个字母(`-U`)组成。 后者是具有两个前导连字符和多字符选项名称(`--unified`)的长选项。

数字`5`是选项值；它前面的选项(`-U`或`--unified`)的参数。 选项值与前面的短选项之间用空格隔开，但与前面的长选项之间用等号分隔(`=`)。

如果要“区分”两个 C 或 C++ 源文件，可以使用命令行开关或标志`-p`获得更多有用的信息。 开关是不以选项值作为参数的选项。 使用此开关，您可以打印在其上下文中检测到特定差异的 C 或 C++ 函数的名称。 没有与之对应的多头选项。

`diff`命令是一个非常强大的工具，您可以使用它来查找完整目录中文件内容的差异。 区分两个目录时，如果一个文件存在于一个目录中而不存在于另一个目录中，`diff`默认情况下会忽略该文件。 但是，您可能希望改为查看新文件的内容。 为此，您将使用`-N`或`--new-file`开关。 如果我们现在想要在 C++ 源代码的两个目录上运行`diff`命令来识别更改，我们可以这样做：

```cpp
$ diff -pN –unified=5 old_source_dir new_source_dir

```

您不必是目光敏锐的人就会注意到我们使用了一个名为`-pN`的选项。 这实际上不是单个选项，而是两个交换机(`-p`)和(`-N`)一起折叠在一起。

从这个案例研究中，某些模式或惯例应该是显而易见的：

*   短选项以单连字符开头
*   以双连字符开头的长选项
*   用空格分隔做空期权和期权价值
*   用等号分隔多头期权和期权价值
*   将短开关折叠在一起

这些是高度兼容 POSIX 的系统(如 Linux)上的*事实上的*标准化约定。 然而，这绝不是唯一遵循的惯例。 Windows 命令行通常使用前导正斜杠(`/`)代替连字符。 它们通常不区分短期权和长期权，有时还用冒号(`:`)代替等号来分隔期权及其期权价值。 Java 命令以及几个较旧的 Unix 系统中的命令对短选项和长选项都使用单个前导连字符。 他们中的一些人使用空格来分隔期权和期权价值，而不管它是做空期权还是做多期权。 在解析命令行时，如何处理如此多因平台而异的复杂规则？ 这就是 Boost Program Options 库发挥巨大作用的地方。

## 使用 Boost.Program_Options

Boost Program Options 库为您提供了一种解析命令行的声明性方式。 您可以为您的程序支持的每个选项指定选项和开关的集合以及选项值的类型。 您还可以指定要为命令行支持的约定集。 然后，您可以将所有这些信息提供给解析和验证命令行的库函数，并将所有命令行数据提取到类似字典的结构中，您可以从该结构访问单个数据位。 现在，我们将编写一些代码来模拟前面提到的`diff`命令的选项：

**清单 2.12a：使用 Boost 程序选项**

```cpp
 1 #include <boost/program_options.hpp>
 2
 3 namespace po = boost::program_options;
 4 namespace postyle = boost::program_options::command_line_style;
 5 
 6 int main(int argc, char *argv[])
 7 {
 8   po::options_description desc("Options");
 9   desc.add_options()
10      ("unified,U", po::value<unsigned int>()->default_value(3),
11             "Print in unified form with specified number of "
12             "lines from the surrounding context")
13      (",p", "Print names of C functions "
14             " containing the difference")
15      (",N", "When comparing two directories, if a file exists in"
16             " only one directory, assume it to be present but "
17             " blank in the other directory")
18      ("help,h", "Print this help message");
```

在前面的代码片段中，我们使用`options_description`对象声明命令行的结构。 连续选项是使用`add_options`返回的对象中的重载函数调用`operator()`声明的。 您可以通过级联对`std::cout`上的插入运算符(`<<`)的调用，以与打印多个值相同的方式级联对此运算符的调用。 这使得选项的规范具有高度可读性。

我们声明`--unified`或`-U`选项，在单个字符串中指定长选项和短选项，用逗号分隔(第 10 行)。 第二个参数表示我们需要一个数字参数，如果没有在命令行中指定该参数，则默认值为`3`。 第三个字段是选项的描述，将用于生成文档字符串。

我们声明短选项`-p`和`-N`(第 13 和 15 行)，但是因为它们没有对应的长选项，所以它们是用逗号后跟短选项(`",p"`和`",N"`)引入的。 它们也不带选项值，所以我们只提供它们的描述。

到目前一切尚好。 现在，我们将通过解析命令行并获取值来完成代码示例。 首先，我们将指定 Windows 和 Unix 中要遵循的样式：

**清单 2.12b：使用 Boost 程序选项**

```cpp
19   int unix_style    = postyle::unix_style
20                      |postyle::short_allow_next;
21
22   int windows_style = postyle::allow_long
23                      |postyle::allow_short
24                      |postyle::allow_slash_for_short
25                      |postyle::allow_slash_for_long
26                      |postyle::case_insensitive
27                      |postyle::short_allow_next
28                      |postyle::long_allow_next;
```

前面的代码突出显示了 Windows 和 Unix 约定之间的一些重要区别：

*   更多或更少标准化的 Unix 样式可以预先预装，并称为`unix_style`。 然而，我们必须自己构建 Windows 风格。
*   `short_allow_next`标志允许您用空格分隔短选项及其选项值；这在 Windows 和 Unix 上都使用。
*   `allows_slash_for_short`和`allow_slash_for_long`标志允许在选项前面加上正斜杠；这是 Windows 上的常见做法。
*   `case_insensitive`标志适用于 Windows，在 Windows 中通常使用不区分大小写的命令和选项。
*   Windows 上的`long_allow_next`标志允许用空格分隔长选项和选项值，而不是用等号分隔。

现在，让我们看看如何使用所有这些信息来解析符合要求的命令行。 为此，我们将声明一个`variables_map`类型的对象来读取所有数据，然后解析命令行：

**清单 2.12c：使用 Boost 程序选项**

```cpp
29   po::variables_map vm;
30   try {
31     po::store(
32       po::command_line_parser(argc, argv)
33          .options(desc)
34          .style(unix_style)  // or windows_style
35          .run(), vm);
36
37     po::notify(vm); 
38
39     if (argc == 1 || vm.count("help")) {
40       std::cout << "USAGE: " << argv[0] << '\n'
41                 << desc << '\n';
42       return 0;
43     }
44   } catch (po::error& poe) {
45     std::cerr << poe.what() << '\n'
46               << "USAGE: " << argv[0] << '\n' << desc << '\n';
47     return EXIT_FAILURE;
48   }
```

我们使用`command_line_parser`函数创建命令行解析器(第 32 行)。 我们在返回的解析器上调用`options`成员函数来指定在`desc`中编码的解析规则(第 33 行)。 我们进一步将成员函数调用链接到解析器的`style`成员函数以指定期望的样式(第 34 行)，并链接到`run`成员函数以实际执行解析。 对`run`的调用返回一个数据结构，其中包含从命令行解析的数据。 对`boost::program_options::store`的调用将来自该数据结构的解析数据存储在`variables_map`对象`vm`内(第 31-35 行)。 最后，我们检查程序是在没有参数的情况下调用的，还是使用`help`选项调用的，并打印帮助字符串(第 39 行)。 将`option_description`实例`desc`流式传输到`ostream`将打印一个帮助字符串，该字符串是根据`desc`中编码的命令行规则自动生成的(第 41 行)。 所有这些都封装在 try-catch 块中，以捕获调用`run`(第 35 行)抛出的任何命令行解析错误。 如果出现此类错误，将打印错误详细信息(第 45 行)和使用详细信息(第 46 行)。

如果您注意到了，我们在第 37 行调用了一个名为`notify(…)`的函数。 在更高级的应用中，我们可以选择使用从命令行读取的值来设置变量或对象成员，或执行其他后处理操作。 可以在声明选项描述时为每个选项指定此类操作，但这些操作只能通过调用`notify`来启动。 为了保持一致性，不要放弃对`notify`的呼叫。

现在，我们可以提取通过命令行传递的值：

**清单 2.12d：使用 Boost 程序选项**

```cpp
49   unsigned int context = 0;
50   if (vm.count("unified")) {
51     context = vm["unified"].as<unsigned int>();
52   }
53
54   bool print_cfunc = (vm.count("p") > 0);
```

### 解析位置参数

如果您很细心，您就会注意到我们没有读取这两个文件名；这是`diff`命令的两个主要操作数。 我们这样做是为了简单，现在我们要解决这个问题。 我们运行`diff`命令，如下所示：

```cpp
$ diff -pN --unified=5 old_source_dir new_source_dir

```

`old_source_dir`和`new_source_dir`参数称为位置参数。 它们不是选项或开关，也不是任何选项的参数。 为了处理它们，我们将不得不使用一些新的技巧。 首先，我们必须告诉解析器我们所期望的这些参数的数量和类型。 其次，我们必须告诉解析器这些是位置参数。 以下是代码片段：

```cpp
 1 std::string file1, file2;
 2 po::options_description posparams("Positional params");
 3 posparams.add_options()
 4         ("file1", po::value<std::string>(&file1)->required(), "")
 5         ("file2", po::value<std::string>(&file2)->required(), "");
 6 desc.add(posparams);
 7
 8
 9 po::positional_options_description posOpts;
10 posOpts.add("file1", 1);  // second param == 1 indicates that
11 posOpts.add("file2", 1);  //  we expect only one arg each
12
13 po::store(po::command_line_parser(argc, argv)14                 .options(desc)
15                 .positional(posOpts)
16                 .style(windows_style)
17                 .run(), vm);
```

在前面的代码中，我们设置了第二个名为`posparams`的选项描述对象来标识位置参数。 我们添加名为`"file1"`和`"file2"`的选项，并使用`value`参数的`required()`成员函数(第 4 和 5 行)指出这些参数是必需的。 我们还指定了两个字符串变量`file1`和`file2`来存储位置参数。 所有这些都被添加到主选项描述对象`desc`(第 6 行)。 为了让解析器不查找名为`"--file1"`和`"--file2"`的实际选项，我们必须告诉解析器这些是位置参数。 这是通过定义一个`positional_options_description`对象(第 9 行)并添加应该被视为位置选项的选项(第 10 和 11 行)来实现的。 调用`add(…)`中的第二个参数指定应该为该选项考虑多少个位置参数。 因为我们需要一个文件名，选项`file1`和`file2`各有一个，所以我们在两个调用中都指定了`1`。 命令行上的位置参数将根据它们添加到位置选项说明中的顺序进行解释。 因此，在这种情况下，第一个位置参数将被视为`file1`，第二个参数将被视为`file2`。

### 多选项值

在某些情况下，单个选项可能具有多个选项值。 例如，在编译期间，您将多次使用`-I`选项来指定多个目录。 要解析此类选项及其选项值，可以将目标类型指定为向量，如以下代码片断所示：

```cpp
 1 po::options_description desc("Options");
 2 desc.add_option()
 3      ("include,I", po::value<std::vector<std::string> >(),
 4       "Include files.")
 5      (…);
```

这将对如下调用起作用：

```cpp
$ c++ source.cpp –o target -I path1 -I path2 -I path3

```

但是，在某些情况下，您可能希望指定多个选项值，但只能指定选项本身一次。 假设您正在运行一个命令来发现连接到一组服务器中的每一个的资产(本地存储、NIC、HBA 等)。 您可以使用如下命令：

```cpp
$ discover_assets --servers svr1 svr2 svr3 --uid user

```

在这种情况下，要对`--server`选项建模，您需要使用`multitoken()`指令，如下所示：

```cpp
 1 po::options_description desc("Options");
 2 desc.add_option()
 3      ("servers,S", 
 4       po::value<std::vector<std::string> >()->multitoken(),
 5       "List of hosts or IPs.")
 6      ("uid,U", po::value<std::string>, "User name");
```

您可以通过变量映射检索向量值参数，如下所示：

```cpp
1 std::vector<std::string> servers = vm["servers"];
```

或者，您也可以在定义选项时使用变量挂钩，如下所示：

```cpp
1 std::vector<std::string> servers;
2 desc.add_option()
3      ("servers,S",
4       po::value<std::vector<std::string> >(&servers
5          ->multitoken(),
6       "List of hosts or IPs.")…;
```

请确保在解析命令行后不要忘记调用`notify`。

### 提示

试图在同一命令中同时支持多个令牌的位置参数和选项可能会混淆解析器，通常应该避免。

Program Options 库使用 Boost Any 来实现它。 为使程序选项库正常工作，您不能禁用程序的 RTTI 生成。

# 其他工具和编译时检查

Boost 包括许多微库，它们提供小但有用的功能。 它们中的大多数都不够详细，不足以成为单独的库。 相反，它们被分组到`Boost.Utility`和`Boost.Core`下的。 我们将在这里查看两个这样的库。

我们还将研究一些有用的方法，以便在编译时尽早检测错误，并使用 Boost 的不同工具收集有关程序编译环境和工具链的信息。

## BOOST_CURRENT_Function

在编写调试日志时，能够编写函数名和有关调用日志的函数的一些限定信息非常有用。 在编译源代码的过程中，编译器(显然)可以获得这些信息。 但是，打印它的方式对于不同的编译器是不同的。 即使对于给定的编译器，也可能有多种方法可以做到这一点。 如果您想要编写可移植的代码，这是一个您必须小心隐藏的缺点。 最好的工具是宏`BOOST_CURRENT_FUNCTION`，它正式是`Boost.Utility`的一部分，如下例所示：

**清单 2.13：漂亮地打印当前函数名**

```cpp
 1 #include <boost/current_function.hpp>
 2 #include <iostream>
 3
 4 namespace FoFum {
 5 class Foo
 6 {
 7 public:
 8   void bar() {
 9     std::cout << BOOST_CURRENT_FUNCTION << '\n';
10     bar_private(5);
11   }
12
13   static void bar_static() {
14     std::cout << BOOST_CURRENT_FUNCTION << '\n';
15   }
16
17 private:
18   float bar_private(int x) const {
19     std::cout << BOOST_CURRENT_FUNCTION << '\n';
20   return 0.0;
21   }
22 };
23 } // end namespace FoFum
24
25 namespace {
26 template <typename T>
27 void baz(const T& x)
28 {
29   std::cout << BOOST_CURRENT_FUNCTION << '\n';
30 }
32 } // end unnamed namespace
33
34 int main()
35 {
36   std::cout << BOOST_CURRENT_FUNCTION << '\n';
37   FoFum::Foo f;
38   f.bar();
39   FoFum::Foo::bar_static();
40   baz(f);
41 }
```

根据您的编译器的不同，您看到的输出格式也会有所不同。 GNU 编译器的输出往往更具可读性，而在 Microsoft Visual Studio 上，您将看到一些非常精细的输出，包括调用约定等细节。 特别是，模板实例化的输出在 Visual Studio 上要详细得多。 以下是我在系统上看到的示例输出。

使用 GNU g++：

```cpp
int main()
void FoFum::Foo::bar()
float FoFum::Foo::bar1(int) const
static void FoFum::Foo::bar_static()
void {anonymous}::baz(const T&) [with T = FoFum::Foo]
```

使用 Visual Studio：

```cpp
int __cdecl main(void)
void __thiscall FoFum::Foo::bar(void)
float __thiscall FoFum::Foo::bar1(int) const
void __cdecl FoFum::Foo::bar_static(void)
void __cdecl 'anonymous-namespace'::baz<class FoFum::Foo>(const class FoFum::Foo &)
```

你可以立即看到一些不同之处。 GNU 编译器从非静态方法中调用静态方法。 在 Visual Studio 上，您必须根据调用约定进行区分(静态成员方法和全局方法的`__cdecl`，例如方法的`__thiscall`)。 您可能希望查看`current_function.hpp`头文件，以确定幕后使用了哪些宏。 例如，在 GNU 编译器上，它是`__PRETTY_FUNCTION__`，而在 Visual Studio 上，它是`__FUNCSIG__`。

## 助推。切换

Boost 交换库是另一个有用的微库，是 Boost Core 的一部分：

```cpp
#include <boost/core/swap.hpp>
namespace boost {
  template<typename T1, typename T2>
  void swap(T1& left, T2& right);}
```

它围绕着交换对象包装了一个众所周知的成语。 让我们先看看问题本身，以了解发生了什么。

在`std`名称空间中有一个全局`swap`函数。 在许多情况下，对于在特定名称空间中定义的类型，可以在同一名称空间中提供专门的`swap`重载。 在编写泛型代码时，这可能会带来一些挑战。 假设有一个泛型函数在其参数上调用`swap`：

```cpp
 1 template <typename T>
 2 void process_values(T& arg1, T& arg2, …)
 3 {
 4   …
 5   std::swap(arg1, arg2);
```

在前面的代码片段中，我们在第 5 行调用`std::swap`来执行交换。 虽然这是格式良好的，但在某些情况下可能不会达到预期效果。 请考虑命名空间`X`中的以下类型和函数：

```cpp
 1 namespace X {
 2   struct Foo {};
 3
 4   void swap(Foo& left, Foo& right) { 
 5     std::cout << BOOST_CURRENT_FUNCTION << '\n';
 6   }
 7 }
```

当然，`X::Foo`是微不足道的类型，`X::swap`是无操作的，但是可以用有意义的实现替换它们，我们在这里提出的观点仍然成立。

那么，如果对类型为`X::Foo`的两个参数调用函数`process_values`，会发生什么情况呢？

```cpp
 1 X::Foo f1, f2;
 2 process_values(f1, f2, …); // calls process_values<X::Foo>
```

对`process_values`(第 2 行)的调用将在传递的`X::Foo`实例上调用`std::swap`，即`f1`和`f2`。 然而，我们可能希望在`f1`和`f2`上调用`X::swap`，因为是更合适的重载。 有一种方法可以做到这一点；您可以改为调用`boost::swap`。 以下是`process_values`模板片段的重写：

```cpp
 1 #include <boost/core/swap.hpp>
 2
 3 template <typename T>
 4 void process_values(T& arg1, T& arg2, …)
 5 {
 6   …
 7   boost::swap(arg1, arg2);
```

如果现在运行此代码，您将看到`X::swap`重载将其名称打印到控制台。 要了解`boost::swap`如何设法调用适当的重载，我们需要了解在没有`boost::swap`的情况下如何解决这个问题：

```cpp
 1 template <typename T>
 2 void process_values(T& arg1, T& arg2, …)
 3 {
 4   …
 5   using std::swap;
 6   swap(arg1, arg2);
```

如果我们没有`using`声明(第 5 行)，对`swap`(第 6 行)的调用仍然会成功，因为在名称空间中定义的类型`T`具有为`T`定义的`swap`重载-这要归功于**参数依赖查找**(**ADL**)-`X::Foo`加上`X::swap`，就是这样的类型。 然而，对于在全局命名空间中定义的类型(假设您没有在全局命名空间中定义泛型`swap`)，它将失败。 使用`using`声明(第 5 行)，我们为对`swap`(第 6 行)的非限定调用创建后备。 当 ADL 成功找到名称空间级别`swap`重载时，对`swap`的调用将解析为此重载。 当 ADL 找不到这样的重载时，则按照`using`声明的规定使用`std::swap`。 问题是，这是一个不明显的把戏，你必须知道它才能使用它。 并不是您团队中的每个工程师都会为配备 C++ 中的所有名称查找规则。 同时，他可以随时使用`boost::swap`，它实质上将这段代码包装在一个函数中。 您现在可以只使用`swap`的一个版本，并期望每次都调用最合适的重载。

## 编译时断言

编译时断言需要特定条件才能在代码中的某个点保持为真。 任何违反条件的行为都会导致编译在该点失败。 这是一种在编译时查找错误的有效方法，否则会在运行时造成严重的损失。 它还可以帮助减少由于模板实例化失败而生成的那种编译器错误消息的数量和繁琐程度。

运行时断言旨在确认某些条件的不变性，这些条件在代码中的某个点必须为真。 这种情况可能是所使用的逻辑或算法的结果，也可能是基于某些文档约定的结果。 例如，如果您正在编写一个函数来将一个数字求幂，那么如何处理数字和幂都为零的数学上未定义的情况呢？ 您可以使用 Assert 来显式地表达这一点，如以下代码片段(第 6 行)所示：

```cpp
 1 #include <cassert>
 2
 3 double power(double base, double exponent)
 4 {
 5   // no negative powers of zero
 6   assert(base != 0 || exponent > 0);
 7   …
 8 }
```

任何违反此类不变量的行为都表示存在需要修复的 bug 或缺陷，并会导致调试版本中程序的灾难性故障。 Boost 提供了一个名为`BOOST_STATIC_ASSERT`的宏，该宏接受一个表达式，该表达式可以在编译时求值，如果该表达式求值为 false，则会触发编译失败。

例如，您可能设计了一个内存分配器类模板，该模板仅用于“小”对象。 当然，小是任意的，但您可以将分配器设计为针对 16 字节或更小的对象进行优化。 如果您想强制正确使用您的类，只需阻止它对任何大小超过 16 字节的类进行实例化即可。 下面是我们的第一个`BOOST_STATIC_ASSERT`示例，它可以帮助您实施分配器的小对象语义：

**清单 2.16a：使用编译时断言**

```cpp
 1 #include <boost/static_assert.hpp>
 2
 3 template <typename T>
 4 class SmallObjectAllocator
 5 {
 6   BOOST_STATIC_ASSERT(sizeof(T) <= 16);
 7
 8 public:
 9   SmallObjectAllocator() {}
10 };
```

我们定义了名为`SmallObjectAllocator`的虚拟分配器模板(第 3 行和第 4 行)，并在类作用域中调用`BOOST_STATIC_ASSERT`宏(第 6 行)。 我们向宏传递一个表达式，该表达式必须能够在编译时求值。 现在，`sizeof`表达式总是由编译器求值，而 16 是整型文字，因此表达式`sizeof(T) <= 16`可以在编译时完全求值，并可以传递给`BOOST_STATIC_ASSERT`。 如果我们现在用大小为 32 字节的类型`Foo`实例化`SmallObjectAllocator`，我们将得到一个编译器错误，这是由于第 6 行上的静态断言。下面是可以触发断言的代码：

**清单 2.16b：使用编译时断言**

```cpp
11 struct Foo
12 {
13   char data[32];
14 };
15
16 int main()
17 {
18   SmallObjectAllocator<int> intAlloc;
19   SmallObjectAllocator<Foo> fooAlloc; // ERROR: sizeof(Foo) > 16
20 }
```

我们定义了一个大小为 32 字节的类型`Foo`，它大于`SmallObjectAllocator`支持的最大值(第 13 行)。 我们使用类型`int`(第 18 行)和`Foo`(第 19 行)实例化`SmallObjectAllocator`模板。 `SmallObjectAllocator<Foo>`的编译失败，我们得到一条错误消息。

### 提示

C++ 11 支持使用 new`static_assert`关键字的编译时断言。 如果您使用的是 C++ 11 编译器，则`BOOST_STATIC_ASSERT`在内部使用`static_assert`。

不同的编译器，特别是在 C++ 03 编译器上，实际的错误消息自然会有所不同。 在 C++ 11 编译器上，因为这在内部使用`static_assert`关键字，所以错误消息往往更统一、更有意义。 然而，在 C++ 11 之前的编译器上，您也可以相当准确地了解有问题的行。 在我的系统上，在 C++ 03 模式下使用 GNU g++ 编译器时，我得到以下错误：

```cpp
StaticAssertTest.cpp: In instantiation of 'class SmallObjectAllocator<Foo>':
StaticAssertTest.cpp:19:29:   required from here
StaticAssertTest.cpp:6:3: error: invalid application of 'sizeof' to incomplete type 'boost::STATIC_ASSERTION_FAILURE<false>'
```

编译器错误的最后一行引用了一个不完整的类型`boost::STATIC_ASSERTION_FAILURE<false>`，该类型来自于`BOOST_STATIC_ASSERT`宏的内部。 很明显，第 6 行出现错误，静态断言失败。 如果我切换到 C++ 11 模式，错误消息会清楚得多：

```cpp
StaticAssertTest.cpp: In instantiation of 'class SmallObjectAllocator<Foo>':
StaticAssertTest.cpp:19:29:   required from here
StaticAssertTest.cpp:6:3: error: static assertion failed: sizeof(T) <= 16
```

静态断言宏还有另一个变体`BOOST_STATIC_ASSERT`，它接受消息字符串作为第二个参数。 使用 C++ 11 编译器，它只需为错误消息打印此消息。 在 C++ 11 之前的编译器中，此消息可能会出现在编译器错误内容中，也可能不会出现。 您可以这样使用它：

```cpp
 1 BOOST_STATIC_ASSERT_MSG(sizeof(T) <= 16, "Objects of size more" 
 2                         " than 16 bytes not supported.");
```

并非所有表达式都可以在编译时求值。 通常，涉及常量整数、类型大小和常规类型计算的表达式可以在编译时计算。 Boost TypeTraits 库和 Boost**元编程库**(**MPL**)提供了几个元函数，使用这些函数可以在编译时检查类型上的许多复杂条件。 我们用一个小例子来说明这种用法。 我们将在后面的章节中看到更多这种用法的例子。

我们不仅可以在类作用域中使用静态断言，还可以在函数和命名空间作用域中使用静态断言。 下面是一个函数模板库的示例，该函数模板库允许对不同 POD 类型进行逐位操作。 实例化这些函数时，我们在编译时断言传递的类型是 POD 类型：

**清单 2.17：使用编译时断言**

```cpp
 1 #include <boost/static_assert.hpp>
 2 #include <boost/type_traits.hpp>
 3
 4 template <typename T, typename U>
 5 T bitwise_or (const T& left, const U& right)
 6 {
 7   BOOST_STATIC_ASSERT(boost::is_pod<T>::value && 
 8                       boost::is_pod<U>::value);
 9   BOOST_STATIC_ASSERT(sizeof(T) >= sizeof(U));
10
11   T result = left;
12   unsigned char *right_array =
13           reinterpret_cast<unsigned char*>(&right);
14   unsigned char *left_array =
15           reinterpret_cast<unsigned char*>(&result);
16   for (size_t i = 0; i < sizeof(U); ++ i) {
17     left_array[i] |= right_array[i];
18   }
19
20   return result;
21 }
```

这里，我们定义了一个函数`bitwise_or`(第 4 行和第 5 行)，该函数接受两个可能具有不同类型和大小的对象，并返回其内容的位或。 在此函数内部，我们使用元函数`boost::is_pod<T>`断言传递的两个对象都是 POD 类型(第 7 行)。 此外，因为函数的返回类型是`T`，也就是左参数的类型，所以我们断言必须首先使用较大的参数调用函数(第 9 行)，这样才不会丢失数据。

## 使用预处理器宏进行诊断

在我的软件工程师职业生涯中，我曾多次使用单一代码库开发基于五种不同风格的 Unix 和 Windows 的产品，这些产品通常是并行的。 这些构建服务器通常是大型铁质服务器，带有数百 GB 的附加存储，可供多个产品用于构建目的。 同一服务器上将有无数的环境、工具链和配置。 肯定花了很长时间才把这些系统稳定到一切都完美无瑕的地步。 有一天，所有的地狱都爆发了，一夜之间，没有任何重要的签入，我们的软件开始变得奇怪。 我们花了几乎一天的时间才发现有人对环境变量进行了修补，因此我们使用不同版本的编译器进行链接，并使用与构建第三方库时不同的运行时进行链接。 我不需要告诉您，即使在构建系统存在的时候，这对于构建系统来说也不是理想的。 不幸的是，您可能仍然会发现这种混乱的环境需要很长时间才能建立起来，然后由于轻率的更改而被破坏。 在半天的徒劳之后，节省了我们的是在程序启动时使用预处理器宏来转储有关构建系统的信息(包括编译器名称、版本、体系结构等)的良好意识。 在程序不可避免地崩溃并发现编译器不匹配之前，我们很快就可以从程序转储的数据中收集到足够的信息。

对于能够通过利用特定接口并根据预处理器宏定义进行有条件的代码编译，从而能够在每个编译器或平台上提供最佳库实现的库编写者来说，这样的信息是非常有用的。 然而，使用这类宏的危害在于，不同的编译器、平台和环境在它们的命名方式和功能方面存在绝对差异。 Boost 提供了一组更加统一的预处理器宏集，用于通过其`Config`和`Predef`库收集有关软件构建环境的信息。 我们将看看这些库中的几个有用的宏。

`Predef`库是一个仅包含头文件的库，它提供了各种宏，用于在编译时获取有关构建环境的有用信息。 可用的信息可以分为不同的类别。 我们将查看以下代码来说明如何访问和使用这些信息，而不是提供一长串选项并解释它们的作用(这项工作在联机文档中做得很充分)：

**清单 2.18a：使用来自 predef**的诊断宏

```cpp
 1 #include <boost/predef.h>
 2 #include <iostream>
 3
 4 void checkOs()
 5 {
 6   // identify OS
 7 #if defined(BOOST_OS_WINDOWS)
 8   std::cout << "Windows" << '\n';
 9 #elif defined(BOOST_OS_LINUX)
10   std::cout << "Linux" << '\n';
11 #elif defined(BOOST_OS_MACOS)
12   std::cout << "MacOS" << '\n';
13 #elif defined(BOOST_OS_UNIX)
14   std::cout << Another UNIX" << '\n'; // *_AIX, *_HPUX, etc. 
15 #endif
16 }
```

前面的函数使用`Predef`库中的`BOOST_OS_*`宏来标识构建代码的操作系统。 我们只显示了三个不同操作系统的宏。 在线文档提供了用于标识不同操作系统的宏列表。

**清单 2.18B：使用来自 Predef**的诊断宏

```cpp
 1 #include <boost/predef.h>
 2 #include <iostream>
 34 void checkArch()
 5 {
 6   // identify architecture
 7 #if defined(BOOST_ARCH_X86)
 8  #if defined(BOOST_ARCH_X86_64)
 9   std::cout << "x86-64 bit" << '\n';
10  #else
11   std::cout << "x86-32 bit" << '\n';
12  #endif
13 #elif defined(BOOST_ARCH_ARM)
14   std::cout << "ARM" << '\n';
15 #else
16   std::cout << "Other architecture" << '\n';
17 #endif
18 }
```

前面的函数使用`Predef`库中的`BOOST_ARCH_*`宏来标识构建代码的平台的体系结构。 我们只展示了 x86 和 ARM 体系结构的宏；在线文档提供了用于标识不同体系结构的完整宏列表。

**清单 2.18c：使用来自 predef**的诊断宏

```cpp
 1 #include <boost/predef.h>
 2 #include <iostream>
 3
 4 void checkCompiler()
 5 {
 6   // identify compiler
 7 #if defined(BOOST_COMP_GNUC)
 8   std::cout << "GCC, Version: " << BOOST_COMP_GNUC << '\n';
 9 #elif defined(BOOST_COMP_MSVC)
10   std::cout << "MSVC, Version: " << BOOST_COMP_MSVC << '\n';
11 #else
12   std::cout << "Other compiler" << '\n';
13 #endif
14 }
```

前面的函数使用`Predef`库中的`BOOST_COMP_*`宏来标识用于构建代码的编译器。 我们只展示了 GNU 和 Microsoft Visual C++ 编译器的宏。 联机文档提供了用于标识不同编译器的完整宏列表。 定义后，特定编译器的`BOOST_COMP_*`宏求值为其数字版本。 例如，在 Visual Studio2010 上，`BOOST_COMP_MSVC`的计算结果为`100030319`。 这可以翻译为版本`10.0.30319`：

**清单 2.18d：使用来自 predef**的诊断宏

```cpp
 1 #include <boost/predef.h>
 2 #include <iostream>
 3
 4 void checkCpp11()
 5 {
 6   // Do version checks
 7 #if defined(BOOST_COMP_GNUC)
 8  #if BOOST_COMP_GNUC < BOOST_VERSION_NUMBER(4, 8, 1)
 9    std::cout << "Incomplete C++ 11 support" << '\n';
10  #else
11    std::cout << "Most C++ 11 features supported" << '\n';
12  #endif
13 #elif defined(BOOST_COMP_MSVC)
14  #if BOOST_COMP_MSVC < BOOST_VERSION_NUMBER(12, 0, 0)
15    std::cout << "Incomplete C++ 11 support" << '\n';
16  #else
17    std::cout << "Most C++ 11 features supported" << '\n';
18  #endif
19 #endif
20 }
```

在前面的代码中，我们使用`BOOST_VERSION_NUMBER`宏来构造与 GNU 或 Microsoft Visual C++ 编译器的当前版本进行比较的版本。 如果 GNU 编译器版本低于 4.8.1 或 Microsoft Visual Studio C++ 编译器版本低于 12.0，我们将打印出对 C++ 11 的支持可能不完整。

在本节的最后一个示例中，我们使用`boost/config.hpp`中的宏来打印编译器、平台和运行时库名称(第 6、7 和 8 行)。 我们还使用`boost/version.hpp`中定义的两个宏将使用的 Boost 版本打印为字符串(第 10 行)和数字值(第 11 行)：

**清单 2.19：使用配置信息宏**

```cpp
 1 #include <boost/config.hpp>
 2 #include <boost/version.hpp>
 3 #include <iostream>
 4 
 5 void buildEnvInfo() {
 6   std::cout << "Compiler: " << BOOST_COMPILER << '\n'
 7             << "Platform: " << BOOST_PLATFORM << '\n'
 8             << "Library: " << BOOST_STDLIB << '\n';
 9
10   std::cout << "Boost version: " << BOOST_LIB_VERSION << '['
11                             << BOOST_VERSION << ']' << '\n';
12 }
```

# 自测题

对于多项选择题，请选择适用的所有选项：

1.  What are the advantages of using `boost::swap` over `std::swap`?

    A.没有真正的优势

    B.`boost::swap`调用与传递的类型一起提供的交换重载(如果有

    C.`boost::swap`比`std::swap`快

    D.`boost::swap`不抛出异常

2.  Can you apply a visitor to multiple variant arguments in a single call? (*Hint*: you may want to look up the online documentation)

    答：是的。 访问器只能应用于一个或两个变体参数

    是的。 访问者可以应用于一个或多个参数

    C.不是。 成员运算符只接受一个变量参数

    D.以上都不是

3.  Is the following a valid compile-time assert?

    `BOOST_STATIC_ASSERT(x == 0); // x is some variable`

    A.可以，只要`x`为整型

    B.可以，只要`x`声明为`const static`数值变量

    C.否，`x`是一个变量，编译时不能知道它的值

    D.只有包含`sizeof`的表达式才在`BOOST_STATIC_ASSERT`中有效

4.  What do we mean when we say that a type `X` is a POD type?

    A.`X`没有用户定义的构造函数或析构函数

    B.`X`可以通过逐位复制其内存布局来复制

    C.`X`没有用户定义的复制构造函数或复制赋值运算符

    D.以上所有事项

5.  What is the type and value stored in a default-constructed object of type `boost::variant<std::string, double>`?

    A.类型为`const char*`，值为`NULL`

    B.类型为`double`，值为`0.0`

    C.类型为`std::string` ，值为默认构造的`std::string`

    D.类型为`boost::optional<double>` ，值为空

6.  Check the reference on Boost.Optional in the online documentation for the latest Boost libraries. What happens if you call the `get` and `get_ptr` methods on an empty `optional` object?

    A.两者都抛出`boost::empty_optional`异常

    B.`get`抛出异常，而`get_ptr`返回空指针

    C.`get`断言，而`get_ptr`返回空指针

    D.`get`和`get_ptr`都断言

# 摘要

本章简要介绍了几个 Boost 库，它们可以帮助您完成重要的编程琐事，例如解析命令行、创建类型安全的变量类型、处理空值以及执行编译时检查。

希望您已经欣赏到 Boost 中库的多样性以及它们为您的代码带来的表现力。 在此过程中，您还会更加熟悉如何编译使用 Boost 库的代码，并根据需要链接到适当的库。

在下一章中，我们将介绍如何使用各种类型的 Boost 智能指针以异常安全的方式确定地管理堆内存和其他资源。

# 发文：2013 年 2 月 10 日星期日下午 12：00

奇怪的重复出现的模板模式：[https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Curiously_Recurring_Template_Pattern)