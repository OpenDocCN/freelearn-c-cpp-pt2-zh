# 检测面部部位和覆盖面具

在[第 6 章](06.html)和*学习对象分类*中，我们了解了对象分类以及如何使用机器学习来实现对象分类。 在本章中，我们将学习如何检测和跟踪不同的人脸部位。 我们将从了解人脸检测管道及其构建方式开始讨论。 然后，我们将使用此框架来检测面部部分，如眼睛、耳朵、嘴巴和鼻子。 最后，我们将学习如何在直播视频中将有趣的面具覆盖在这些面部部位上。

学完本章后，我们应该熟悉以下主题：

*   了解哈尔叶栅
*   整体图像以及我们为什么需要它们
*   构建通用人脸检测流水线
*   探测和跟踪..。

# 技术要求

本章要求基本熟悉 C++ 编程语言。 本章中使用的所有代码都可以从以下 gihub 链接下载：*[https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_07](https://github.com/PacktPublishing/Learn-OpenCV-4-By-Building-Projects-Second-Edition/tree/master/Chapter_07)。*这些代码可以在任何操作系统上执行，尽管它只在 Ubuntu 上测试过。

请查看以下视频，了解实际操作中的代码：
[http://bit.ly/2SlpTK6](http://bit.ly/2SlpTK6)

# 了解哈尔叶栅

Haar 级联是基于 Haar 特征的级联分类器。 什么是级联分级机？ 它只是一组可用于创建强分类器的弱分类器的串联。 我们所说的**弱**和**强**分类器是什么意思？ 弱分类器是性能有限的分类器。 他们没有能力正确地对所有东西进行分类。 如果你让问题变得非常简单，他们可能会表现在可以接受的水平。 另一方面，强分类器非常擅长对我们的数据进行正确的分类。 在接下来的几个段落中，我们将看到这一切是如何结合在一起的。 Haar 级联的另一个重要部分是**Haar 特性**。 这些特征是对……的简单概括。

# 什么是整体图像？

为了提取这些 Haar 特征，我们必须计算包含在图像的许多矩形区域中的像素值的总和。 为了使其具有比例不变性，我们需要在多个比例下计算这些面积(对于不同的矩形大小)。 如果实现得很幼稚，这将是一个计算非常密集的过程；因为我们将不得不迭代每个矩形的所有像素，包括多次读取相同的像素(如果它们包含在不同的重叠矩形中)。 如果你想构建一个可以实时运行的系统，你不能在计算上花费这么多时间。 在面积计算过程中，我们需要找到一种方法来避免这种巨大的冗余，因为我们在相同的像素上迭代了多次。 为了避免这种情况，我们可以使用一种叫做积分图像的东西。 这些图像可以在线性时间初始化(通过在图像上仅迭代两次)，然后通过仅读取四个值来提供任意大小的任意矩形内的像素总和。 为了更好地理解它，我们来看下图：

![](Images/17189123-7d03-4a17-a954-222e9ca17c79.png)

如果我们想要计算图表中任何矩形的面积，我们不必遍历该区域中的所有像素。 让我们考虑一个由图像中左上角的点和任意点 P 组成的矩形作为对角点。 设 A<sub>P</sub>表示该矩形的面积。 例如，在上图中，A<sub>B</sub>表示将左上点和**B**作为对角点形成的 5x2 矩形的面积。 为了清楚起见，让我们看一下下图：

![](Images/fb75616a-63ba-49d5-8c05-d2cdfae54485.png)

让我们考虑一下上图中的左上角正方形。 蓝色像素表示左上角像素和点**A**之间的区域。 这由 A<sub>A</sub>表示。 其余的图表由各自的名称表示：A<sub>B</sub>、A<sub>C</sub>和 A<sub>D</sub>。 现在，如果我们要计算矩形的面积，如上图所示，我们将使用以下公式：

**矩形面积**：*ABCD*=*A<sub>C</sub>*-(*A<sub>B</sub>*+*A<sub>D</sub>*-*A<sub>A</sub>*)

这个特别的配方有什么特别之处？ 众所周知，从图像中提取 Haar 特征包括计算这些求和，我们将不得不对图像中许多不同尺度的矩形进行求和。 很多这样的计算都是重复的，因为我们会一遍又一遍地重复相同的像素。 速度如此之慢，以至于建立一个实时系统是不可行的。 因此，我们需要这个公式。 如您所见，我们不必多次迭代相同的像素。 如果我们要计算任何矩形的面积，前面公式右侧的所有值在积分图像中都很容易得到。 我们只需选取正确的值，将它们替换到前面的方程式中，然后提取特征即可。

# 在直播视频中叠加口罩

OpenCV 提供了一个很好的人脸检测框架。 我们只需要加载级联文件，并使用它来检测图像中的人脸。 当我们从网络摄像头捕捉到视频流时，我们可以将滑稽的面具覆盖在我们的脸上。 它看起来如下所示：

![](Images/4b3881f9-9bf6-4642-864b-b47979fcd9dc.png)

让我们看一下代码的主要部分，看看如何在输入视频流的面部覆盖这个蒙版。 在随本书提供的可下载代码包中提供了完整的代码：

```cpp
#include "opencv2/core/utility.hpp"#include "opencv2/objdetect/objdetect.hpp"#include "opencv2/imgproc.hpp"#include "opencv2/highgui.hpp"using namespace ...
```

# 代码里发生了什么？

首先要注意的是，这段代码有两个输入参数-**face ascade XML**文件和**掩码图像**。 您可以使用`resources`文件夹下提供的`haarcascade_frontalface_alt.xml`和`facemask.jpg`文件。 我们需要一个可用于检测图像中人脸的分类器模型，OpenCV 提供了一个可用于此目的的预构建 XML 文件。 我们使用`faceCascade.load()`函数加载 XML 文件，并检查文件是否加载正确。 我们启动视频捕获对象来捕获来自网络摄像头的输入帧。 然后我们将其转换为灰度以运行检测器。 函数的作用是提取输入图像中所有人脸的边界。 我们可能需要根据需要缩小图像，因此此函数中的第二个参数可以解决这一问题。 此比例因子是我们在每个比例下进行的跳跃；由于我们需要在多个比例下查找面，因此下一个大小将是当前大小的 1.1 倍。 最后一个参数是阈值，它指定保留当前矩形所需的相邻矩形的数量。 它可以用来增加人脸检测器的鲁棒性。 我们开始`while`循环，并在每一帧中持续检测人脸，直到用户按下*Esc*键。 一旦我们检测到一张脸，我们需要在它上面覆盖一个面具。 我们可能需要稍微修改一下尺寸，以确保面罩合身。 此自定义稍有主观性，它取决于所使用的遮罩。 现在我们已经提取了感兴趣的区域，我们需要将遮罩放置在该区域的顶部。 如果我们用白色背景覆盖面具，它看起来会很奇怪。 我们必须提取蒙版的精确曲线边界，然后将其覆盖。 我们希望头骨蒙版像素是可见的，其余区域应该是透明的。

正如我们所看到的，输入掩码的背景是白色的。 因此，我们通过对蒙版图像应用阈值来创建蒙版。 使用试错法，我们可以看到阈值`240`运行良好。 在图像中，强度值大于`240`的所有像素将变为`0`，所有其他像素将变为`255`。 就感兴趣的区域而言，我们必须将该区域内的所有像素都涂黑。 要做到这一点，我们只需使用刚刚创建的蒙版的反面。 在最后一步中，我们只需添加掩码版本即可生成最终输出图像。

# 戴上你的太阳镜

既然我们了解了如何检测人脸，我们就可以将这个概念推广到检测人脸的不同部位。 我们将在直播视频中使用眼睛探测器覆盖太阳镜。 重要的是要理解 Viola-Jones 框架可以应用于任何对象。 准确性和健壮性将取决于对象的唯一性。 例如，人脸有非常独特的特征，所以很容易训练我们的系统变得健壮。 另一方面，像毛巾这样的物体太通用了，没有明显的特征，所以很难构建一个健壮的毛巾检测器。 一旦你建造了眼睛探测器并覆盖了眼镜，它看起来就像这样：

让我们..。

# 查看代码内部

您可能已经注意到，代码流看起来与我们在直播视频中的*覆盖面膜部分中讨论的人脸检测代码类似。 我们加载了人脸检测级联分类器和眼睛检测级联分类器。 那么，为什么我们在检测眼睛的时候需要加载人脸级联分类器呢？ 嗯，我们并不真的需要使用面部检测器，但它可以帮助我们限制对眼睛位置的搜索。 我们知道眼睛总是位于某人的脸上，所以我们可以将眼睛检测限制在面部区域。 第一步是检测脸部，然后在这个区域运行我们的眼睛探测器代码。 由于我们将在较小的地区开展业务，因此速度会更快，效率也会更高。*

对于每一帧，我们从检测人脸开始。 然后我们继续对这个区域进行手术来检测眼睛的位置。 在这一步之后，我们需要覆盖太阳镜。 要做到这一点，我们需要调整太阳镜图像的大小，以确保它适合我们的脸。 为了获得合适的比例，我们可以考虑被检测的两只眼睛之间的距离。 只有当我们察觉到两只眼睛时，我们才会戴上太阳镜。 这就是为什么我们首先运行眼睛探测器，收集所有的中心，然后覆盖太阳镜。 一旦我们有了这个，我们只需要盖上太阳镜面具。 用于遮罩的原理与我们用于覆盖面膜的原理非常相似。 您可能需要定制太阳镜的大小和位置，具体取决于您想要的。 你可以玩不同类型的太阳镜，看看它们是什么样子。

# 跟踪鼻子、嘴巴和耳朵

既然您知道了如何使用该框架跟踪不同的东西，那么您也可以尝试跟踪您的鼻子、嘴巴和耳朵了。 让我们用鼻子探测器覆盖一个滑稽的鼻子：

![](Images/b51f1ac4-21ab-427a-bed0-ad67d269f491.png)

您可以参考代码文件了解该检测器的完整实现。 `haarcascade_mcs_nose.xml`、`haarcascade_mcs_mouth.xml`、`haarcascade_mcs_leftear.xml`和`haarcascade_mcs_rightear.xml`级联文件可用于跟踪不同的面部分。 和他们一起玩耍，试着把胡子或德古拉耳朵盖在自己身上。

# 简略的 / 概括的 / 简易判罪的 / 简易的

在这一章中，我们讨论了 Haar 级联和积分像。 我们了解了人脸检测管道是如何构建的。 我们学习了如何检测和跟踪实时视频流中的人脸。 我们讨论了使用人脸检测框架来检测各种人脸部位，如眼睛、耳朵、鼻子和嘴巴。 最后，我们学习了如何利用人脸部分检测的结果在输入图像上叠加蒙版。

在下一章中，我们将学习视频监控、背景去除和形态学图像处理。