# *第 10 章*: C ++ 中的编译器优化

在上一章中，我们了解了 C 程序效率低下的主要原因。消除这些低效率的负担主要落在程序员身上。但是，编译器也可以做很多事情来使程序更快。这就是我们现在要探索的。

本章将介绍编译器优化这一非常重要的问题，以及程序员如何帮助编译器生成更高效的代码。

在本章中，我们将介绍以下主要主题:

*   编译器如何优化代码
*   编译器优化的限制
*   如何从编译器中获得最佳优化

# 技术要求

同样，您将需要一个 C 编译器和一个微基准测试工具，例如我们在上一章中使用的Google 基准库 (在[https://github.com/google/benchmark](https://github.com/google/benchmark)找到)。本章随附的代码可在[https://github.com/PacktPublishing/ 高效程序/tree/master/Chapter10](https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter10)中找到。

您还将需要一种方法来检查编译器生成的汇编代码。许多开发环境都有一个显示程序集的选项，GCC 和 Clang 可以写出程序集而不是目标代码，调试器和其他工具可以从目标代码生成程序集 (反汇编它)。使用哪种工具取决于个人喜好。

# 编译器优化代码

优化编译器对于实现高性能至关重要。只需尝试运行一个没有优化的程序就可以理解编译器的作用: 一个未优化的程序 (优化级别为零) 运行的速度比启用所有优化的编译程序慢一个数量级的速度并不少见。

但是，通常情况下，优化器可以使用程序员的一些帮助。这种帮助可以采取非常微妙且经常违反直觉的变化的形式。在我们看一些改进代码优化的特定技术之前，它有助于了解编译器如何看待您的程序。

## 编译器优化基础

关于优化，您必须了解的最重要的事情是，任何正确的代码都必须保持正确。*正确*这里与你对什么是正确的看法无关: 程序可能有 bug，给出一个你认为错误的答案，但是编译器必须保留这个答案。唯一的例外是定义不明确或调用未定义行为的程序: 如果该程序在标准眼中是不正确的，则编译器可以自由地做任何它想做的事情。我们将在下一章研究这方面的含义。现在，我们将假设该程序定义良好，并且仅使用有效的 C。当然，由于要求答案不得针对任何输入组合更改，因此编译器可以进行哪些更改。后者非常重要: 您可能知道某个输入值始终为正，或者某个字符串的长度永远不会超过 16 个字符，但是编译器不知道 (除非您找到一种方法来告诉它)。编译器只有在可以证明此转换产生完全等效的程序时才能进行优化转换: 该程序可以为任何输入产生相同的输出。实际上，编译器在放弃之前可以管理的证明的复杂性也受到限制。

这种理解*这不是你所知道的，而是你可以证明*的是通过代码成功地与编译器交互以实现更好的优化的关键。基本上，本章的其余部分展示了不同的方式，您可以更轻松地证明某些理想的优化不会改变程序的结果。

编译器在有关程序的信息方面也受到限制。它只能使用在**编译时**已知的内容，不了解任何运行时数据，并且必须假设任何合法状态在运行时都是可能的。

这里有一个简单的例子来说明这一点。首先，考虑以下代码:

```
std::vector<int> v;
… fill v with data … 
for (int& x : v) ++x;
```

我们关注的焦点是最后一行，循环。如果手动展开循环，性能可能会更好: 如所写，每个增量都有一个分支 (循环终止条件)。展开循环可以减少这种开销。在一个只有两个元素的向量的简单情况下，更好的是完全删除循环，只增加两个元素。但是，向量的大小是运行时信息的一个示例。编译器可能能够生成带有一些额外分支的部分展开的循环来处理所有可能的向量大小，但是它不能针对特定大小优化代码。

将其与以下代码进行对比:

```
int v[16];
… fill v with data … 
for (int& x : v) ++x;
```

现在编译器确切地知道在循环中处理了多少个整数。它可以展开循环，甚至可以用一次对几个数字进行操作的向量指令替换单个整数增量 (例如，x86 上的 AVX2 指令集可以一次添加 8 个整数)。

如果你知道向量总是有 16 个元素呢？可能没关系。重要的是编译器是否知道这一点并可以肯定地证明这一点。这比你想象的要难。例如，考虑以下代码:

```
constexpr size_t N = 16;
std::vector<int> v(N);
… fill v with data … 
for (int& x : v) ++x;
```

程序员竭尽全力使向量大小很明显是编译时常数。编译器要优化循环吗？可能这完全取决于编译器能否证明向量大小不变。它将如何改变？问问自己，填充向量的代码中可能隐藏了什么？不是您所知道的，而是可以从代码本身中学到什么？如果所有代码都写在两行之间，即构造和增量循环，则从理论上讲，编译器可以知道所有内容 (实际上，如果这个代码片段太长，编译器将放弃，并假设*任何事情都是可能的*，否则编译时间将爆炸)。但是，如果您调用一个函数并且该函数可以访问 vector 对象，则编译器无法知道该函数是否会更改向量的大小，除非该函数是内联的。像`fill_vector_without_resizing()`这样有用的函数名称只对程序员有帮助。

即使没有将`v`作为参数的函数调用，我们仍然不清楚。该函数还能如何访问向量对象？如果向量`v`是在函数作用域中声明的局部变量，则可能不能。但是如果`v`是一个全局变量，那么任何函数都可以访问它。同样，如果`v`是一个类成员变量，则任何成员函数或朋友函数都可以访问它。因此，如果我们调用一个非内联函数，它不能通过其参数列表直接访问`v`，它可能仍然能够通过其他方式访问`v` (而关于创建全局指针到局部变量的真正邪恶的做法，越好)。

从程序员的角度来看，基于程序员对程序中真正发生的事情的了解，很容易高估编译器所拥有的知识。另外，请记住，在大多数情况下，*令人费解的事情*并不是编译器的长处之一。例如，您可以在循环之前添加`assert`:

```
constexpr size_t N = 16;
std::vector<int> v(N);
… fill v with data … 
assert(v.size() == N); // if (v.size() != N) abort();
for (int& x : v) ++x;
```

一些编译器，在最高的优化级别和简单的上下文中，将推断执行流无法到达循环，除非向量正好有 16 个元素，并将针对该大小进行优化。大多数人不会。顺便说一句，我们假设断言已启用 (`NDEBUG`未定义)，或者您使用自己的断言。

我们已经考虑的基本示例已经具有用于帮助编译器优化代码的技术的关键元素:

*   非内联函数会破坏大多数优化，因为编译器必须假设其代码看不到的函数可以执行法律允许的任何操作。
*   全局变量和共享变量对于优化来说是可怕的。
*   与长而复杂的代码片段相比，编译器更有可能优化一个短而简单的代码片段。

第一个和最后一个概念有些冲突。编译器中的大多数优化仅限于所谓的基本代码块: 这些代码块只有一个入口点和一个出口点。它们充当程序的流控制图中的节点。基本块很重要的原因是编译器可以看到块内部正在发生的所有事情，因此它可以对不更改输出的代码转换进行推理。内联的优点是增加了基本块的大小。编译器不知道非内联函数的作用，因此它必须假设最坏的情况。但是，如果函数是内联的，编译器确切地知道它在做什么 (更重要的是，它没有做什么)。内联的缺点还在于它增加了基本块的大小: 编译器只能分析这么多代码，而不会使编译时间不合理。内联对于编译器优化非常重要，因为我们现在要探讨的原因。

## 函数内联

内联是由编译器在用函数主体的副本替换函数调用时完成的。为了使这种情况发生，内联必须是可能的: 函数的定义必须在调用代码的编译过程中可见，并且在编译时必须知道正在调用的函数。在一些进行整个程序优化 (仍然不常见) 的编译器中，第一个要求被放宽了。第二个需求通过函数指针排除了虚函数调用和间接调用。并非每个可以内联的函数最终都被内联: 编译器必须权衡代码膨胀和内联的好处。不同的编译器对内联有不同的启发式方法。C ++ 的`inline`关键字只是一个建议，编译器可以忽略它。

函数调用内联最明显的好处是它消除了函数调用本身的成本。在大多数情况下，这也是最不重要的好处: 函数调用不是那么昂贵。主要的好处是，编译器在对函数调用的优化上非常有限。考虑这个简单的例子:

```
double f(int& i, double x) {
  double res = g(x);
  ++i;
  res += h(x);
  res += g(x);
  ++i;
  res += h(x);
  return res;
}
```

以下是有效的优化吗？

```
double f(int& i, double x) {
  i += 2;
  return 2*(g(x) + h(x));
}
```

如果您回答*是*，您仍然是通过程序员的眼睛而不是编译器的眼睛来看待这个问题。有这么多的方式，这种优化可以打破代码 (没有一个可能是正确的任何合理的程序，你会写，但一个假设编译器不能做的是一个合理的程序员)。

*   首先，函数`g()`和`h()`可以产生输出，在这种情况下，消除重复的函数调用将改变可观察的行为。
*   其次，调用`g()`可能会锁定一些互斥锁，而调用`h()`可能会解锁它，在这种情况下，执行顺序-调用`g()`锁定，增量`i`，调用`h()`解锁-非常重要。
*   第三，即使使用相同的参数，`g()`和`h()`的结果也可能不同: 例如，它们可以在内部使用随机数。
*   最后 (这种可能性最常被程序员错过)，变量`i`通过引用传递，所以我们不知道调用者可能会用它做什么: 它可能是一个全局变量，或者一些对象可能存储对它的引用，所以，一种或另一种方式，函数`g()`和`h()`可能在`i`上运行，即使我们没有看到它被传递到这些函数中。

另一方面，如果函数`g()`和`h()`内联，则编译器可以准确地看到发生了什么，例如:

```
double f(int& i, double x) {
  double res = x + 1; // g(x);
  ++i;
  res += x – 1; // h(x);
  res += x + 1; // g(x)
  ++i;
  res += x – 1; // h(x);
  return res;
}
```

整个函数`f()`现在是一个基本块，编译器只有一个限制: 保留返回的值。这是一个有效的优化:

```
double f(int& i, double x) {
  i += 2;
  return 4*x;
}
```

内联对优化的影响可以*滴流*相当远。考虑 STL 容器的析构函数，例如`std::vector<T>`。它必须做的步骤之一是调用容器中所有对象的析构函数:

```
for (auto it = crbegin(); it != crend(); ++it) it->~T();
```

因此，析构函数的执行时间与向量的大小`N`成正比。除非不是: 考虑整数向量，`std::vector<int>`。编译器非常清楚析构函数在这种情况下的作用: 绝对没有。编译器可以还可以看到对`crbegin()`和`crend()`的调用不会修改向量 (如果您担心通过`const_iterator`破坏对象，请考虑`const`对象是如何被破坏的)。因此，可以消除整个循环。

现在考虑使用简单聚合的向量:

```
struct S {
  long a;
  double x;
};
std::vector<S> v;
```

这次，类型`T`具有析构函数，编译器再次知道它的作用 (毕竟编译器确实生成了它)。同样，析构函数什么也不做，整个破坏循环被消除。`default`析构函数也是如此:

```
struct S {
  long a;
  double x;
  ~S() = default;
};
```

编译器应该能够对空析构函数进行相同的优化，但前提是它是内联的:

```
struct S {
  long a;
  double x;
  ~S() {}     // Probably optimized away
};
```

另一方面，如果类声明仅声明如下所示的析构函数:

```
struct S {
  long a;
  double x;
  ~S();
};
```

并且定义在单独的编译单元中提供，那么编译器必须为每个向量元素生成一个函数调用。该函数仍然不执行任何操作，但是运行循环并执行`N`函数调用仍然需要时间。内联允许编译器将此时间优化为零。

这是内联的关键及其对优化的影响: 内联使编译器可以看到在其他神秘函数中发生的*不是*。内联还有另一个重要作用: 它创建内联函数主体的唯一克隆，可以使用调用者给出的特定输入进行优化。在这个独特的克隆中，可能会观察到一些优化友好的条件，这些条件对于该功能通常不成立。同样，这里是一个例子:

```
bool pred(int i) { return i == 0; }
  … 
std::vector<int> v = … fill vector with data …;
auto it = std::find_if(v.begin(), v.end(), pred);
```

假设函数`pred()`的定义与对`std::find_if()`的调用在同一个编译单元中，对`pred()`的调用会内联吗？答案是*也许*，关键取决于是否先内联`find_if()`的调用。现在，`find_if()`是一个模板，所以编译器总是看到函数定义。它可能决定不内联函数，不管。如果`find_if()`没有内联，那么我们有一个针对特定类型的模板生成的函数。在这个函数中，第三个参数的类型是已知的: 它是`bool (*)(int)`，一个指向一个函数的指针，它取一个`int`并返回一个`bool`。但是这个指针的值在编译时是未知的: 相同的`find_if()`函数可以用许多不同的谓词来调用，所以它们都不能内联。只有当编译器为此特定调用生成`find_if()`的唯一克隆时，谓词函数才能内联。编译器有时只会做; 不出所料，它被称为**克隆**。但是，在大多数情况下，内联谓词或作为参数传入的任何其他内部函数的唯一方法是首先内联外部函数。

这个特定的示例在不同的编译器上产生不同的结果: 例如，GCC 将仅在最高优化设置下内联`find_if()`和`pred()`。即使到那时，其他编译器也不会这样做。但是，还有另一种方法可以鼓励编译器内联函数调用，并且它看起来确实违反直觉，因为它向程序添加了更多代码，并使嵌套函数调用的链更长:

```
 bool pred(int i) { return i == 0; }
  … 
std::vector<int> v = … fill vector with data …;
auto it = std::find_if(v.begin(), v.end(), 
  [&](int i) { return pred(i); });
```

这里的悖论是，我们在相同的间接函数调用周围添加了一个额外的间接层，一个 lambda 表达式 (顺便说一句，我们假设程序员不想简单地将谓词的主体直接复制到 lambda 中是有原因的)。这种对`pred()`的调用实际上要更容易内联，即使编译器没有内联`find_if()`函数。原因是这一次，谓词的类型是唯一的: 每个 lambda 表达式都有一个唯一的类型，因此对于这些特定的类型参数，只有一个`find_if()`模板的实例化。编译器更有可能内联一个只被调用一次的函数: 毕竟，这样做不会生成更多的代码。但是，即使对`find_if()`的调用没有内联，在该函数中，第三个参数只有一个可能的值，这个值在编译时已知为`pred()`，因此，对`pred()`的调用可以内联。

顺便说一句，我们终于可以澄清一下我们一直在[*第一章*](01.html#_idTextAnchor014)，*性能和并发简介*中提出的问题的答案: 虚拟函数调用的成本是多少？首先，编译器通常使用函数指针表来实现虚拟调用，因此调用本身涉及额外的间接层: 与非虚拟调用相比，CPU 必须多读取一个指针并进行一次跳转。这给函数调用增加了几条指令，使得函数调用的代码大约是原来的两倍 (根据硬件和缓存状态有很大的变化)。但是，我们通常调用一个函数来完成一些工作，因此函数调用的机械只是整个函数执行时间的一部分。即使对于简单的功能，虚拟功能的成本也很少超过非虚拟功能的 10-15%。

但是，在我们花费太多时间对指令进行计数之前，我们应该对原始问题的有效性提出质疑: 如果一个非虚函数调用就足够了，也就是说，如果我们在编译时知道将调用哪个函数，为什么我们首先要使用虚拟的函数？相反，如果我们找出仅在运行时调用哪个函数，那么根本无法使用非虚函数，因此其速度无关紧要。遵循此逻辑，我们应该将虚拟函数调用与功能等效的运行时解决方案进行比较: 有条件地使用一些运行时信息来选择几个函数之一。使用`if-else`或`switch`语句通常会导致执行速度变慢，至少如果要调用的函数有两个以上的版本。最有效的实现是函数指针表，这正是编译器对虚拟函数所做的。

当然，最初的问题实际上并不是完全没有意义: 如果我们有一个具有虚函数的多态类，但是在某些情况下，我们在编译时知道实际类型，该怎么办？在这种情况下，将虚拟函数调用与非虚拟函数调用进行比较是有意义的。我们还应该提到一个有趣的编译器优化，它适用: 如果编译器可以在编译时找出对象的真实类型，因此，知道虚拟函数的哪个覆盖将被调用，它会在所谓的**去虚拟化**中将调用转换为非虚拟。

但是，为什么此讨论会在专门用于内联的部分中进行？因为我们缺少房间里的大象: 虚拟函数对性能的最大影响是 (除非编译器可以对调用进行去虚拟化) 它们不能内联。一个简单的函数如`int f() { return x; }`在内联后导致一个甚至零个指令，但非内联版本有常规函数调用机械，这要慢几个数量级。现在添加一个事实，即如果没有内联，编译器就无法知道虚拟函数内部发生了什么，并且必须对每个外部可访问的数据进行最坏的假设，并且您可以看到在最坏的情况下，虚拟函数调用可能会花费数千倍。

内联，公开函数的内容，以及创建函数的唯一的，专门的副本，这两种效果都有助于优化器，因为它们增加了编译器对代码的了解。正如我们已经提到的，了解编译器真正知道什么是非常重要的，如果你想帮助它更好地优化你的代码。

现在，我们将探索编译器操作的不同限制，因此您可以开发一个识别*错误约束*的眼睛: 您知道这是真的，但编译器不知道。

## 编译器真正知道什么？

也许对优化的最大限制是了解在执行此代码的过程中会发生什么变化。为什么这很重要？同样，这里是一个例子:

```
int g(int a);
int f(const std::vector<int>& v, bool b) {
  int sum = 0;
  for (int a : v) {
    if (b) sum += g(a);
  }
  return sum;
} 
```

在这种情况下，只有`g()`的声明可用。编译器可以优化`if()`语句并消除条件的重复评估吗？在经历了本章的所有惊喜和陷阱之后，您可能正在寻找为什么不这样做的原因。没有一个，它是一个完全有效的优化:

```
int f(const std::vector<int>& v, bool b) {
  if (!b) return 0;
  int sum = 0;
  for (int a : v) {
    sum += g(a);
  }
  return sum;
} 
```

现在让我们稍微修改一下例子:

```
int g(int a);
int f(const std::vector<int>& v, const bool& b) {
  int sum = 0;
  for (int a : v) {
    if (b) sum += g(a);
  }
  return sum;
} 
```

为什么你会通过`const`引用传递一个`bool`参数？最常见的原因是模板: 如果你有一个模板函数，不需要复制参数，它必须将参数声明为`const T&`，假设`T`可以是任何东西。如果将`T`推导为`bool`，则您现在有一个`const bool&`参数。变化可能很小，但对优化的影响是深远的。如果您认为我们之前所做的优化仍然有效，请在更大的上下文中考虑我们的示例。现在你可以看到一切 (假设编译器仍然不能):

```
bool flag = false;
int g(int a) {
  flag = a == 0;
  return –a;
}
int f(const std::vector<int>& v, const bool& b) {
  int sum = 0;
  for (int a : v) {
    if (b) sum += g(a);
  }
  return sum;
} 
int main() {
  f({0, 1, 2, 3, 4}, flag);
}
```

请注意，通过调用`g()`，我们可以更改`b`，因为`b`是绑定到全局变量的引用，在`g()`内也可以访问。在第一次迭代时，`b`是`false`，但是对`g()`的调用有一个副作用: `b`更改为`true`。如果参数是按值传递的，则不会发生: 该值是在函数的最开始捕获的，并且不会跟踪调用者的变量。但是通过引用传递，它确实发生了，并且循环的第二次迭代不再是死代码。在每次迭代中，必须评估条件，并且无法进行优化。我们想再次强调程序员可能知道的内容和编译器可以证明的内容之间的区别: 您可能肯定知道代码中没有任何全局变量，或者您可能确切知道函数`g()`的功能。编译器不能做出任何这样的猜测，必须假设程序会做 (或者在将来的某个时候会做)，就像我们在前面的例子中演示的那样，这使得优化可能不安全。

同样，如果函数`g()`内联并且编译器可以看到它不修改任何全局变量，则不会发生这种情况。但是你不能指望你的整个代码是内联的，所以在某个时候，你必须考虑如何帮助编译器确定它自己不知道的东西。在当前的示例中，最简单的方法是引入一个临时变量 (当然，在这个简单的示例中，您可以手动进行优化，但这在更复杂的现实代码中并不实用)。为了使示例稍微更现实，我们将记住函数`f()`可能来自模板实例化。我们不想临时复制未知类型的参数`b`，但我们知道它必须可转换为`bool`，因此可以是我们的临时变量:

```
template <typename T>
int f(const std::vector<int>& v, const T& t) {
  const bool b = bool(t);
  int sum = 0;
  for (int a: v) {
    if (b) sum += g(a);
  }
  return sum;
} 
```

编译器仍然必须假设函数`g()`可能会更改`t`的值。但这不再重要: 条件使用临时变量`b`，绝对不能更改，因为它在函数`f()`之外不可见。当然，如果函数`g()`确实可以访问一个全局变量，该变量改变了`f()`的第二个参数，那么我们的转换就改变了程序的结果。通过创建这个临时变量，我们告诉编译器这种情况不会发生。这是编译器无法自行提出的附加信息。

这里的教训很简单，在理论上，但在实践中相当困难: 如果你知道一些关于你的程序，编译器不知道是真的，你必须以编译器可以使用的方式断言它。这很难做到的一个原因是，我们通常不会像编译器那样考虑我们的程序，并且很难放开你肯定知道的隐式假设是绝对真实的。

顺便问一下，您是否注意到我们将临时变量`b`声明为`const`？这主要是为了我们自己的利益，以防止由于意外修改它而引起的任何错误。但它也有助于编译器。您可能会想知道为什么: 编译器应该能够看到没有任何东西改变`b`的值。与早期棘手的情况不同，这种情况很简单: 编译器看到了`b`所做的一切。然而，你不能仅仅因为知识是可用的就确定编译器知道一些东西: 分析程序需要时间，程序员只愿意等这么长时间让编译器完成它的工作。另一方面，语法检查是强制性的: 如果我们声明变量`const`并试图改变它，程序将不会编译，我们永远也不会进入优化步骤。所以优化器可以假设任何`const`变量确实不会改变。还有另一个理由在可能的情况下声明对象`const`，但是我们将在下一章中讨论这个问题。

所以这里是第二课，就在第一课之后: 如果你知道你的程序，你可以很容易地与编译器通信，那么就这样做。这个建议确实违背了一个非常常见的建议: 不要创建临时变量，除非它们使程序更容易阅读-编译器无论如何都会摆脱它们。编译器可能确实会摆脱它们，但它确实保留 (并使用) 它们的存在所表达的其他信息。

阻止编译器进行优化的另一个非常常见的情况是混叠的可能性。下面是一个初始化两个 C 风格字符串的函数的例子:

```
void init(char* a, char* b, size_t N) {
  for (size_t i = 0; i < N; ++i) {
    a[i] = '0';
    b[i] = '1';
  }
}
```

一次写入一个字节的内存是相当低效的。有更好的方法将所有字符初始化为相同的值。这个版本会快得多:

```
void init(char* a, char* b, size_t N) {
  std::memset(a, '0', N);
  std::memset(b, '1', N);
}
```

您可以手工编写此代码，但是编译器永远不会为您进行此优化，了解原因很重要。当您看到此函数时，您希望它可以按预期使用，即初始化两个字符数组。但是编译器必须考虑两个指针`a`和`b`指向同一数组或一个数组的重叠部分的可能性。对你来说，以这种方式调用`init()`可能是没有意义的: 这两个初始化将相互覆盖。然而，编译器只有一个问题: 如何不改变代码的行为，无论是什么。

在通过引用或指针获取多个参数的任何函数中都可能发生相同的问题。例如，考虑这个函数:

```
void do_work(int& a, int& b, int& x) {
  if (x < 0) x = -x;
  a += x;
  b += x;
}
```

如果将`a`和`b`和`x`绑定到相同的变量，则编译器无法执行任何无效的优化。这被称为**别名**: 在代码中，相同的变量在两个不同的名称或别名下是已知的。在这种情况下，具体来说，编译器必须在递增`a`之后从内存中读取`x`。为什么？因为`a`和`x`可以引用相同的值，并且编译器不能假设`x`保持不变。

如果您确定不会发生混叠，如何解决此问题？在 C 中，有一个关键字`restrict`通知编译器特定的指针是访问当前函数范围内的值的唯一方法:

```
void init(char* restrict a, char* restrict b, size_t N);
```

在`init()`函数内部，编译器可以假设只能通过这个指针访问整个数组`a`。这也适用于标量变量。到目前为止，`restrict`关键字不是 C 标准的一部分。尽管如此，许多编译器支持此功能，尽管使用不同的语法 (`restrict`，`__restrict`，`__restrict__`)。对于奇异值 (特别是引用)，创建临时变量通常会解决以下问题:

```
void do_work(int& a, int& b, int& x) {
  if (x < 0) x = -x;
  const int y = x;
  a += y;
  b += y;
}
```

编译器可能会消除临时变量 (不为它分配任何内存)，但现在它可以保证`a`和`b`都增加相同的量。编译器实际上会做优化吗？最简单的方法是如下比较程序集输出:

![Figure 10.1 – x86 assembly output before (left) and after (right) the aliasing optimization ](Images/Figure_12.1_B16229.jpg)]

图 10.1-x86 混叠优化之前 (左) 和之后 (右) 的程序集输出

*图 10.1*显示了 GCC 为增量操作生成的 x86 程序集 (我们省略了函数调用和分支，在两种情况下都是相同的)。使用别名，编译器必须从内存中进行两次读取 (`mov`指令)。使用手动优化，只有一次读取。

这些优化有多重要？它取决于许多因素，因此您不应该着手进行项目以消除代码中的所有别名，而无需先进行一些测量。分析代码将告诉您哪些部分对性能至关重要; 在那里，您必须检查所有优化机会。最终通过向编译器提供额外的知识来帮助编译器的优化通常是最容易实现的 (编译器会做艰苦的工作)。

建议向编译器提供有关您的程序的难以发现的信息的另一面是: 不要担心编译器可以轻松解决的问题。这个问题在不同的上下文中出现，但是更常见的情况之一是使用验证其输入的函数。在你的库中，你有一个交换函数，它在指针上工作:

```
template <typename T>
void my_swap(T* p, T* q) {
    if (p && q) {
        using std::swap;
        swap(*p, *q);
    }
}
```

该函数接受空指针，但不对它们做任何事情。在你自己的代码中，出于某种原因，你无论如何都要检查指针，只有当两者都是非 null 时，你才调用`my_swap()` (如果它们是 null，也许你需要做一些其他的事情，所以你必须检查)。忽略你可能做的所有其他工作，调用代码看起来像这样:

```
void f(int* p, int* q) {
    if (p && q) my_swap(p, q);
}
```

C 程序员花费了过多的时间来争论冗余检查是否会影响性能。我们应该尝试在呼叫现场删除支票吗？假设我们不能，我们是否应该创建另一个版本的`my_swap()`，不测试其输入？这里的关键观察是，函数`my_swap()`是一个模板 (和一个小函数)，因此几乎可以肯定会被内联。编译器具有所有必要的信息，以确定对 null 的第二个测试是冗余的。是吗？我们将比较两个程序的程序集输出，而不是尝试对可能的性能差异 (在任何情况下都将非常小) 进行基准测试。如果编译器在使用和不使用冗余`if()`语句的情况下生成相同的机器代码，则可以确定没有性能差异。这里是由 GCC 生成的 x86 上的程序集输出:

![Figure 10.2 – Assembly output with (left) and without (right) redundant pointer test ](Images/Figure_12.2_B16229.jpg)]

图 10.2-带有 (左) 和不带有 (右) 冗余指针测试的程序集输出

在图 10.2 的左边是为程序生成的代码，其中有两个`if()`语句，一个在`my_swap()`内，一个在外部。右边是具有特殊非测试版本`my_swap()`的程序的代码。您可以看到机器代码是绝对相同的 (如果您可以阅读 x86 程序集，您还会注意到在两种情况下只有两个比较，而不是四个)。

正如我们已经说过的，内联在这里起着至关重要的作用: 如果没有内联`my_swap()`，则在函数`f()`中进行第一个测试，很好，因为它避免了不必要的函数调用，并且允许编译器在指针之一为 null 的情况下更好地优化调用代码。现在`my_swap()`内部的测试是多余的，但是编译器无论如何都会生成它，因为它不知道`my_swap()`是否在其他地方被调用，可能在输入上没有任何保证。由于第二个测试是硬件 100% 可预测的 (我们在[*第 3 章*](03.html#_idTextAnchor047)，*CPU 架构、资源和性能影响*中对此进行了讨论)，因此性能差异仍然是不可测量的。

顺便说一句，这种情况最常见的例子可能是运算符`delete`: C 允许删除空指针 (什么都没有发生)。但是，很多程序员还是这样写代码:

```
if (p) delete p; 
```

即使在理论上，它也会影响性能吗？否: 您可以查看程序集输出并说服自己，无论有无额外检查，都只有一个与 null 的比较。

现在，您对编译器如何看待您的程序有了更好的了解，让我们看到一种更有用的技术，可以从编译器中获得更好的优化。

## 将知识从运行时提升到编译时

我们这里将要讨论的方法归结为一件事: 给编译器更多关于程序的信息，在本例中，通过将运行时信息转换为编译时信息。在下面的示例中，我们需要处理很多由`Shape`类表示的几何对象。它们存储在容器中 (如果类型是多态的，它将是指针的容器)。处理包括执行以下两个操作之一: 我们缩小每个对象或使其增长。让我们看看如何:

```
enum op_t { do_shrink, do_grow };
void process(std::vector<Shape>& v, op_t op) {
  for (Shape& s : v) {
    if (op == do_shrink) s.shrink();
    else s.grow();
  }
}
```

概括地说，我们有一个函数，其行为在运行时由一个或多个配置变量控制。通常，这些变量是布尔的 (为了可读性，我们选择了`enum`)。我们已经看到，如果通过引用传递配置参数`op`，编译器必须将比较留在循环内部，并对每个形状进行评估。即使参数是按值传递的，许多编译器也不会将分支从循环中吊出: 它需要复制循环的主体 (一个循环用于收缩，一个循环用于增长)，并且编译器警惕过多地膨胀代码。

应该认真对待这个问题: 更大的可执行文件需要更长的时间来加载，更多的代码增加了指令缓存 (i-cache，用于缓存即将到来的指令的方式与数据缓存缓存即将被 CPU 使用的数据相同) 的压力。但是，在某些情况下，这种优化仍然是正确的选择: 通常，您知道在不更改配置变量的情况下处理了大量数据。也许这些变量在程序的整个运行中甚至是恒定的 (您一次加载配置并使用它)。

重写我们的简单示例以将分支移出循环很容易，但是如果代码很复杂，那么重构也是如此。如果我们愿意轮流给它帮助，我们可以从编译器那里得到一些帮助。这个想法是将运行时值转换为编译时值:

```
template <op_t op>
void process(std::vector<Shape>& v) {
  for (Shape& s : v) {
    if (op == do_shrink) s.shrink();
    else s.grow();
  }
}
void process(std::vector<Shape>& v, op_t op) {
  if (op == do_shrink) process<do_shrink>(v);
  else process<do_grow>(v);
}
```

整个 (潜在大的) 旧函数`process()`被转换为模板，但除了之外，没有任何变化。具体来说，我们没有将分支移出循环。但是，控制分支的条件现在是编译时常数 (模板参数)。编译器将在每个模板实例化中消除分支以及相应的死代码。在我们程序的其余部分中，配置变量仍然是一个运行时值，只是一个不会经常更改 (或根本不会更改) 的值。所以我们仍然需要一个运行时测试，但它仅用于决定要调用哪个模板实例化。

这种方法可以推广。想象一下，我们需要为每个形状计算一些属性，例如体积，尺寸，重量等。这都是由一个函数完成的，因为很多计算是在不同的属性之间共享的。但是它需要时间来计算我们不需要的属性，所以我们可以实现这样的函数:

```
void measure(const std::vector<Shape>& s,
  double* length, double* width, double* depth,
  double* volume, double* weight);
```

空指针有效，表明我们不需要该结果。在函数内部，我们为请求值的特定组合最佳地编写代码: 我们只进行一次通用计算，并且不计算不需要的任何内容。但是，此检查是在形状的循环中完成的，这一次，这是一组非常复杂的条件。如果我们需要为同一组测量处理大量形状，则将条件从循环中提升出来是有意义的，但是编译器不太可能做到这一点，即使可以。同样，我们可以编写一个包含许多非类型参数的模板: 它们将是布尔值，例如`need_length`，`need_width`等。在该模板中，编译器将消除所有从未针对特定测量组合执行的分支，因为现在这是编译时信息。在运行时调用的函数必须将调用转发到正确的模板实例化，基于哪些指针是非空的。最有效的实现之一是查找表:

```
template <bool use_length, bool use_width, …>
void measure(const std::vector<Shape>& v,
         double* length, … );
void measure(const std::vector<Shape>& v,
         double* length, … ) {
  const int key = ((length != nullptr) << 0) |
                  ((width  != nullptr) << 1) |
                  ((depth  != nullptr) << 2) |
                  ((volume != nullptr) << 3) |
                  ((weight != nullptr) << 4);
  switch (key) {
    case 0x01: measure<true , false, … >(v, length, … );
               break;
    case 0x02: measure<false, true , … >(v, length, … );
               break;
    …
    default:; // Programming error, assert
 }
}
```

这会产生大量代码: 测量的每个变体都是一个新函数。这种重大转换的效果应始终通过分析来验证。但是，在测量相对简单的情况下 (例如，许多形状是立方体)，并且对于许多 (数百万) 形状请求相同的测量集合，这种改变可以产生显著的性能提升。

当使用特定的编译器时，了解其功能 (包括优化) 是值得的。这样的详细程度超出了本书的范围，并且是不稳定的知识-编译器迅速发展。相反，本章为理解编译器优化奠定了基础，并为您 (读者) 提供了参考框架，以增进您的理解。让我们回顾一下我们所学到的要点。

# 总结

在本章中，我们探讨了 C ++ 效率的第二个主要领域: 帮助编译器生成更高效的代码。

这本书的目标是武装你理解你的代码、计算机和编译器之间的交互，这样你就能以良好的判断力和扎实的理解做出这些决定。

帮助编译器优化代码的最简单的方法是遵循一般的*经验法则*进行有效的优化，其中许多也是好的设计规则: 最小化代码不同部分之间的接口和交互，将代码组织成块，函数，和模块，每个模块都有简单的逻辑和明确定义的接口边界，避免全局变量和其他*隐藏*的交互，等等。这些也是最佳设计实践的事实并非巧合: 通常，程序员易于阅读的代码也易于编译器分析。

更高级的优化通常需要检查编译器产生的代码。如果你注意到编译器没有做一些优化，考虑是否有一个场景，优化是无效的: 不认为在你的程序中发生了什么，但在给定的代码片段中会发生什么 (例如，你可能知道你从来没有使用全局变量，但编译器必须假设你可能)。

在下一章中，我们将探讨 C ++ 的一个非常微妙的领域 (以及一般的软件设计)，它可能与性能研究产生意想不到的重叠。

# 问题

1.  是什么限制了编译器优化？
2.  为什么函数内联对编译器优化如此重要？
3.  为什么编译器不做一个*明显*的优化？
4.  为什么内联是一种有效的优化？