# 十二、性能设计

本章回顾了我们在本书中学到的所有与性能相关的因素和功能，并探讨了我们所获得的知识和理解如何影响我们在开发新软件系统或重新构建现有软件系统时做出的设计决策的主题。我们将了解设计决策如何影响软件系统的性能，了解如何在没有详细数据的情况下做出与性能相关的设计决策，以及回顾设计 api、并发数据结构和高性能数据结构的最佳实践，以避免效率低下。我们将探讨以下主题:

*   设计与性能之间的相互作用
*   性能设计
*   API 设计注意事项
*   优化数据访问的设计
*   性能权衡
*   做出明智的设计决策

您将学习如何从一开始就将良好的性能视为设计目标之一，以及如何以确保高效实现不会成为与程序的基本架构作斗争的方式设计高性能软件系统。

# 技术要求

您将需要一个 C 编译器和一个微基准测试工具，例如我们在上一章中使用的 Google 基准库 (在[https://github.com/google/benchmark](https://github.com/google/benchmark)找到)。本章随附的代码可在[https://github.com/PacktPublishing/ 《高效程序编写艺术》/tree/master/Chapter12](https://github.com/PacktPublishing/The-Art-of-Writing-Efficient-Programs/tree/master/Chapter12)找到。

# 设计与性能的交互

好的设计是否有助于实现良好的性能，还是您必须偶尔折衷最佳设计实践才能实现最佳性能？这些问题在编程社区中引起了激烈的争论。通常，设计布道者会争辩说，如果你认为你需要在好的设计和好的性能之间做出选择，你的设计就不够好。另一方面，黑客 (我们在经典意义上使用这个术语，程序员一起破解解决方案，与犯罪方面无关) 通常将设计指南视为对最佳优化的约束。

本章的目的是在一定程度上表明这两种观点都是有效的。如果被视为 “全部真相”，它们也会被误认为。否认许多设计实践在应用于特定软件系统时会限制性能是不诚实的。另一方面，许多实现和维护高效代码的准则也是可靠的设计建议，可以提高性能和设计质量。

我们对设计和性能之间的张力有更细微的了解。对于一个特定的系统 (你最感兴趣的是你的系统，你现在正在研究*系统*)，一些设计准则和实践确实会导致效率低下和性能低下。我们很难说出一个总是与效率相反的设计规则，但是对于一个特定的系统，也许在某些特定的环境中，这样的规则和实践是相当普遍的。如果你接受一个遵循这样的规则的设计，你可能最终会将低效率嵌入到你的软件系统的核心体系结构中，并且很难通过 “优化” 来补救，而不完全重写程序的关键部分。任何对这种陷阱的潜在严重性不屑一顾的人都没有考虑到你的最大利益。另一方面，任何声称这证明放弃坚实的设计实践是合理的人都会提出一个错误的、过于简单的选择。

如果您意识到一种特定的设计方法遵循良好的实践，提高了清晰度和可维护性，但会降低性能，那么正确的应对方法就是选择一种不同但也不错的设计方法。换句话说，虽然发现一些好的设计会产生较差的性能是很常见的，但对于给定的软件系统来说，每一个好的设计都会导致效率低下的可能性很小。您需要做的 “所有” 就是从几种可能的高质量设计中选择一种也可以实现良好性能的设计。

当然，这说起来容易做起来难，但希望这本书能有所帮助。在本章的其余部分，我们将重点讨论问题的两个方面。首先，当性能是一个问题时，建议采取哪些设计实践？其次，当我们没有一个我们可以运行和测量的程序，但我们所拥有的只是一个 (可能不完整的) 设计时，我们如何评估可能的性能影响？

如果你仔细阅读了最后两段，你就无法逃避性能是设计考虑因素的观察: 就像我们在设计中考虑了我们的要求，例如 “支持许多用户” 或 “将 tb 的数据存储在磁盘上”，“性能目标是要求的一部分，应在设计阶段明确考虑。这使我们想到了设计高性能系统的关键概念，即…

# 性能设计

正如我们所说，性能是设计目标之一，与其他约束和要求同等重要。因此，“这种设计导致性能不佳” 的问题的答案与如果问题是 “这种设计没有提供我们需要的特性” 时我们会做的相同。在这两种情况下，我们都需要不同的设计，而不是更差的设计。我们只是更习惯于根据设计的工作而不是快速进行评估。

为了帮助您在第一次尝试时选择提升性能的设计实践，我们现在将介绍一些专门针对良好性能的设计准则。它们也是可靠的设计原则，有充分的理由接受它们: 遵循这些准则不会使您的设计变得更糟。

前两个这样的准则涉及设计的不同组件 (功能，类，模块，过程，任何组件) 的交互。首先，我们建议这些交互传递尽可能少的信息，以使整个系统仍能正常运行。其次，我们建议不同的组件相互提供与相互作用的预期结果一样多的信息。如果你认为这是一个矛盾，你是绝对正确的。设计通常是解决矛盾的艺术，而您这样做的方式是: 两个矛盾的陈述都是正确的，只是不在同一时间或同一地点。下面是对这种 (更通用的) 管理设计矛盾的技术的一个很好的说明。

## 最小信息原则

让我们从第一个准则开始: 交流尽可能少的信息。上下文在这里至关重要: 具体地说，我们建议组件尽可能少地揭示关于它如何处理特定请求的信息。组件之间的交互受合同约束。当我们谈论类和函数的接口时，我们已经习惯了这个想法，但它是一个更广泛的概念。例如，用于在两个进程之间进行通信的协议是合同。

在任何此类界面或互动中，做出并履行承诺的一方不得自愿提供任何其他信息。让我们看一些具体的例子。我们将从一个实现基本队列的类开始，并问自己，从效率的角度来看，什么是好的接口？

其中一种方法允许我们检查队列是否为空。请注意，调用者没有问队列有多少个元素，只是问它是否为空。虽然队列的一些实现可以缓存大小并将其与零进行比较以解决此请求，但是对于其他实现，确定队列是否为空比计数元素更有效。合同说: “如果队列为空，我将返回 true。”即使您认为自己知道大小，也不要做出任何其他承诺: 不要自愿提供任何未要求的信息。这样，您可以自由地在以后更改您的实现。

同样，入队和出队的方法应仅保证将新元素添加到队列中或从队列中删除。对于从队列中弹出元素，我们必须处理空队列的情况或声明未定义的尝试的结果 (STL 选择的方法)。您可能会注意到，到目前为止，STL 队列从效率的角度来看具有出色的接口: 它满足了队列数据结构的契约，而没有透露任何不必要的细节。特别是，`std::queue`是一个适配器，可以在几个容器之一的顶部实现。队列可以实现为 vector，deque 或列表的事实告诉我们，该接口在隐藏实现细节方面做得很好。

对于接口泄漏太多实现信息的相反示例，请考虑另一个 STL 容器，即无序集 (或 map)。`std::unordered_set`容器有一个接口，允许我们插入新的元素，并检查一个给定值是否已经在集 (到目前为止，很好)。根据定义，它缺乏元素的内部顺序，并且标准提供的性能保证清楚地表明数据结构使用散列。Perforce，接口中明确引用哈希的部分不能被认为是免费的: 特别是，有必要指定用户给定的哈希函数。但是接口走得更远，通过`bucket_count()`等方法，暴露了一个事实，即底层实现*必须*是一个独立链接的哈希表，其中包含用于解决哈希冲突的桶。因此，不可能使用例如开放的寻址哈希表来创建完全符合 STL 的无序集。此接口会限制实现，并且可能会阻止您使用更有效的实现。

虽然我们使用类设计来进行简单的示例，但相同的原理可以应用于较大模块的 api，客户端-服务器协议以及系统组件之间的其他交互: *在设计响应请求或提供服务的组件时，提供一份简短的合同，并透露请求者所需的信息，除此之外别无其他*。

设计揭示最小信息或最小承诺的准则本质上是类接口的流行准则的概括: 接口不应揭示实现。此外，考虑到纠正违反此准则的行为将非常困难: 如果您的设计泄露了实现细节，客户端将开始依赖它们，并且一旦您更改实现就会中断。因此，到目前为止，针对性能的设计与一般的良好设计实践是一致的。随着下一个指南，我们开始暴露不同设计目标和相应的最佳实践之间的张力。

## 最大信息原则

虽然满足请求的组件应避免不必要地公开任何可能会限制实现的内容，但对于发出请求的组件则相反。请求者或呼叫者应该能够提供有关确切需要什么的特定信息。当然，呼叫者仅在存在适当的接口时才提供信息，因此，我们真正要说的是，接口应设计为允许此类 “完整” 请求。

特别是，为了提供最佳性能，了解请求背后的意图通常很重要。同样，一个例子应该可以更容易地理解这个概念。

让我们从一个随机访问序列容器开始。随机访问意味着我们可以访问容器的任意第 i 个元素，而无需访问任何其他元素。通常的方法是使用索引运算符:

```cpp
T& operator[](size_t i) { return … i-th element …; }
```

有了这个运算符，我们可以，例如，迭代容器:

```cpp
container<T> cont;
… add some data to cont …
for (size_t i = 0; i != cont.size(); ++ i) {
  T& element_i = cont[i];
  … do some work on the i-th element …
}
```

从效率的角度来看，这不是最好的方法: 我们使用随机访问迭代器进行顺序迭代。通常，当您使用功能更强大或功能更强大的接口但仅使用其功能的一小部分时，您应该关注效率: 此接口的额外灵活性可能会以某些性能为代价，如果您不使用这些功能，则会浪费这些性能。

我们做不需要举一个例子。让我们考虑`std::deque`: 它是一个支持随机访问的块分配容器。为了访问任意元素`i`，我们首先要计算出哪个块包含这个元素 (一般是取模运算) 以及该块内元素的索引，然后在辅助数据结构 (块指针表) 中找到该块的地址并索引到该块中。即使在大多数情况下，该元素将驻留在同一块中，并且我们已经知道其地址，也必须对下一个元素重复此过程。发生这种情况是因为对任意元素的请求没有包含足够的信息: 没有办法表达我们将很快要求下一个元素。因此，deque 无法以最有效的方式处理遍历。

扫描整个容器的替代方法是使用 iterator 接口:

```cpp
for (auto it = cont.begin(); it != cont.end(); ++ it) {
  T& element = *it;
  … do some work on the element …
}
```

deque 的实现者可以假设递增 (或递减) 迭代器是经常完成的操作。因此，如果你有一个迭代器`it`并访问相应的元素`*it`，你很可能会要求下一个元素。deque 迭代器可以将块指针或右条目的索引存储在块指针表中，这将使访问一个块内的所有元素便宜得多。在一个简单的基准测试的帮助下，我们可以验证使用迭代器遍历 deque 确实比使用索引要快得多:

```cpp
void BM_index(benchmark::State& state) {
     const unsigned int N = state.range(0);
     std::deque<unsigned long> d(N);
     for (auto _ : state) {
           for (size_t i = 0; i < N; ++ i) {
                 benchmark::DoNotOptimize(d[i]);
           }
           benchmark::ClobberMemory();
     }
     state.SetItemsProcessed(N*state.iterations());
}
void BM_iter(benchmark::State& state) {
     const unsigned int N = state.range(0);
     std::deque<unsigned long> d(N);
     for (auto _ : state) {
           for (auto it = d.cbegin(), it0 = d.cend(); 
                  it != it0; ++ it) {
                 benchmark::DoNotOptimize(*it);
           }
           benchmark::ClobberMemory();
     }
     state.SetItemsProcessed(N*state.iterations());
}
```

结果显示出非常令人印象深刻的性能差异:

![Figure 12.1 – Traversal of std::deque using index versus iterator ](img/Figure_11.1_B16229.jpg)

图 12.1-使用索引与迭代器遍历 std::deque

指出性能设计和性能优化之间的关键区别非常重要。不能保证迭代器对 deque 的访问速度更快: 实际上，特定的实现可以使用索引运算符来实现迭代器。这种保证可能仅来自优化的实现。在本章中，我们对设计感兴趣。设计不能真正 “优化”，尽管，如果你谈论一个 “高效的设计”，其他人可能会理解你的意思。设计可以允许或阻止某些优化，因此谈论 “性能敌对” 和 “性能友好” 设计 (后者通常被称为高效设计) 更为准确。

在我们的 deque 示例中，索引运算符接口对于随机访问的效率与它一样高，并且它将顺序迭代视为随机访问的特定情况。呼叫者无法说: “接下来我可能会要求相邻元素。”相反，从迭代器的存在，我们可以推断出它很可能是递增或递减的。实现是免费的，以使这种增量操作更加有效。

让我们把我们的容器例子再往前走一步。这一次，我们考虑一个自定义容器，它本质上是一个树，但是与`std::set`不同，我们不将值存储在树节点中。相反，我们将值存储在序列容器 (数据存储) 中，而树节点包含指向该容器元素的指针。树本质上是数据存储中的索引，因此它需要一个自定义的比较功能: 我们要比较值，而不是指针。

```cpp
template<typename T> struct compare_ptr {
  bool operator()(const T* a, const T* b) const {
     return *a < *b;
  }
};
template <typename T> class index_tree {
  public:
  void insert(const T& t) { 
     data_.push_back(t);
     idx_.insert(&(data_[data_.size() - 1]));
  }
  private:
  std::set<T*, compare_ptr<T>> idx_;
  std::vector<T> data_;
};
```

当插入新元素时，它将被添加到数据存储的末尾，而指针将被添加到索引中的适当位置 (由元素的比较确定)。为什么我们会选择这样的实现而不是`std::set`？在某些情况下，我们可能有迫使我们的手的要求: 例如，数据存储可能是磁盘上的内存映射文件。在其他情况下，我们可能会选择这种实现来提高性能，尽管乍一看，额外的内存使用和通过指针间接访问元素会降低性能。

为了了解此索引树容器的性能优势，让我们检查搜索满足给定谓词的元素的操作。我们可以很容易地做这个搜索，假设我们的容器提供了迭代器，简单地迭代索引集; dereference 运算符应该返回索引元素，而不是指针:

```cpp
template <typename T> class index_tree {
  using idx_t = typename std::set<T*, compare_ptr<T>>;
  using idx_iter_t = typename idx_t::const_iterator;
  public:
  class const_iterator {
     idx_iter_t it_;
     public:
     const_iterator(idx_iter_t it) : it_(it) {}
     const_iterator operator++() { ++ it_; return *this; }
     const T& operator*() const { return *(*it_); }
     friend bool operator!=(const const_iterator& a,
                            const const_iterator& b) {
        return a.it_ != b.it_;
     }
  };
  const_iterator cbegin() const { return idx_.cbegin(); }
  const_iterator cend() const { return idx_.cend(); }
  …
};
```

要确定满足某些要求的值是否已存储在容器中，我们可以简单地遍历整个容器并检查每个值的谓词:

```cpp
template <typename C, typename F> bool find(const C& c, F f) {
  for (auto it = c.cbegin(), i0 = c.cend(); it != i0; ++ it) {
     if (f(*it)) return true;
  }
  return false;
}
```

当我们使用迭代器访问容器时，我们会向容器提供什么信息，就像我们刚才所做的那样？就像以前一样，我们告诉它我们打算每次都访问下一个元素。我们不会告诉它任何我们这样做的原因。意图重要吗？在这种情况下，非常重要。仔细查看我们真正需要做的事情: 我们需要访问容器中的每个元素，直到找到满足给定条件的元素。如果这看起来像是在重述同一件事，那么您还不够学究。在这个需求声明中，我们没有说我们想按顺序访问容器元素*，只是我们需要遍历所有元素。如果我们有一个 API 调用，告诉容器检查所有元素，但不需要任何特定的顺序，容器实现将自由优化访问顺序。对于我们的索引容器，最佳访问顺序是迭代数据存储向量本身: 这提供了最佳的内存访问模式 (顺序访问)。在我们的情况下，商店中元素的实际顺序是添加它们的顺序，但这并不重要: 我们要求返回的只是一个布尔值; 我们甚至不问匹配元素位于何处。换句话说，虽然可能有多个满足条件的元素，但调用者想知道是否存在至少一个这样的元素。我们没有要求元素或任何特定元素的值: 这是 “查找任何” 而不是 “查找第一” 的请求。*

这是接口的版本，它允许调用方提供所有相关信息和一个可能的实现:

```cpp
template <typename T> class index_tree {
  …
  template <typename F> bool find(F f) const {
     for (const T& x : data_) {
        if (f(x)) return true;
     }
     return false;
  }
};
```

速度更快吗？同样，基准可以回答。如果未找到该值或很少找到该值，则差异更为明显:

![Figure 12.2 – Search in an indexed data store using iterators vs. find() member function ](img/Figure_11.2_B16229.jpg)

图 12.2-使用迭代器 vs. find() 成员函数在索引数据存储中搜索

再一次，退后一步，重新评估这个例子，作为软件设计的课程，而不是特定的优化技术，这一点非常重要。在这种情况下，我们的`find()`成员函数比基于迭代器的搜索快得多并不重要。在设计阶段重要的是，通过适当的实现，它可能会更快。它可能更快的原因是对呼叫者意图的了解。

使用非成员与成员 `find()` 比较呼叫者提供的信息。当非成员`find()`函数调用容器接口时，我们告诉容器，“让我依次查看所有容器元素的值。”我们实际上并不需要这些，但这是我们给容器的信息，因为这是我们可以通过迭代器接口进行通道的唯一信息。另一方面，成员`find()`允许我们提出以下请求: “以任何顺序检查所有元素，并告诉我是否至少有一个符合此条件。”此请求施加的限制要少得多: 它是一个高级请求，将详细信息留给容器本身。在我们的示例中，实现者利用这种自由来提供更好的性能。

在设计阶段，您可能不知道这种优化的实现是可能的。成员`find()`的第一个实现不妨运行迭代器循环或调用`std::find_if`。您也可能永远不会优化此功能，因为在您的应用程序中，它很少被调用，并且不是性能瓶颈。但是软件系统的寿命往往比您预期的要长，并且进行根本性的重新设计既困难又耗时。一个好的系统架构不应该限制系统的发展数年，有时甚至数十年，即使添加了新功能并且性能要求发生了变化。

同样，我们已经看到了性能友好设计和性能敌对设计之间的区别。当然，同样的原则也适用于系统组件之间的交互，并且不限于类: *在设计响应请求或提供服务的组件时，允许请求者提供所有相关信息，特别是表达请求背后的意图。*

这是一个更具争议性的准则，原因有几个。首先，它明确地违背了类设计的流行方法: 永远不要为不需要特权访问的任务实现 (公共) 成员函数，并且可以完全通过现有的公共 API 来实现。我们有几种方法可以对此进行推理。首先，可以说 “可以实施慢十倍” 并不真正符合 “可以实施” 的条件，因此该准则不适用。与之相对的是，在设计阶段，您甚至可能都不知道您需要这种性能。我们可能违反的另一个重要规则是 “不要过早优化”，尽管不应简单地采用此规则: 特别是，该规则的合理支持者通常会添加 “但也不要过早悲观”。在设计的背景下，后者意味着做出设计决策，从而切断未来的优化机会。

因此，使用最大信息原则 (或信息丰富的界面) 是平衡和合理判断的问题。考虑到，在一般情况下，违反这一准则并不像不遵循之前的规则那样令人讨厌: 如果你的界面或合同暴露了不必要的信息，很难从所有依赖它的客户那里收回它。另一方面，如果您的接口不允许客户端提供相关的意图信息，则客户端可能会被迫进行低效的实现。但是，稍后添加更多信息丰富的界面后，什么都不会中断，并且客户端可以根据需要过渡到此界面。

因此，关于是否预先提供更多信息丰富的界面的决定取决于以下几个因素:

*   这个组件或组件之间的交互将对性能至关重要的可能性有多大？虽然对特定代码的性能的猜测是不鼓励的，但您通常知道所讨论的组件的一般要求: 每秒访问数百万次的数据库很可能是某个地方的性能瓶颈，而每月两次为员工地址提供薪水的系统可以保守设计，并在需要时稍后进行优化。
*   这个设计决策的影响有多广泛？特别是，如果效率低下的实施激增，那么当我们添加新的更高级别的接口时，它将变得多么根深蒂固？使用一次或两次的类可以轻松地与其客户端一起更新; 一种通信协议将成为整个系统的标准，并将在 restful API 中使用，该 API 将消息存储在磁盘上数周或数月，从一开始就应该具有可扩展性，包括未来信息丰富的请求的选项。

通常，这些选择并不明确，而是依赖于设计师的直觉与知识和经验。这本书可以帮助前者，而实践则照顾后者。

正如您在本节中看到的那样，在考虑不同设计决策的性能影响时，我们经常关注接口和数据组织。在接下来的两节中，我们将从界面设计开始显式地转向这两个主题。

# API 设计注意事项

有许多书籍和文章介绍了 API 设计的最佳实践。他们通常把重点放在可用性、清晰度和灵活性上。常见的准则，例如 “使接口清晰且易于正确使用” 和 “使接口难以滥用”，不仅没有直接解决性能问题，而且也不会干扰促进良好性能和效率的实践。在上一节中，我们讨论了在设计性能接口时应该记住的两个重要准则。在本节中，我们将探讨一些明确针对性能的更具体的准则。许多高性能程序依赖于并发执行，因此首先解决并发的设计是有意义的。

## 并发的 API 设计

在设计并发组件及其接口时，最重要的规则是提供清晰的线程安全保证。请注意，“清除” 并不意味着 “强大”: 实际上，为了获得最佳性能，通常最好在低级接口上提供较弱的保证。STL 选择的方法是一个很好的例子: 所有可能改变对象状态的方法都提供了一个弱的保证: 只要在任何时候只有一个线程在使用容器，程序就定义良好。

如果你想要更强的保证，你可以在应用程序级别使用锁。更好的做法是创建自己的锁定类，这些类可以为所需的接口提供强大的保证。有时，这些类只是锁定装饰器: 它们将装饰对象的每个成员函数包装在锁中。更常见的是，有多个操作必须由单个锁保护。

为什么？因为在完成 “一半” 操作之后，允许客户端查看特定的数据结构是没有意义的。这使我们有一个更普遍的观察: 通常，线程安全接口也应该是事务性的。在进行 API 调用之前和之后，组件 (类，服务器，数据库等) 的状态应该是有效的。应维护接口合同承诺的所有不变量。很可能，在执行所请求的成员函数 (对于类) 期间，对象经历了一个或多个客户端认为无效的状态: 它不维护指定的不变量。接口应使另一个线程无法在这种无效状态下观察对象。让我们用一个例子来说明。

回顾上一节中的索引树。如果我们想让这个树线程安全 (这是提供强有力的保证的一只手)，我们应该让插入新元素安全，即使从多个线程同时调用:

```cpp
template <typename T> class index_tree {
  public:
  void insert(const T& t) {
     std::lock_guard guard(m_);
     data_.push_back(t);
     idx_.insert(&(data_[data_.size() - 1]));
  }
  private:
  std::set<T*, compare_ptr<T>> idx_;
  std::vector<T> data_;
  std::mutex m_;
};
```

当然，其他方法也必须受到保护。很明显，我们不想分别锁定`push_back()`和`insert()`调用: 客户端将如何处理在数据存储中具有新元素但不在索引中的对象？根据我们的接口，甚至没有定义这个新元素是否在容器中: 如果我们使用迭代器扫描索引，它不是，但是如果我们使用`find()`扫描数据存储，那么它是。这种不一致告诉我们，索引树容器的不变量在插入之前和之后都保持不变，但不在插入的中间。因此，非常重要的是，没有其他线程可以看到这样一个定义不明确的状态。我们通过确保接口是线程安全的和事务性的来实现这一点。并发调用多个成员函数是安全的; 有些线程会阻塞并等待其他线程完成其工作，但没有未定义的行为。每个成员函数将对象从一个定义良好的状态移动到另一个定义良好的状态 (换句话说，它执行诸如添加新元素之类的事务)。这两个因素的结合使对象可以安全使用。

如果您需要一个反例 (在设计并发接口时不要做什么)，请回想一下[*第 7 章*](07.html#_idTextAnchor117)，*并发数据结构*中的`std::queue`的讨论。从队列中删除元素的接口不是事务性的: `front()`返回前元素但不删除它，而`pop()`删除前元素但不返回任何内容，如果队列为空，两者都会产生未定义的行为。单独锁定这些方法对我们没有好处，因此线程安全的 API 必须使用我们在[*第 7 章*](07.html#_idTextAnchor117)，*并发的数据结构*中考虑的方法之一，来构造一个事务，并用锁来保护它。

现在我们转向效率: 正如你所看到的，如果作为我们容器的构件的单个对象自己锁定，这对我们没有好处。想象一下，如果`std::deque<T>::push_back()`本身被锁保护。这将使 deque 线程安全 (当然，假设其他相关方法也被锁定)。但这对我们没有任何好处，因为我们仍然需要用锁来保护整个交易。它所做的只是浪费一些时间来获取和释放我们不需要的锁。

另外，请记住，并非所有数据都可以同时访问。在一个精心设计的程序中，可以最大程度地减少共享状态的数量，大多数工作都是针对特定于线程的数据 (对象和其他数据是一个线程所独有的) 完成的，并且对共享数据的更新相对较少。独占一个线程的对象不应产生锁定或其他同步的开销。

看来我们现在有一个矛盾: 一方面，我们应该使用线程安全的事务接口来设计我们的类和其他组件。另一方面，我们不应该用锁或其他同步机制来负担这些接口，因为我们可能正在构建更高级别的组件，这些组件可以自己进行锁定。

解决这一矛盾的一般方法是同时做: 提供非锁定接口，这些接口可以用作更高级别的组件的构建块，并在有意义的地方提供线程安全接口。通常，后者是通过用锁定防护装置装饰非锁定接口来实现的。当然，这必须在合理的范围内完成。首先，任何非事务性接口都专门用于单线程使用或用于构建更高级别的接口。无论哪种方式，它们都不需要锁定。其次，在特定设计中，有一些组件和接口在狭窄的上下文中使用。也许一个数据结构是专门为分别在每个线程上完成的工作而设计的; 同样，没有理由将并发的开销添加到其中。根据设计，某些组件可能仅用于并发使用，并且是顶级组件-它们应该具有线程安全的事务接口。这仍然留下了许多类和其他组件，它们可能同时使用，并且需要锁定和非锁定变体。

从根本上说，有两种方法可以解决这个问题。首先是设计一个可以在请求时使用锁定的单个组件，例如:

```cpp
template <typename T> class index_tree {
  public:
  explicit index_tree(bool lock) : lock_(lock) {}
  void insert(const T& t) {
     optional_lock_guard guard(lock_ ? &m_ : nullptr);
     …
  }
  private:
  …
  std::mutex m_;
  const bool lock_;
};
```

为了实现的工作，我们需要一个有条件的`lock_guard`。可以使用`std::optional`或`std::unique_ptr`构建一个，但是它不优雅且效率低下。编写我们自己的类似于`std::lock_guard`的 RAII 类要容易得多:

```cpp
template <typename L> class optional_lock_guard {
  L* lock_;
  public:
  explicit optional_lock_guard(L* lock) : lock_(lock) {
     if (lock_) lock_->lock();
  }
  ~optional_lock_guard() {
     if (lock_) lock_->unlock();
  }
  optional_lock_guard(const optional_lock_guard&) = delete;
  // Handle other copy/move operations.
};
```

除了不可复制之外，`std::lock_guard`也是不可移动的。您可以遵循相同的设计或使您的类可移动。对于类，您通常可以在编译时而不是运行时处理锁定条件。此方法使用具有锁定策略的基于策略的设计:

```cpp
template <typename T, typename LP> class index_tree {
  public:
  void insert(const T& t) {
     LP guard;
     …
  }
};
```

我们应该至少有两个版本的锁定策略`LP`:

```cpp
struct locking_policy {
  locking_policy() { m_.lock(); }
  ~locking_policy() { m_.unlock(); }
  std::mutex m_;
};
struct non_locking_policy {};
```

现在我们可以创建具有弱或强线程安全保证的`index_tree`对象:

```cpp
index_tree<int, locking_policy> strong_ts_tree;
index_tree<int, non_locking_policy> weak_ts_tree;
```

当然，这种编译时方法适用于类，但可能不适用于其他类型的组件和接口。例如，当与远程服务器通信时，您可能希望在运行时通知它当前会话是共享的还是排他的。

第二种选择是我们前面讨论过的，一个锁定装饰器。在此版本中，原始类 (`index_tree`) 仅提供弱线程安全保证。这个包装器类提供了强有力的保证:

```cpp
template <typename T> class index_tree_ts :
  private index_tree<T> 
{
  public:
  using index_tree<T>::index_tree;
  void insert(const T& t) {
     std::lock_guard guard(m_);
     index_tree<T>::insert(t);
  }
  private:
  std::mutex m_;
};
```

请注意，虽然封装通常比继承更可取，但这里继承的优点是我们可以避免复制修饰类的所有构造函数。

相同的方法可以应用于其他 api: 控制锁定的显式参数与装饰器。使用哪一个在很大程度上取决于您的设计细节-它们都有其优缺点。请注意，即使与特定 API 调用所做的工作相比，锁定的开销微不足道，也可能有充分的理由避免无端锁定: 特别是，这种锁定大大增加了应对可能的死锁进行审查的代码量。

请注意，所有线程安全接口都应该是事务性的指南与设计异常安全接口 (或更一般地说，错误安全接口) 的最佳实践之间存在很多重叠。后者更复杂，因为我们不仅必须保证在调用接口之前和之后的有效状态，而且在检测到错误后系统仍处于定义良好的状态。

从性能的角度来看，错误处理本质上是开销: 我们不期望错误频繁发生 (否则，它们不是真正的错误，而是我们必须处理的经常发生的情况)。幸运的是，编写错误安全代码的最佳实践 (例如使用 RAII 对象进行清理) 也非常有效，并且很少施加大量开销。尽管如此，一些错误条件还是很难可靠地检测到，正如我们在[*第 11 章*](11.html#_idTextAnchor176)，*未定义的行为和性能*中看到的那样。

我们在本节中了解了一些设计高效并发 api 的准则:

*   用于并发使用的接口应为**事务性**。
*   接口应**提供最小必要的线程安全保证** (不打算同时使用的接口的弱保证)。
*   对于既用作客户端可见 API 的接口，又用作创建自己的更复杂事务并提供适当锁定的更高级别的组件的构建块的接口，通常需要有两个版本: 一个具有强大的线程安全保证，另一个具有弱的 (或，锁定和非锁定)。这可以通过条件锁定或使用装饰器来完成。

这些指南与设计健壮和清晰的 api 的其他最佳实践基本一致。因此，我们很少需要进行设计权衡以实现更好的性能。

现在让我们抛开并发的问题，转向性能设计的其他领域。

## 复制和发送数据

当我们谈到不必要的复制时，这个讨论将是对我们在[*第 9 章*](09.html#_idTextAnchor149)，*高性能 C*中涉及的问题的概括。使用任何接口，而不仅仅是一个 C 函数调用，通常涉及发送或接收一些数据。这是一个非常普遍的概念，除了同样普遍的 “注意数据传输的成本” 之外，我们将无法提供任何普遍适用的具体指导方针。我们可以针对一些常见类型的接口进行一些详细说明。

我们已经讨论了在 C 中复制内存的开销以及由此产生的接口注意事项。我们介绍了[*第九章*](09.html#_idTextAnchor149)，*高性能 C*中的实现技术。对于设计，我们可以强调通常重要的指导方针: **具有明确定义的数据所有权和生命周期管理**。它在性能的上下文中出现的原因是，通常过度复制是混乱的所有权的副作用，这是数据消失的变通方法，而它仍在使用中，因为复杂系统的许多部分的生命周期尚未得到很好的理解。

需要在分布式程序，客户端-服务器应用程序或通常在带宽限制重要的组件之间的任何接口中管理一组非常不同的问题。在这些情况下，经常使用数据压缩: 我们用 CPU 时间来换取带宽，因为压缩和解压缩数据会花费处理时间，但是传输会更快。通常，在设计时无法做出是否在特定渠道中压缩数据的决定: 我们只是没有足够的知识来做出明智的权衡。因此，重要的是设计系统以允许压缩的可能性。这对于设计可以转换为压缩格式的数据结构的接口具有一些非平凡的含义。如果您的设计要求压缩整个数据集，将其传输，然后将其转换回解压缩格式，则用于使用数据的接口 不会更改，但是内存需求不断增长，因为您将在某个时候同时存储在内存中的压缩表示形式和未压缩表示形式。另一种选择是在内部存储压缩数据的数据结构，在设计其接口时需要一些深谋远虑。

作为一个例子，想象一下，我们有一个简单的结构来存储三维位置，也许一些属性:

```cpp
struct point {
  double x, y, z;
  int color;
  … maybe more data …
};
```

一个非常流行的指南说，我们应该避免只访问相应的数据成员的 getter 和 setter 方法; 我们被建议不要这样做:

```cpp
class point {
  double x, y, z;
  int color;
  public:
  double get_x() const { return x; }
  void set_x(double x_in) { x = x_in; } // Same for y etc
};
```

我们将这些对象存储在一个点的集合中:

```cpp
class point_collection {
  point& operator[](size_t i);
};
```

这个设计为我们服务了一段时间，但是需求不断发展，现在我们必须存储和传输数百万个点。很难想象我们如何通过这个接口引入内部压缩: 索引运算符返回对必须有三个可直接访问的数据成员的对象的引用。如果我们有 getter 和 setter，我们可能已经能够实现点作为集合中压缩点集的代理:

```cpp
class point {
  point_collection& coll_;
  size_t point_id_;
  public:
  double get_x() const { return coll_[point_id_]; }
  …
};
```

该集合存储压缩数据，并且可以在运行中解压缩数据的一部分，以访问由`point_id_`标识的点。

当然，一个更加压缩友好的界面将要求我们顺序迭代整个点集合。现在，您应该意识到，我们只是重新审视了指导我们尽可能少地透露有关我们收藏内部运作的信息的指南。对压缩的关注为我们提供了一种特殊的观点。如果您考虑数据压缩的可能性，或者通常是用于存储和传输的替代数据表示，则还必须考虑限制对该数据的访问。也许你可以想出算法来完成所有必需的计算，而不使用对数据的随机访问？如果通过设计限制访问，则保留了压缩数据的可能性 (或以其他方式利用受限访问模式)。

当然，还有其他类型的接口，它们都有自己的运行时、内存和与传输大量数据相关的存储空间成本。在为性能设计时，请考虑这些成本将变得对性能至关重要的可能性，并尝试**限制接口以实现内部数据表示**的最大自由度。当然，与其他任何东西一样，这应该在合理的范围内进行实践; 手写的配置文件极不可能成为性能瓶颈 (计算机的读取速度比您编写的任何格式)。

我们已经谈到了数据布局问题，因为它会影响界面设计。现在让我们直接关注数据组织的性能影响。

# 优化数据访问的设计

我们在[*第四章*](04.html#_idTextAnchor064)，*内存体系结构和性能*中详细讨论了数据组织对性能的影响。在那里，我们观察到，每当您没有 “热代码” 时，通常都会找到 “热数据”。换句话说，如果运行时分散在大部分代码中，并且没有什么是很好的优化机会，那么很可能有一些数据 (一个或多个数据结构) 在整个程序中被访问，正是这些访问限制了整体性能。

这可能是一个非常不愉快的情况，发现自己在: 探查器显示没有低垂的优化结果，你可能会发现一些次优的代码，但测量表明，你最多可以节省一个或两个总运行时间从每个这些地方。除非您知道要寻找什么，否则很难找到提高此类代码性能的方法。

既然你知道你需要寻找 “热数据”，你是怎么做到的？首先，如果所有数据访问都是通过函数调用而不是通过直接读写公共数据成员来完成的，则要容易得多。即使这些访问器功能本身并不需要花费太多时间，您也可以对它们进行仪器以计算访问操作，这将直接显示哪些数据是热门的。这种方法类似于代码分析，只是找到多次执行的指令，而是找到多次访问的内存位置 (一些配置文件会为您进行这样的测量，而不需要对代码进行仪器处理)。再次，我们回到设计指南，该指南规定了明确定义的接口，这些接口不会公开内部细节，例如内存中的数据布局-能够轻松监视数据访问是这种方法的另一个好处。

我们应该指出，每个设计都涉及代码的组织 (组件，接口等) 和数据的组织。您可能还没有考虑特定的数据结构，但是您绝对必须考虑数据流: 每个组件都需要一些信息来完成其工作。系统的哪些部分生成此信息，谁拥有该信息，谁负责将其传递到需要的组件或模块？计算通常会产生一些新信息。同样，它应该在哪里交付，谁将拥有它？每个设计都包括这样的数据流分析: 如果你认为你没有它，你是通过接口的文档隐式地做的。信息流及其所有权可以从 API 合同的整体中推断出来，但这是一种相当复杂的处理方式。

一旦你明确描述了信息流，你就知道在执行的每一步都存在什么数据，并且每个组件都可以访问什么数据。您还知道必须在组件之间传输哪些数据。您现在可以考虑如何组织这些数据。

在数据组织方面，您可以在设计阶段采取两种方法。一种方法是依靠接口来提供数据的抽象视图，同时隐藏有关其真实组织的所有细节。这是我们从本章开始的第一个指导方针，即最低信息原则，达到了极致。如果可行，则可以根据需要稍后实现优化接口背后的数据结构。需要注意的是，很少有可能设计一个不以任何方式限制底层数据组织的接口，这样做通常要付出很高的代价。例如，如果您有一个有序的数据集合，您是否希望允许在集合中间插入？如果答案是肯定的，则数据将不会存储在类似数组的结构中，该结构需要移动一半的元素才能在中间打开一个空间 (对实现的限制)。另一方面，如果你坚定地拒绝允许任何限制你实现的接口，你最终会得到一个非常有限的接口，并且可能无法使用最快的算法 (不尽早提交给特定数据组织的成本)。

第二种方法是将至少一些数据组织视为设计的一部分。这将降低实现的灵活性，但将放宽对接口设计的一些限制。例如，您可以决定，为了以特定顺序访问数据，您将使用指向存储数据元素的位置的索引。您可以将间接访问的成本嵌入到系统架构的基础中，但是您可以获得数据访问的灵活性: 可以最佳地存储元素，并且可以为任何类型的随机或有序访问构建正确的索引。我们的`index_tree`是这种设计的一个微不足道的例子。

请注意，在讨论如何为性能设计数据组织时，我们必须使用一些相当低级的概念。通常，诸如 “通过额外的指针访问” 之类的细节被视为实现问题。但是在设计高性能系统时，您必须关注诸如缓存局部性和间接引用之类的问题。

最好的结果通常是通过将两种方法结合起来获得的: 确定最重要的数据并提出一个高效的组织。当然，不是每个细节，但通常，例如，如果您的程序在其基本级别上搜索了很多字符串，您可能会决定将所有字符串存储在一个大的、连续的内存块中，并使用索引进行搜索和其他有针对性的访问。然后，您将设计一个高级接口来构建索引并通过迭代器使用它，但是这种索引的确切组织留给实现。您的接口施加了一些限制: 例如，您可能会决定调用方在构建索引时可能会请求随机访问或双向迭代器，这反过来会影响实现。

并发系统的设计需要特别注意数据的共享。在设计阶段，您应该特别注意将数据分类为不共享，只读或共享以供写入。后者应该最小化，当然: 正如我们在[*第 6 章*](06.html#_idTextAnchor103)，*并发和性能*中看到的，访问共享数据是昂贵的。另一方面，重新设计用于独占单线程访问的组件或数据结构是线程安全的，这很困难，并且通常会导致性能不佳 (很难将线程安全性移植到根本不安全的设计之上)。您应该在数据流分析期间的设计阶段花费时间，以明确定义数据所有权和访问限制。由于 “数据所有权” 一词通常指的是非常低级的细节，例如 “我们是否使用智能指针以及哪个类拥有它？”，因此谈论信息所有权和对信息的访问可能更可取。确定必须一起可用的信息，确定哪个组件产生并拥有该信息，哪些组件修改了某些信息，以及是否同时完成。****设计应包括按其访问方式对所有数据的高级分类: 单线程 (独占) 、只读或共享**。请注意，这些角色可能会及时更改: 某些数据可以由单个线程生成，但以后可以由多个线程一次读取，而无需修改。这也应该反映在设计中。**

 ****将数据流或知识流作为设计**的一部分的总体指导方针经常被遗忘，但在其他方面非常简单。这是更具体的指导原则，以**考虑数据组织限制和接口的组合，这些限制和接口在设计过程中留下了显著的实现自由**，这通常被视为过早的优化。许多程序员会坚持认为 “缓存位置” 一词在设计阶段没有位置。这确实是我们将性能作为设计目标之一时必须做出的妥协之一。在系统设计过程中，我们经常不得不权衡这种竞争动机，这使我们在进行性能设计时要进行权衡。

# 性能权衡

设计通常是妥协的艺术; 有相互竞争的目标和要求，必须平衡。在本节中，我们将专门讨论与性能相关的权衡。在设计高性能系统时，你会做出很多这样的决定。这里有一些需要注意的。

## 【T0 �� Interface design

在本章中，我们目睹了尽可能少地公开实施的好处。但是，我们在这样做中获得的优化自由与非常抽象的界面的成本之间存在紧张关系。

这种紧张关系需要在优化不同组件之间进行权衡: 一个不以任何方式限制实现的接口通常会相当严重地限制客户端。例如，让我们重新审视我们的积分集合。在不限制其实施的情况下，我们能做什么？除了最后，我们不能允许任何插入 (实现可能是向量，复制一半的集合是不可接受的)。我们只能追加到最后，这意味着我们不能维护排序顺序，例如。可以没有随机访问 (集合可以存储在列表中)。如果集合被压缩，我们甚至可能无法提供反向迭代器。给实现者留下几乎无限自由的点集合被限制为转发迭代器 (流访问) 和可能的附加操作。甚至后者是一种限制，某些压缩方案需要在数据被读取之前完成数据，因此集合可以处于仅写状态或只读状态。

我们并不是举这个例子来证明对实现不可知的 api 的严格追求如何导致对客户端的不切实际的限制。恰恰相反: 这是处理大量数据的有效设计。通过附加到末尾来编写集合; 在完成写入之前，数据没有特定的顺序。定稿可能包括排序和压缩。要读取集合，我们会即时解压缩它 (如果我们的压缩算法一次在几个点上工作，我们需要一个缓冲区来保存未压缩的数据)。如果集合必须编辑，我们可以使用我们在[*第 4 章*](04.html#_idTextAnchor064)，*内存架构和性能*中首先介绍的算法，进行内存高效的编辑或字符串: 我们总是从头到尾阅读整个集合; 每个点都根据需要修改，增加新的点，等等。我们将结果写入新的集合，并最终删除原来的集合。这种设计允许非常高效的数据存储，无论是在内存使用方面 (高压缩) 还是在有效的内存访问方面 (仅缓存友好的顺序访问)。它还要求客户端在流访问和读-修改-写操作方面实现其所有操作。

你可以从另一端到达同一点: 如果你分析你的数据访问模式，并得出结论，你可以忍受流访问和读-修改-写更新，你可以把这一部分作为你的设计。当然，不是特定的压缩方案，而是高级数据组织: 写入必须在读取任何内容之前完成，并且更改数据的唯一方法是将整个集合复制到一个新集合，并根据需要在复制过程中修改其内容。

关于这种权衡的一个有趣的观察是，我们不仅必须平衡性能要求与易用性或其他设计考虑因素，而且通常要决定性能的哪个方面更重要。通常，应优先考虑低级组件: 与高级组件中的算法选择相比，它们的体系结构对整体设计更为基础。因此，以后很难更改，这使得做出明智的设计决策变得更加重要。请注意，在设计组件时，还需要进行其他权衡。

## �� T0 】 Component design

我们刚刚看到，有时为了使一个组件具有出色的设计性能，必须对其他组件施加限制，这些组件的性能需要仔细选择算法和熟练的实现。但这不是我们必须做出的唯一权衡。

性能设计中最常见的平衡措施之一是为组件和模块选择适当的粒度级别。制作小型组件通常是一种良好的设计实践，尤其是在测试驱动设计中 (但通常在任何以可测试性为目标之一的设计中)。另一方面，将系统分成太多的部分，它们之间的交互受到限制，这可能不利于性能。通常，将较大的数据和代码单元视为单个组件可以实现更有效的实现。同样，我们的点集合是一个例子: 如果我们不允许无限制地访问集合内的点对象，它会更有效。

最后，应该通过考虑相互冲突的要求并利用解决矛盾的机会来做出这些决定。最好有一个点作为一个单独的单元，在其他代码中可测试和重用。但是，我们真的需要将点集合公开为这些点单位的集合吗？也许，我们可以将其视为包含在其存储的点中的所有信息的集合，而 point 对象的创建仅用于读取和写入集合中的点，一次一个。这种方法使我们能够保持良好的模块化并实现高性能。通常，接口是根据清晰且可测试的组件来实现的，而在内部，较大的组件以完全不同的格式存储数据。

应该避免的是在界面中创建 “后门”，这些 “后门” 专门用于解决遵循良好设计实践但现在导致性能限制的限制。这通常以临时方式损害了两个竞争设计目标。相反，最好重新设计所涉及的组件。如果您看不到解决矛盾需求的方法，请删除组件边界，并将较小的单元制成内部的，特定于实现的子组件。

到目前为止，我们根本不关心的另一个设计方面是错误处理，因此需要几句话。

## 错误和未定义的行为

错误处理是通常被视为事后考虑的事情之一，但在设计决策中应该是一个平等而重要的因素。特别是，很难将异常安全性 (以及扩展为错误安全性) 添加到未考虑特定异常处理方法的程序中。

错误处理始于接口: 所有接口本质上都是控制组件之间交互的契约。这些合同应包括对输入数据的任何限制: 如果满足某些外部条件，则组件将按规定运行。但是合同还应指定如果不满足条件并且组件无法履行合同 (或者程序员认为这样做是不可取的或太困难的) 会发生什么。

合同还应涵盖许多错误响应: 如果未满足指定要求，则组件将以某种方式报告错误。它可能是异常、错误代码、状态标志或其他方法的组合。其他书籍都是关于错误处理的最佳实践的。在这里，我们关注性能。

从性能的角度来看，最重要的考虑因素通常是在更常见的情况下处理潜在错误的开销，当输入和结果正确并且没有发生任何不良情况时。通常简单地表示为 “错误处理必须便宜”。

这意味着在正常的无错误情况下，错误处理必须便宜。相反，当这种罕见事件实际发生时，我们通常不在乎处理错误的费用。这到底需要什么，从一个设计到下一个设计都有很大的不同。

例如，在处理事务的应用程序中，我们通常希望提交或回滚语义: 每个事务要么成功，要么什么都不做。然而，这种设计的性能成本可能很高。通常，只要这些更改不改变系统的主要不变量，失败的事务仍然会影响某些更改是可以接受的。对于基于磁盘的数据库，在磁盘上浪费一些空间可能是可以接受的; 然后，我们总是可以为事务分配空间并写入磁盘，但是，如果出现错误，我们将使用户无法访问此部分写入的区域。

在这种情况下，我们 “隐藏” 错误的全部后果以提高性能，最好设计一个单独的机制来清除错误的后遗症。对于我们的数据库，这样的清理可以在独立的后台进程中进行，优先级较低，以避免干扰主要访问。同样，这是通过及时分离矛盾来解决矛盾的一个例子: 如果我们必须从错误中恢复，但这样做太昂贵了，请稍后再做昂贵的部分。

最后，我们必须考虑在某些情况下即使检测到合同违规也过于昂贵的可能性。[*第 11 章*](11.html#_idTextAnchor176)，*未定义的行为和性能*，涵盖了这个场景。接口合同应明确说明，如果违反了某些限制，则结果是不确定的。如果选择这种方法，不要使程序花费时间使未定义的结果更 “可接受”。Undefined表示未定义; 任何事情都可能发生。这不应轻易完成，您应该考虑替代方案，例如轻量级数据收集，这些替代方案将昂贵的工作留给了处理真正错误时的代码路径。但是，明确合同边界和不确定的结果比不确定的替代方案更可取，因为 “我们将尽力而为，但没有承诺”。

在设计阶段必须进行许多权衡，本章并不是要进行权衡的完整列表或实现平衡的全方位指南。相反，我们展示了几种常见的矛盾以及解决这些矛盾的可能方法。

为了在平衡性能设计目标与其他目标和动机时做出明智的决策，重要的是要有一些性能估计。但是，我们如何在设计阶段这么早就获得性能指标呢？这是最后一个，在某些方面，也是我们尚未讨论的性能设计中最难的部分。

# 做出明智的设计决策

不仅在做出权衡决策时，我们还必须站在良好性能数据的坚实基础上。毕竟，如果我们不知道以高速缓存最佳顺序而不是某种随机顺序访问数据要花多少钱，我们如何才能决定设计用于有效内存访问的数据结构？这又回到了性能的第一条规则，你现在应该已经记住了: 永远不要猜测性能。如果我们的程序以白板上设计图的分散形式存在，说起来容易做起来难。

你不能运行一个设计，那么你如何获得测量来指导和支持你的设计决策呢？一些知识伴随着经验而来。这样，我并不是说那种说 “我们一直都是这样做的” 的经历。但是您可能已经设计并实现了新系统的类似组件和其他部分。如果它们是可重复使用的，它们会附带可靠的性能信息。但是，即使您必须修改它们或设计类似的东西，您也具有高度相关的性能度量，这些度量很可能会很好地转移到新设计中。

那么，如果我们没有可以用来衡量性能的相关程序，我们该怎么办？这是我们必须依靠模型和原型的时候。模型是人工构造，据我们所知，它模仿了我们未来计划某些部分的预期工作量和性能。例如，如果我们必须决定在内存中组织大量数据，并且我们知道我们将不得不频繁地处理整个数据语料库，那么我们的微观基准将从[*第 4 章*](04.html#_idTextAnchor064)，*内存体系结构和性能*是您可能使用的模型: 处理作为列表而不是数组组织的相同数据量。这是一个模型，不是对你未来计划性能的精确测量，但它提供了有价值的洞察力，并为你提供了良好的数据来支持你的决策。请记住，模型越近似的，预测就越不准确: 如果您对两种替代设计进行建模并在彼此的 10% 范围内得出性能测量，则可能应该将其视为洗。顺便说一句，这并不会使它成为浪费: 您获得了重要的信息，两种设计选项都提供相似的性能，因此您可以根据其他标准自由选择。

并非所有模型都是微观基准。有时你可以使用现有的程序来建模新的行为。假设您有一个分布式程序，该程序对某些数据进行操作，类似于下一个程序需要处理的数据。新程序将有更多的数据，并且相似性只是肤浅的 (可能两个程序都在字符串上工作)，因此旧程序不能用于处理新数据的任何实际测量。没关系: 我们可以修改代码来发送和接收更长的字符串。如果我们现有的程序不使用它们怎么办？这也没关系: 我们将编写一些代码以某种现实的方式生成和使用这些字符串，并将其嵌入程序中。现在，我们可以启动程序中执行分布式计算的部分，并查看发送和接收预期数据量所需的时间。让我们假设它需要足够长的时间来考虑压缩。不过，我们可以做得更好: 向代码添加压缩，并将网络传输速度与压缩和解压缩成本进行比较。如果您不想投入大量时间为您的特定数据编写逼真的压缩算法，请尝试重用现有的压缩库。比较来自免费可用库的几种压缩算法将为您提供更有价值的数据，以便以后您必须确定多少压缩是最佳的。

请仔细注意我们刚刚做的事情: 我们使用现有程序作为框架来运行一些新代码，这些代码近似于未来程序的行为。换句话说，我们已经构建了一个原型。原型是另一种获取性能评估以做出设计决策的方法。当然，为性能构建原型与制作基于特征的原型有些不同。在后一种情况下，我们希望快速组合一个系统，该系统可以演示所需的行为，通常不考虑实现的性能或质量。性能原型应该为我们提供合理的性能数字，因此低级实现必须高效。我们可以忽略极端情况和错误处理。我们也可以跳过许多功能，只要我们原型的功能执行我们想要基准测试的代码即可。有时，我们的原型根本没有任何功能: 相反，在代码中的某个地方，我们将硬编码一个条件，即在实际系统中，当某些功能被行使时会发生这种情况。我们在这种原型制作过程中必须创建的高性能代码通常会形成我们的低级库的基础。

应该指出的是，所有模型都是近似的，即使您对试图衡量其性能的代码有一个完整的最终实现，它们仍然是近似的。通常，微型基准测试的准确性不如大型框架，这引起了诸如 “微型基准测试是谎言” 之类的醒目标题。微基准和其他性能模型并不总是与最终结果相匹配的主要原因是任何程序的性能都会受到其环境的影响。例如，您可以对一段代码进行基准测试以获得最佳的内存访问，只是发现它通常与其他完全饱和内存总线的线程一起运行。

就像理解模型的局限性很重要一样，不要过度反应也很重要。基准确实提供了有用的信息。测量的软件越完整和真实，结果越准确。如果基准显示一段代码的速度比另一段快几倍，那么一旦代码在其最终上下文中运行，这种差异就不可能完全消失。但是，试图从运行在真实数据上的代码的最终版本之外的任何东西中获得效率的最后 5% 是愚蠢的。

原型-真实程序的近似值，可以在一定程度上精确地再现我们感兴趣的属性-使我们能够从不同的设计决策中获得对性能的合理估计。它们的范围从微型基准到大型现有程序的实验，但它们都服务于一个目标: 将性能设计从猜测领域转移到声音测量驱动决策的基础。

# 总结

我们书的最后一章回顾了我们所学到的关于性能的一切以及决定性能的因素，然后利用这些知识提出了高性能软件系统的设计指南。我们已经为设计接口，数据组织，组件和模块提供了一些建议，并描述了在实现其性能可以测量之前，使设计决策具有良好测量结果的方法。

我们必须再次强调，性能设计不会自动产生良好的性能: 它允许高性能实现的可能性。另一种选择是性能不利的设计，该设计锁定了限制和阻止有效代码和数据结构的决策。

这本书是一段旅程: 我们从了解各个硬件组件的性能开始，然后研究了它们之间的相互作用以及它们如何影响我们对编程语言的使用。最后，这条道路使我们想到了为性能设计的想法。这是本书的最后一章，但不是您旅程的最后一步: 现在是将您的知识应用于等待您的实际问题的广泛而令人兴奋的领域。

# 问题

1.  什么是性能设计？
2.  我们如何确保接口不限制最佳实现？
3.  为什么传达客户端意图的接口允许更好的性能？
4.  当我们没有性能测量时，我们如何做出明智的与性能相关的设计决策？**