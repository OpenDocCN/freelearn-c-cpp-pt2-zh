# 第十三章：小贴士和小窍门

本章将介绍以下食谱：

*   有效地注释您的代码
*   在结构中使用位字段
*   撰写一份完善的技术设计文档
*   使用 const 关键字优化代码
*   在枚举中使用位移位运算符
*   使用 C++ 11 中的新 lambda 特性

# 简介

C++ 是一片汪洋大海。 掌握 C++ 需要很多概念和技术。 最重要的是，程序员还可以不时学习一些小技巧，以帮助开发更好的软件。 在本章中，我们将介绍程序员可以学习的一些技术，以编写更好的代码。

# 有效地注释您的代码

通常，程序员太专注于解决问题，以至于忘记注释代码。 虽然这在他们工作时可能不是问题，但如果涉及到的其他团队成员必须使用相同的代码段，则可能会变得非常难以理解。 因此，必须从开发的早期阶段对代码进行注释。

## 做好准备

要完成本食谱，您需要一台运行 Windows 和 Visual Studio 的计算机。 不需要其他前提条件。

## How to Do It…

在本食谱中，我们将看到注释代码是多么容易。 让我们添加一个名为`Source.cpp`的源文件。 将以下代码添加到文件中：

```cpp
//Header files
#include <iostream>

class Game
{
  //Member variables (Already known)
public:
private:
protected:

};

//Adding 2 numbers
int Add(int a=4,int b=5)
{
  return a + b;
}

void Logic(int a,int b)
{
  if (a > 10 ? std::cout << a : std::cout << b);

}
int main()
{
  std::cout<<Add()<<std::endl;
  Logic(5,8);

  int a;
  std::cin >> a;
}
```

## …的工作原理

注释应该写在任何部分，以帮助其他开发人员了解正在发生的事情。 要注释代码，我们使用`//`双反斜杠符号。 我们在其中编写的任何内容都不会被编译，也会被编译器忽略。 因此，我们可以使用它来记录代码中的不同方面。 我们还可以使用`/*`和`*/`符号来注释多行。 编译器将忽略一对`/*`和`*/`符号内的任何内容。 如果我们需要调试应用程序，此技术将变得非常有用。 我们首先注释掉我们认为是罪魁祸首的一大部分代码。 代码现在应该构建好了。 然后，我们开始取消对代码的注释，直到代码再次崩溃。

有时，程序员往往会过度评论。 例如，不需要在加法函数上编写`//Addition`，因为我们可以清楚地看到两个数字被相加。 同样，我们也不应该低估。 因为在`Logic`函数的顶部没有注释，所以我们不知道为什么要使用该函数以及该函数做什么。 因此，我们必须记住发表足够的评论。 只有通过练习和在团队环境中工作，才能做到这一点。

# 在结构中使用位字段

在结构中，我们可以使用位字段来表示我们希望结构的大小。 除此之外，了解结构的实际大小也很重要。

## 做好准备

您需要一台 Windows 计算机和一份 Visual Studio 的工作副本。 不需要其他前提条件。

## How to Do It…

在本食谱中，我们将了解使用位字段查找结构大小是多么容易。 添加名为`Source.cpp`的源文件。 然后向其中添加以下代码：

```cpp
#include <iostream>

struct Type
{
  int a;
  unsigned char c[9];
  unsigned  b;
  float d;

};

struct Type2
{
  int a : 2;
  int b : 2;
};
int main()
{
  std::cout << sizeof(Type)<<std::endl;
  std::cout << sizeof(Type2);

  int a;
  std::cin >> a;
}
```

## …的工作原理

如您所见，在本例中，我们分配了一个 int 结构、一个 char 数组、一个未定义的无符号变量和一个浮点数。 当我们执行程序时，输出应该是两个结构的大小(以字节为单位)。 假设我们在 64 位机器上运行这个程序，int 是 4 字节，无符号字符数组是 9 字节，无符号默认是 4 字节，Float 是 4 字节。 如果我们把它们加起来，总数是 21 个字节。 但是如果我们把它打印出来，我们会注意到输出是 24 字节。 其原因称为*填充*。 C++ 总是在个 4 字节的块中获取数据。 因此，它总是用额外的字节填充，直到大小是 4 的倍数。因为结构的大小是 21，所以最接近的 4 的倍数是 24，所以我们得到了答案。 填充不是作为一个整体对结构进行的，而是针对每个声明进行的，例如：

```cpp
struct structA
{
   char a;
   char b;
   char c;
   int d;
};

struct structB
{
   char a;
   int d;
   char b;
   char c;
};

Sizeof structA = 2 bytes
Sizeof structb = 3 bytes
```

看一下第二个结构，我们所做的事情被分配了一个位字段。 虽然 int 是 4 个字节，但我们可以指示它只有 2 个字节。 执行此操作的语法是在字节值后面添加一个`:`符号。 因此，对于第二个结构，如果我们找到值，它将把它输出为`4`而不是`8`。

# 撰写一份完善的技术设计文件

当我们开始一个项目时，我们通常依赖两个文档。 第一个文档是游戏设计文档，第二个文档是技术设计文档。 技术设计文档应列出关键功能和关键功能的高级架构。 然而，随着独立游戏的出现，这一体系正在迅速变化。 然而，在大型游戏工作室中，这一过程仍然有效。

## 做好准备

您需要有一台可以正常工作的 Windows 计算机。

## How to Do It…

在本食谱中，我们将看到创建技术设计文档是多么容易：

1.  打开您选择的编辑器，最好是 Microsoft Word。
2.  列出游戏的关键技术组件。
3.  创建数据流程图以表示引擎各个组件之间的数据流。
4.  创建一个流程图来解释某个复杂部分的逻辑。
5.  为游戏开发的关键部分编写伪代码。

## …的工作原理

一旦列出了关键组件，项目经理就可以自动评估每项任务的风险和复杂性。 开发人员还将了解引擎或游戏的关键组件是什么。 这也将帮助开发人员计划他们的行动。 绘制数据流图后，就很容易理解哪个组件依赖于哪个其他组件。 因此，开发人员将知道他们必须在开始编码*B*之前实现*A*。 流程图也是理解逻辑流程的好方法，有时有助于解决将来可能出现的歧义。 最后，伪代码对于向开发人员解释他们必须如何实现代码至关重要，或者更确切地说，什么是明智的方法。 由于伪代码是独立于语言的，所以即使在 C++ 之外的其他语言中，也可以使用相同的伪代码来编写游戏。

# 使用 const 关键字优化代码

我们已经在前面的配方中看到了，`const`关键字用于使数据或指针成为常量，这样我们就不能分别更改值或地址。 使用`const`关键字还有一个优点。 这在面向对象的范例中特别有用。

## 做好准备

对于本食谱，您需要一台 Windows 计算机和一个已安装的 Visual Studio 版本。

## How to Do It…

在本食谱中，我们将了解有效使用`const`关键字是多么容易：

```cpp
#include <iostream>

class A
{
public:

  void Calc()const
  {
    Add(a, b);
    //a = 9;       // Not Allowed
  }
  A()
  {
    a = 10;
    b = 10;

  }
private:

  int a, b;
  void Add(int a, int b)const
  {

    std::cout << a + b << std::endl;
  }
};

int main()
{

  A _a;
  _a.Calc();

  int a;
  std::cin >> a;

  return 0;
}
```

## …的工作原理

在本例中，我们编写了一个简单的应用程序来将两个数字相加。 第一个函数是公共函数。 这意味着它向其他类公开。 无论何时编写公共函数，我们都必须确保它们不会损害该类的任何私有数据。 例如，如果公共函数要返回成员变量的值或更改这些值，则此公共函数风险很大。 因此，我们必须确保函数不能通过在函数末尾添加`const`关键字来修改任何成员变量。 这确保不允许该函数更改任何成员变量。 如果我们试图为该成员赋一个不同的值，我们将得到一个编译器错误：

```cpp
error C3490: 'a' cannot be modified because it is being accessed through a const object.
```

因此，这使得代码更加安全。 然而，还有另一个问题。 此公共函数在内部调用另一个私有函数。 如果此私有函数修改成员变量的值，该怎么办？ 再说一次，我们将面临同样的风险。 因此，C++ 不允许我们调用该函数，除非它在函数末尾具有相同的 const 签名。 这是为了确保函数不能更改成员变量的值。

# 在枚举中使用位移位运算符

正如我们在前面的食谱中看到的一样，枚举用来表示状态的集合。 默认情况下，所有状态都被赋予一个整数值，从`0`开始。 但是，我们也可以指定不同的整数值。 更有趣的是，我们可以使用位移位操作符来组合一些状态，轻松地将它们设置为活动或非活动状态，并对它们进行其他操作。

## 做好准备

要完成本指南，您需要一台运行 Windows 且安装了 Visual Studio 的计算机。

## How to Do It…

在这个配方中，我们将看到在枚举中编写位移位运算符是多么容易：

```cpp
#include <iostream>

enum Flags
{
  FLAG1 = (1 << 0),
  FLAG2 = (1 << 1),
  FLAG3 = (1 << 2)
};

int main()
{

  int flags = FLAG1 | FLAG2;

  if (flags&FLAG1)
  {
    //Do Something
  }
  if (flags&FLAG2)
  {
    //Do Something
  }

  return 0;
}
```

## …的工作原理

在上面的示例中，我们在枚举中有三个标志状态。 它们由位移位运算符表示。 因此，在内存中，第一个状态表示为`0000`，第二个状态表示为`0001`，第三个状态表示为`0010`。 我们现在可以使用`OR`运算符(`|`)组合状态。 我们可以有一个状态叫`JUMP`，另一个状态叫`SHOOT`。 如果我们希望角色现在`JUMP`和`SHOOT`在一起，我们可以组合这些状态。 我们可以使用`&`运算符检查状态是否处于活动状态。 类似地，如果我们必须从组合中删除状态，我们可以使用`XOR`运算符(`^`)。 我们可以使用`~`运算符禁用状态。

# 使用 C++ 11 的新 lambda 函数

Lambda函数是 C++ 家族的新成员。 它们可以被描述为匿名函数。

## 做好准备

要完成本食谱，您需要一台运行 Windows 和 Visual Studio 的计算机。

## How to Do It…

为了理解 lambda 函数，让我们看一下以下代码：

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
  vector<int> numbers{ 4,8,9,9,77,8,11,2,7 };
  int b = 10;
  for_each(numbers.begin(), numbers.end(), [=](int y) mutable->void { if(y>b) cout<<  y<<endl;  });

  int a;
  cin >> a;

}
```

## …的工作原理

Lambda 函数是 C++ 11 家族的新成员。 它们是匿名函数，非常方便。 它们通常作为参数传递给函数。 Lambda 函数的语法如下：

*   `[ capture-list ] ( params ) mutable(optional) exception attribute -> ret { body }`

关键字`mutable`是可选的，用于修改参数和调用它们的非常数函数。 该属性提供闭包类型的规范。 捕获列表是可选的，并且具有允许的类型列表：

*   `[a,&b]`：这里`a`是通过值捕获的，`b`是通过引用捕获的
*   `[this]`：这将通过值捕获`this`指针
*   `[&]`：通过引用捕获 lambda 主体中使用的所有自动变量
*   `[=]`：这将按值捕获 lambda 主体中使用的所有自动变量
*   `[]`：这不会捕获任何内容

参数是个参数的列表，就像在命名函数中一样，除了不允许使用个默认参数(直到 C++ 14)。 如果 AUTO 被用作参数类型，那么 lambda 就是一个通用的 lambda(从 C++ 14 开始)。 `ret`是函数的返回类型。 如果没有提供类型，那么`ret`会尝试自动注入返回类型，或者如果没有返回任何内容，则尝试自动注入 void。 最后，我们有函数体，它用于编写函数的逻辑。

在本例中，我们存储了一个向量数字列表。 之后，我们遍历列表并使用 lambda 函数。 Lambda 函数存储所有大于 10 的数字并显示该数字。 Lambda 函数可能很难入门，但经过实践，它们很容易掌握。